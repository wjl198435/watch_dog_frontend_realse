(self["webpackJsonp"] = self["webpackJsonp"] || []).push([["vendors~hls.js"],{

/***/ "./node_modules/hls.js/dist/hls.js":
/*!*****************************************!*\
  !*** ./node_modules/hls.js/dist/hls.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

typeof window !== "undefined" &&
(function webpackUniversalModuleDefinition(root, factory) {
	if(true)
		module.exports = factory();
	else {}
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/dist/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/hls.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/eventemitter3/index.js":
/*!*********************************************!*\
  !*** ./node_modules/eventemitter3/index.js ***!
  \*********************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var has = Object.prototype.hasOwnProperty
  , prefix = '~';

/**
 * Constructor to create a storage for our `EE` objects.
 * An `Events` instance is a plain object whose properties are event names.
 *
 * @constructor
 * @private
 */
function Events() {}

//
// We try to not inherit from `Object.prototype`. In some engines creating an
// instance in this way is faster than calling `Object.create(null)` directly.
// If `Object.create(null)` is not supported we prefix the event names with a
// character to make sure that the built-in object properties are not
// overridden or used as an attack vector.
//
if (Object.create) {
  Events.prototype = Object.create(null);

  //
  // This hack is needed because the `__proto__` property is still inherited in
  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.
  //
  if (!new Events().__proto__) prefix = false;
}

/**
 * Representation of a single event listener.
 *
 * @param {Function} fn The listener function.
 * @param {*} context The context to invoke the listener with.
 * @param {Boolean} [once=false] Specify if the listener is a one-time listener.
 * @constructor
 * @private
 */
function EE(fn, context, once) {
  this.fn = fn;
  this.context = context;
  this.once = once || false;
}

/**
 * Add a listener for a given event.
 *
 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} context The context to invoke the listener with.
 * @param {Boolean} once Specify if the listener is a one-time listener.
 * @returns {EventEmitter}
 * @private
 */
function addListener(emitter, event, fn, context, once) {
  if (typeof fn !== 'function') {
    throw new TypeError('The listener must be a function');
  }

  var listener = new EE(fn, context || emitter, once)
    , evt = prefix ? prefix + event : event;

  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
  else emitter._events[evt] = [emitter._events[evt], listener];

  return emitter;
}

/**
 * Clear event by name.
 *
 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
 * @param {(String|Symbol)} evt The Event name.
 * @private
 */
function clearEvent(emitter, evt) {
  if (--emitter._eventsCount === 0) emitter._events = new Events();
  else delete emitter._events[evt];
}

/**
 * Minimal `EventEmitter` interface that is molded against the Node.js
 * `EventEmitter` interface.
 *
 * @constructor
 * @public
 */
function EventEmitter() {
  this._events = new Events();
  this._eventsCount = 0;
}

/**
 * Return an array listing the events for which the emitter has registered
 * listeners.
 *
 * @returns {Array}
 * @public
 */
EventEmitter.prototype.eventNames = function eventNames() {
  var names = []
    , events
    , name;

  if (this._eventsCount === 0) return names;

  for (name in (events = this._events)) {
    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
  }

  if (Object.getOwnPropertySymbols) {
    return names.concat(Object.getOwnPropertySymbols(events));
  }

  return names;
};

/**
 * Return the listeners registered for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Array} The registered listeners.
 * @public
 */
EventEmitter.prototype.listeners = function listeners(event) {
  var evt = prefix ? prefix + event : event
    , handlers = this._events[evt];

  if (!handlers) return [];
  if (handlers.fn) return [handlers.fn];

  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
    ee[i] = handlers[i].fn;
  }

  return ee;
};

/**
 * Return the number of listeners listening to a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Number} The number of listeners.
 * @public
 */
EventEmitter.prototype.listenerCount = function listenerCount(event) {
  var evt = prefix ? prefix + event : event
    , listeners = this._events[evt];

  if (!listeners) return 0;
  if (listeners.fn) return 1;
  return listeners.length;
};

/**
 * Calls each of the listeners registered for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Boolean} `true` if the event had listeners, else `false`.
 * @public
 */
EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
  var evt = prefix ? prefix + event : event;

  if (!this._events[evt]) return false;

  var listeners = this._events[evt]
    , len = arguments.length
    , args
    , i;

  if (listeners.fn) {
    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);

    switch (len) {
      case 1: return listeners.fn.call(listeners.context), true;
      case 2: return listeners.fn.call(listeners.context, a1), true;
      case 3: return listeners.fn.call(listeners.context, a1, a2), true;
      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;
      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
    }

    for (i = 1, args = new Array(len -1); i < len; i++) {
      args[i - 1] = arguments[i];
    }

    listeners.fn.apply(listeners.context, args);
  } else {
    var length = listeners.length
      , j;

    for (i = 0; i < length; i++) {
      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);

      switch (len) {
        case 1: listeners[i].fn.call(listeners[i].context); break;
        case 2: listeners[i].fn.call(listeners[i].context, a1); break;
        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;
        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;
        default:
          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {
            args[j - 1] = arguments[j];
          }

          listeners[i].fn.apply(listeners[i].context, args);
      }
    }
  }

  return true;
};

/**
 * Add a listener for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} [context=this] The context to invoke the listener with.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.on = function on(event, fn, context) {
  return addListener(this, event, fn, context, false);
};

/**
 * Add a one-time listener for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} [context=this] The context to invoke the listener with.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.once = function once(event, fn, context) {
  return addListener(this, event, fn, context, true);
};

/**
 * Remove the listeners of a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn Only remove the listeners that match this function.
 * @param {*} context Only remove the listeners that have this context.
 * @param {Boolean} once Only remove one-time listeners.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
  var evt = prefix ? prefix + event : event;

  if (!this._events[evt]) return this;
  if (!fn) {
    clearEvent(this, evt);
    return this;
  }

  var listeners = this._events[evt];

  if (listeners.fn) {
    if (
      listeners.fn === fn &&
      (!once || listeners.once) &&
      (!context || listeners.context === context)
    ) {
      clearEvent(this, evt);
    }
  } else {
    for (var i = 0, events = [], length = listeners.length; i < length; i++) {
      if (
        listeners[i].fn !== fn ||
        (once && !listeners[i].once) ||
        (context && listeners[i].context !== context)
      ) {
        events.push(listeners[i]);
      }
    }

    //
    // Reset the array, or remove it completely if we have no more listeners.
    //
    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
    else clearEvent(this, evt);
  }

  return this;
};

/**
 * Remove all listeners, or those of the specified event.
 *
 * @param {(String|Symbol)} [event] The event name.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
  var evt;

  if (event) {
    evt = prefix ? prefix + event : event;
    if (this._events[evt]) clearEvent(this, evt);
  } else {
    this._events = new Events();
    this._eventsCount = 0;
  }

  return this;
};

//
// Alias methods names because people roll like that.
//
EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
EventEmitter.prototype.addListener = EventEmitter.prototype.on;

//
// Expose the prefix.
//
EventEmitter.prefixed = prefix;

//
// Allow `EventEmitter` to be imported as module namespace.
//
EventEmitter.EventEmitter = EventEmitter;

//
// Expose the module.
//
if (true) {
  module.exports = EventEmitter;
}


/***/ }),

/***/ "./node_modules/node-libs-browser/node_modules/events/events.js":
/*!**********************************************************************!*\
  !*** ./node_modules/node-libs-browser/node_modules/events/events.js ***!
  \**********************************************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports) {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      } else {
        // At least give some kind of context to the user
        var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
        err.context = er;
        throw err;
      }
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        args = Array.prototype.slice.call(arguments, 1);
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    args = Array.prototype.slice.call(arguments, 1);
    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else if (listeners) {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.prototype.listenerCount = function(type) {
  if (this._events) {
    var evlistener = this._events[type];

    if (isFunction(evlistener))
      return 1;
    else if (evlistener)
      return evlistener.length;
  }
  return 0;
};

EventEmitter.listenerCount = function(emitter, type) {
  return emitter.listenerCount(type);
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}


/***/ }),

/***/ "./node_modules/url-toolkit/src/url-toolkit.js":
/*!*****************************************************!*\
  !*** ./node_modules/url-toolkit/src/url-toolkit.js ***!
  \*****************************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

// see https://tools.ietf.org/html/rfc1808

/* jshint ignore:start */
(function(root) { 
/* jshint ignore:end */

  var URL_REGEX = /^((?:[a-zA-Z0-9+\-.]+:)?)(\/\/[^\/?#]*)?((?:[^\/\?#]*\/)*.*?)??(;.*?)?(\?.*?)?(#.*?)?$/;
  var FIRST_SEGMENT_REGEX = /^([^\/?#]*)(.*)$/;
  var SLASH_DOT_REGEX = /(?:\/|^)\.(?=\/)/g;
  var SLASH_DOT_DOT_REGEX = /(?:\/|^)\.\.\/(?!\.\.\/).*?(?=\/)/g;

  var URLToolkit = { // jshint ignore:line
    // If opts.alwaysNormalize is true then the path will always be normalized even when it starts with / or //
    // E.g
    // With opts.alwaysNormalize = false (default, spec compliant)
    // http://a.com/b/cd + /e/f/../g => http://a.com/e/f/../g
    // With opts.alwaysNormalize = true (not spec compliant)
    // http://a.com/b/cd + /e/f/../g => http://a.com/e/g
    buildAbsoluteURL: function(baseURL, relativeURL, opts) {
      opts = opts || {};
      // remove any remaining space and CRLF
      baseURL = baseURL.trim();
      relativeURL = relativeURL.trim();
      if (!relativeURL) {
        // 2a) If the embedded URL is entirely empty, it inherits the
        // entire base URL (i.e., is set equal to the base URL)
        // and we are done.
        if (!opts.alwaysNormalize) {
          return baseURL;
        }
        var basePartsForNormalise = URLToolkit.parseURL(baseURL);
        if (!basePartsForNormalise) {
          throw new Error('Error trying to parse base URL.');
        }
        basePartsForNormalise.path = URLToolkit.normalizePath(basePartsForNormalise.path);
        return URLToolkit.buildURLFromParts(basePartsForNormalise);
      }
      var relativeParts = URLToolkit.parseURL(relativeURL);
      if (!relativeParts) {
        throw new Error('Error trying to parse relative URL.');
      }
      if (relativeParts.scheme) {
        // 2b) If the embedded URL starts with a scheme name, it is
        // interpreted as an absolute URL and we are done.
        if (!opts.alwaysNormalize) {
          return relativeURL;
        }
        relativeParts.path = URLToolkit.normalizePath(relativeParts.path);
        return URLToolkit.buildURLFromParts(relativeParts);
      }
      var baseParts = URLToolkit.parseURL(baseURL);
      if (!baseParts) {
        throw new Error('Error trying to parse base URL.');
      }
      if (!baseParts.netLoc && baseParts.path && baseParts.path[0] !== '/') {
        // If netLoc missing and path doesn't start with '/', assume everthing before the first '/' is the netLoc
        // This causes 'example.com/a' to be handled as '//example.com/a' instead of '/example.com/a'
        var pathParts = FIRST_SEGMENT_REGEX.exec(baseParts.path);
        baseParts.netLoc = pathParts[1];
        baseParts.path = pathParts[2];
      }
      if (baseParts.netLoc && !baseParts.path) {
        baseParts.path = '/';
      }
      var builtParts = {
        // 2c) Otherwise, the embedded URL inherits the scheme of
        // the base URL.
        scheme: baseParts.scheme,
        netLoc: relativeParts.netLoc,
        path: null,
        params: relativeParts.params,
        query: relativeParts.query,
        fragment: relativeParts.fragment
      };
      if (!relativeParts.netLoc) {
        // 3) If the embedded URL's <net_loc> is non-empty, we skip to
        // Step 7.  Otherwise, the embedded URL inherits the <net_loc>
        // (if any) of the base URL.
        builtParts.netLoc = baseParts.netLoc;
        // 4) If the embedded URL path is preceded by a slash "/", the
        // path is not relative and we skip to Step 7.
        if (relativeParts.path[0] !== '/') {
          if (!relativeParts.path) {
            // 5) If the embedded URL path is empty (and not preceded by a
            // slash), then the embedded URL inherits the base URL path
            builtParts.path = baseParts.path;
            // 5a) if the embedded URL's <params> is non-empty, we skip to
            // step 7; otherwise, it inherits the <params> of the base
            // URL (if any) and
            if (!relativeParts.params) {
              builtParts.params = baseParts.params;
              // 5b) if the embedded URL's <query> is non-empty, we skip to
              // step 7; otherwise, it inherits the <query> of the base
              // URL (if any) and we skip to step 7.
              if (!relativeParts.query) {
                builtParts.query = baseParts.query;
              }
            }
          } else {
            // 6) The last segment of the base URL's path (anything
            // following the rightmost slash "/", or the entire path if no
            // slash is present) is removed and the embedded URL's path is
            // appended in its place.
            var baseURLPath = baseParts.path;
            var newPath = baseURLPath.substring(0, baseURLPath.lastIndexOf('/') + 1) + relativeParts.path;
            builtParts.path = URLToolkit.normalizePath(newPath);
          }
        }
      }
      if (builtParts.path === null) {
        builtParts.path = opts.alwaysNormalize ? URLToolkit.normalizePath(relativeParts.path) : relativeParts.path;
      }
      return URLToolkit.buildURLFromParts(builtParts);
    },
    parseURL: function(url) {
      var parts = URL_REGEX.exec(url);
      if (!parts) {
        return null;
      }
      return {
        scheme: parts[1] || '',
        netLoc: parts[2] || '',
        path: parts[3] || '',
        params: parts[4] || '',
        query: parts[5] || '',
        fragment: parts[6] || ''
      };
    },
    normalizePath: function(path) {
      // The following operations are
      // then applied, in order, to the new path:
      // 6a) All occurrences of "./", where "." is a complete path
      // segment, are removed.
      // 6b) If the path ends with "." as a complete path segment,
      // that "." is removed.
      path = path.split('').reverse().join('').replace(SLASH_DOT_REGEX, '');
      // 6c) All occurrences of "<segment>/../", where <segment> is a
      // complete path segment not equal to "..", are removed.
      // Removal of these path segments is performed iteratively,
      // removing the leftmost matching pattern on each iteration,
      // until no matching pattern remains.
      // 6d) If the path ends with "<segment>/..", where <segment> is a
      // complete path segment not equal to "..", that
      // "<segment>/.." is removed.
      while (path.length !== (path = path.replace(SLASH_DOT_DOT_REGEX, '')).length) {} // jshint ignore:line
      return path.split('').reverse().join('');
    },
    buildURLFromParts: function(parts) {
      return parts.scheme + parts.netLoc + parts.path + parts.params + parts.query + parts.fragment;
    }
  };

/* jshint ignore:start */
  if(true)
    module.exports = URLToolkit;
  else {}
})(this);
/* jshint ignore:end */


/***/ }),

/***/ "./node_modules/webworkify-webpack/index.js":
/*!**************************************************!*\
  !*** ./node_modules/webworkify-webpack/index.js ***!
  \**************************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

function webpackBootstrapFunc (modules) {
/******/  // The module cache
/******/  var installedModules = {};

/******/  // The require function
/******/  function __webpack_require__(moduleId) {

/******/    // Check if module is in cache
/******/    if(installedModules[moduleId])
/******/      return installedModules[moduleId].exports;

/******/    // Create a new module (and put it into the cache)
/******/    var module = installedModules[moduleId] = {
/******/      i: moduleId,
/******/      l: false,
/******/      exports: {}
/******/    };

/******/    // Execute the module function
/******/    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/    // Flag the module as loaded
/******/    module.l = true;

/******/    // Return the exports of the module
/******/    return module.exports;
/******/  }

/******/  // expose the modules object (__webpack_modules__)
/******/  __webpack_require__.m = modules;

/******/  // expose the module cache
/******/  __webpack_require__.c = installedModules;

/******/  // identity function for calling harmony imports with the correct context
/******/  __webpack_require__.i = function(value) { return value; };

/******/  // define getter function for harmony exports
/******/  __webpack_require__.d = function(exports, name, getter) {
/******/    if(!__webpack_require__.o(exports, name)) {
/******/      Object.defineProperty(exports, name, {
/******/        configurable: false,
/******/        enumerable: true,
/******/        get: getter
/******/      });
/******/    }
/******/  };

/******/  // define __esModule on exports
/******/  __webpack_require__.r = function(exports) {
/******/    Object.defineProperty(exports, '__esModule', { value: true });
/******/  };

/******/  // getDefaultExport function for compatibility with non-harmony modules
/******/  __webpack_require__.n = function(module) {
/******/    var getter = module && module.__esModule ?
/******/      function getDefault() { return module['default']; } :
/******/      function getModuleExports() { return module; };
/******/    __webpack_require__.d(getter, 'a', getter);
/******/    return getter;
/******/  };

/******/  // Object.prototype.hasOwnProperty.call
/******/  __webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };

/******/  // __webpack_public_path__
/******/  __webpack_require__.p = "/";

/******/  // on error function for async loading
/******/  __webpack_require__.oe = function(err) { console.error(err); throw err; };

  var f = __webpack_require__(__webpack_require__.s = ENTRY_MODULE)
  return f.default || f // try to call default if defined to also support babel esmodule exports
}

var moduleNameReqExp = '[\\.|\\-|\\+|\\w|\/|@]+'
var dependencyRegExp = '\\((\/\\*.*?\\*\/)?\s?.*?(' + moduleNameReqExp + ').*?\\)' // additional chars when output.pathinfo is true

// http://stackoverflow.com/a/2593661/130442
function quoteRegExp (str) {
  return (str + '').replace(/[.?*+^$[\]\\(){}|-]/g, '\\$&')
}

function isNumeric(n) {
  return !isNaN(1 * n); // 1 * n converts integers, integers as string ("123"), 1e3 and "1e3" to integers and strings to NaN
}

function getModuleDependencies (sources, module, queueName) {
  var retval = {}
  retval[queueName] = []

  var fnString = module.toString()
  var wrapperSignature = fnString.match(/^function\s?\(\w+,\s*\w+,\s*(\w+)\)/)
  if (!wrapperSignature) return retval
  var webpackRequireName = wrapperSignature[1]

  // main bundle deps
  var re = new RegExp('(\\\\n|\\W)' + quoteRegExp(webpackRequireName) + dependencyRegExp, 'g')
  var match
  while ((match = re.exec(fnString))) {
    if (match[3] === 'dll-reference') continue
    retval[queueName].push(match[3])
  }

  // dll deps
  re = new RegExp('\\(' + quoteRegExp(webpackRequireName) + '\\("(dll-reference\\s(' + moduleNameReqExp + '))"\\)\\)' + dependencyRegExp, 'g')
  while ((match = re.exec(fnString))) {
    if (!sources[match[2]]) {
      retval[queueName].push(match[1])
      sources[match[2]] = __webpack_require__(match[1]).m
    }
    retval[match[2]] = retval[match[2]] || []
    retval[match[2]].push(match[4])
  }

  // convert 1e3 back to 1000 - this can be important after uglify-js converted 1000 to 1e3
  var keys = Object.keys(retval);
  for (var i = 0; i < keys.length; i++) {
    for (var j = 0; j < retval[keys[i]].length; j++) {
      if (isNumeric(retval[keys[i]][j])) {
        retval[keys[i]][j] = 1 * retval[keys[i]][j];
      }
    }
  }

  return retval
}

function hasValuesInQueues (queues) {
  var keys = Object.keys(queues)
  return keys.reduce(function (hasValues, key) {
    return hasValues || queues[key].length > 0
  }, false)
}

function getRequiredModules (sources, moduleId) {
  var modulesQueue = {
    main: [moduleId]
  }
  var requiredModules = {
    main: []
  }
  var seenModules = {
    main: {}
  }

  while (hasValuesInQueues(modulesQueue)) {
    var queues = Object.keys(modulesQueue)
    for (var i = 0; i < queues.length; i++) {
      var queueName = queues[i]
      var queue = modulesQueue[queueName]
      var moduleToCheck = queue.pop()
      seenModules[queueName] = seenModules[queueName] || {}
      if (seenModules[queueName][moduleToCheck] || !sources[queueName][moduleToCheck]) continue
      seenModules[queueName][moduleToCheck] = true
      requiredModules[queueName] = requiredModules[queueName] || []
      requiredModules[queueName].push(moduleToCheck)
      var newModules = getModuleDependencies(sources, sources[queueName][moduleToCheck], queueName)
      var newModulesKeys = Object.keys(newModules)
      for (var j = 0; j < newModulesKeys.length; j++) {
        modulesQueue[newModulesKeys[j]] = modulesQueue[newModulesKeys[j]] || []
        modulesQueue[newModulesKeys[j]] = modulesQueue[newModulesKeys[j]].concat(newModules[newModulesKeys[j]])
      }
    }
  }

  return requiredModules
}

module.exports = function (moduleId, options) {
  options = options || {}
  var sources = {
    main: __webpack_require__.m
  }

  var requiredModules = options.all ? { main: Object.keys(sources.main) } : getRequiredModules(sources, moduleId)

  var src = ''

  Object.keys(requiredModules).filter(function (m) { return m !== 'main' }).forEach(function (module) {
    var entryModule = 0
    while (requiredModules[module][entryModule]) {
      entryModule++
    }
    requiredModules[module].push(entryModule)
    sources[module][entryModule] = '(function(module, exports, __webpack_require__) { module.exports = __webpack_require__; })'
    src = src + 'var ' + module + ' = (' + webpackBootstrapFunc.toString().replace('ENTRY_MODULE', JSON.stringify(entryModule)) + ')({' + requiredModules[module].map(function (id) { return '' + JSON.stringify(id) + ': ' + sources[module][id].toString() }).join(',') + '});\n'
  })

  src = src + 'new ((' + webpackBootstrapFunc.toString().replace('ENTRY_MODULE', JSON.stringify(moduleId)) + ')({' + requiredModules.main.map(function (id) { return '' + JSON.stringify(id) + ': ' + sources.main[id].toString() }).join(',') + '}))(self);'

  var blob = new window.Blob([src], { type: 'text/javascript' })
  if (options.bare) { return blob }

  var URL = window.URL || window.webkitURL || window.mozURL || window.msURL

  var workerUrl = URL.createObjectURL(blob)
  var worker = new window.Worker(workerUrl)
  worker.objectURL = workerUrl

  return worker
}


/***/ }),

/***/ "./src/config.js":
/*!***********************!*\
  !*** ./src/config.js ***!
  \***********************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * HLS config
 */
Object.defineProperty(exports, "__esModule", { value: true });
var abr_controller_1 = __webpack_require__(/*! ./controller/abr-controller */ "./src/controller/abr-controller.js");
var buffer_controller_1 = __webpack_require__(/*! ./controller/buffer-controller */ "./src/controller/buffer-controller.js");
var cap_level_controller_1 = __webpack_require__(/*! ./controller/cap-level-controller */ "./src/controller/cap-level-controller.js");
var fps_controller_1 = __webpack_require__(/*! ./controller/fps-controller */ "./src/controller/fps-controller.js");
var xhr_loader_1 = __webpack_require__(/*! ./utils/xhr-loader */ "./src/utils/xhr-loader.js");
// import FetchLoader from './utils/fetch-loader';
var audio_track_controller_1 = __webpack_require__(/*! ./controller/audio-track-controller */ "./src/controller/audio-track-controller.js");
var audio_stream_controller_1 = __webpack_require__(/*! ./controller/audio-stream-controller */ "./src/controller/audio-stream-controller.js");
var Cues = __webpack_require__(/*! ./utils/cues */ "./src/utils/cues.js");
var timeline_controller_1 = __webpack_require__(/*! ./controller/timeline-controller */ "./src/controller/timeline-controller.js");
var subtitle_track_controller_1 = __webpack_require__(/*! ./controller/subtitle-track-controller */ "./src/controller/subtitle-track-controller.js");
var subtitle_stream_controller_1 = __webpack_require__(/*! ./controller/subtitle-stream-controller */ "./src/controller/subtitle-stream-controller.js");
var eme_controller_1 = __webpack_require__(/*! ./controller/eme-controller */ "./src/controller/eme-controller.js");
var mediakeys_helper_1 = __webpack_require__(/*! ./utils/mediakeys-helper */ "./src/utils/mediakeys-helper.js");
exports.hlsDefaultConfig = {
    autoStartLoad: true,
    startPosition: -1,
    defaultAudioCodec: undefined,
    debug: false,
    capLevelOnFPSDrop: false,
    capLevelToPlayerSize: false,
    initialLiveManifestSize: 1,
    maxBufferLength: 30,
    maxBufferSize: 60 * 1000 * 1000,
    maxBufferHole: 0.5,
    lowBufferWatchdogPeriod: 0.5,
    highBufferWatchdogPeriod: 3,
    nudgeOffset: 0.1,
    nudgeMaxRetry: 3,
    maxFragLookUpTolerance: 0.25,
    liveSyncDurationCount: 3,
    liveMaxLatencyDurationCount: Infinity,
    liveSyncDuration: undefined,
    liveMaxLatencyDuration: undefined,
    liveDurationInfinity: false,
    liveBackBufferLength: Infinity,
    maxMaxBufferLength: 600,
    enableWorker: true,
    enableSoftwareAES: true,
    manifestLoadingTimeOut: 10000,
    manifestLoadingMaxRetry: 1,
    manifestLoadingRetryDelay: 1000,
    manifestLoadingMaxRetryTimeout: 64000,
    startLevel: undefined,
    levelLoadingTimeOut: 10000,
    levelLoadingMaxRetry: 4,
    levelLoadingRetryDelay: 1000,
    levelLoadingMaxRetryTimeout: 64000,
    fragLoadingTimeOut: 20000,
    fragLoadingMaxRetry: 6,
    fragLoadingRetryDelay: 1000,
    fragLoadingMaxRetryTimeout: 64000,
    startFragPrefetch: false,
    fpsDroppedMonitoringPeriod: 5000,
    fpsDroppedMonitoringThreshold: 0.2,
    appendErrorMaxRetry: 3,
    loader: xhr_loader_1.default,
    // loader: FetchLoader,
    fLoader: undefined,
    pLoader: undefined,
    xhrSetup: undefined,
    licenseXhrSetup: undefined,
    // fetchSetup: undefined,
    abrController: abr_controller_1.default,
    bufferController: buffer_controller_1.default,
    capLevelController: cap_level_controller_1.default,
    fpsController: fps_controller_1.default,
    stretchShortVideoTrack: false,
    maxAudioFramesDrift: 1,
    forceKeyFrameOnDiscontinuity: true,
    abrEwmaFastLive: 3,
    abrEwmaSlowLive: 9,
    abrEwmaFastVoD: 3,
    abrEwmaSlowVoD: 9,
    abrEwmaDefaultEstimate: 5e5,
    abrBandWidthFactor: 0.95,
    abrBandWidthUpFactor: 0.7,
    abrMaxWithRealBitrate: false,
    maxStarvationDelay: 4,
    maxLoadingDelay: 4,
    minAutoBitrate: 0,
    emeEnabled: false,
    widevineLicenseUrl: undefined,
    requestMediaKeySystemAccessFunc: mediakeys_helper_1.requestMediaKeySystemAccess // used by eme-controller
};
if (true) {
    exports.hlsDefaultConfig.subtitleStreamController = subtitle_stream_controller_1.SubtitleStreamController;
    exports.hlsDefaultConfig.subtitleTrackController = subtitle_track_controller_1.default;
    exports.hlsDefaultConfig.timelineController = timeline_controller_1.default;
    exports.hlsDefaultConfig.cueHandler = Cues; // used by timeline-controller
    exports.hlsDefaultConfig.enableCEA708Captions = true; // used by timeline-controller
    exports.hlsDefaultConfig.enableWebVTT = true; // used by timeline-controller
    exports.hlsDefaultConfig.captionsTextTrack1Label = 'English'; // used by timeline-controller
    exports.hlsDefaultConfig.captionsTextTrack1LanguageCode = 'en'; // used by timeline-controller
    exports.hlsDefaultConfig.captionsTextTrack2Label = 'Spanish'; // used by timeline-controller
    exports.hlsDefaultConfig.captionsTextTrack2LanguageCode = 'es'; // used by timeline-controller
}
if (true) {
    exports.hlsDefaultConfig.audioStreamController = audio_stream_controller_1.default;
    exports.hlsDefaultConfig.audioTrackController = audio_track_controller_1.default;
}
if (true) {
    exports.hlsDefaultConfig.emeController = eme_controller_1.default;
}


/***/ }),

/***/ "./src/controller/abr-controller.js":
/*!******************************************!*\
  !*** ./src/controller/abr-controller.js ***!
  \******************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Number) {
/*
 * simple ABR Controller
 *  - compute next level based on last fragment bw heuristics
 *  - implement an abandon rules triggered if we have less than 2 frag buffered and if computed bw shows that we risk buffer stalling
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var events_1 = __webpack_require__(/*! ../events */ "./src/events.js");
var event_handler_1 = __webpack_require__(/*! ../event-handler */ "./src/event-handler.js");
var buffer_helper_1 = __webpack_require__(/*! ../utils/buffer-helper */ "./src/utils/buffer-helper.js");
var errors_1 = __webpack_require__(/*! ../errors */ "./src/errors.js");
var logger_1 = __webpack_require__(/*! ../utils/logger */ "./src/utils/logger.js");
var ewma_bandwidth_estimator_1 = __webpack_require__(/*! ../utils/ewma-bandwidth-estimator */ "./src/utils/ewma-bandwidth-estimator.js");
var performance = window.performance;
var AbrController = /** @class */ (function (_super) {
    __extends(AbrController, _super);
    function AbrController(hls) {
        var _this = _super.call(this, hls, events_1.default.FRAG_LOADING, events_1.default.FRAG_LOADED, events_1.default.FRAG_BUFFERED, events_1.default.ERROR) || this;
        _this.lastLoadedFragLevel = 0;
        _this._nextAutoLevel = -1;
        _this.hls = hls;
        _this.timer = null;
        _this._bwEstimator = null;
        _this.onCheck = _this._abandonRulesCheck.bind(_this);
        return _this;
    }
    AbrController.prototype.destroy = function () {
        this.clearTimer();
        event_handler_1.default.prototype.destroy.call(this);
    };
    AbrController.prototype.onFragLoading = function (data) {
        var frag = data.frag;
        if (frag.type === 'main') {
            if (!this.timer) {
                this.fragCurrent = frag;
                this.timer = setInterval(this.onCheck, 100);
            }
            // lazy init of BwEstimator, rationale is that we use different params for Live/VoD
            // so we need to wait for stream manifest / playlist type to instantiate it.
            if (!this._bwEstimator) {
                var hls_1 = this.hls;
                var config = hls_1.config;
                var level = frag.level;
                var isLive = hls_1.levels[level].details.live;
                var ewmaFast = void 0, ewmaSlow = void 0;
                if (isLive) {
                    ewmaFast = config.abrEwmaFastLive;
                    ewmaSlow = config.abrEwmaSlowLive;
                }
                else {
                    ewmaFast = config.abrEwmaFastVoD;
                    ewmaSlow = config.abrEwmaSlowVoD;
                }
                this._bwEstimator = new ewma_bandwidth_estimator_1.default(hls_1, ewmaSlow, ewmaFast, config.abrEwmaDefaultEstimate);
            }
        }
    };
    AbrController.prototype._abandonRulesCheck = function () {
        /*
          monitor fragment retrieval time...
          we compute expected time of arrival of the complete fragment.
          we compare it to expected time of buffer starvation
        */
        var hls = this.hls;
        var video = hls.media;
        var frag = this.fragCurrent;
        if (!frag) {
            return;
        }
        var loader = frag.loader;
        var minAutoLevel = hls.minAutoLevel;
        // if loader has been destroyed or loading has been aborted, stop timer and return
        if (!loader || (loader.stats && loader.stats.aborted)) {
            logger_1.logger.warn('frag loader destroy or aborted, disarm abandonRules');
            this.clearTimer();
            // reset forced auto level value so that next level will be selected
            this._nextAutoLevel = -1;
            return;
        }
        var stats = loader.stats;
        /* only monitor frag retrieval time if
        (video not paused OR first fragment being loaded(ready state === HAVE_NOTHING = 0)) AND autoswitching enabled AND not lowest level (=> means that we have several levels) */
        if (video && stats && ((!video.paused && (video.playbackRate !== 0)) || !video.readyState) && frag.autoLevel && frag.level) {
            var requestDelay = performance.now() - stats.trequest, playbackRate = Math.abs(video.playbackRate);
            // monitor fragment load progress after half of expected fragment duration,to stabilize bitrate
            if (requestDelay > (500 * frag.duration / playbackRate)) {
                var levels = hls.levels, loadRate = Math.max(1, stats.bw ? stats.bw / 8 : stats.loaded * 1000 / requestDelay), // byte/s; at least 1 byte/s to avoid division by zero
                // compute expected fragment length using frag duration and level bitrate. also ensure that expected len is gte than already loaded size
                level = levels[frag.level], levelBitrate = level.realBitrate ? Math.max(level.realBitrate, level.bitrate) : level.bitrate, expectedLen = stats.total ? stats.total : Math.max(stats.loaded, Math.round(frag.duration * levelBitrate / 8)), pos = video.currentTime, fragLoadedDelay = (expectedLen - stats.loaded) / loadRate, bufferStarvationDelay = (buffer_helper_1.BufferHelper.bufferInfo(video, pos, hls.config.maxBufferHole).end - pos) / playbackRate;
                // consider emergency switch down only if we have less than 2 frag buffered AND
                // time to finish loading current fragment is bigger than buffer starvation delay
                // ie if we risk buffer starvation if bw does not increase quickly
                if ((bufferStarvationDelay < (2 * frag.duration / playbackRate)) && (fragLoadedDelay > bufferStarvationDelay)) {
                    var fragLevelNextLoadedDelay = void 0, nextLoadLevel = void 0;
                    // lets iterate through lower level and try to find the biggest one that could avoid rebuffering
                    // we start from current level - 1 and we step down , until we find a matching level
                    for (nextLoadLevel = frag.level - 1; nextLoadLevel > minAutoLevel; nextLoadLevel--) {
                        // compute time to load next fragment at lower level
                        // 0.8 : consider only 80% of current bw to be conservative
                        // 8 = bits per byte (bps/Bps)
                        var levelNextBitrate = levels[nextLoadLevel].realBitrate ? Math.max(levels[nextLoadLevel].realBitrate, levels[nextLoadLevel].bitrate) : levels[nextLoadLevel].bitrate;
                        fragLevelNextLoadedDelay = frag.duration * levelNextBitrate / (8 * 0.8 * loadRate);
                        if (fragLevelNextLoadedDelay < bufferStarvationDelay) {
                            // we found a lower level that be rebuffering free with current estimated bw !
                            break;
                        }
                    }
                    // only emergency switch down if it takes less time to load new fragment at lowest level instead
                    // of finishing loading current one ...
                    if (fragLevelNextLoadedDelay < fragLoadedDelay) {
                        logger_1.logger.warn("loading too slow, abort fragment loading and switch to level " + nextLoadLevel + ":fragLoadedDelay[" + nextLoadLevel + "]<fragLoadedDelay[" + (frag.level - 1) + "];bufferStarvationDelay:" + fragLevelNextLoadedDelay.toFixed(1) + "<" + fragLoadedDelay.toFixed(1) + ":" + bufferStarvationDelay.toFixed(1));
                        // force next load level in auto mode
                        hls.nextLoadLevel = nextLoadLevel;
                        // update bw estimate for this fragment before cancelling load (this will help reducing the bw)
                        this._bwEstimator.sample(requestDelay, stats.loaded);
                        // abort fragment loading
                        loader.abort();
                        // stop abandon rules timer
                        this.clearTimer();
                        hls.trigger(events_1.default.FRAG_LOAD_EMERGENCY_ABORTED, { frag: frag, stats: stats });
                    }
                }
            }
        }
    };
    AbrController.prototype.onFragLoaded = function (data) {
        var frag = data.frag;
        if (frag.type === 'main' && Number.isFinite(frag.sn)) {
            // stop monitoring bw once frag loaded
            this.clearTimer();
            // store level id after successful fragment load
            this.lastLoadedFragLevel = frag.level;
            // reset forced auto level value so that next level will be selected
            this._nextAutoLevel = -1;
            // compute level average bitrate
            if (this.hls.config.abrMaxWithRealBitrate) {
                var level = this.hls.levels[frag.level];
                var loadedBytes = (level.loaded ? level.loaded.bytes : 0) + data.stats.loaded;
                var loadedDuration = (level.loaded ? level.loaded.duration : 0) + data.frag.duration;
                level.loaded = { bytes: loadedBytes, duration: loadedDuration };
                level.realBitrate = Math.round(8 * loadedBytes / loadedDuration);
            }
            // if fragment has been loaded to perform a bitrate test,
            if (data.frag.bitrateTest) {
                var stats = data.stats;
                stats.tparsed = stats.tbuffered = stats.tload;
                this.onFragBuffered(data);
            }
        }
    };
    AbrController.prototype.onFragBuffered = function (data) {
        var stats = data.stats;
        var frag = data.frag;
        // only update stats on first frag buffering
        // if same frag is loaded multiple times, it might be in browser cache, and loaded quickly
        // and leading to wrong bw estimation
        // on bitrate test, also only update stats once (if tload = tbuffered == on FRAG_LOADED)
        if (stats.aborted !== true && frag.type === 'main' && Number.isFinite(frag.sn) && ((!frag.bitrateTest || stats.tload === stats.tbuffered))) {
            // use tparsed-trequest instead of tbuffered-trequest to compute fragLoadingProcessing; rationale is that  buffer appending only happens once media is attached
            // in case we use config.startFragPrefetch while media is not attached yet, fragment might be parsed while media not attached yet, but it will only be buffered on media attached
            // as a consequence it could happen really late in the process. meaning that appending duration might appears huge ... leading to underestimated throughput estimation
            var fragLoadingProcessingMs = stats.tparsed - stats.trequest;
            logger_1.logger.log("latency/loading/parsing/append/kbps:" + Math.round(stats.tfirst - stats.trequest) + "/" + Math.round(stats.tload - stats.tfirst) + "/" + Math.round(stats.tparsed - stats.tload) + "/" + Math.round(stats.tbuffered - stats.tparsed) + "/" + Math.round(8 * stats.loaded / (stats.tbuffered - stats.trequest)));
            this._bwEstimator.sample(fragLoadingProcessingMs, stats.loaded);
            stats.bwEstimate = this._bwEstimator.getEstimate();
            // if fragment has been loaded to perform a bitrate test, (hls.startLevel = -1), store bitrate test delay duration
            if (frag.bitrateTest) {
                this.bitrateTestDelay = fragLoadingProcessingMs / 1000;
            }
            else {
                this.bitrateTestDelay = 0;
            }
        }
    };
    AbrController.prototype.onError = function (data) {
        // stop timer in case of frag loading error
        switch (data.details) {
            case errors_1.ErrorDetails.FRAG_LOAD_ERROR:
            case errors_1.ErrorDetails.FRAG_LOAD_TIMEOUT:
                this.clearTimer();
                break;
            default:
                break;
        }
    };
    AbrController.prototype.clearTimer = function () {
        clearInterval(this.timer);
        this.timer = null;
    };
    Object.defineProperty(AbrController.prototype, "nextAutoLevel", {
        // return next auto level
        get: function () {
            var forcedAutoLevel = this._nextAutoLevel;
            var bwEstimator = this._bwEstimator;
            // in case next auto level has been forced, and bw not available or not reliable, return forced value
            if (forcedAutoLevel !== -1 && (!bwEstimator || !bwEstimator.canEstimate())) {
                return forcedAutoLevel;
            }
            // compute next level using ABR logic
            var nextABRAutoLevel = this._nextABRAutoLevel;
            // if forced auto level has been defined, use it to cap ABR computed quality level
            if (forcedAutoLevel !== -1) {
                nextABRAutoLevel = Math.min(forcedAutoLevel, nextABRAutoLevel);
            }
            return nextABRAutoLevel;
        },
        set: function (nextLevel) {
            this._nextAutoLevel = nextLevel;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AbrController.prototype, "_nextABRAutoLevel", {
        get: function () {
            var hls = this.hls, maxAutoLevel = hls.maxAutoLevel, levels = hls.levels, config = hls.config, minAutoLevel = hls.minAutoLevel;
            var video = hls.media, currentLevel = this.lastLoadedFragLevel, currentFragDuration = this.fragCurrent ? this.fragCurrent.duration : 0, pos = (video ? video.currentTime : 0), 
            // playbackRate is the absolute value of the playback rate; if video.playbackRate is 0, we use 1 to load as
            // if we're playing back at the normal rate.
            playbackRate = ((video && (video.playbackRate !== 0)) ? Math.abs(video.playbackRate) : 1.0), avgbw = this._bwEstimator ? this._bwEstimator.getEstimate() : config.abrEwmaDefaultEstimate, 
            // bufferStarvationDelay is the wall-clock time left until the playback buffer is exhausted.
            bufferStarvationDelay = (buffer_helper_1.BufferHelper.bufferInfo(video, pos, config.maxBufferHole).end - pos) / playbackRate;
            // First, look to see if we can find a level matching with our avg bandwidth AND that could also guarantee no rebuffering at all
            var bestLevel = this._findBestLevel(currentLevel, currentFragDuration, avgbw, minAutoLevel, maxAutoLevel, bufferStarvationDelay, config.abrBandWidthFactor, config.abrBandWidthUpFactor, levels);
            if (bestLevel >= 0) {
                return bestLevel;
            }
            else {
                logger_1.logger.trace('rebuffering expected to happen, lets try to find a quality level minimizing the rebuffering');
                // not possible to get rid of rebuffering ... let's try to find level that will guarantee less than maxStarvationDelay of rebuffering
                // if no matching level found, logic will return 0
                var maxStarvationDelay = currentFragDuration ? Math.min(currentFragDuration, config.maxStarvationDelay) : config.maxStarvationDelay, bwFactor = config.abrBandWidthFactor, bwUpFactor = config.abrBandWidthUpFactor;
                if (bufferStarvationDelay === 0) {
                    // in case buffer is empty, let's check if previous fragment was loaded to perform a bitrate test
                    var bitrateTestDelay = this.bitrateTestDelay;
                    if (bitrateTestDelay) {
                        // if it is the case, then we need to adjust our max starvation delay using maxLoadingDelay config value
                        // max video loading delay used in  automatic start level selection :
                        // in that mode ABR controller will ensure that video loading time (ie the time to fetch the first fragment at lowest quality level +
                        // the time to fetch the fragment at the appropriate quality level is less than ```maxLoadingDelay``` )
                        // cap maxLoadingDelay and ensure it is not bigger 'than bitrate test' frag duration
                        var maxLoadingDelay = currentFragDuration ? Math.min(currentFragDuration, config.maxLoadingDelay) : config.maxLoadingDelay;
                        maxStarvationDelay = maxLoadingDelay - bitrateTestDelay;
                        logger_1.logger.trace("bitrate test took " + Math.round(1000 * bitrateTestDelay) + "ms, set first fragment max fetchDuration to " + Math.round(1000 * maxStarvationDelay) + " ms");
                        // don't use conservative factor on bitrate test
                        bwFactor = bwUpFactor = 1;
                    }
                }
                bestLevel = this._findBestLevel(currentLevel, currentFragDuration, avgbw, minAutoLevel, maxAutoLevel, bufferStarvationDelay + maxStarvationDelay, bwFactor, bwUpFactor, levels);
                return Math.max(bestLevel, 0);
            }
        },
        enumerable: true,
        configurable: true
    });
    AbrController.prototype._findBestLevel = function (currentLevel, currentFragDuration, currentBw, minAutoLevel, maxAutoLevel, maxFetchDuration, bwFactor, bwUpFactor, levels) {
        for (var i = maxAutoLevel; i >= minAutoLevel; i--) {
            var levelInfo = levels[i];
            if (!levelInfo) {
                continue;
            }
            var levelDetails = levelInfo.details, avgDuration = levelDetails ? levelDetails.totalduration / levelDetails.fragments.length : currentFragDuration, live = levelDetails ? levelDetails.live : false, adjustedbw = void 0;
            // follow algorithm captured from stagefright :
            // https://android.googlesource.com/platform/frameworks/av/+/master/media/libstagefright/httplive/LiveSession.cpp
            // Pick the highest bandwidth stream below or equal to estimated bandwidth.
            // consider only 80% of the available bandwidth, but if we are switching up,
            // be even more conservative (70%) to avoid overestimating and immediately
            // switching back.
            if (i <= currentLevel) {
                adjustedbw = bwFactor * currentBw;
            }
            else {
                adjustedbw = bwUpFactor * currentBw;
            }
            var bitrate = levels[i].realBitrate ? Math.max(levels[i].realBitrate, levels[i].bitrate) : levels[i].bitrate, fetchDuration = bitrate * avgDuration / adjustedbw;
            logger_1.logger.trace("level/adjustedbw/bitrate/avgDuration/maxFetchDuration/fetchDuration: " + i + "/" + Math.round(adjustedbw) + "/" + bitrate + "/" + avgDuration + "/" + maxFetchDuration + "/" + fetchDuration);
            // if adjusted bw is greater than level bitrate AND
            if (adjustedbw > bitrate &&
                // fragment fetchDuration unknown OR live stream OR fragment fetchDuration less than max allowed fetch duration, then this level matches
                // we don't account for max Fetch Duration for live streams, this is to avoid switching down when near the edge of live sliding window ...
                // special case to support startLevel = -1 (bitrateTest) on live streams : in that case we should not exit loop so that _findBestLevel will return -1
                (!fetchDuration || (live && !this.bitrateTestDelay) || fetchDuration < maxFetchDuration)) {
                // as we are looping from highest to lowest, this will return the best achievable quality level
                return i;
            }
        }
        // not enough time budget even with quality level 0 ... rebuffering might happen
        return -1;
    };
    return AbrController;
}(event_handler_1.default));
exports.default = AbrController;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./src/polyfills/number */ "./src/polyfills/number.js")["Number"]))

/***/ }),

/***/ "./src/controller/audio-stream-controller.js":
/*!***************************************************!*\
  !*** ./src/controller/audio-stream-controller.js ***!
  \***************************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Number) {
/*
 * Audio Stream Controller
*/
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var binary_search_1 = __webpack_require__(/*! ../utils/binary-search */ "./src/utils/binary-search.js");
var buffer_helper_1 = __webpack_require__(/*! ../utils/buffer-helper */ "./src/utils/buffer-helper.js");
var demuxer_1 = __webpack_require__(/*! ../demux/demuxer */ "./src/demux/demuxer.js");
var events_1 = __webpack_require__(/*! ../events */ "./src/events.js");
var LevelHelper = __webpack_require__(/*! ./level-helper */ "./src/controller/level-helper.js");
var time_ranges_1 = __webpack_require__(/*! ../utils/time-ranges */ "./src/utils/time-ranges.js");
var errors_1 = __webpack_require__(/*! ../errors */ "./src/errors.js");
var logger_1 = __webpack_require__(/*! ../utils/logger */ "./src/utils/logger.js");
var discontinuities_1 = __webpack_require__(/*! ../utils/discontinuities */ "./src/utils/discontinuities.js");
var fragment_tracker_1 = __webpack_require__(/*! ./fragment-tracker */ "./src/controller/fragment-tracker.js");
var fragment_1 = __webpack_require__(/*! ../loader/fragment */ "./src/loader/fragment.js");
var base_stream_controller_1 = __webpack_require__(/*! ./base-stream-controller */ "./src/controller/base-stream-controller.js");
var performance = window.performance;
var TICK_INTERVAL = 100; // how often to tick in ms
var AudioStreamController = /** @class */ (function (_super) {
    __extends(AudioStreamController, _super);
    function AudioStreamController(hls, fragmentTracker) {
        var _this = _super.call(this, hls, events_1.default.MEDIA_ATTACHED, events_1.default.MEDIA_DETACHING, events_1.default.AUDIO_TRACKS_UPDATED, events_1.default.AUDIO_TRACK_SWITCHING, events_1.default.AUDIO_TRACK_LOADED, events_1.default.KEY_LOADED, events_1.default.FRAG_LOADED, events_1.default.FRAG_PARSING_INIT_SEGMENT, events_1.default.FRAG_PARSING_DATA, events_1.default.FRAG_PARSED, events_1.default.ERROR, events_1.default.BUFFER_RESET, events_1.default.BUFFER_CREATED, events_1.default.BUFFER_APPENDED, events_1.default.BUFFER_FLUSHED, events_1.default.INIT_PTS_FOUND) || this;
        _this.fragmentTracker = fragmentTracker;
        _this.config = hls.config;
        _this.audioCodecSwap = false;
        _this._state = base_stream_controller_1.State.STOPPED;
        _this.initPTS = [];
        _this.waitingFragment = null;
        _this.videoTrackCC = null;
        return _this;
    }
    // Signal that video PTS was found
    AudioStreamController.prototype.onInitPtsFound = function (data) {
        var demuxerId = data.id, cc = data.frag.cc, initPTS = data.initPTS;
        if (demuxerId === 'main') {
            // Always update the new INIT PTS
            // Can change due level switch
            this.initPTS[cc] = initPTS;
            this.videoTrackCC = cc;
            logger_1.logger.log("InitPTS for cc: " + cc + " found from video track: " + initPTS);
            // If we are waiting we need to demux/remux the waiting frag
            // With the new initPTS
            if (this.state === base_stream_controller_1.State.WAITING_INIT_PTS) {
                this.tick();
            }
        }
    };
    AudioStreamController.prototype.startLoad = function (startPosition) {
        if (this.tracks) {
            var lastCurrentTime = this.lastCurrentTime;
            this.stopLoad();
            this.setInterval(TICK_INTERVAL);
            this.fragLoadError = 0;
            if (lastCurrentTime > 0 && startPosition === -1) {
                logger_1.logger.log("audio:override startPosition with lastCurrentTime @" + lastCurrentTime.toFixed(3));
                this.state = base_stream_controller_1.State.IDLE;
            }
            else {
                this.lastCurrentTime = this.startPosition ? this.startPosition : startPosition;
                this.state = base_stream_controller_1.State.STARTING;
            }
            this.nextLoadPosition = this.startPosition = this.lastCurrentTime;
            this.tick();
        }
        else {
            this.startPosition = startPosition;
            this.state = base_stream_controller_1.State.STOPPED;
        }
    };
    Object.defineProperty(AudioStreamController.prototype, "state", {
        get: function () {
            return this._state;
        },
        set: function (nextState) {
            if (this.state !== nextState) {
                var previousState = this.state;
                this._state = nextState;
                logger_1.logger.log("audio stream:" + previousState + "->" + nextState);
            }
        },
        enumerable: true,
        configurable: true
    });
    AudioStreamController.prototype.doTick = function () {
        var pos, track, trackDetails, hls = this.hls, config = hls.config;
        // logger.log('audioStream:' + this.state);
        switch (this.state) {
            case base_stream_controller_1.State.ERROR:
            // don't do anything in error state to avoid breaking further ...
            case base_stream_controller_1.State.PAUSED:
            // don't do anything in paused state either ...
            case base_stream_controller_1.State.BUFFER_FLUSHING:
                break;
            case base_stream_controller_1.State.STARTING:
                this.state = base_stream_controller_1.State.WAITING_TRACK;
                this.loadedmetadata = false;
                break;
            case base_stream_controller_1.State.IDLE:
                var tracks = this.tracks;
                // audio tracks not received => exit loop
                if (!tracks) {
                    break;
                }
                // if video not attached AND
                // start fragment already requested OR start frag prefetch disable
                // exit loop
                // => if media not attached but start frag prefetch is enabled and start frag not requested yet, we will not exit loop
                if (!this.media &&
                    (this.startFragRequested || !config.startFragPrefetch)) {
                    break;
                }
                // determine next candidate fragment to be loaded, based on current position and
                //  end of buffer position
                // if we have not yet loaded any fragment, start loading from start position
                if (this.loadedmetadata) {
                    pos = this.media.currentTime;
                }
                else {
                    pos = this.nextLoadPosition;
                    if (pos === undefined) {
                        break;
                    }
                }
                var media = this.mediaBuffer ? this.mediaBuffer : this.media, videoBuffer = this.videoBuffer ? this.videoBuffer : this.media, bufferInfo = buffer_helper_1.BufferHelper.bufferInfo(media, pos, config.maxBufferHole), mainBufferInfo = buffer_helper_1.BufferHelper.bufferInfo(videoBuffer, pos, config.maxBufferHole), bufferLen = bufferInfo.len, bufferEnd_1 = bufferInfo.end, fragPrevious = this.fragPrevious, 
                // ensure we buffer at least config.maxBufferLength (default 30s) or config.maxMaxBufferLength (default: 600s)
                // whichever is smaller.
                // once we reach that threshold, don't buffer more than video (mainBufferInfo.len)
                maxConfigBuffer = Math.min(config.maxBufferLength, config.maxMaxBufferLength), maxBufLen = Math.max(maxConfigBuffer, mainBufferInfo.len), audioSwitch = this.audioSwitch, trackId = this.trackId;
                // if buffer length is less than maxBufLen try to load a new fragment
                if ((bufferLen < maxBufLen || audioSwitch) && trackId < tracks.length) {
                    trackDetails = tracks[trackId].details;
                    // if track info not retrieved yet, switch state and wait for track retrieval
                    if (typeof trackDetails === 'undefined') {
                        this.state = base_stream_controller_1.State.WAITING_TRACK;
                        break;
                    }
                    if (!audioSwitch && this._streamEnded(bufferInfo, trackDetails)) {
                        this.hls.trigger(events_1.default.BUFFER_EOS, { type: 'audio' });
                        this.state = base_stream_controller_1.State.ENDED;
                        return;
                    }
                    // find fragment index, contiguous with end of buffer position
                    var fragments = trackDetails.fragments, fragLen = fragments.length, start = fragments[0].start, end = fragments[fragLen - 1].start + fragments[fragLen - 1].duration, frag = void 0;
                    // When switching audio track, reload audio as close as possible to currentTime
                    if (audioSwitch) {
                        if (trackDetails.live && !trackDetails.PTSKnown) {
                            logger_1.logger.log('switching audiotrack, live stream, unknown PTS,load first fragment');
                            bufferEnd_1 = 0;
                        }
                        else {
                            bufferEnd_1 = pos;
                            // if currentTime (pos) is less than alt audio playlist start time, it means that alt audio is ahead of currentTime
                            if (trackDetails.PTSKnown && pos < start) {
                                // if everything is buffered from pos to start or if audio buffer upfront, let's seek to start
                                if (bufferInfo.end > start || bufferInfo.nextStart) {
                                    logger_1.logger.log('alt audio track ahead of main track, seek to start of alt audio track');
                                    this.media.currentTime = start + 0.05;
                                }
                                else {
                                    return;
                                }
                            }
                        }
                    }
                    if (trackDetails.initSegment && !trackDetails.initSegment.data) {
                        frag = trackDetails.initSegment;
                    } // eslint-disable-line brace-style
                    // if bufferEnd before start of playlist, load first fragment
                    else if (bufferEnd_1 <= start) {
                        frag = fragments[0];
                        if (this.videoTrackCC !== null && frag.cc !== this.videoTrackCC) {
                            // Ensure we find a fragment which matches the continuity of the video track
                            frag = discontinuities_1.findFragWithCC(fragments, this.videoTrackCC);
                        }
                        if (trackDetails.live && frag.loadIdx && frag.loadIdx === this.fragLoadIdx) {
                            // we just loaded this first fragment, and we are still lagging behind the start of the live playlist
                            // let's force seek to start
                            var nextBuffered = bufferInfo.nextStart ? bufferInfo.nextStart : start;
                            logger_1.logger.log("no alt audio available @currentTime:" + this.media.currentTime + ", seeking @" + (nextBuffered + 0.05));
                            this.media.currentTime = nextBuffered + 0.05;
                            return;
                        }
                    }
                    else {
                        var foundFrag = void 0;
                        var maxFragLookUpTolerance_1 = config.maxFragLookUpTolerance;
                        var fragNext = fragPrevious ? fragments[fragPrevious.sn - fragments[0].sn + 1] : undefined;
                        var fragmentWithinToleranceTest = function (candidate) {
                            // offset should be within fragment boundary - config.maxFragLookUpTolerance
                            // this is to cope with situations like
                            // bufferEnd = 9.991
                            // frag[] : [0,10]
                            // frag[1] : [10,20]
                            // bufferEnd is within frag[0] range ... although what we are expecting is to return frag[1] here
                            //              frag start               frag start+duration
                            //                  |-----------------------------|
                            //              <--->                         <--->
                            //  ...--------><-----------------------------><---------....
                            // previous frag         matching fragment         next frag
                            //  return -1             return 0                 return 1
                            // logger.log(`level/sn/start/end/bufEnd:${level}/${candidate.sn}/${candidate.start}/${(candidate.start+candidate.duration)}/${bufferEnd}`);
                            // Set the lookup tolerance to be small enough to detect the current segment - ensures we don't skip over very small segments
                            var candidateLookupTolerance = Math.min(maxFragLookUpTolerance_1, candidate.duration);
                            if ((candidate.start + candidate.duration - candidateLookupTolerance) <= bufferEnd_1) {
                                return 1;
                            }
                            else if (candidate.start - candidateLookupTolerance > bufferEnd_1 && candidate.start) {
                                // if maxFragLookUpTolerance will have negative value then don't return -1 for first element
                                return -1;
                            }
                            return 0;
                        };
                        if (bufferEnd_1 < end) {
                            if (bufferEnd_1 > end - maxFragLookUpTolerance_1) {
                                maxFragLookUpTolerance_1 = 0;
                            }
                            // Prefer the next fragment if it's within tolerance
                            if (fragNext && !fragmentWithinToleranceTest(fragNext)) {
                                foundFrag = fragNext;
                            }
                            else {
                                foundFrag = binary_search_1.default.search(fragments, fragmentWithinToleranceTest);
                            }
                        }
                        else {
                            // reach end of playlist
                            foundFrag = fragments[fragLen - 1];
                        }
                        if (foundFrag) {
                            frag = foundFrag;
                            start = foundFrag.start;
                            // logger.log('find SN matching with pos:' +  bufferEnd + ':' + frag.sn);
                            if (fragPrevious && frag.level === fragPrevious.level && frag.sn === fragPrevious.sn) {
                                if (frag.sn < trackDetails.endSN) {
                                    frag = fragments[frag.sn + 1 - trackDetails.startSN];
                                    logger_1.logger.log("SN just loaded, load next one: " + frag.sn);
                                }
                                else {
                                    frag = null;
                                }
                            }
                        }
                    }
                    if (frag) {
                        // logger.log('      loading frag ' + i +',pos/bufEnd:' + pos.toFixed(3) + '/' + bufferEnd.toFixed(3));
                        if (frag.encrypted) {
                            logger_1.logger.log("Loading key for " + frag.sn + " of [" + trackDetails.startSN + " ," + trackDetails.endSN + "],track " + trackId);
                            this.state = base_stream_controller_1.State.KEY_LOADING;
                            hls.trigger(events_1.default.KEY_LOADING, { frag: frag });
                        }
                        else {
                            logger_1.logger.log("Loading " + frag.sn + ", cc: " + frag.cc + " of [" + trackDetails.startSN + " ," + trackDetails.endSN + "],track " + trackId + ", currentTime:" + pos + ",bufferEnd:" + bufferEnd_1.toFixed(3));
                            // only load if fragment is not loaded or if in audio switch
                            // we force a frag loading in audio switch as fragment tracker might not have evicted previous frags in case of quick audio switch
                            this.fragCurrent = frag;
                            if (audioSwitch || this.fragmentTracker.getState(frag) === fragment_tracker_1.FragmentState.NOT_LOADED) {
                                this.startFragRequested = true;
                                if (Number.isFinite(frag.sn)) {
                                    this.nextLoadPosition = frag.start + frag.duration;
                                }
                                hls.trigger(events_1.default.FRAG_LOADING, { frag: frag });
                                this.state = base_stream_controller_1.State.FRAG_LOADING;
                            }
                        }
                    }
                }
                break;
            case base_stream_controller_1.State.WAITING_TRACK:
                track = this.tracks[this.trackId];
                // check if playlist is already loaded
                if (track && track.details) {
                    this.state = base_stream_controller_1.State.IDLE;
                }
                break;
            case base_stream_controller_1.State.FRAG_LOADING_WAITING_RETRY:
                var now = performance.now();
                var retryDate = this.retryDate;
                media = this.media;
                var isSeeking = media && media.seeking;
                // if current time is gt than retryDate, or if media seeking let's switch to IDLE state to retry loading
                if (!retryDate || (now >= retryDate) || isSeeking) {
                    logger_1.logger.log('audioStreamController: retryDate reached, switch back to IDLE state');
                    this.state = base_stream_controller_1.State.IDLE;
                }
                break;
            case base_stream_controller_1.State.WAITING_INIT_PTS:
                var videoTrackCC = this.videoTrackCC;
                if (this.initPTS[videoTrackCC] === undefined) {
                    break;
                }
                // Ensure we don't get stuck in the WAITING_INIT_PTS state if the waiting frag CC doesn't match any initPTS
                var waitingFrag = this.waitingFragment;
                if (waitingFrag) {
                    var waitingFragCC = waitingFrag.frag.cc;
                    if (videoTrackCC !== waitingFragCC) {
                        track = this.tracks[this.trackId];
                        if (track.details && track.details.live) {
                            logger_1.logger.warn("Waiting fragment CC (" + waitingFragCC + ") does not match video track CC (" + videoTrackCC + ")");
                            this.waitingFragment = null;
                            this.state = base_stream_controller_1.State.IDLE;
                        }
                    }
                    else {
                        this.state = base_stream_controller_1.State.FRAG_LOADING;
                        this.onFragLoaded(this.waitingFragment);
                        this.waitingFragment = null;
                    }
                }
                else {
                    this.state = base_stream_controller_1.State.IDLE;
                }
                break;
            case base_stream_controller_1.State.STOPPED:
            case base_stream_controller_1.State.FRAG_LOADING:
            case base_stream_controller_1.State.PARSING:
            case base_stream_controller_1.State.PARSED:
            case base_stream_controller_1.State.ENDED:
                break;
            default:
                break;
        }
    };
    AudioStreamController.prototype.onMediaAttached = function (data) {
        var media = this.media = this.mediaBuffer = data.media;
        this.onvseeking = this.onMediaSeeking.bind(this);
        this.onvended = this.onMediaEnded.bind(this);
        media.addEventListener('seeking', this.onvseeking);
        media.addEventListener('ended', this.onvended);
        var config = this.config;
        if (this.tracks && config.autoStartLoad) {
            this.startLoad(config.startPosition);
        }
    };
    AudioStreamController.prototype.onMediaDetaching = function () {
        var media = this.media;
        if (media && media.ended) {
            logger_1.logger.log('MSE detaching and video ended, reset startPosition');
            this.startPosition = this.lastCurrentTime = 0;
        }
        // remove video listeners
        if (media) {
            media.removeEventListener('seeking', this.onvseeking);
            media.removeEventListener('ended', this.onvended);
            this.onvseeking = this.onvseeked = this.onvended = null;
        }
        this.media = this.mediaBuffer = this.videoBuffer = null;
        this.loadedmetadata = false;
        this.stopLoad();
    };
    AudioStreamController.prototype.onAudioTracksUpdated = function (data) {
        logger_1.logger.log('audio tracks updated');
        this.tracks = data.audioTracks;
    };
    AudioStreamController.prototype.onAudioTrackSwitching = function (data) {
        // if any URL found on new audio track, it is an alternate audio track
        var altAudio = !!data.url;
        this.trackId = data.id;
        this.fragCurrent = null;
        this.state = base_stream_controller_1.State.PAUSED;
        this.waitingFragment = null;
        // destroy useless demuxer when switching audio to main
        if (!altAudio) {
            if (this.demuxer) {
                this.demuxer.destroy();
                this.demuxer = null;
            }
        }
        else {
            // switching to audio track, start timer if not already started
            this.setInterval(TICK_INTERVAL);
        }
        // should we switch tracks ?
        if (altAudio) {
            this.audioSwitch = true;
            // main audio track are handled by stream-controller, just do something if switching to alt audio track
            this.state = base_stream_controller_1.State.IDLE;
        }
        this.tick();
    };
    AudioStreamController.prototype.onAudioTrackLoaded = function (data) {
        var newDetails = data.details, trackId = data.id, track = this.tracks[trackId], duration = newDetails.totalduration, sliding = 0;
        logger_1.logger.log("track " + trackId + " loaded [" + newDetails.startSN + "," + newDetails.endSN + "],duration:" + duration);
        if (newDetails.live) {
            var curDetails = track.details;
            if (curDetails && newDetails.fragments.length > 0) {
                // we already have details for that level, merge them
                LevelHelper.mergeDetails(curDetails, newDetails);
                sliding = newDetails.fragments[0].start;
                // TODO
                // this.liveSyncPosition = this.computeLivePosition(sliding, curDetails);
                if (newDetails.PTSKnown) {
                    logger_1.logger.log("live audio playlist sliding:" + sliding.toFixed(3));
                }
                else {
                    logger_1.logger.log('live audio playlist - outdated PTS, unknown sliding');
                }
            }
            else {
                newDetails.PTSKnown = false;
                logger_1.logger.log('live audio playlist - first load, unknown sliding');
            }
        }
        else {
            newDetails.PTSKnown = false;
        }
        track.details = newDetails;
        // compute start position
        if (!this.startFragRequested) {
            // compute start position if set to -1. use it straight away if value is defined
            if (this.startPosition === -1) {
                // first, check if start time offset has been set in playlist, if yes, use this value
                var startTimeOffset = newDetails.startTimeOffset;
                if (Number.isFinite(startTimeOffset)) {
                    logger_1.logger.log("start time offset found in playlist, adjust startPosition to " + startTimeOffset);
                    this.startPosition = startTimeOffset;
                }
                else {
                    this.startPosition = 0;
                }
            }
            this.nextLoadPosition = this.startPosition;
        }
        // only switch batck to IDLE state if we were waiting for track to start downloading a new fragment
        if (this.state === base_stream_controller_1.State.WAITING_TRACK) {
            this.state = base_stream_controller_1.State.IDLE;
        }
        // trigger handler right now
        this.tick();
    };
    AudioStreamController.prototype.onKeyLoaded = function () {
        if (this.state === base_stream_controller_1.State.KEY_LOADING) {
            this.state = base_stream_controller_1.State.IDLE;
            this.tick();
        }
    };
    AudioStreamController.prototype.onFragLoaded = function (data) {
        var fragCurrent = this.fragCurrent, fragLoaded = data.frag;
        if (this.state === base_stream_controller_1.State.FRAG_LOADING &&
            fragCurrent &&
            fragLoaded.type === 'audio' &&
            fragLoaded.level === fragCurrent.level &&
            fragLoaded.sn === fragCurrent.sn) {
            var track = this.tracks[this.trackId], details = track.details, duration = details.totalduration, trackId = fragCurrent.level, sn = fragCurrent.sn, cc = fragCurrent.cc, audioCodec = this.config.defaultAudioCodec || track.audioCodec || 'mp4a.40.2', stats = this.stats = data.stats;
            if (sn === 'initSegment') {
                this.state = base_stream_controller_1.State.IDLE;
                stats.tparsed = stats.tbuffered = performance.now();
                details.initSegment.data = data.payload;
                this.hls.trigger(events_1.default.FRAG_BUFFERED, { stats: stats, frag: fragCurrent, id: 'audio' });
                this.tick();
            }
            else {
                this.state = base_stream_controller_1.State.PARSING;
                // transmux the MPEG-TS data to ISO-BMFF segments
                this.appended = false;
                if (!this.demuxer) {
                    this.demuxer = new demuxer_1.default(this.hls, 'audio');
                }
                // Check if we have video initPTS
                // If not we need to wait for it
                var initPTS = this.initPTS[cc];
                var initSegmentData = details.initSegment ? details.initSegment.data : [];
                if (details.initSegment || initPTS !== undefined) {
                    this.pendingBuffering = true;
                    logger_1.logger.log("Demuxing " + sn + " of [" + details.startSN + " ," + details.endSN + "],track " + trackId);
                    // time Offset is accurate if level PTS is known, or if playlist is not sliding (not live)
                    var accurateTimeOffset = false; // details.PTSKnown || !details.live;
                    this.demuxer.push(data.payload, initSegmentData, audioCodec, null, fragCurrent, duration, accurateTimeOffset, initPTS);
                }
                else {
                    logger_1.logger.log("unknown video PTS for continuity counter " + cc + ", waiting for video PTS before demuxing audio frag " + sn + " of [" + details.startSN + " ," + details.endSN + "],track " + trackId);
                    this.waitingFragment = data;
                    this.state = base_stream_controller_1.State.WAITING_INIT_PTS;
                }
            }
        }
        this.fragLoadError = 0;
    };
    AudioStreamController.prototype.onFragParsingInitSegment = function (data) {
        var fragCurrent = this.fragCurrent;
        var fragNew = data.frag;
        if (fragCurrent &&
            data.id === 'audio' &&
            fragNew.sn === fragCurrent.sn &&
            fragNew.level === fragCurrent.level &&
            this.state === base_stream_controller_1.State.PARSING) {
            var tracks = data.tracks, track = void 0;
            // delete any video track found on audio demuxer
            if (tracks.video) {
                delete tracks.video;
            }
            // include levelCodec in audio and video tracks
            track = tracks.audio;
            if (track) {
                track.levelCodec = track.codec;
                track.id = data.id;
                this.hls.trigger(events_1.default.BUFFER_CODECS, tracks);
                logger_1.logger.log("audio track:audio,container:" + track.container + ",codecs[level/parsed]=[" + track.levelCodec + "/" + track.codec + "]");
                var initSegment = track.initSegment;
                if (initSegment) {
                    var appendObj = { type: 'audio', data: initSegment, parent: 'audio', content: 'initSegment' };
                    if (this.audioSwitch) {
                        this.pendingData = [appendObj];
                    }
                    else {
                        this.appended = true;
                        // arm pending Buffering flag before appending a segment
                        this.pendingBuffering = true;
                        this.hls.trigger(events_1.default.BUFFER_APPENDING, appendObj);
                    }
                }
                // trigger handler right now
                this.tick();
            }
        }
    };
    AudioStreamController.prototype.onFragParsingData = function (data) {
        var _this = this;
        var fragCurrent = this.fragCurrent;
        var fragNew = data.frag;
        if (fragCurrent &&
            data.id === 'audio' &&
            data.type === 'audio' &&
            fragNew.sn === fragCurrent.sn &&
            fragNew.level === fragCurrent.level &&
            this.state === base_stream_controller_1.State.PARSING) {
            var trackId = this.trackId, track = this.tracks[trackId], hls_1 = this.hls;
            if (!Number.isFinite(data.endPTS)) {
                data.endPTS = data.startPTS + fragCurrent.duration;
                data.endDTS = data.startDTS + fragCurrent.duration;
            }
            fragCurrent.addElementaryStream(fragment_1.default.ElementaryStreamTypes.AUDIO);
            logger_1.logger.log("parsed " + data.type + ",PTS:[" + data.startPTS.toFixed(3) + "," + data.endPTS.toFixed(3) + "],DTS:[" + data.startDTS.toFixed(3) + "/" + data.endDTS.toFixed(3) + "],nb:" + data.nb);
            LevelHelper.updateFragPTSDTS(track.details, fragCurrent, data.startPTS, data.endPTS);
            var audioSwitch = this.audioSwitch, media = this.media, appendOnBufferFlush = false;
            // Only flush audio from old audio tracks when PTS is known on new audio track
            if (audioSwitch && media) {
                if (media.readyState) {
                    var currentTime = media.currentTime;
                    logger_1.logger.log('switching audio track : currentTime:' + currentTime);
                    if (currentTime >= data.startPTS) {
                        logger_1.logger.log('switching audio track : flushing all audio');
                        this.state = base_stream_controller_1.State.BUFFER_FLUSHING;
                        hls_1.trigger(events_1.default.BUFFER_FLUSHING, { startOffset: 0, endOffset: Number.POSITIVE_INFINITY, type: 'audio' });
                        appendOnBufferFlush = true;
                        // Lets announce that the initial audio track switch flush occur
                        this.audioSwitch = false;
                        hls_1.trigger(events_1.default.AUDIO_TRACK_SWITCHED, { id: trackId });
                    }
                }
                else {
                    // Lets announce that the initial audio track switch flush occur
                    this.audioSwitch = false;
                    hls_1.trigger(events_1.default.AUDIO_TRACK_SWITCHED, { id: trackId });
                }
            }
            var pendingData_1 = this.pendingData;
            if (!pendingData_1) {
                logger_1.logger.warn('Apparently attempt to enqueue media payload without codec initialization data upfront');
                hls_1.trigger(events_1.default.ERROR, { type: errors_1.ErrorTypes.MEDIA_ERROR, details: null, fatal: true });
                return;
            }
            if (!this.audioSwitch) {
                [data.data1, data.data2].forEach(function (buffer) {
                    if (buffer && buffer.length) {
                        pendingData_1.push({ type: data.type, data: buffer, parent: 'audio', content: 'data' });
                    }
                });
                if (!appendOnBufferFlush && pendingData_1.length) {
                    pendingData_1.forEach(function (appendObj) {
                        // only append in PARSING state (rationale is that an appending error could happen synchronously on first segment appending)
                        // in that case it is useless to append following segments
                        if (_this.state === base_stream_controller_1.State.PARSING) {
                            // arm pending Buffering flag before appending a segment
                            _this.pendingBuffering = true;
                            _this.hls.trigger(events_1.default.BUFFER_APPENDING, appendObj);
                        }
                    });
                    this.pendingData = [];
                    this.appended = true;
                }
            }
            // trigger handler right now
            this.tick();
        }
    };
    AudioStreamController.prototype.onFragParsed = function (data) {
        var fragCurrent = this.fragCurrent;
        var fragNew = data.frag;
        if (fragCurrent &&
            data.id === 'audio' &&
            fragNew.sn === fragCurrent.sn &&
            fragNew.level === fragCurrent.level &&
            this.state === base_stream_controller_1.State.PARSING) {
            this.stats.tparsed = performance.now();
            this.state = base_stream_controller_1.State.PARSED;
            this._checkAppendedParsed();
        }
    };
    AudioStreamController.prototype.onBufferReset = function () {
        // reset reference to sourcebuffers
        this.mediaBuffer = this.videoBuffer = null;
        this.loadedmetadata = false;
    };
    AudioStreamController.prototype.onBufferCreated = function (data) {
        var audioTrack = data.tracks.audio;
        if (audioTrack) {
            this.mediaBuffer = audioTrack.buffer;
            this.loadedmetadata = true;
        }
        if (data.tracks.video) {
            this.videoBuffer = data.tracks.video.buffer;
        }
    };
    AudioStreamController.prototype.onBufferAppended = function (data) {
        if (data.parent === 'audio') {
            var state = this.state;
            if (state === base_stream_controller_1.State.PARSING || state === base_stream_controller_1.State.PARSED) {
                // check if all buffers have been appended
                this.pendingBuffering = (data.pending > 0);
                this._checkAppendedParsed();
            }
        }
    };
    AudioStreamController.prototype._checkAppendedParsed = function () {
        // trigger handler right now
        if (this.state === base_stream_controller_1.State.PARSED && (!this.appended || !this.pendingBuffering)) {
            var frag = this.fragCurrent, stats = this.stats, hls_2 = this.hls;
            if (frag) {
                this.fragPrevious = frag;
                stats.tbuffered = performance.now();
                hls_2.trigger(events_1.default.FRAG_BUFFERED, { stats: stats, frag: frag, id: 'audio' });
                var media = this.mediaBuffer ? this.mediaBuffer : this.media;
                logger_1.logger.log("audio buffered : " + time_ranges_1.default.toString(media.buffered));
                if (this.audioSwitch && this.appended) {
                    this.audioSwitch = false;
                    hls_2.trigger(events_1.default.AUDIO_TRACK_SWITCHED, { id: this.trackId });
                }
                this.state = base_stream_controller_1.State.IDLE;
            }
            this.tick();
        }
    };
    AudioStreamController.prototype.onError = function (data) {
        var frag = data.frag;
        // don't handle frag error not related to audio fragment
        if (frag && frag.type !== 'audio') {
            return;
        }
        switch (data.details) {
            case errors_1.ErrorDetails.FRAG_LOAD_ERROR:
            case errors_1.ErrorDetails.FRAG_LOAD_TIMEOUT:
                var frag_1 = data.frag;
                // don't handle frag error not related to audio fragment
                if (frag_1 && frag_1.type !== 'audio') {
                    break;
                }
                if (!data.fatal) {
                    var loadError = this.fragLoadError;
                    if (loadError) {
                        loadError++;
                    }
                    else {
                        loadError = 1;
                    }
                    var config = this.config;
                    if (loadError <= config.fragLoadingMaxRetry) {
                        this.fragLoadError = loadError;
                        // exponential backoff capped to config.fragLoadingMaxRetryTimeout
                        var delay = Math.min(Math.pow(2, loadError - 1) * config.fragLoadingRetryDelay, config.fragLoadingMaxRetryTimeout);
                        logger_1.logger.warn("AudioStreamController: frag loading failed, retry in " + delay + " ms");
                        this.retryDate = performance.now() + delay;
                        // retry loading state
                        this.state = base_stream_controller_1.State.FRAG_LOADING_WAITING_RETRY;
                    }
                    else {
                        logger_1.logger.error("AudioStreamController: " + data.details + " reaches max retry, redispatch as fatal ...");
                        // switch error to fatal
                        data.fatal = true;
                        this.state = base_stream_controller_1.State.ERROR;
                    }
                }
                break;
            case errors_1.ErrorDetails.AUDIO_TRACK_LOAD_ERROR:
            case errors_1.ErrorDetails.AUDIO_TRACK_LOAD_TIMEOUT:
            case errors_1.ErrorDetails.KEY_LOAD_ERROR:
            case errors_1.ErrorDetails.KEY_LOAD_TIMEOUT:
                //  when in ERROR state, don't switch back to IDLE state in case a non-fatal error is received
                if (this.state !== base_stream_controller_1.State.ERROR) {
                    // if fatal error, stop processing, otherwise move to IDLE to retry loading
                    this.state = data.fatal ? base_stream_controller_1.State.ERROR : base_stream_controller_1.State.IDLE;
                    logger_1.logger.warn("AudioStreamController: " + data.details + " while loading frag, now switching to " + this.state + " state ...");
                }
                break;
            case errors_1.ErrorDetails.BUFFER_FULL_ERROR:
                // if in appending state
                if (data.parent === 'audio' && (this.state === base_stream_controller_1.State.PARSING || this.state === base_stream_controller_1.State.PARSED)) {
                    var media = this.mediaBuffer, currentTime = this.media.currentTime, mediaBuffered = media && buffer_helper_1.BufferHelper.isBuffered(media, currentTime) && buffer_helper_1.BufferHelper.isBuffered(media, currentTime + 0.5);
                    // reduce max buf len if current position is buffered
                    if (mediaBuffered) {
                        var config = this.config;
                        if (config.maxMaxBufferLength >= config.maxBufferLength) {
                            // reduce max buffer length as it might be too high. we do this to avoid loop flushing ...
                            config.maxMaxBufferLength /= 2;
                            logger_1.logger.warn("AudioStreamController: reduce max buffer length to " + config.maxMaxBufferLength + "s");
                        }
                        this.state = base_stream_controller_1.State.IDLE;
                    }
                    else {
                        // current position is not buffered, but browser is still complaining about buffer full error
                        // this happens on IE/Edge, refer to https://github.com/video-dev/hls.js/pull/708
                        // in that case flush the whole audio buffer to recover
                        logger_1.logger.warn('AudioStreamController: buffer full error also media.currentTime is not buffered, flush audio buffer');
                        this.fragCurrent = null;
                        // flush everything
                        this.state = base_stream_controller_1.State.BUFFER_FLUSHING;
                        this.hls.trigger(events_1.default.BUFFER_FLUSHING, { startOffset: 0, endOffset: Number.POSITIVE_INFINITY, type: 'audio' });
                    }
                }
                break;
            default:
                break;
        }
    };
    AudioStreamController.prototype.onBufferFlushed = function () {
        var _this = this;
        var pendingData = this.pendingData;
        if (pendingData && pendingData.length) {
            logger_1.logger.log('AudioStreamController: appending pending audio data after buffer flushed');
            pendingData.forEach(function (appendObj) {
                _this.hls.trigger(events_1.default.BUFFER_APPENDING, appendObj);
            });
            this.appended = true;
            this.pendingData = [];
            this.state = base_stream_controller_1.State.PARSED;
        }
        else {
            // move to IDLE once flush complete. this should trigger new fragment loading
            this.state = base_stream_controller_1.State.IDLE;
            // reset reference to frag
            this.fragPrevious = null;
            this.tick();
        }
    };
    return AudioStreamController;
}(base_stream_controller_1.default));
exports.default = AudioStreamController;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./src/polyfills/number */ "./src/polyfills/number.js")["Number"]))

/***/ }),

/***/ "./src/controller/audio-track-controller.js":
/*!**************************************************!*\
  !*** ./src/controller/audio-track-controller.js ***!
  \**************************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var events_1 = __webpack_require__(/*! ../events */ "./src/events.js");
var task_loop_1 = __webpack_require__(/*! ../task-loop */ "./src/task-loop.js");
var logger_1 = __webpack_require__(/*! ../utils/logger */ "./src/utils/logger.js");
var errors_1 = __webpack_require__(/*! ../errors */ "./src/errors.js");
/**
 * @class AudioTrackController
 * @implements {EventHandler}
 *
 * Handles main manifest and audio-track metadata loaded,
 * owns and exposes the selectable audio-tracks data-models.
 *
 * Exposes internal interface to select available audio-tracks.
 *
 * Handles errors on loading audio-track playlists. Manages fallback mechanism
 * with redundants tracks (group-IDs).
 *
 * Handles level-loading and group-ID switches for video (fallback on video levels),
 * and eventually adapts the audio-track group-ID to match.
 *
 * @fires AUDIO_TRACK_LOADING
 * @fires AUDIO_TRACK_SWITCHING
 * @fires AUDIO_TRACKS_UPDATED
 * @fires ERROR
 *
 */
var AudioTrackController = /** @class */ (function (_super) {
    __extends(AudioTrackController, _super);
    function AudioTrackController(hls) {
        var _this = _super.call(this, hls, events_1.default.MANIFEST_LOADING, events_1.default.MANIFEST_PARSED, events_1.default.AUDIO_TRACK_LOADED, events_1.default.AUDIO_TRACK_SWITCHED, events_1.default.LEVEL_LOADED, events_1.default.ERROR) || this;
        /**
         * @private
         * Currently selected index in `tracks`
         * @member {number} trackId
         */
        _this._trackId = -1;
        /**
         * @private
         * If should select tracks according to default track attribute
         * @member {boolean} _selectDefaultTrack
         */
        _this._selectDefaultTrack = true;
        /**
         * @public
         * All tracks available
         * @member {AudioTrack[]}
         */
        _this.tracks = [];
        /**
         * @public
         * List of blacklisted audio track IDs (that have caused failure)
         * @member {number[]}
         */
        _this.trackIdBlacklist = Object.create(null);
        /**
         * @public
         * The currently running group ID for audio
         * (we grab this on manifest-parsed and new level-loaded)
         * @member {string}
         */
        _this.audioGroupId = null;
        return _this;
    }
    /**
     * Reset audio tracks on new manifest loading.
     */
    AudioTrackController.prototype.onManifestLoading = function () {
        this.tracks = [];
        this._trackId = -1;
        this._selectDefaultTrack = true;
    };
    /**
     * Store tracks data from manifest parsed data.
     *
     * Trigger AUDIO_TRACKS_UPDATED event.
     *
     * @param {*} data
     */
    AudioTrackController.prototype.onManifestParsed = function (data) {
        var tracks = this.tracks = data.audioTracks || [];
        this.hls.trigger(events_1.default.AUDIO_TRACKS_UPDATED, { audioTracks: tracks });
    };
    /**
     * Store track details of loaded track in our data-model.
     *
     * Set-up metadata update interval task for live-mode streams.
     *
     * @param {} data
     */
    AudioTrackController.prototype.onAudioTrackLoaded = function (data) {
        if (data.id >= this.tracks.length) {
            logger_1.logger.warn('Invalid audio track id:', data.id);
            return;
        }
        logger_1.logger.log("audioTrack " + data.id + " loaded");
        this.tracks[data.id].details = data.details;
        // check if current playlist is a live playlist
        // and if we have already our reload interval setup
        if (data.details.live && !this.hasInterval()) {
            // if live playlist we will have to reload it periodically
            // set reload period to playlist target duration
            var updatePeriodMs = data.details.targetduration * 1000;
            this.setInterval(updatePeriodMs);
        }
        if (!data.details.live && this.hasInterval()) {
            // playlist is not live and timer is scheduled: cancel it
            this.clearInterval();
        }
    };
    /**
     * Update the internal group ID to any audio-track we may have set manually
     * or because of a failure-handling fallback.
     *
     * Quality-levels should update to that group ID in this case.
     *
     * @param {*} data
     */
    AudioTrackController.prototype.onAudioTrackSwitched = function (data) {
        var audioGroupId = this.tracks[data.id].groupId;
        if (audioGroupId && (this.audioGroupId !== audioGroupId)) {
            this.audioGroupId = audioGroupId;
        }
    };
    /**
     * When a level gets loaded, if it has redundant audioGroupIds (in the same ordinality as it's redundant URLs)
     * we are setting our audio-group ID internally to the one set, if it is different from the group ID currently set.
     *
     * If group-ID got update, we re-select the appropriate audio-track with this group-ID matching the currently
     * selected one (based on NAME property).
     *
     * @param {*} data
     */
    AudioTrackController.prototype.onLevelLoaded = function (data) {
        // FIXME: crashes because currentLevel is undefined
        // const levelInfo = this.hls.levels[this.hls.currentLevel];
        var levelInfo = this.hls.levels[data.level];
        if (!levelInfo.audioGroupIds) {
            return;
        }
        var audioGroupId = levelInfo.audioGroupIds[levelInfo.urlId];
        if (this.audioGroupId !== audioGroupId) {
            this.audioGroupId = audioGroupId;
            this._selectInitialAudioTrack();
        }
    };
    /**
     * Handle network errors loading audio track manifests
     * and also pausing on any netwok errors.
     *
     * @param {ErrorEventData} data
     */
    AudioTrackController.prototype.onError = function (data) {
        // Only handle network errors
        if (data.type !== errors_1.ErrorTypes.NETWORK_ERROR) {
            return;
        }
        // If fatal network error, cancel update task
        if (data.fatal) {
            this.clearInterval();
        }
        // If not an audio-track loading error don't handle further
        if (data.details !== errors_1.ErrorDetails.AUDIO_TRACK_LOAD_ERROR) {
            return;
        }
        logger_1.logger.warn('Network failure on audio-track id:', data.context.id);
        this._handleLoadError();
    };
    Object.defineProperty(AudioTrackController.prototype, "audioTracks", {
        /**
         * @type {AudioTrack[]} Audio-track list we own
         */
        get: function () {
            return this.tracks;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AudioTrackController.prototype, "audioTrack", {
        /**
         * @type {number} Index into audio-tracks list of currently selected track.
         */
        get: function () {
            return this._trackId;
        },
        /**
         * Select current track by index
         */
        set: function (newId) {
            this._setAudioTrack(newId);
            // If audio track is selected from API then don't choose from the manifest default track
            this._selectDefaultTrack = false;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @private
     * @param {number} newId
     */
    AudioTrackController.prototype._setAudioTrack = function (newId) {
        // noop on same audio track id as already set
        if (this._trackId === newId && this.tracks[this._trackId].details) {
            logger_1.logger.debug('Same id as current audio-track passed, and track details available -> no-op');
            return;
        }
        // check if level idx is valid
        if (newId < 0 || newId >= this.tracks.length) {
            logger_1.logger.warn('Invalid id passed to audio-track controller');
            return;
        }
        var audioTrack = this.tracks[newId];
        logger_1.logger.log("Now switching to audio-track index " + newId);
        // stopping live reloading timer if any
        this.clearInterval();
        this._trackId = newId;
        var url = audioTrack.url, type = audioTrack.type, id = audioTrack.id;
        this.hls.trigger(events_1.default.AUDIO_TRACK_SWITCHING, { id: id, type: type, url: url });
        this._loadTrackDetailsIfNeeded(audioTrack);
    };
    /**
     * @override
     */
    AudioTrackController.prototype.doTick = function () {
        this._updateTrack(this._trackId);
    };
    /**
     * Select initial track
     * @private
     */
    AudioTrackController.prototype._selectInitialAudioTrack = function () {
        var _this = this;
        var tracks = this.tracks;
        if (!tracks.length) {
            return;
        }
        var currentAudioTrack = this.tracks[this._trackId];
        var name = null;
        if (currentAudioTrack) {
            name = currentAudioTrack.name;
        }
        // Pre-select default tracks if there are any
        if (this._selectDefaultTrack) {
            var defaultTracks = tracks.filter(function (track) { return track.default; });
            if (defaultTracks.length) {
                tracks = defaultTracks;
            }
            else {
                logger_1.logger.warn('No default audio tracks defined');
            }
        }
        var trackFound = false;
        var traverseTracks = function () {
            // Select track with right group ID
            tracks.forEach(function (track) {
                if (trackFound) {
                    return;
                }
                // We need to match the (pre-)selected group ID
                // and the NAME of the current track.
                if ((!_this.audioGroupId || track.groupId === _this.audioGroupId) &&
                    (!name || name === track.name)) {
                    // If there was a previous track try to stay with the same `NAME`.
                    // It should be unique across tracks of same group, and consistent through redundant track groups.
                    _this._setAudioTrack(track.id);
                    trackFound = true;
                }
            });
        };
        traverseTracks();
        if (!trackFound) {
            name = null;
            traverseTracks();
        }
        if (!trackFound) {
            logger_1.logger.error("No track found for running audio group-ID: " + this.audioGroupId);
            this.hls.trigger(events_1.default.ERROR, {
                type: errors_1.ErrorTypes.MEDIA_ERROR,
                details: errors_1.ErrorDetails.AUDIO_TRACK_LOAD_ERROR,
                fatal: true
            });
        }
    };
    /**
     * @private
     * @param {AudioTrack} audioTrack
     * @returns {boolean}
     */
    AudioTrackController.prototype._needsTrackLoading = function (audioTrack) {
        var details = audioTrack.details, url = audioTrack.url;
        if (!details || details.live) {
            // check if we face an audio track embedded in main playlist (audio track without URI attribute)
            return !!url;
        }
        return false;
    };
    /**
     * @private
     * @param {AudioTrack} audioTrack
     */
    AudioTrackController.prototype._loadTrackDetailsIfNeeded = function (audioTrack) {
        if (this._needsTrackLoading(audioTrack)) {
            var url = audioTrack.url, id = audioTrack.id;
            // track not retrieved yet, or live playlist we need to (re)load it
            logger_1.logger.log("loading audio-track playlist for id: " + id);
            this.hls.trigger(events_1.default.AUDIO_TRACK_LOADING, { url: url, id: id });
        }
    };
    /**
     * @private
     * @param {number} newId
     */
    AudioTrackController.prototype._updateTrack = function (newId) {
        // check if level idx is valid
        if (newId < 0 || newId >= this.tracks.length) {
            return;
        }
        // stopping live reloading timer if any
        this.clearInterval();
        this._trackId = newId;
        logger_1.logger.log("trying to update audio-track " + newId);
        var audioTrack = this.tracks[newId];
        this._loadTrackDetailsIfNeeded(audioTrack);
    };
    /**
     * @private
     */
    AudioTrackController.prototype._handleLoadError = function () {
        // First, let's black list current track id
        this.trackIdBlacklist[this._trackId] = true;
        // Let's try to fall back on a functional audio-track with the same group ID
        var previousId = this._trackId;
        var _a = this.tracks[previousId], name = _a.name, language = _a.language, groupId = _a.groupId;
        logger_1.logger.warn("Loading failed on audio track id: " + previousId + ", group-id: " + groupId + ", name/language: \"" + name + "\" / \"" + language + "\"");
        // Find a non-blacklisted track ID with the same NAME
        // At least a track that is not blacklisted, thus on another group-ID.
        var newId = previousId;
        for (var i = 0; i < this.tracks.length; i++) {
            if (this.trackIdBlacklist[i]) {
                continue;
            }
            var newTrack = this.tracks[i];
            if (newTrack.name === name) {
                newId = i;
                break;
            }
        }
        if (newId === previousId) {
            logger_1.logger.warn("No fallback audio-track found for name/language: \"" + name + "\" / \"" + language + "\"");
            return;
        }
        logger_1.logger.log('Attempting audio-track fallback id:', newId, 'group-id:', this.tracks[newId].groupId);
        this._setAudioTrack(newId);
    };
    return AudioTrackController;
}(task_loop_1.default));
exports.default = AudioTrackController;


/***/ }),

/***/ "./src/controller/base-stream-controller.js":
/*!**************************************************!*\
  !*** ./src/controller/base-stream-controller.js ***!
  \**************************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Number) {
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var task_loop_1 = __webpack_require__(/*! ../task-loop */ "./src/task-loop.js");
var fragment_tracker_1 = __webpack_require__(/*! ./fragment-tracker */ "./src/controller/fragment-tracker.js");
var buffer_helper_1 = __webpack_require__(/*! ../utils/buffer-helper */ "./src/utils/buffer-helper.js");
var logger_1 = __webpack_require__(/*! ../utils/logger */ "./src/utils/logger.js");
exports.State = {
    STOPPED: 'STOPPED',
    STARTING: 'STARTING',
    IDLE: 'IDLE',
    PAUSED: 'PAUSED',
    KEY_LOADING: 'KEY_LOADING',
    FRAG_LOADING: 'FRAG_LOADING',
    FRAG_LOADING_WAITING_RETRY: 'FRAG_LOADING_WAITING_RETRY',
    WAITING_TRACK: 'WAITING_TRACK',
    PARSING: 'PARSING',
    PARSED: 'PARSED',
    BUFFER_FLUSHING: 'BUFFER_FLUSHING',
    ENDED: 'ENDED',
    ERROR: 'ERROR',
    WAITING_INIT_PTS: 'WAITING_INIT_PTS',
    WAITING_LEVEL: 'WAITING_LEVEL'
};
var BaseStreamController = /** @class */ (function (_super) {
    __extends(BaseStreamController, _super);
    function BaseStreamController() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    BaseStreamController.prototype.doTick = function () { };
    BaseStreamController.prototype.startLoad = function () { };
    BaseStreamController.prototype.stopLoad = function () {
        var frag = this.fragCurrent;
        if (frag) {
            if (frag.loader) {
                frag.loader.abort();
            }
            this.fragmentTracker.removeFragment(frag);
        }
        if (this.demuxer) {
            this.demuxer.destroy();
            this.demuxer = null;
        }
        this.fragCurrent = null;
        this.fragPrevious = null;
        this.clearInterval();
        this.clearNextTick();
        this.state = exports.State.STOPPED;
    };
    BaseStreamController.prototype._streamEnded = function (bufferInfo, levelDetails) {
        var _a = this, fragCurrent = _a.fragCurrent, fragmentTracker = _a.fragmentTracker;
        // we just got done loading the final fragment and there is no other buffered range after ...
        // rationale is that in case there are any buffered ranges after, it means that there are unbuffered portion in between
        // so we should not switch to ENDED in that case, to be able to buffer them
        // dont switch to ENDED if we need to backtrack last fragment
        if (!levelDetails.live && fragCurrent && !fragCurrent.backtracked && fragCurrent.sn === levelDetails.endSN && !bufferInfo.nextStart) {
            var fragState = fragmentTracker.getState(fragCurrent);
            return fragState === fragment_tracker_1.FragmentState.PARTIAL || fragState === fragment_tracker_1.FragmentState.OK;
        }
        return false;
    };
    BaseStreamController.prototype.onMediaSeeking = function () {
        var _a = this, config = _a.config, media = _a.media, mediaBuffer = _a.mediaBuffer, state = _a.state;
        var currentTime = media ? media.currentTime : null;
        var bufferInfo = buffer_helper_1.BufferHelper.bufferInfo(mediaBuffer || media, currentTime, this.config.maxBufferHole);
        if (Number.isFinite(currentTime)) {
            logger_1.logger.log("media seeking to " + currentTime.toFixed(3));
        }
        if (state === exports.State.FRAG_LOADING) {
            var fragCurrent = this.fragCurrent;
            // check if we are seeking to a unbuffered area AND if frag loading is in progress
            if (bufferInfo.len === 0 && fragCurrent) {
                var tolerance = config.maxFragLookUpTolerance;
                var fragStartOffset = fragCurrent.start - tolerance;
                var fragEndOffset = fragCurrent.start + fragCurrent.duration + tolerance;
                // check if we seek position will be out of currently loaded frag range : if out cancel frag load, if in, don't do anything
                if (currentTime < fragStartOffset || currentTime > fragEndOffset) {
                    if (fragCurrent.loader) {
                        logger_1.logger.log('seeking outside of buffer while fragment load in progress, cancel fragment load');
                        fragCurrent.loader.abort();
                    }
                    this.fragCurrent = null;
                    this.fragPrevious = null;
                    // switch to IDLE state to load new fragment
                    this.state = exports.State.IDLE;
                }
                else {
                    logger_1.logger.log('seeking outside of buffer but within currently loaded fragment range');
                }
            }
        }
        else if (state === exports.State.ENDED) {
            // if seeking to unbuffered area, clean up fragPrevious
            if (bufferInfo.len === 0) {
                this.fragPrevious = null;
                this.fragCurrent = null;
            }
            // switch to IDLE state to check for potential new fragment
            this.state = exports.State.IDLE;
        }
        if (media) {
            this.lastCurrentTime = currentTime;
        }
        // in case seeking occurs although no media buffered, adjust startPosition and nextLoadPosition to seek target
        if (!this.loadedmetadata) {
            this.nextLoadPosition = this.startPosition = currentTime;
        }
        // tick to speed up processing
        this.tick();
    };
    BaseStreamController.prototype.onMediaEnded = function () {
        // reset startPosition and lastCurrentTime to restart playback @ stream beginning
        this.startPosition = this.lastCurrentTime = 0;
    };
    BaseStreamController.prototype.onHandlerDestroying = function () {
        this.stopLoad();
        _super.prototype.onHandlerDestroying.call(this);
    };
    BaseStreamController.prototype.onHandlerDestroyed = function () {
        this.state = exports.State.STOPPED;
        this.fragmentTracker = null;
    };
    return BaseStreamController;
}(task_loop_1.default));
exports.default = BaseStreamController;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./src/polyfills/number */ "./src/polyfills/number.js")["Number"]))

/***/ }),

/***/ "./src/controller/buffer-controller.js":
/*!*********************************************!*\
  !*** ./src/controller/buffer-controller.js ***!
  \*********************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Number) {
/*
 * Buffer Controller
*/
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var events_1 = __webpack_require__(/*! ../events */ "./src/events.js");
var event_handler_1 = __webpack_require__(/*! ../event-handler */ "./src/event-handler.js");
var logger_1 = __webpack_require__(/*! ../utils/logger */ "./src/utils/logger.js");
var errors_1 = __webpack_require__(/*! ../errors */ "./src/errors.js");
var mediasource_helper_1 = __webpack_require__(/*! ../utils/mediasource-helper */ "./src/utils/mediasource-helper.js");
var MediaSource = mediasource_helper_1.getMediaSource();
var BufferController = /** @class */ (function (_super) {
    __extends(BufferController, _super);
    function BufferController(hls) {
        var _this = _super.call(this, hls, events_1.default.MEDIA_ATTACHING, events_1.default.MEDIA_DETACHING, events_1.default.MANIFEST_PARSED, events_1.default.BUFFER_RESET, events_1.default.BUFFER_APPENDING, events_1.default.BUFFER_CODECS, events_1.default.BUFFER_EOS, events_1.default.BUFFER_FLUSHING, events_1.default.LEVEL_PTS_UPDATED, events_1.default.LEVEL_UPDATED) || this;
        // the value that we have set mediasource.duration to
        // (the actual duration may be tweaked slighly by the browser)
        _this._msDuration = null;
        // the value that we want to set mediaSource.duration to
        _this._levelDuration = null;
        // the target duration of the current media playlist
        _this._levelTargetDuration = 10;
        // current stream state: true - for live broadcast, false - for VoD content
        _this._live = null;
        // cache the self generated object url to detect hijack of video tag
        _this._objectUrl = null;
        // The number of BUFFER_CODEC events received before any sourceBuffers are created
        _this.bufferCodecEventsExpected = 0;
        // Source Buffer listeners
        _this.onsbue = _this.onSBUpdateEnd.bind(_this);
        _this.onsbe = _this.onSBUpdateError.bind(_this);
        _this.pendingTracks = {};
        _this.tracks = {};
        return _this;
    }
    BufferController.prototype.destroy = function () {
        event_handler_1.default.prototype.destroy.call(this);
    };
    BufferController.prototype.onLevelPtsUpdated = function (data) {
        var type = data.type;
        var audioTrack = this.tracks.audio;
        // Adjusting `SourceBuffer.timestampOffset` (desired point in the timeline where the next frames should be appended)
        // in Chrome browser when we detect MPEG audio container and time delta between level PTS and `SourceBuffer.timestampOffset`
        // is greater than 100ms (this is enough to handle seek for VOD or level change for LIVE videos). At the time of change we issue
        // `SourceBuffer.abort()` and adjusting `SourceBuffer.timestampOffset` if `SourceBuffer.updating` is false or awaiting `updateend`
        // event if SB is in updating state.
        // More info here: https://github.com/video-dev/hls.js/issues/332#issuecomment-257986486
        if (type === 'audio' && audioTrack && audioTrack.container === 'audio/mpeg') { // Chrome audio mp3 track
            var audioBuffer = this.sourceBuffer.audio;
            var delta = Math.abs(audioBuffer.timestampOffset - data.start);
            // adjust timestamp offset if time delta is greater than 100ms
            if (delta > 0.1) {
                var updating = audioBuffer.updating;
                try {
                    audioBuffer.abort();
                }
                catch (err) {
                    logger_1.logger.warn('can not abort audio buffer: ' + err);
                }
                if (!updating) {
                    logger_1.logger.warn('change mpeg audio timestamp offset from ' + audioBuffer.timestampOffset + ' to ' + data.start);
                    audioBuffer.timestampOffset = data.start;
                }
                else {
                    this.audioTimestampOffset = data.start;
                }
            }
        }
    };
    BufferController.prototype.onManifestParsed = function (data) {
        // in case of alt audio 2 BUFFER_CODECS events will be triggered, one per stream controller
        // sourcebuffers will be created all at once when the expected nb of tracks will be reached
        // in case alt audio is not used, only one BUFFER_CODEC event will be fired from main stream controller
        // it will contain the expected nb of source buffers, no need to compute it
        this.bufferCodecEventsExpected = data.altAudio ? 2 : 1;
        logger_1.logger.log(this.bufferCodecEventsExpected + " bufferCodec event(s) expected");
    };
    BufferController.prototype.onMediaAttaching = function (data) {
        var media = this.media = data.media;
        if (media) {
            // setup the media source
            var ms = this.mediaSource = new MediaSource();
            // Media Source listeners
            this.onmso = this.onMediaSourceOpen.bind(this);
            this.onmse = this.onMediaSourceEnded.bind(this);
            this.onmsc = this.onMediaSourceClose.bind(this);
            ms.addEventListener('sourceopen', this.onmso);
            ms.addEventListener('sourceended', this.onmse);
            ms.addEventListener('sourceclose', this.onmsc);
            // link video and media Source
            media.src = window.URL.createObjectURL(ms);
            // cache the locally generated object url
            this._objectUrl = media.src;
        }
    };
    BufferController.prototype.onMediaDetaching = function () {
        logger_1.logger.log('media source detaching');
        var ms = this.mediaSource;
        if (ms) {
            if (ms.readyState === 'open') {
                try {
                    // endOfStream could trigger exception if any sourcebuffer is in updating state
                    // we don't really care about checking sourcebuffer state here,
                    // as we are anyway detaching the MediaSource
                    // let's just avoid this exception to propagate
                    ms.endOfStream();
                }
                catch (err) {
                    logger_1.logger.warn("onMediaDetaching:" + err.message + " while calling endOfStream");
                }
            }
            ms.removeEventListener('sourceopen', this.onmso);
            ms.removeEventListener('sourceended', this.onmse);
            ms.removeEventListener('sourceclose', this.onmsc);
            // Detach properly the MediaSource from the HTMLMediaElement as
            // suggested in https://github.com/w3c/media-source/issues/53.
            if (this.media) {
                window.URL.revokeObjectURL(this._objectUrl);
                // clean up video tag src only if it's our own url. some external libraries might
                // hijack the video tag and change its 'src' without destroying the Hls instance first
                if (this.media.src === this._objectUrl) {
                    this.media.removeAttribute('src');
                    this.media.load();
                }
                else {
                    logger_1.logger.warn('media.src was changed by a third party - skip cleanup');
                }
            }
            this.mediaSource = null;
            this.media = null;
            this._objectUrl = null;
            this.pendingTracks = {};
            this.tracks = {};
            this.sourceBuffer = {};
            this.flushRange = [];
            this.segments = [];
            this.appended = 0;
        }
        this.onmso = this.onmse = this.onmsc = null;
        this.hls.trigger(events_1.default.MEDIA_DETACHED);
    };
    BufferController.prototype.onMediaSourceOpen = function () {
        logger_1.logger.log('media source opened');
        this.hls.trigger(events_1.default.MEDIA_ATTACHED, { media: this.media });
        var mediaSource = this.mediaSource;
        if (mediaSource) {
            // once received, don't listen anymore to sourceopen event
            mediaSource.removeEventListener('sourceopen', this.onmso);
        }
        this.checkPendingTracks();
    };
    BufferController.prototype.checkPendingTracks = function () {
        var _a = this, bufferCodecEventsExpected = _a.bufferCodecEventsExpected, pendingTracks = _a.pendingTracks;
        // Check if we've received all of the expected bufferCodec events. When none remain, create all the sourceBuffers at once.
        // This is important because the MSE spec allows implementations to throw QuotaExceededErrors if creating new sourceBuffers after
        // data has been appended to existing ones.
        // 2 tracks is the max (one for audio, one for video). If we've reach this max go ahead and create the buffers.
        var pendingTracksCount = Object.keys(pendingTracks).length;
        if ((pendingTracksCount && !bufferCodecEventsExpected) || pendingTracksCount === 2) {
            // ok, let's create them now !
            this.createSourceBuffers(pendingTracks);
            this.pendingTracks = {};
            // append any pending segments now !
            this.doAppending();
        }
    };
    BufferController.prototype.onMediaSourceClose = function () {
        logger_1.logger.log('media source closed');
    };
    BufferController.prototype.onMediaSourceEnded = function () {
        logger_1.logger.log('media source ended');
    };
    BufferController.prototype.onSBUpdateEnd = function () {
        // update timestampOffset
        if (this.audioTimestampOffset) {
            var audioBuffer = this.sourceBuffer.audio;
            logger_1.logger.warn("change mpeg audio timestamp offset from " + audioBuffer.timestampOffset + " to " + this.audioTimestampOffset);
            audioBuffer.timestampOffset = this.audioTimestampOffset;
            delete this.audioTimestampOffset;
        }
        if (this._needsFlush) {
            this.doFlush();
        }
        if (this._needsEos) {
            this.checkEos();
        }
        this.appending = false;
        var parent = this.parent;
        // count nb of pending segments waiting for appending on this sourcebuffer
        var pending = this.segments.reduce(function (counter, segment) { return (segment.parent === parent) ? counter + 1 : counter; }, 0);
        // this.sourceBuffer is better to use than media.buffered as it is closer to the PTS data from the fragments
        var timeRanges = {};
        var sourceBuffer = this.sourceBuffer;
        for (var streamType in sourceBuffer) {
            timeRanges[streamType] = sourceBuffer[streamType].buffered;
        }
        this.hls.trigger(events_1.default.BUFFER_APPENDED, { parent: parent, pending: pending, timeRanges: timeRanges });
        // don't append in flushing mode
        if (!this._needsFlush) {
            this.doAppending();
        }
        this.updateMediaElementDuration();
        // appending goes first
        if (pending === 0) {
            this.flushLiveBackBuffer();
        }
    };
    BufferController.prototype.onSBUpdateError = function (event) {
        logger_1.logger.error('sourceBuffer error:', event);
        // according to http://www.w3.org/TR/media-source/#sourcebuffer-append-error
        // this error might not always be fatal (it is fatal if decode error is set, in that case
        // it will be followed by a mediaElement error ...)
        this.hls.trigger(events_1.default.ERROR, { type: errors_1.ErrorTypes.MEDIA_ERROR, details: errors_1.ErrorDetails.BUFFER_APPENDING_ERROR, fatal: false });
        // we don't need to do more than that, as accordin to the spec, updateend will be fired just after
    };
    BufferController.prototype.onBufferReset = function () {
        var sourceBuffer = this.sourceBuffer;
        for (var type in sourceBuffer) {
            var sb = sourceBuffer[type];
            try {
                this.mediaSource.removeSourceBuffer(sb);
                sb.removeEventListener('updateend', this.onsbue);
                sb.removeEventListener('error', this.onsbe);
            }
            catch (err) {
            }
        }
        this.sourceBuffer = {};
        this.flushRange = [];
        this.segments = [];
        this.appended = 0;
    };
    BufferController.prototype.onBufferCodecs = function (tracks) {
        var _this = this;
        // if source buffer(s) not created yet, appended buffer tracks in this.pendingTracks
        // if sourcebuffers already created, do nothing ...
        if (Object.keys(this.sourceBuffer).length) {
            return;
        }
        Object.keys(tracks).forEach(function (trackName) {
            _this.pendingTracks[trackName] = tracks[trackName];
        });
        var mediaSource = this.mediaSource;
        this.bufferCodecEventsExpected = Math.max(this.bufferCodecEventsExpected - 1, 0);
        if (mediaSource && mediaSource.readyState === 'open') {
            this.checkPendingTracks();
        }
    };
    BufferController.prototype.createSourceBuffers = function (tracks) {
        var sourceBuffer = this.sourceBuffer, mediaSource = this.mediaSource;
        for (var trackName in tracks) {
            if (!sourceBuffer[trackName]) {
                var track = tracks[trackName];
                // use levelCodec as first priority
                var codec = track.levelCodec || track.codec;
                var mimeType = track.container + ";codecs=" + codec;
                logger_1.logger.log("creating sourceBuffer(" + mimeType + ")");
                try {
                    var sb = sourceBuffer[trackName] = mediaSource.addSourceBuffer(mimeType);
                    sb.addEventListener('updateend', this.onsbue);
                    sb.addEventListener('error', this.onsbe);
                    this.tracks[trackName] = { codec: codec, container: track.container };
                    track.buffer = sb;
                }
                catch (err) {
                    logger_1.logger.error("error while trying to add sourceBuffer:" + err.message);
                    this.hls.trigger(events_1.default.ERROR, { type: errors_1.ErrorTypes.MEDIA_ERROR, details: errors_1.ErrorDetails.BUFFER_ADD_CODEC_ERROR, fatal: false, err: err, mimeType: mimeType });
                }
            }
        }
        this.hls.trigger(events_1.default.BUFFER_CREATED, { tracks: tracks });
    };
    BufferController.prototype.onBufferAppending = function (data) {
        if (!this._needsFlush) {
            if (!this.segments) {
                this.segments = [data];
            }
            else {
                this.segments.push(data);
            }
            this.doAppending();
        }
    };
    BufferController.prototype.onBufferAppendFail = function (data) {
        logger_1.logger.error('sourceBuffer error:', data.event);
        // according to http://www.w3.org/TR/media-source/#sourcebuffer-append-error
        // this error might not always be fatal (it is fatal if decode error is set, in that case
        // it will be followed by a mediaElement error ...)
        this.hls.trigger(events_1.default.ERROR, { type: errors_1.ErrorTypes.MEDIA_ERROR, details: errors_1.ErrorDetails.BUFFER_APPENDING_ERROR, fatal: false });
    };
    // on BUFFER_EOS mark matching sourcebuffer(s) as ended and trigger checkEos()
    BufferController.prototype.onBufferEos = function (data) {
        var sb = this.sourceBuffer;
        var dataType = data.type;
        for (var type in sb) {
            if (!dataType || type === dataType) {
                if (!sb[type].ended) {
                    sb[type].ended = true;
                    logger_1.logger.log(type + " sourceBuffer now EOS");
                }
            }
        }
        this.checkEos();
    };
    // if all source buffers are marked as ended, signal endOfStream() to MediaSource.
    BufferController.prototype.checkEos = function () {
        var sb = this.sourceBuffer, mediaSource = this.mediaSource;
        if (!mediaSource || mediaSource.readyState !== 'open') {
            this._needsEos = false;
            return;
        }
        for (var type in sb) {
            var sbobj = sb[type];
            if (!sbobj.ended) {
                return;
            }
            if (sbobj.updating) {
                this._needsEos = true;
                return;
            }
        }
        logger_1.logger.log('all media data are available, signal endOfStream() to MediaSource and stop loading fragment');
        // Notify the media element that it now has all of the media data
        try {
            mediaSource.endOfStream();
        }
        catch (e) {
            logger_1.logger.warn('exception while calling mediaSource.endOfStream()');
        }
        this._needsEos = false;
    };
    BufferController.prototype.onBufferFlushing = function (data) {
        this.flushRange.push({ start: data.startOffset, end: data.endOffset, type: data.type });
        // attempt flush immediately
        this.flushBufferCounter = 0;
        this.doFlush();
    };
    BufferController.prototype.flushLiveBackBuffer = function () {
        // clear back buffer for live only
        if (!this._live) {
            return;
        }
        var liveBackBufferLength = this.hls.config.liveBackBufferLength;
        if (!isFinite(liveBackBufferLength) || liveBackBufferLength < 0) {
            return;
        }
        var currentTime = this.media.currentTime;
        var sourceBuffer = this.sourceBuffer;
        var bufferTypes = Object.keys(sourceBuffer);
        var targetBackBufferPosition = currentTime - Math.max(liveBackBufferLength, this._levelTargetDuration);
        for (var index = bufferTypes.length - 1; index >= 0; index--) {
            var bufferType = bufferTypes[index], buffered = sourceBuffer[bufferType].buffered;
            // when target buffer start exceeds actual buffer start
            if (buffered.length > 0 && targetBackBufferPosition > buffered.start(0)) {
                // remove buffer up until current time minus minimum back buffer length (removing buffer too close to current
                // time will lead to playback freezing)
                // credits for level target duration - https://github.com/videojs/http-streaming/blob/3132933b6aa99ddefab29c10447624efd6fd6e52/src/segment-loader.js#L91
                this.removeBufferRange(bufferType, sourceBuffer[bufferType], 0, targetBackBufferPosition);
            }
        }
    };
    BufferController.prototype.onLevelUpdated = function (_a) {
        var details = _a.details;
        if (details.fragments.length > 0) {
            this._levelDuration = details.totalduration + details.fragments[0].start;
            this._levelTargetDuration = details.averagetargetduration || details.targetduration || 10;
            this._live = details.live;
            this.updateMediaElementDuration();
        }
    };
    /**
     * Update Media Source duration to current level duration or override to Infinity if configuration parameter
     * 'liveDurationInfinity` is set to `true`
     * More details: https://github.com/video-dev/hls.js/issues/355
     */
    BufferController.prototype.updateMediaElementDuration = function () {
        var config = this.hls.config;
        var duration;
        if (this._levelDuration === null ||
            !this.media ||
            !this.mediaSource ||
            !this.sourceBuffer ||
            this.media.readyState === 0 ||
            this.mediaSource.readyState !== 'open') {
            return;
        }
        for (var type in this.sourceBuffer) {
            if (this.sourceBuffer[type].updating === true) {
                // can't set duration whilst a buffer is updating
                return;
            }
        }
        duration = this.media.duration;
        // initialise to the value that the media source is reporting
        if (this._msDuration === null) {
            this._msDuration = this.mediaSource.duration;
        }
        if (this._live === true && config.liveDurationInfinity === true) {
            // Override duration to Infinity
            logger_1.logger.log('Media Source duration is set to Infinity');
            this._msDuration = this.mediaSource.duration = Infinity;
        }
        else if ((this._levelDuration > this._msDuration && this._levelDuration > duration) || !Number.isFinite(duration)) {
            // levelDuration was the last value we set.
            // not using mediaSource.duration as the browser may tweak this value
            // only update Media Source duration if its value increase, this is to avoid
            // flushing already buffered portion when switching between quality level
            logger_1.logger.log("Updating Media Source duration to " + this._levelDuration.toFixed(3));
            this._msDuration = this.mediaSource.duration = this._levelDuration;
        }
    };
    BufferController.prototype.doFlush = function () {
        // loop through all buffer ranges to flush
        while (this.flushRange.length) {
            var range = this.flushRange[0];
            // flushBuffer will abort any buffer append in progress and flush Audio/Video Buffer
            if (this.flushBuffer(range.start, range.end, range.type)) {
                // range flushed, remove from flush array
                this.flushRange.shift();
                this.flushBufferCounter = 0;
            }
            else {
                this._needsFlush = true;
                // avoid looping, wait for SB update end to retrigger a flush
                return;
            }
        }
        if (this.flushRange.length === 0) {
            // everything flushed
            this._needsFlush = false;
            // let's recompute this.appended, which is used to avoid flush looping
            var appended = 0;
            var sourceBuffer = this.sourceBuffer;
            try {
                for (var type in sourceBuffer) {
                    appended += sourceBuffer[type].buffered.length;
                }
            }
            catch (error) {
                // error could be thrown while accessing buffered, in case sourcebuffer has already been removed from MediaSource
                // this is harmess at this stage, catch this to avoid reporting an internal exception
                logger_1.logger.error('error while accessing sourceBuffer.buffered');
            }
            this.appended = appended;
            this.hls.trigger(events_1.default.BUFFER_FLUSHED);
        }
    };
    BufferController.prototype.doAppending = function () {
        var _a = this, hls = _a.hls, segments = _a.segments, sourceBuffer = _a.sourceBuffer;
        if (Object.keys(sourceBuffer).length) {
            if (this.media.error) {
                this.segments = [];
                logger_1.logger.error('trying to append although a media error occured, flush segment and abort');
                return;
            }
            if (this.appending) {
                // logger.log(`sb appending in progress`);
                return;
            }
            if (segments && segments.length) {
                var segment = segments.shift();
                try {
                    var type = segment.type, sb = sourceBuffer[type];
                    if (sb) {
                        if (!sb.updating) {
                            // reset sourceBuffer ended flag before appending segment
                            sb.ended = false;
                            // logger.log(`appending ${segment.content} ${type} SB, size:${segment.data.length}, ${segment.parent}`);
                            this.parent = segment.parent;
                            sb.appendBuffer(segment.data);
                            this.appendError = 0;
                            this.appended++;
                            this.appending = true;
                        }
                        else {
                            segments.unshift(segment);
                        }
                    }
                    else {
                        // in case we don't have any source buffer matching with this segment type,
                        // it means that Mediasource fails to create sourcebuffer
                        // discard this segment, and trigger update end
                        this.onSBUpdateEnd();
                    }
                }
                catch (err) {
                    // in case any error occured while appending, put back segment in segments table
                    logger_1.logger.error("error while trying to append buffer:" + err.message);
                    segments.unshift(segment);
                    var event_1 = { type: errors_1.ErrorTypes.MEDIA_ERROR, parent: segment.parent };
                    if (err.code !== 22) {
                        if (this.appendError) {
                            this.appendError++;
                        }
                        else {
                            this.appendError = 1;
                        }
                        event_1.details = errors_1.ErrorDetails.BUFFER_APPEND_ERROR;
                        /* with UHD content, we could get loop of quota exceeded error until
                          browser is able to evict some data from sourcebuffer. retrying help recovering this
                        */
                        if (this.appendError > hls.config.appendErrorMaxRetry) {
                            logger_1.logger.log("fail " + hls.config.appendErrorMaxRetry + " times to append segment in sourceBuffer");
                            this.segments = [];
                            event_1.fatal = true;
                            hls.trigger(events_1.default.ERROR, event_1);
                        }
                        else {
                            event_1.fatal = false;
                            hls.trigger(events_1.default.ERROR, event_1);
                        }
                    }
                    else {
                        // QuotaExceededError: http://www.w3.org/TR/html5/infrastructure.html#quotaexceedederror
                        // let's stop appending any segments, and report BUFFER_FULL_ERROR error
                        this.segments = [];
                        event_1.details = errors_1.ErrorDetails.BUFFER_FULL_ERROR;
                        event_1.fatal = false;
                        hls.trigger(events_1.default.ERROR, event_1);
                    }
                }
            }
        }
    };
    /*
      flush specified buffered range,
      return true once range has been flushed.
      as sourceBuffer.remove() is asynchronous, flushBuffer will be retriggered on sourceBuffer update end
    */
    BufferController.prototype.flushBuffer = function (startOffset, endOffset, typeIn) {
        var sb;
        var sourceBuffer = this.sourceBuffer;
        if (Object.keys(sourceBuffer).length) {
            logger_1.logger.log("flushBuffer,pos/start/end: " + this.media.currentTime.toFixed(3) + "/" + startOffset + "/" + endOffset);
            // safeguard to avoid infinite looping : don't try to flush more than the nb of appended segments
            if (this.flushBufferCounter < this.appended) {
                for (var type in sourceBuffer) {
                    // check if sourcebuffer type is defined (typeIn): if yes, let's only flush this one
                    // if no, let's flush all sourcebuffers
                    if (typeIn && type !== typeIn) {
                        continue;
                    }
                    sb = sourceBuffer[type];
                    // we are going to flush buffer, mark source buffer as 'not ended'
                    sb.ended = false;
                    if (!sb.updating) {
                        if (this.removeBufferRange(type, sb, startOffset, endOffset)) {
                            this.flushBufferCounter++;
                            return false;
                        }
                    }
                    else {
                        logger_1.logger.warn('cannot flush, sb updating in progress');
                        return false;
                    }
                }
            }
            else {
                logger_1.logger.warn('abort flushing too many retries');
            }
            logger_1.logger.log('buffer flushed');
        }
        // everything flushed !
        return true;
    };
    /**
     * Removes first buffered range from provided source buffer that lies within given start and end offsets.
     *
     * @param type Type of the source buffer, logging purposes only.
     * @param sb Target SourceBuffer instance.
     * @param startOffset
     * @param endOffset
     *
     * @returns {boolean} True when source buffer remove requested.
     */
    BufferController.prototype.removeBufferRange = function (type, sb, startOffset, endOffset) {
        try {
            for (var i = 0; i < sb.buffered.length; i++) {
                var bufStart = sb.buffered.start(i);
                var bufEnd = sb.buffered.end(i);
                var removeStart = Math.max(bufStart, startOffset);
                var removeEnd = Math.min(bufEnd, endOffset);
                /* sometimes sourcebuffer.remove() does not flush
                  the exact expected time range.
                  to avoid rounding issues/infinite loop,
                  only flush buffer range of length greater than 500ms.
                */
                if (Math.min(removeEnd, bufEnd) - removeStart > 0.5) {
                    logger_1.logger.log("sb remove " + type + " [" + removeStart + "," + removeEnd + "], of [" + bufStart + "," + bufEnd + "], pos:" + this.media.currentTime);
                    sb.remove(removeStart, removeEnd);
                    return true;
                }
            }
        }
        catch (error) {
            logger_1.logger.warn('removeBufferRange failed', error);
        }
        return false;
    };
    return BufferController;
}(event_handler_1.default));
exports.default = BufferController;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./src/polyfills/number */ "./src/polyfills/number.js")["Number"]))

/***/ }),

/***/ "./src/controller/cap-level-controller.js":
/*!************************************************!*\
  !*** ./src/controller/cap-level-controller.js ***!
  \************************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Number) {
/*
 * cap stream level to media size dimension controller
*/
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var events_1 = __webpack_require__(/*! ../events */ "./src/events.js");
var event_handler_1 = __webpack_require__(/*! ../event-handler */ "./src/event-handler.js");
var CapLevelController = /** @class */ (function (_super) {
    __extends(CapLevelController, _super);
    function CapLevelController(hls) {
        var _this = _super.call(this, hls, events_1.default.FPS_DROP_LEVEL_CAPPING, events_1.default.MEDIA_ATTACHING, events_1.default.MANIFEST_PARSED, events_1.default.BUFFER_CODECS, events_1.default.MEDIA_DETACHING) || this;
        _this.autoLevelCapping = Number.POSITIVE_INFINITY;
        _this.firstLevel = null;
        _this.levels = [];
        _this.media = null;
        _this.restrictedLevels = [];
        _this.timer = null;
        return _this;
    }
    CapLevelController.prototype.destroy = function () {
        if (this.hls.config.capLevelToPlayerSize) {
            this.media = null;
            this._stopCapping();
        }
    };
    CapLevelController.prototype.onFpsDropLevelCapping = function (data) {
        // Don't add a restricted level more than once
        if (CapLevelController.isLevelAllowed(data.droppedLevel, this.restrictedLevels)) {
            this.restrictedLevels.push(data.droppedLevel);
        }
    };
    CapLevelController.prototype.onMediaAttaching = function (data) {
        this.media = data.media instanceof window.HTMLVideoElement ? data.media : null;
    };
    CapLevelController.prototype.onManifestParsed = function (data) {
        var hls = this.hls;
        this.restrictedLevels = [];
        this.levels = data.levels;
        this.firstLevel = data.firstLevel;
        if (hls.config.capLevelToPlayerSize && data.video) {
            // Start capping immediately if the manifest has signaled video codecs
            this._startCapping();
        }
    };
    // Only activate capping when playing a video stream; otherwise, multi-bitrate audio-only streams will be restricted
    // to the first level
    CapLevelController.prototype.onBufferCodecs = function (data) {
        var hls = this.hls;
        if (hls.config.capLevelToPlayerSize && data.video) {
            // If the manifest did not signal a video codec capping has been deferred until we're certain video is present
            this._startCapping();
        }
    };
    CapLevelController.prototype.onLevelsUpdated = function (data) {
        this.levels = data.levels;
    };
    CapLevelController.prototype.onMediaDetaching = function () {
        this._stopCapping();
    };
    CapLevelController.prototype.detectPlayerSize = function () {
        if (this.media) {
            var levelsLength = this.levels ? this.levels.length : 0;
            if (levelsLength) {
                var hls_1 = this.hls;
                hls_1.autoLevelCapping = this.getMaxLevel(levelsLength - 1);
                if (hls_1.autoLevelCapping > this.autoLevelCapping) {
                    // if auto level capping has a higher value for the previous one, flush the buffer using nextLevelSwitch
                    // usually happen when the user go to the fullscreen mode.
                    hls_1.streamController.nextLevelSwitch();
                }
                this.autoLevelCapping = hls_1.autoLevelCapping;
            }
        }
    };
    /*
    * returns level should be the one with the dimensions equal or greater than the media (player) dimensions (so the video will be downscaled)
    */
    CapLevelController.prototype.getMaxLevel = function (capLevelIndex) {
        var _this = this;
        if (!this.levels) {
            return -1;
        }
        var validLevels = this.levels.filter(function (level, index) {
            return CapLevelController.isLevelAllowed(index, _this.restrictedLevels) && index <= capLevelIndex;
        });
        return CapLevelController.getMaxLevelByMediaSize(validLevels, this.mediaWidth, this.mediaHeight);
    };
    CapLevelController.prototype._startCapping = function () {
        if (this.timer) {
            // Don't reset capping if started twice; this can happen if the manifest signals a video codec
            return;
        }
        this.autoLevelCapping = Number.POSITIVE_INFINITY;
        this.hls.firstLevel = this.getMaxLevel(this.firstLevel);
        clearInterval(this.timer);
        this.timer = setInterval(this.detectPlayerSize.bind(this), 1000);
        this.detectPlayerSize();
    };
    CapLevelController.prototype._stopCapping = function () {
        this.restrictedLevels = [];
        this.firstLevel = null;
        this.autoLevelCapping = Number.POSITIVE_INFINITY;
        if (this.timer) {
            this.timer = clearInterval(this.timer);
            this.timer = null;
        }
    };
    Object.defineProperty(CapLevelController.prototype, "mediaWidth", {
        get: function () {
            var width;
            var media = this.media;
            if (media) {
                width = media.width || media.clientWidth || media.offsetWidth;
                width *= CapLevelController.contentScaleFactor;
            }
            return width;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CapLevelController.prototype, "mediaHeight", {
        get: function () {
            var height;
            var media = this.media;
            if (media) {
                height = media.height || media.clientHeight || media.offsetHeight;
                height *= CapLevelController.contentScaleFactor;
            }
            return height;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CapLevelController, "contentScaleFactor", {
        get: function () {
            var pixelRatio = 1;
            try {
                pixelRatio = window.devicePixelRatio;
            }
            catch (e) { }
            return pixelRatio;
        },
        enumerable: true,
        configurable: true
    });
    CapLevelController.isLevelAllowed = function (level, restrictedLevels) {
        if (restrictedLevels === void 0) { restrictedLevels = []; }
        return restrictedLevels.indexOf(level) === -1;
    };
    CapLevelController.getMaxLevelByMediaSize = function (levels, width, height) {
        if (!levels || (levels && !levels.length)) {
            return -1;
        }
        // Levels can have the same dimensions but differing bandwidths - since levels are ordered, we can look to the next
        // to determine whether we've chosen the greatest bandwidth for the media's dimensions
        var atGreatestBandiwdth = function (curLevel, nextLevel) {
            if (!nextLevel) {
                return true;
            }
            return curLevel.width !== nextLevel.width || curLevel.height !== nextLevel.height;
        };
        // If we run through the loop without breaking, the media's dimensions are greater than every level, so default to
        // the max level
        var maxLevelIndex = levels.length - 1;
        for (var i = 0; i < levels.length; i += 1) {
            var level = levels[i];
            if ((level.width >= width || level.height >= height) && atGreatestBandiwdth(level, levels[i + 1])) {
                maxLevelIndex = i;
                break;
            }
        }
        return maxLevelIndex;
    };
    return CapLevelController;
}(event_handler_1.default));
exports.default = CapLevelController;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./src/polyfills/number */ "./src/polyfills/number.js")["Number"]))

/***/ }),

/***/ "./src/controller/eme-controller.js":
/*!******************************************!*\
  !*** ./src/controller/eme-controller.js ***!
  \******************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @author Stephan Hesse <disparat@gmail.com> | <tchakabam@gmail.com>
 *
 * DRM support for Hls.js
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var event_handler_1 = __webpack_require__(/*! ../event-handler */ "./src/event-handler.js");
var events_1 = __webpack_require__(/*! ../events */ "./src/events.js");
var errors_1 = __webpack_require__(/*! ../errors */ "./src/errors.js");
var logger_1 = __webpack_require__(/*! ../utils/logger */ "./src/utils/logger.js");
var XMLHttpRequest = window.XMLHttpRequest;
var MAX_LICENSE_REQUEST_FAILURES = 3;
/**
 * @see https://developer.mozilla.org/en-US/docs/Web/API/Navigator/requestMediaKeySystemAccess
 */
var KeySystems = {
    WIDEVINE: 'com.widevine.alpha',
    PLAYREADY: 'com.microsoft.playready'
};
/**
 * @see https://developer.mozilla.org/en-US/docs/Web/API/MediaKeySystemConfiguration
 * @param {Array<string>} audioCodecs List of required audio codecs to support
 * @param {Array<string>} videoCodecs List of required video codecs to support
 * @param {object} drmSystemOptions Optional parameters/requirements for the key-system
 * @returns {Array<MediaSystemConfiguration>} An array of supported configurations
 */
var createWidevineMediaKeySystemConfigurations = function (audioCodecs, videoCodecs, drmSystemOptions) {
    var baseConfig = {
        // initDataTypes: ['keyids', 'mp4'],
        // label: "",
        // persistentState: "not-allowed", // or "required" ?
        // distinctiveIdentifier: "not-allowed", // or "required" ?
        // sessionTypes: ['temporary'],
        videoCapabilities: [
        // { contentType: 'video/mp4; codecs="avc1.42E01E"' }
        ]
    };
    videoCodecs.forEach(function (codec) {
        baseConfig.videoCapabilities.push({
            contentType: "video/mp4; codecs=\"" + codec + "\""
        });
    });
    return [
        baseConfig
    ];
};
/**
 * The idea here is to handle key-system (and their respective platforms) specific configuration differences
 * in order to work with the local requestMediaKeySystemAccess method.
 *
 * We can also rule-out platform-related key-system support at this point by throwing an error or returning null.
 *
 * @param {string} keySystem Identifier for the key-system, see `KeySystems` enum
 * @param {Array<string>} audioCodecs List of required audio codecs to support
 * @param {Array<string>} videoCodecs List of required video codecs to support
 * @returns {Array<MediaSystemConfiguration> | null} A non-empty Array of MediaKeySystemConfiguration objects or `null`
 */
var getSupportedMediaKeySystemConfigurations = function (keySystem, audioCodecs, videoCodecs) {
    switch (keySystem) {
        case KeySystems.WIDEVINE:
            return createWidevineMediaKeySystemConfigurations(audioCodecs, videoCodecs);
        default:
            throw Error('Unknown key-system: ' + keySystem);
    }
};
/**
 * Controller to deal with encrypted media extensions (EME)
 * @see https://developer.mozilla.org/en-US/docs/Web/API/Encrypted_Media_Extensions_API
 *
 * @class
 * @constructor
 */
var EMEController = /** @class */ (function (_super) {
    __extends(EMEController, _super);
    /**
       * @constructs
       * @param {Hls} hls Our Hls.js instance
       */
    function EMEController(hls) {
        var _this = _super.call(this, hls, events_1.default.MEDIA_ATTACHED, events_1.default.MANIFEST_PARSED) || this;
        _this._widevineLicenseUrl = hls.config.widevineLicenseUrl;
        _this._licenseXhrSetup = hls.config.licenseXhrSetup;
        _this._emeEnabled = hls.config.emeEnabled;
        _this._requestMediaKeySystemAccess = hls.config.requestMediaKeySystemAccessFunc;
        _this._mediaKeysList = [];
        _this._media = null;
        _this._hasSetMediaKeys = false;
        _this._isMediaEncrypted = false;
        _this._requestLicenseFailureCount = 0;
        return _this;
    }
    /**
       *
       * @param {string} keySystem Identifier for the key-system, see `KeySystems` enum
       * @returns {string} License server URL for key-system (if any configured, otherwise causes error)
       */
    EMEController.prototype.getLicenseServerUrl = function (keySystem) {
        var url;
        switch (keySystem) {
            case KeySystems.WIDEVINE:
                url = this._widevineLicenseUrl;
                break;
            default:
                url = null;
                break;
        }
        if (!url) {
            logger_1.logger.error("No license server URL configured for key-system \"" + keySystem + "\"");
            this.hls.trigger(events_1.default.ERROR, {
                type: errors_1.ErrorTypes.KEY_SYSTEM_ERROR,
                details: errors_1.ErrorDetails.KEY_SYSTEM_LICENSE_REQUEST_FAILED,
                fatal: true
            });
        }
        return url;
    };
    /**
       * Requests access object and adds it to our list upon success
       * @private
       * @param {string} keySystem System ID (see `KeySystems`)
       * @param {Array<string>} audioCodecs List of required audio codecs to support
       * @param {Array<string>} videoCodecs List of required video codecs to support
       */
    EMEController.prototype._attemptKeySystemAccess = function (keySystem, audioCodecs, videoCodecs) {
        // TODO: add other DRM "options"
        var _this = this;
        var mediaKeySystemConfigs = getSupportedMediaKeySystemConfigurations(keySystem, audioCodecs, videoCodecs);
        if (!mediaKeySystemConfigs) {
            logger_1.logger.warn('Can not create config for key-system (maybe because platform is not supported):', keySystem);
            return;
        }
        logger_1.logger.log('Requesting encrypted media key-system access');
        // expecting interface like window.navigator.requestMediaKeySystemAccess
        this.requestMediaKeySystemAccess(keySystem, mediaKeySystemConfigs)
            .then(function (mediaKeySystemAccess) {
            _this._onMediaKeySystemAccessObtained(keySystem, mediaKeySystemAccess);
        })
            .catch(function (err) {
            logger_1.logger.error("Failed to obtain key-system \"" + keySystem + "\" access:", err);
        });
    };
    Object.defineProperty(EMEController.prototype, "requestMediaKeySystemAccess", {
        get: function () {
            if (!this._requestMediaKeySystemAccess) {
                throw new Error('No requestMediaKeySystemAccess function configured');
            }
            return this._requestMediaKeySystemAccess;
        },
        enumerable: true,
        configurable: true
    });
    /**
       * Handles obtaining access to a key-system
       *
       * @param {string} keySystem
       * @param {MediaKeySystemAccess} mediaKeySystemAccess https://developer.mozilla.org/en-US/docs/Web/API/MediaKeySystemAccess
       */
    EMEController.prototype._onMediaKeySystemAccessObtained = function (keySystem, mediaKeySystemAccess) {
        var _this = this;
        logger_1.logger.log("Access for key-system \"" + keySystem + "\" obtained");
        var mediaKeysListItem = {
            mediaKeys: null,
            mediaKeysSession: null,
            mediaKeysSessionInitialized: false,
            mediaKeySystemAccess: mediaKeySystemAccess,
            mediaKeySystemDomain: keySystem
        };
        this._mediaKeysList.push(mediaKeysListItem);
        mediaKeySystemAccess.createMediaKeys()
            .then(function (mediaKeys) {
            mediaKeysListItem.mediaKeys = mediaKeys;
            logger_1.logger.log("Media-keys created for key-system \"" + keySystem + "\"");
            _this._onMediaKeysCreated();
        })
            .catch(function (err) {
            logger_1.logger.error('Failed to create media-keys:', err);
        });
    };
    /**
       * Handles key-creation (represents access to CDM). We are going to create key-sessions upon this
       * for all existing keys where no session exists yet.
       */
    EMEController.prototype._onMediaKeysCreated = function () {
        var _this = this;
        // check for all key-list items if a session exists, otherwise, create one
        this._mediaKeysList.forEach(function (mediaKeysListItem) {
            if (!mediaKeysListItem.mediaKeysSession) {
                mediaKeysListItem.mediaKeysSession = mediaKeysListItem.mediaKeys.createSession();
                _this._onNewMediaKeySession(mediaKeysListItem.mediaKeysSession);
            }
        });
    };
    /**
       *
       * @param {*} keySession
       */
    EMEController.prototype._onNewMediaKeySession = function (keySession) {
        var _this = this;
        logger_1.logger.log("New key-system session " + keySession.sessionId);
        keySession.addEventListener('message', function (event) {
            _this._onKeySessionMessage(keySession, event.message);
        }, false);
    };
    EMEController.prototype._onKeySessionMessage = function (keySession, message) {
        logger_1.logger.log('Got EME message event, creating license request');
        this._requestLicense(message, function (data) {
            logger_1.logger.log('Received license data, updating key-session');
            keySession.update(data);
        });
    };
    EMEController.prototype._onMediaEncrypted = function (initDataType, initData) {
        logger_1.logger.log("Media is encrypted using \"" + initDataType + "\" init data type");
        this._isMediaEncrypted = true;
        this._mediaEncryptionInitDataType = initDataType;
        this._mediaEncryptionInitData = initData;
        this._attemptSetMediaKeys();
        this._generateRequestWithPreferredKeySession();
    };
    EMEController.prototype._attemptSetMediaKeys = function () {
        if (!this._hasSetMediaKeys) {
            // FIXME: see if we can/want/need-to really to deal with several potential key-sessions?
            var keysListItem = this._mediaKeysList[0];
            if (!keysListItem || !keysListItem.mediaKeys) {
                logger_1.logger.error('Fatal: Media is encrypted but no CDM access or no keys have been obtained yet');
                this.hls.trigger(events_1.default.ERROR, {
                    type: errors_1.ErrorTypes.KEY_SYSTEM_ERROR,
                    details: errors_1.ErrorDetails.KEY_SYSTEM_NO_KEYS,
                    fatal: true
                });
                return;
            }
            logger_1.logger.log('Setting keys for encrypted media');
            this._media.setMediaKeys(keysListItem.mediaKeys);
            this._hasSetMediaKeys = true;
        }
    };
    EMEController.prototype._generateRequestWithPreferredKeySession = function () {
        var _this = this;
        // FIXME: see if we can/want/need-to really to deal with several potential key-sessions?
        var keysListItem = this._mediaKeysList[0];
        if (!keysListItem) {
            logger_1.logger.error('Fatal: Media is encrypted but not any key-system access has been obtained yet');
            this.hls.trigger(events_1.default.ERROR, {
                type: errors_1.ErrorTypes.KEY_SYSTEM_ERROR,
                details: errors_1.ErrorDetails.KEY_SYSTEM_NO_ACCESS,
                fatal: true
            });
            return;
        }
        if (keysListItem.mediaKeysSessionInitialized) {
            logger_1.logger.warn('Key-Session already initialized but requested again');
            return;
        }
        var keySession = keysListItem.mediaKeysSession;
        if (!keySession) {
            logger_1.logger.error('Fatal: Media is encrypted but no key-session existing');
            this.hls.trigger(events_1.default.ERROR, {
                type: errors_1.ErrorTypes.KEY_SYSTEM_ERROR,
                details: errors_1.ErrorDetails.KEY_SYSTEM_NO_SESSION,
                fatal: true
            });
        }
        var initDataType = this._mediaEncryptionInitDataType;
        var initData = this._mediaEncryptionInitData;
        logger_1.logger.log("Generating key-session request for \"" + initDataType + "\" init data type");
        keysListItem.mediaKeysSessionInitialized = true;
        keySession.generateRequest(initDataType, initData)
            .then(function () {
            logger_1.logger.debug('Key-session generation succeeded');
        })
            .catch(function (err) {
            logger_1.logger.error('Error generating key-session request:', err);
            _this.hls.trigger(events_1.default.ERROR, {
                type: errors_1.ErrorTypes.KEY_SYSTEM_ERROR,
                details: errors_1.ErrorDetails.KEY_SYSTEM_NO_SESSION,
                fatal: false
            });
        });
    };
    /**
       * @param {string} url License server URL
       * @param {ArrayBuffer} keyMessage Message data issued by key-system
       * @param {function} callback Called when XHR has succeeded
       * @returns {XMLHttpRequest} Unsent (but opened state) XHR object
       */
    EMEController.prototype._createLicenseXhr = function (url, keyMessage, callback) {
        var xhr = new XMLHttpRequest();
        var licenseXhrSetup = this._licenseXhrSetup;
        try {
            if (licenseXhrSetup) {
                try {
                    licenseXhrSetup(xhr, url);
                }
                catch (e) {
                    // let's try to open before running setup
                    xhr.open('POST', url, true);
                    licenseXhrSetup(xhr, url);
                }
            }
            // if licenseXhrSetup did not yet call open, let's do it now
            if (!xhr.readyState) {
                xhr.open('POST', url, true);
            }
        }
        catch (e) {
            // IE11 throws an exception on xhr.open if attempting to access an HTTP resource over HTTPS
            logger_1.logger.error('Error setting up key-system license XHR', e);
            this.hls.trigger(events_1.default.ERROR, {
                type: errors_1.ErrorTypes.KEY_SYSTEM_ERROR,
                details: errors_1.ErrorDetails.KEY_SYSTEM_LICENSE_REQUEST_FAILED,
                fatal: true
            });
            return;
        }
        xhr.responseType = 'arraybuffer';
        xhr.onreadystatechange =
            this._onLicenseRequestReadyStageChange.bind(this, xhr, url, keyMessage, callback);
        return xhr;
    };
    /**
       * @param {XMLHttpRequest} xhr
       * @param {string} url License server URL
       * @param {ArrayBuffer} keyMessage Message data issued by key-system
       * @param {function} callback Called when XHR has succeeded
       *
       */
    EMEController.prototype._onLicenseRequestReadyStageChange = function (xhr, url, keyMessage, callback) {
        switch (xhr.readyState) {
            case 4:
                if (xhr.status === 200) {
                    this._requestLicenseFailureCount = 0;
                    logger_1.logger.log('License request succeeded');
                    callback(xhr.response);
                }
                else {
                    logger_1.logger.error("License Request XHR failed (" + url + "). Status: " + xhr.status + " (" + xhr.statusText + ")");
                    this._requestLicenseFailureCount++;
                    if (this._requestLicenseFailureCount <= MAX_LICENSE_REQUEST_FAILURES) {
                        var attemptsLeft = MAX_LICENSE_REQUEST_FAILURES - this._requestLicenseFailureCount + 1;
                        logger_1.logger.warn("Retrying license request, " + attemptsLeft + " attempts left");
                        this._requestLicense(keyMessage, callback);
                        return;
                    }
                    this.hls.trigger(events_1.default.ERROR, {
                        type: errors_1.ErrorTypes.KEY_SYSTEM_ERROR,
                        details: errors_1.ErrorDetails.KEY_SYSTEM_LICENSE_REQUEST_FAILED,
                        fatal: true
                    });
                }
                break;
        }
    };
    /**
       * @param {object} keysListItem
       * @param {ArrayBuffer} keyMessage
       * @returns {ArrayBuffer} Challenge data posted to license server
       */
    EMEController.prototype._generateLicenseRequestChallenge = function (keysListItem, keyMessage) {
        var challenge;
        if (keysListItem.mediaKeySystemDomain === KeySystems.PLAYREADY) {
            logger_1.logger.error('PlayReady is not supported (yet)');
            // from https://github.com/MicrosoftEdge/Demos/blob/master/eme/scripts/demo.js
            /*
              if (this.licenseType !== this.LICENSE_TYPE_WIDEVINE) {
                  // For PlayReady CDMs, we need to dig the Challenge out of the XML.
                  var keyMessageXml = new DOMParser().parseFromString(String.fromCharCode.apply(null, new Uint16Array(keyMessage)), 'application/xml');
                  if (keyMessageXml.getElementsByTagName('Challenge')[0]) {
                      challenge = atob(keyMessageXml.getElementsByTagName('Challenge')[0].childNodes[0].nodeValue);
                  } else {
                      throw 'Cannot find <Challenge> in key message';
                  }
                  var headerNames = keyMessageXml.getElementsByTagName('name');
                  var headerValues = keyMessageXml.getElementsByTagName('value');
                  if (headerNames.length !== headerValues.length) {
                      throw 'Mismatched header <name>/<value> pair in key message';
                  }
                  for (var i = 0; i < headerNames.length; i++) {
                      xhr.setRequestHeader(headerNames[i].childNodes[0].nodeValue, headerValues[i].childNodes[0].nodeValue);
                  }
              }
              */
        }
        else if (keysListItem.mediaKeySystemDomain === KeySystems.WIDEVINE) {
            // For Widevine CDMs, the challenge is the keyMessage.
            challenge = keyMessage;
        }
        else {
            logger_1.logger.error('Unsupported key-system:', keysListItem.mediaKeySystemDomain);
        }
        return challenge;
    };
    EMEController.prototype._requestLicense = function (keyMessage, callback) {
        logger_1.logger.log('Requesting content license for key-system');
        var keysListItem = this._mediaKeysList[0];
        if (!keysListItem) {
            logger_1.logger.error('Fatal error: Media is encrypted but no key-system access has been obtained yet');
            this.hls.trigger(events_1.default.ERROR, {
                type: errors_1.ErrorTypes.KEY_SYSTEM_ERROR,
                details: errors_1.ErrorDetails.KEY_SYSTEM_NO_ACCESS,
                fatal: true
            });
            return;
        }
        var url = this.getLicenseServerUrl(keysListItem.mediaKeySystemDomain);
        var xhr = this._createLicenseXhr(url, keyMessage, callback);
        logger_1.logger.log("Sending license request to URL: " + url);
        xhr.send(this._generateLicenseRequestChallenge(keysListItem, keyMessage));
    };
    EMEController.prototype.onMediaAttached = function (data) {
        var _this = this;
        if (!this._emeEnabled) {
            return;
        }
        var media = data.media;
        // keep reference of media
        this._media = media;
        // FIXME: also handle detaching media !
        media.addEventListener('encrypted', function (e) {
            _this._onMediaEncrypted(e.initDataType, e.initData);
        });
    };
    EMEController.prototype.onManifestParsed = function (data) {
        if (!this._emeEnabled) {
            return;
        }
        var audioCodecs = data.levels.map(function (level) { return level.audioCodec; });
        var videoCodecs = data.levels.map(function (level) { return level.videoCodec; });
        this._attemptKeySystemAccess(KeySystems.WIDEVINE, audioCodecs, videoCodecs);
    };
    return EMEController;
}(event_handler_1.default));
exports.default = EMEController;


/***/ }),

/***/ "./src/controller/fps-controller.js":
/*!******************************************!*\
  !*** ./src/controller/fps-controller.js ***!
  \******************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * FPS Controller
*/
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var events_1 = __webpack_require__(/*! ../events */ "./src/events.js");
var event_handler_1 = __webpack_require__(/*! ../event-handler */ "./src/event-handler.js");
var logger_1 = __webpack_require__(/*! ../utils/logger */ "./src/utils/logger.js");
var performance = window.performance;
var FPSController = /** @class */ (function (_super) {
    __extends(FPSController, _super);
    function FPSController(hls) {
        return _super.call(this, hls, events_1.default.MEDIA_ATTACHING) || this;
    }
    FPSController.prototype.destroy = function () {
        if (this.timer) {
            clearInterval(this.timer);
        }
        this.isVideoPlaybackQualityAvailable = false;
    };
    FPSController.prototype.onMediaAttaching = function (data) {
        var config = this.hls.config;
        if (config.capLevelOnFPSDrop) {
            var video_1 = this.video = data.media instanceof window.HTMLVideoElement ? data.media : null;
            if (typeof video_1.getVideoPlaybackQuality === 'function') {
                this.isVideoPlaybackQualityAvailable = true;
            }
            clearInterval(this.timer);
            this.timer = setInterval(this.checkFPSInterval.bind(this), config.fpsDroppedMonitoringPeriod);
        }
    };
    FPSController.prototype.checkFPS = function (video, decodedFrames, droppedFrames) {
        var currentTime = performance.now();
        if (decodedFrames) {
            if (this.lastTime) {
                var currentPeriod = currentTime - this.lastTime, currentDropped = droppedFrames - this.lastDroppedFrames, currentDecoded = decodedFrames - this.lastDecodedFrames, droppedFPS = 1000 * currentDropped / currentPeriod, hls_1 = this.hls;
                hls_1.trigger(events_1.default.FPS_DROP, { currentDropped: currentDropped, currentDecoded: currentDecoded, totalDroppedFrames: droppedFrames });
                if (droppedFPS > 0) {
                    // logger.log('checkFPS : droppedFPS/decodedFPS:' + droppedFPS/(1000 * currentDecoded / currentPeriod));
                    if (currentDropped > hls_1.config.fpsDroppedMonitoringThreshold * currentDecoded) {
                        var currentLevel = hls_1.currentLevel;
                        logger_1.logger.warn('drop FPS ratio greater than max allowed value for currentLevel: ' + currentLevel);
                        if (currentLevel > 0 && (hls_1.autoLevelCapping === -1 || hls_1.autoLevelCapping >= currentLevel)) {
                            currentLevel = currentLevel - 1;
                            hls_1.trigger(events_1.default.FPS_DROP_LEVEL_CAPPING, { level: currentLevel, droppedLevel: hls_1.currentLevel });
                            hls_1.autoLevelCapping = currentLevel;
                            hls_1.streamController.nextLevelSwitch();
                        }
                    }
                }
            }
            this.lastTime = currentTime;
            this.lastDroppedFrames = droppedFrames;
            this.lastDecodedFrames = decodedFrames;
        }
    };
    FPSController.prototype.checkFPSInterval = function () {
        var video = this.video;
        if (video) {
            if (this.isVideoPlaybackQualityAvailable) {
                var videoPlaybackQuality = video.getVideoPlaybackQuality();
                this.checkFPS(video, videoPlaybackQuality.totalVideoFrames, videoPlaybackQuality.droppedVideoFrames);
            }
            else {
                this.checkFPS(video, video.webkitDecodedFrameCount, video.webkitDroppedFrameCount);
            }
        }
    };
    return FPSController;
}(event_handler_1.default));
exports.default = FPSController;


/***/ }),

/***/ "./src/controller/fragment-finders.js":
/*!********************************************!*\
  !*** ./src/controller/fragment-finders.js ***!
  \********************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Number) {
Object.defineProperty(exports, "__esModule", { value: true });
var binary_search_1 = __webpack_require__(/*! ../utils/binary-search */ "./src/utils/binary-search.js");
/**
 * Returns first fragment whose endPdt value exceeds the given PDT.
 * @param {Array<Fragment>} fragments - The array of candidate fragments
 * @param {number|null} [PDTValue = null] - The PDT value which must be exceeded
 * @param {number} [maxFragLookUpTolerance = 0] - The amount of time that a fragment's start/end can be within in order to be considered contiguous
 * @returns {*|null} fragment - The best matching fragment
 */
function findFragmentByPDT(fragments, PDTValue, maxFragLookUpTolerance) {
    if (!Array.isArray(fragments) || !fragments.length || !Number.isFinite(PDTValue)) {
        return null;
    }
    // if less than start
    if (PDTValue < fragments[0].programDateTime) {
        return null;
    }
    if (PDTValue >= fragments[fragments.length - 1].endProgramDateTime) {
        return null;
    }
    maxFragLookUpTolerance = maxFragLookUpTolerance || 0;
    for (var seg = 0; seg < fragments.length; ++seg) {
        var frag = fragments[seg];
        if (pdtWithinToleranceTest(PDTValue, maxFragLookUpTolerance, frag)) {
            return frag;
        }
    }
    return null;
}
exports.findFragmentByPDT = findFragmentByPDT;
/**
 * Finds a fragment based on the SN of the previous fragment; or based on the needs of the current buffer.
 * This method compensates for small buffer gaps by applying a tolerance to the start of any candidate fragment, thus
 * breaking any traps which would cause the same fragment to be continuously selected within a small range.
 * @param {*} fragPrevious - The last frag successfully appended
 * @param {Array<Fragment>} fragments - The array of candidate fragments
 * @param {number} [bufferEnd = 0] - The end of the contiguous buffered range the playhead is currently within
 * @param {number} maxFragLookUpTolerance - The amount of time that a fragment's start/end can be within in order to be considered contiguous
 * @returns {*} foundFrag - The best matching fragment
 */
function findFragmentByPTS(fragPrevious, fragments, bufferEnd, maxFragLookUpTolerance) {
    if (bufferEnd === void 0) { bufferEnd = 0; }
    if (maxFragLookUpTolerance === void 0) { maxFragLookUpTolerance = 0; }
    var fragNext = fragPrevious ? fragments[fragPrevious.sn - fragments[0].sn + 1] : null;
    // Prefer the next fragment if it's within tolerance
    if (fragNext && !fragmentWithinToleranceTest(bufferEnd, maxFragLookUpTolerance, fragNext)) {
        return fragNext;
    }
    return binary_search_1.default.search(fragments, fragmentWithinToleranceTest.bind(null, bufferEnd, maxFragLookUpTolerance));
}
exports.findFragmentByPTS = findFragmentByPTS;
/**
 * The test function used by the findFragmentBySn's BinarySearch to look for the best match to the current buffer conditions.
 * @param {*} candidate - The fragment to test
 * @param {number} [bufferEnd = 0] - The end of the current buffered range the playhead is currently within
 * @param {number} [maxFragLookUpTolerance = 0] - The amount of time that a fragment's start can be within in order to be considered contiguous
 * @returns {number} - 0 if it matches, 1 if too low, -1 if too high
 */
function fragmentWithinToleranceTest(bufferEnd, maxFragLookUpTolerance, candidate) {
    if (bufferEnd === void 0) { bufferEnd = 0; }
    if (maxFragLookUpTolerance === void 0) { maxFragLookUpTolerance = 0; }
    // offset should be within fragment boundary - config.maxFragLookUpTolerance
    // this is to cope with situations like
    // bufferEnd = 9.991
    // frag[] : [0,10]
    // frag[1] : [10,20]
    // bufferEnd is within frag[0] range ... although what we are expecting is to return frag[1] here
    //              frag start               frag start+duration
    //                  |-----------------------------|
    //              <--->                         <--->
    //  ...--------><-----------------------------><---------....
    // previous frag         matching fragment         next frag
    //  return -1             return 0                 return 1
    // logger.log(`level/sn/start/end/bufEnd:${level}/${candidate.sn}/${candidate.start}/${(candidate.start+candidate.duration)}/${bufferEnd}`);
    // Set the lookup tolerance to be small enough to detect the current segment - ensures we don't skip over very small segments
    var candidateLookupTolerance = Math.min(maxFragLookUpTolerance, candidate.duration + (candidate.deltaPTS ? candidate.deltaPTS : 0));
    if (candidate.start + candidate.duration - candidateLookupTolerance <= bufferEnd) {
        return 1;
    }
    else if (candidate.start - candidateLookupTolerance > bufferEnd && candidate.start) {
        // if maxFragLookUpTolerance will have negative value then don't return -1 for first element
        return -1;
    }
    return 0;
}
exports.fragmentWithinToleranceTest = fragmentWithinToleranceTest;
/**
 * The test function used by the findFragmentByPdt's BinarySearch to look for the best match to the current buffer conditions.
 * This function tests the candidate's program date time values, as represented in Unix time
 * @param {*} candidate - The fragment to test
 * @param {number} [pdtBufferEnd = 0] - The Unix time representing the end of the current buffered range
 * @param {number} [maxFragLookUpTolerance = 0] - The amount of time that a fragment's start can be within in order to be considered contiguous
 * @returns {boolean} True if contiguous, false otherwise
 */
function pdtWithinToleranceTest(pdtBufferEnd, maxFragLookUpTolerance, candidate) {
    var candidateLookupTolerance = Math.min(maxFragLookUpTolerance, candidate.duration + (candidate.deltaPTS ? candidate.deltaPTS : 0)) * 1000;
    return candidate.endProgramDateTime - candidateLookupTolerance > pdtBufferEnd;
}
exports.pdtWithinToleranceTest = pdtWithinToleranceTest;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./src/polyfills/number */ "./src/polyfills/number.js")["Number"]))

/***/ }),

/***/ "./src/controller/fragment-tracker.js":
/*!********************************************!*\
  !*** ./src/controller/fragment-tracker.js ***!
  \********************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Number) {
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var event_handler_1 = __webpack_require__(/*! ../event-handler */ "./src/event-handler.js");
var events_1 = __webpack_require__(/*! ../events */ "./src/events.js");
exports.FragmentState = {
    NOT_LOADED: 'NOT_LOADED',
    APPENDING: 'APPENDING',
    PARTIAL: 'PARTIAL',
    OK: 'OK'
};
var FragmentTracker = /** @class */ (function (_super) {
    __extends(FragmentTracker, _super);
    function FragmentTracker(hls) {
        var _this = _super.call(this, hls, events_1.default.BUFFER_APPENDED, events_1.default.FRAG_BUFFERED, events_1.default.FRAG_LOADED) || this;
        _this.bufferPadding = 0.2;
        _this.fragments = Object.create(null);
        _this.timeRanges = Object.create(null);
        _this.config = hls.config;
        return _this;
    }
    FragmentTracker.prototype.destroy = function () {
        this.fragments = Object.create(null);
        this.timeRanges = Object.create(null);
        this.config = null;
        event_handler_1.default.prototype.destroy.call(this);
        _super.prototype.destroy.call(this);
    };
    /**
     * Return a Fragment that match the position and levelType.
     * If not found any Fragment, return null
     * @param {number} position
     * @param {LevelType} levelType
     * @returns {Fragment|null}
     */
    FragmentTracker.prototype.getBufferedFrag = function (position, levelType) {
        var fragments = this.fragments;
        var bufferedFrags = Object.keys(fragments).filter(function (key) {
            var fragmentEntity = fragments[key];
            if (fragmentEntity.body.type !== levelType) {
                return false;
            }
            if (!fragmentEntity.buffered) {
                return false;
            }
            var frag = fragmentEntity.body;
            return frag.startPTS <= position && position <= frag.endPTS;
        });
        if (bufferedFrags.length === 0) {
            return null;
        }
        else {
            // https://github.com/video-dev/hls.js/pull/1545#discussion_r166229566
            var bufferedFragKey = bufferedFrags.pop();
            return fragments[bufferedFragKey].body;
        }
    };
    /**
     * Partial fragments effected by coded frame eviction will be removed
     * The browser will unload parts of the buffer to free up memory for new buffer data
     * Fragments will need to be reloaded when the buffer is freed up, removing partial fragments will allow them to reload(since there might be parts that are still playable)
     * @param {String} elementaryStream The elementaryStream of media this is (eg. video/audio)
     * @param {TimeRanges} timeRange TimeRange object from a sourceBuffer
     */
    FragmentTracker.prototype.detectEvictedFragments = function (elementaryStream, timeRange) {
        var _this = this;
        var fragmentTimes, time;
        // Check if any flagged fragments have been unloaded
        Object.keys(this.fragments).forEach(function (key) {
            var fragmentEntity = _this.fragments[key];
            if (fragmentEntity.buffered === true) {
                var esData = fragmentEntity.range[elementaryStream];
                if (esData) {
                    fragmentTimes = esData.time;
                    for (var i = 0; i < fragmentTimes.length; i++) {
                        time = fragmentTimes[i];
                        if (_this.isTimeBuffered(time.startPTS, time.endPTS, timeRange) === false) {
                            // Unregister partial fragment as it needs to load again to be reused
                            _this.removeFragment(fragmentEntity.body);
                            break;
                        }
                    }
                }
            }
        });
    };
    /**
     * Checks if the fragment passed in is loaded in the buffer properly
     * Partially loaded fragments will be registered as a partial fragment
     * @param {Object} fragment Check the fragment against all sourceBuffers loaded
     */
    FragmentTracker.prototype.detectPartialFragments = function (fragment) {
        var _this = this;
        var fragKey = this.getFragmentKey(fragment);
        var fragmentEntity = this.fragments[fragKey];
        if (fragmentEntity) {
            fragmentEntity.buffered = true;
            Object.keys(this.timeRanges).forEach(function (elementaryStream) {
                if (fragment.hasElementaryStream(elementaryStream)) {
                    var timeRange = _this.timeRanges[elementaryStream];
                    // Check for malformed fragments
                    // Gaps need to be calculated for each elementaryStream
                    fragmentEntity.range[elementaryStream] = _this.getBufferedTimes(fragment.startPTS, fragment.endPTS, timeRange);
                }
            });
        }
    };
    FragmentTracker.prototype.getBufferedTimes = function (startPTS, endPTS, timeRange) {
        var fragmentTimes = [];
        var startTime, endTime;
        var fragmentPartial = false;
        for (var i = 0; i < timeRange.length; i++) {
            startTime = timeRange.start(i) - this.bufferPadding;
            endTime = timeRange.end(i) + this.bufferPadding;
            if (startPTS >= startTime && endPTS <= endTime) {
                // Fragment is entirely contained in buffer
                // No need to check the other timeRange times since it's completely playable
                fragmentTimes.push({
                    startPTS: Math.max(startPTS, timeRange.start(i)),
                    endPTS: Math.min(endPTS, timeRange.end(i))
                });
                break;
            }
            else if (startPTS < endTime && endPTS > startTime) {
                // Check for intersection with buffer
                // Get playable sections of the fragment
                fragmentTimes.push({
                    startPTS: Math.max(startPTS, timeRange.start(i)),
                    endPTS: Math.min(endPTS, timeRange.end(i))
                });
                fragmentPartial = true;
            }
            else if (endPTS <= startTime) {
                // No need to check the rest of the timeRange as it is in order
                break;
            }
        }
        return {
            time: fragmentTimes,
            partial: fragmentPartial
        };
    };
    FragmentTracker.prototype.getFragmentKey = function (fragment) {
        return fragment.type + "_" + fragment.level + "_" + fragment.urlId + "_" + fragment.sn;
    };
    /**
     * Gets the partial fragment for a certain time
     * @param {Number} time
     * @returns {Object} fragment Returns a partial fragment at a time or null if there is no partial fragment
     */
    FragmentTracker.prototype.getPartialFragment = function (time) {
        var _this = this;
        var timePadding, startTime, endTime;
        var bestFragment = null;
        var bestOverlap = 0;
        Object.keys(this.fragments).forEach(function (key) {
            var fragmentEntity = _this.fragments[key];
            if (_this.isPartial(fragmentEntity)) {
                startTime = fragmentEntity.body.startPTS - _this.bufferPadding;
                endTime = fragmentEntity.body.endPTS + _this.bufferPadding;
                if (time >= startTime && time <= endTime) {
                    // Use the fragment that has the most padding from start and end time
                    timePadding = Math.min(time - startTime, endTime - time);
                    if (bestOverlap <= timePadding) {
                        bestFragment = fragmentEntity.body;
                        bestOverlap = timePadding;
                    }
                }
            }
        });
        return bestFragment;
    };
    /**
     * @param {Object} fragment The fragment to check
     * @returns {String} Returns the fragment state when a fragment never loaded or if it partially loaded
     */
    FragmentTracker.prototype.getState = function (fragment) {
        var fragKey = this.getFragmentKey(fragment);
        var fragmentEntity = this.fragments[fragKey];
        var state = exports.FragmentState.NOT_LOADED;
        if (fragmentEntity !== undefined) {
            if (!fragmentEntity.buffered) {
                state = exports.FragmentState.APPENDING;
            }
            else if (this.isPartial(fragmentEntity) === true) {
                state = exports.FragmentState.PARTIAL;
            }
            else {
                state = exports.FragmentState.OK;
            }
        }
        return state;
    };
    FragmentTracker.prototype.isPartial = function (fragmentEntity) {
        return fragmentEntity.buffered === true &&
            ((fragmentEntity.range.video !== undefined && fragmentEntity.range.video.partial === true) ||
                (fragmentEntity.range.audio !== undefined && fragmentEntity.range.audio.partial === true));
    };
    FragmentTracker.prototype.isTimeBuffered = function (startPTS, endPTS, timeRange) {
        var startTime, endTime;
        for (var i = 0; i < timeRange.length; i++) {
            startTime = timeRange.start(i) - this.bufferPadding;
            endTime = timeRange.end(i) + this.bufferPadding;
            if (startPTS >= startTime && endPTS <= endTime) {
                return true;
            }
            if (endPTS <= startTime) {
                // No need to check the rest of the timeRange as it is in order
                return false;
            }
        }
        return false;
    };
    /**
     * Fires when a fragment loading is completed
     */
    FragmentTracker.prototype.onFragLoaded = function (e) {
        var fragment = e.frag;
        // don't track initsegment (for which sn is not a number)
        // don't track frags used for bitrateTest, they're irrelevant.
        if (!Number.isFinite(fragment.sn) || fragment.bitrateTest) {
            return;
        }
        this.fragments[this.getFragmentKey(fragment)] = {
            body: fragment,
            range: Object.create(null),
            buffered: false
        };
    };
    /**
     * Fires when the buffer is updated
     */
    FragmentTracker.prototype.onBufferAppended = function (e) {
        var _this = this;
        // Store the latest timeRanges loaded in the buffer
        this.timeRanges = e.timeRanges;
        Object.keys(this.timeRanges).forEach(function (elementaryStream) {
            var timeRange = _this.timeRanges[elementaryStream];
            _this.detectEvictedFragments(elementaryStream, timeRange);
        });
    };
    /**
     * Fires after a fragment has been loaded into the source buffer
     */
    FragmentTracker.prototype.onFragBuffered = function (e) {
        this.detectPartialFragments(e.frag);
    };
    /**
     * Return true if fragment tracker has the fragment.
     * @param {Object} fragment
     * @returns {boolean}
     */
    FragmentTracker.prototype.hasFragment = function (fragment) {
        var fragKey = this.getFragmentKey(fragment);
        return this.fragments[fragKey] !== undefined;
    };
    /**
     * Remove a fragment from fragment tracker until it is loaded again
     * @param {Object} fragment The fragment to remove
     */
    FragmentTracker.prototype.removeFragment = function (fragment) {
        var fragKey = this.getFragmentKey(fragment);
        delete this.fragments[fragKey];
    };
    /**
     * Remove all fragments from fragment tracker.
     */
    FragmentTracker.prototype.removeAllFragments = function () {
        this.fragments = Object.create(null);
    };
    return FragmentTracker;
}(event_handler_1.default));
exports.FragmentTracker = FragmentTracker;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./src/polyfills/number */ "./src/polyfills/number.js")["Number"]))

/***/ }),

/***/ "./src/controller/gap-controller.js":
/*!******************************************!*\
  !*** ./src/controller/gap-controller.js ***!
  \******************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var buffer_helper_1 = __webpack_require__(/*! ../utils/buffer-helper */ "./src/utils/buffer-helper.js");
var errors_1 = __webpack_require__(/*! ../errors */ "./src/errors.js");
var events_1 = __webpack_require__(/*! ../events */ "./src/events.js");
var logger_1 = __webpack_require__(/*! ../utils/logger */ "./src/utils/logger.js");
var stallDebounceInterval = 1000;
var jumpThreshold = 0.5; // tolerance needed as some browsers stalls playback before reaching buffered range end
var GapController = /** @class */ (function () {
    function GapController(config, media, fragmentTracker, hls) {
        this.config = config;
        this.media = media;
        this.fragmentTracker = fragmentTracker;
        this.hls = hls;
        this.stallReported = false;
    }
    /**
     * Checks if the playhead is stuck within a gap, and if so, attempts to free it.
     * A gap is an unbuffered range between two buffered ranges (or the start and the first buffered range).
     * @param lastCurrentTime
     * @param buffered
     */
    GapController.prototype.poll = function (lastCurrentTime, buffered) {
        var _a = this, config = _a.config, media = _a.media;
        var currentTime = media.currentTime;
        var tnow = window.performance.now();
        if (currentTime !== lastCurrentTime) {
            // The playhead is now moving, but was previously stalled
            if (this.stallReported) {
                logger_1.logger.warn("playback not stuck anymore @" + currentTime + ", after " + Math.round(tnow - this.stalled) + "ms");
                this.stallReported = false;
            }
            this.stalled = null;
            this.nudgeRetry = 0;
            return;
        }
        if (media.ended || !media.buffered.length || media.readyState > 2) {
            return;
        }
        if (media.seeking && buffer_helper_1.BufferHelper.isBuffered(media, currentTime)) {
            return;
        }
        // The playhead isn't moving but it should be
        // Allow some slack time to for small stalls to resolve themselves
        var stalledDuration = tnow - this.stalled;
        var bufferInfo = buffer_helper_1.BufferHelper.bufferInfo(media, currentTime, config.maxBufferHole);
        if (!this.stalled) {
            this.stalled = tnow;
            return;
        }
        else if (stalledDuration >= stallDebounceInterval) {
            // Report stalling after trying to fix
            this._reportStall(bufferInfo.len);
        }
        this._tryFixBufferStall(bufferInfo, stalledDuration);
    };
    /**
     * Detects and attempts to fix known buffer stalling issues.
     * @param bufferInfo - The properties of the current buffer.
     * @param stalledDuration - The amount of time Hls.js has been stalling for.
     * @private
     */
    GapController.prototype._tryFixBufferStall = function (bufferInfo, stalledDuration) {
        var _a = this, config = _a.config, fragmentTracker = _a.fragmentTracker, media = _a.media;
        var currentTime = media.currentTime;
        var partial = fragmentTracker.getPartialFragment(currentTime);
        if (partial) {
            // Try to skip over the buffer hole caused by a partial fragment
            // This method isn't limited by the size of the gap between buffered ranges
            this._trySkipBufferHole(partial);
        }
        if (bufferInfo.len > jumpThreshold && stalledDuration > config.highBufferWatchdogPeriod * 1000) {
            // Try to nudge currentTime over a buffer hole if we've been stalling for the configured amount of seconds
            // We only try to jump the hole if it's under the configured size
            // Reset stalled so to rearm watchdog timer
            this.stalled = null;
            this._tryNudgeBuffer();
        }
    };
    /**
     * Triggers a BUFFER_STALLED_ERROR event, but only once per stall period.
     * @param bufferLen - The playhead distance from the end of the current buffer segment.
     * @private
     */
    GapController.prototype._reportStall = function (bufferLen) {
        var _a = this, hls = _a.hls, media = _a.media, stallReported = _a.stallReported;
        if (!stallReported) {
            // Report stalled error once
            this.stallReported = true;
            logger_1.logger.warn("Playback stalling at @" + media.currentTime + " due to low buffer");
            hls.trigger(events_1.default.ERROR, {
                type: errors_1.ErrorTypes.MEDIA_ERROR,
                details: errors_1.ErrorDetails.BUFFER_STALLED_ERROR,
                fatal: false,
                buffer: bufferLen
            });
        }
    };
    /**
     * Attempts to fix buffer stalls by jumping over known gaps caused by partial fragments
     * @param partial - The partial fragment found at the current time (where playback is stalling).
     * @private
     */
    GapController.prototype._trySkipBufferHole = function (partial) {
        var _a = this, hls = _a.hls, media = _a.media;
        var currentTime = media.currentTime;
        var lastEndTime = 0;
        // Check if currentTime is between unbuffered regions of partial fragments
        for (var i = 0; i < media.buffered.length; i++) {
            var startTime = media.buffered.start(i);
            if (currentTime >= lastEndTime && currentTime < startTime) {
                media.currentTime = Math.max(startTime, media.currentTime + 0.1);
                logger_1.logger.warn("skipping hole, adjusting currentTime from " + currentTime + " to " + media.currentTime);
                this.stalled = null;
                hls.trigger(events_1.default.ERROR, {
                    type: errors_1.ErrorTypes.MEDIA_ERROR,
                    details: errors_1.ErrorDetails.BUFFER_SEEK_OVER_HOLE,
                    fatal: false,
                    reason: "fragment loaded with buffer holes, seeking from " + currentTime + " to " + media.currentTime,
                    frag: partial
                });
                return;
            }
            lastEndTime = media.buffered.end(i);
        }
    };
    /**
     * Attempts to fix buffer stalls by advancing the mediaElement's current time by a small amount.
     * @private
     */
    GapController.prototype._tryNudgeBuffer = function () {
        var _a = this, config = _a.config, hls = _a.hls, media = _a.media;
        var currentTime = media.currentTime;
        var nudgeRetry = (this.nudgeRetry || 0) + 1;
        this.nudgeRetry = nudgeRetry;
        if (nudgeRetry < config.nudgeMaxRetry) {
            var targetTime = currentTime + nudgeRetry * config.nudgeOffset;
            logger_1.logger.log("adjust currentTime from " + currentTime + " to " + targetTime);
            // playback stalled in buffered area ... let's nudge currentTime to try to overcome this
            media.currentTime = targetTime;
            hls.trigger(events_1.default.ERROR, {
                type: errors_1.ErrorTypes.MEDIA_ERROR,
                details: errors_1.ErrorDetails.BUFFER_NUDGE_ON_STALL,
                fatal: false
            });
        }
        else {
            logger_1.logger.error("still stuck in high buffer @" + currentTime + " after " + config.nudgeMaxRetry + ", raise fatal error");
            hls.trigger(events_1.default.ERROR, {
                type: errors_1.ErrorTypes.MEDIA_ERROR,
                details: errors_1.ErrorDetails.BUFFER_STALLED_ERROR,
                fatal: true
            });
        }
    };
    return GapController;
}());
exports.default = GapController;


/***/ }),

/***/ "./src/controller/id3-track-controller.js":
/*!************************************************!*\
  !*** ./src/controller/id3-track-controller.js ***!
  \************************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * id3 metadata track controller
*/
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var events_1 = __webpack_require__(/*! ../events */ "./src/events.js");
var event_handler_1 = __webpack_require__(/*! ../event-handler */ "./src/event-handler.js");
var id3_1 = __webpack_require__(/*! ../demux/id3 */ "./src/demux/id3.js");
var texttrack_utils_1 = __webpack_require__(/*! ../utils/texttrack-utils */ "./src/utils/texttrack-utils.js");
var ID3TrackController = /** @class */ (function (_super) {
    __extends(ID3TrackController, _super);
    function ID3TrackController(hls) {
        var _this = _super.call(this, hls, events_1.default.MEDIA_ATTACHED, events_1.default.MEDIA_DETACHING, events_1.default.FRAG_PARSING_METADATA) || this;
        _this.id3Track = undefined;
        _this.media = undefined;
        return _this;
    }
    ID3TrackController.prototype.destroy = function () {
        event_handler_1.default.prototype.destroy.call(this);
    };
    // Add ID3 metatadata text track.
    ID3TrackController.prototype.onMediaAttached = function (data) {
        this.media = data.media;
        if (!this.media) {
        }
    };
    ID3TrackController.prototype.onMediaDetaching = function () {
        texttrack_utils_1.clearCurrentCues(this.id3Track);
        this.id3Track = undefined;
        this.media = undefined;
    };
    ID3TrackController.prototype.getID3Track = function (textTracks) {
        for (var i = 0; i < textTracks.length; i++) {
            var textTrack = textTracks[i];
            if (textTrack.kind === 'metadata' && textTrack.label === 'id3') {
                // send 'addtrack' when reusing the textTrack for metadata,
                // same as what we do for captions
                texttrack_utils_1.sendAddTrackEvent(textTrack, this.media);
                return textTrack;
            }
        }
        return this.media.addTextTrack('metadata', 'id3');
    };
    ID3TrackController.prototype.onFragParsingMetadata = function (data) {
        var fragment = data.frag;
        var samples = data.samples;
        // create track dynamically
        if (!this.id3Track) {
            this.id3Track = this.getID3Track(this.media.textTracks);
            this.id3Track.mode = 'hidden';
        }
        // Attempt to recreate Safari functionality by creating
        // WebKitDataCue objects when available and store the decoded
        // ID3 data in the value property of the cue
        var Cue = window.WebKitDataCue || window.VTTCue || window.TextTrackCue;
        for (var i = 0; i < samples.length; i++) {
            var frames_1 = id3_1.default.getID3Frames(samples[i].data);
            if (frames_1) {
                var startTime = samples[i].pts;
                var endTime = i < samples.length - 1 ? samples[i + 1].pts : fragment.endPTS;
                // Give a slight bump to the endTime if it's equal to startTime to avoid a SyntaxError in IE
                if (startTime === endTime) {
                    endTime += 0.0001;
                }
                for (var j = 0; j < frames_1.length; j++) {
                    var frame = frames_1[j];
                    // Safari doesn't put the timestamp frame in the TextTrack
                    if (!id3_1.default.isTimeStampFrame(frame)) {
                        var cue = new Cue(startTime, endTime, '');
                        cue.value = frame;
                        this.id3Track.addCue(cue);
                    }
                }
            }
        }
    };
    return ID3TrackController;
}(event_handler_1.default));
exports.default = ID3TrackController;


/***/ }),

/***/ "./src/controller/level-controller.js":
/*!********************************************!*\
  !*** ./src/controller/level-controller.js ***!
  \********************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Level Controller
*/
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var events_1 = __webpack_require__(/*! ../events */ "./src/events.js");
var event_handler_1 = __webpack_require__(/*! ../event-handler */ "./src/event-handler.js");
var logger_1 = __webpack_require__(/*! ../utils/logger */ "./src/utils/logger.js");
var errors_1 = __webpack_require__(/*! ../errors */ "./src/errors.js");
var codecs_1 = __webpack_require__(/*! ../utils/codecs */ "./src/utils/codecs.js");
var level_helper_1 = __webpack_require__(/*! ./level-helper */ "./src/controller/level-helper.js");
var performance = window.performance;
var chromeOrFirefox;
var LevelController = /** @class */ (function (_super) {
    __extends(LevelController, _super);
    function LevelController(hls) {
        var _this = _super.call(this, hls, events_1.default.MANIFEST_LOADED, events_1.default.LEVEL_LOADED, events_1.default.AUDIO_TRACK_SWITCHED, events_1.default.FRAG_LOADED, events_1.default.ERROR) || this;
        _this.canload = false;
        _this.currentLevelIndex = null;
        _this.manualLevelIndex = -1;
        _this.timer = null;
        chromeOrFirefox = /chrome|firefox/.test(navigator.userAgent.toLowerCase());
        return _this;
    }
    LevelController.prototype.onHandlerDestroying = function () {
        this.clearTimer();
        this.manualLevelIndex = -1;
    };
    LevelController.prototype.clearTimer = function () {
        if (this.timer !== null) {
            clearTimeout(this.timer);
            this.timer = null;
        }
    };
    LevelController.prototype.startLoad = function () {
        var levels = this._levels;
        this.canload = true;
        this.levelRetryCount = 0;
        // clean up live level details to force reload them, and reset load errors
        if (levels) {
            levels.forEach(function (level) {
                level.loadError = 0;
                var levelDetails = level.details;
                if (levelDetails && levelDetails.live) {
                    level.details = undefined;
                }
            });
        }
        // speed up live playlist refresh if timer exists
        if (this.timer !== null) {
            this.loadLevel();
        }
    };
    LevelController.prototype.stopLoad = function () {
        this.canload = false;
    };
    LevelController.prototype.onManifestLoaded = function (data) {
        var levels = [];
        var audioTracks = [];
        var bitrateStart;
        var levelSet = {};
        var levelFromSet = null;
        var videoCodecFound = false;
        var audioCodecFound = false;
        // regroup redundant levels together
        data.levels.forEach(function (level) {
            var attributes = level.attrs;
            level.loadError = 0;
            level.fragmentError = false;
            videoCodecFound = videoCodecFound || !!level.videoCodec;
            audioCodecFound = audioCodecFound || !!level.audioCodec;
            // erase audio codec info if browser does not support mp4a.40.34.
            // demuxer will autodetect codec and fallback to mpeg/audio
            if (chromeOrFirefox && level.audioCodec && level.audioCodec.indexOf('mp4a.40.34') !== -1) {
                level.audioCodec = undefined;
            }
            levelFromSet = levelSet[level.bitrate]; // FIXME: we would also have to match the resolution here
            if (!levelFromSet) {
                level.url = [level.url];
                level.urlId = 0;
                levelSet[level.bitrate] = level;
                levels.push(level);
            }
            else {
                levelFromSet.url.push(level.url);
            }
            if (attributes) {
                if (attributes.AUDIO) {
                    audioCodecFound = true;
                    level_helper_1.addGroupId(levelFromSet || level, 'audio', attributes.AUDIO);
                }
                if (attributes.SUBTITLES) {
                    level_helper_1.addGroupId(levelFromSet || level, 'text', attributes.SUBTITLES);
                }
            }
        });
        // remove audio-only level if we also have levels with audio+video codecs signalled
        if (videoCodecFound && audioCodecFound) {
            levels = levels.filter(function (_a) {
                var videoCodec = _a.videoCodec;
                return !!videoCodec;
            });
        }
        // only keep levels with supported audio/video codecs
        levels = levels.filter(function (_a) {
            var audioCodec = _a.audioCodec, videoCodec = _a.videoCodec;
            return (!audioCodec || codecs_1.isCodecSupportedInMp4(audioCodec, 'audio')) && (!videoCodec || codecs_1.isCodecSupportedInMp4(videoCodec, 'video'));
        });
        if (data.audioTracks) {
            audioTracks = data.audioTracks.filter(function (track) { return !track.audioCodec || codecs_1.isCodecSupportedInMp4(track.audioCodec, 'audio'); });
            // Reassign id's after filtering since they're used as array indices
            audioTracks.forEach(function (track, index) {
                track.id = index;
            });
        }
        if (levels.length > 0) {
            // start bitrate is the first bitrate of the manifest
            bitrateStart = levels[0].bitrate;
            // sort level on bitrate
            levels.sort(function (a, b) { return a.bitrate - b.bitrate; });
            this._levels = levels;
            // find index of first level in sorted levels
            for (var i = 0; i < levels.length; i++) {
                if (levels[i].bitrate === bitrateStart) {
                    this._firstLevel = i;
                    logger_1.logger.log("manifest loaded," + levels.length + " level(s) found, first bitrate:" + bitrateStart);
                    break;
                }
            }
            // Audio is only alternate if manifest include a URI along with the audio group tag
            this.hls.trigger(events_1.default.MANIFEST_PARSED, {
                levels: levels,
                audioTracks: audioTracks,
                firstLevel: this._firstLevel,
                stats: data.stats,
                audio: audioCodecFound,
                video: videoCodecFound,
                altAudio: audioTracks.some(function (t) { return !!t.url; })
            });
        }
        else {
            this.hls.trigger(events_1.default.ERROR, {
                type: errors_1.ErrorTypes.MEDIA_ERROR,
                details: errors_1.ErrorDetails.MANIFEST_INCOMPATIBLE_CODECS_ERROR,
                fatal: true,
                url: this.hls.url,
                reason: 'no level with compatible codecs found in manifest'
            });
        }
    };
    Object.defineProperty(LevelController.prototype, "levels", {
        get: function () {
            return this._levels;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LevelController.prototype, "level", {
        get: function () {
            return this.currentLevelIndex;
        },
        set: function (newLevel) {
            var levels = this._levels;
            if (levels) {
                newLevel = Math.min(newLevel, levels.length - 1);
                if (this.currentLevelIndex !== newLevel || !levels[newLevel].details) {
                    this.setLevelInternal(newLevel);
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    LevelController.prototype.setLevelInternal = function (newLevel) {
        var levels = this._levels;
        var hls = this.hls;
        // check if level idx is valid
        if (newLevel >= 0 && newLevel < levels.length) {
            // stopping live reloading timer if any
            this.clearTimer();
            if (this.currentLevelIndex !== newLevel) {
                logger_1.logger.log("switching to level " + newLevel);
                this.currentLevelIndex = newLevel;
                var levelProperties = levels[newLevel];
                levelProperties.level = newLevel;
                hls.trigger(events_1.default.LEVEL_SWITCHING, levelProperties);
            }
            var level = levels[newLevel];
            var levelDetails = level.details;
            // check if we need to load playlist for this level
            if (!levelDetails || levelDetails.live) {
                // level not retrieved yet, or live playlist we need to (re)load it
                var urlId = level.urlId;
                hls.trigger(events_1.default.LEVEL_LOADING, { url: level.url[urlId], level: newLevel, id: urlId });
            }
        }
        else {
            // invalid level id given, trigger error
            hls.trigger(events_1.default.ERROR, {
                type: errors_1.ErrorTypes.OTHER_ERROR,
                details: errors_1.ErrorDetails.LEVEL_SWITCH_ERROR,
                level: newLevel,
                fatal: false,
                reason: 'invalid level idx'
            });
        }
    };
    Object.defineProperty(LevelController.prototype, "manualLevel", {
        get: function () {
            return this.manualLevelIndex;
        },
        set: function (newLevel) {
            this.manualLevelIndex = newLevel;
            if (this._startLevel === undefined) {
                this._startLevel = newLevel;
            }
            if (newLevel !== -1) {
                this.level = newLevel;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LevelController.prototype, "firstLevel", {
        get: function () {
            return this._firstLevel;
        },
        set: function (newLevel) {
            this._firstLevel = newLevel;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LevelController.prototype, "startLevel", {
        get: function () {
            // hls.startLevel takes precedence over config.startLevel
            // if none of these values are defined, fallback on this._firstLevel (first quality level appearing in variant manifest)
            if (this._startLevel === undefined) {
                var configStartLevel = this.hls.config.startLevel;
                if (configStartLevel !== undefined) {
                    return configStartLevel;
                }
                else {
                    return this._firstLevel;
                }
            }
            else {
                return this._startLevel;
            }
        },
        set: function (newLevel) {
            this._startLevel = newLevel;
        },
        enumerable: true,
        configurable: true
    });
    LevelController.prototype.onError = function (data) {
        if (data.fatal) {
            if (data.type === errors_1.ErrorTypes.NETWORK_ERROR) {
                this.clearTimer();
            }
            return;
        }
        var levelError = false, fragmentError = false;
        var levelIndex;
        // try to recover not fatal errors
        switch (data.details) {
            case errors_1.ErrorDetails.FRAG_LOAD_ERROR:
            case errors_1.ErrorDetails.FRAG_LOAD_TIMEOUT:
            case errors_1.ErrorDetails.KEY_LOAD_ERROR:
            case errors_1.ErrorDetails.KEY_LOAD_TIMEOUT:
                levelIndex = data.frag.level;
                fragmentError = true;
                break;
            case errors_1.ErrorDetails.LEVEL_LOAD_ERROR:
            case errors_1.ErrorDetails.LEVEL_LOAD_TIMEOUT:
                levelIndex = data.context.level;
                levelError = true;
                break;
            case errors_1.ErrorDetails.REMUX_ALLOC_ERROR:
                levelIndex = data.level;
                levelError = true;
                break;
        }
        if (levelIndex !== undefined) {
            this.recoverLevel(data, levelIndex, levelError, fragmentError);
        }
    };
    /**
     * Switch to a redundant stream if any available.
     * If redundant stream is not available, emergency switch down if ABR mode is enabled.
     *
     * @param {Object} errorEvent
     * @param {Number} levelIndex current level index
     * @param {Boolean} levelError
     * @param {Boolean} fragmentError
     */
    // FIXME Find a better abstraction where fragment/level retry management is well decoupled
    LevelController.prototype.recoverLevel = function (errorEvent, levelIndex, levelError, fragmentError) {
        var _this = this;
        var config = this.hls.config;
        var errorDetails = errorEvent.details;
        var level = this._levels[levelIndex];
        var redundantLevels, delay, nextLevel;
        level.loadError++;
        level.fragmentError = fragmentError;
        if (levelError) {
            if ((this.levelRetryCount + 1) <= config.levelLoadingMaxRetry) {
                // exponential backoff capped to max retry timeout
                delay = Math.min(Math.pow(2, this.levelRetryCount) * config.levelLoadingRetryDelay, config.levelLoadingMaxRetryTimeout);
                // Schedule level reload
                this.timer = setTimeout(function () { return _this.loadLevel(); }, delay);
                // boolean used to inform stream controller not to switch back to IDLE on non fatal error
                errorEvent.levelRetry = true;
                this.levelRetryCount++;
                logger_1.logger.warn("level controller, " + errorDetails + ", retry in " + delay + " ms, current retry count is " + this.levelRetryCount);
            }
            else {
                logger_1.logger.error("level controller, cannot recover from " + errorDetails + " error");
                this.currentLevelIndex = null;
                // stopping live reloading timer if any
                this.clearTimer();
                // switch error to fatal
                errorEvent.fatal = true;
                return;
            }
        }
        // Try any redundant streams if available for both errors: level and fragment
        // If level.loadError reaches redundantLevels it means that we tried them all, no hope  => let's switch down
        if (levelError || fragmentError) {
            redundantLevels = level.url.length;
            if (redundantLevels > 1 && level.loadError < redundantLevels) {
                level.urlId = (level.urlId + 1) % redundantLevels;
                level.details = undefined;
                logger_1.logger.warn("level controller, " + errorDetails + " for level " + levelIndex + ": switching to redundant URL-id " + level.urlId);
                // console.log('Current audio track group ID:', this.hls.audioTracks[this.hls.audioTrack].groupId);
                // console.log('New video quality level audio group id:', level.attrs.AUDIO);
            }
            else {
                // Search for available level
                if (this.manualLevelIndex === -1) {
                    // When lowest level has been reached, let's start hunt from the top
                    nextLevel = (levelIndex === 0) ? this._levels.length - 1 : levelIndex - 1;
                    logger_1.logger.warn("level controller, " + errorDetails + ": switch to " + nextLevel);
                    this.hls.nextAutoLevel = this.currentLevelIndex = nextLevel;
                }
                else if (fragmentError) {
                    // Allow fragment retry as long as configuration allows.
                    // reset this._level so that another call to set level() will trigger again a frag load
                    logger_1.logger.warn("level controller, " + errorDetails + ": reload a fragment");
                    this.currentLevelIndex = null;
                }
            }
        }
    };
    // reset errors on the successful load of a fragment
    LevelController.prototype.onFragLoaded = function (_a) {
        var frag = _a.frag;
        if (frag !== undefined && frag.type === 'main') {
            var level = this._levels[frag.level];
            if (level !== undefined) {
                level.fragmentError = false;
                level.loadError = 0;
                this.levelRetryCount = 0;
            }
        }
    };
    LevelController.prototype.onLevelLoaded = function (data) {
        var _this = this;
        var level = data.level, details = data.details;
        // only process level loaded events matching with expected level
        if (level !== this.currentLevelIndex) {
            return;
        }
        var curLevel = this._levels[level];
        // reset level load error counter on successful level loaded only if there is no issues with fragments
        if (!curLevel.fragmentError) {
            curLevel.loadError = 0;
            this.levelRetryCount = 0;
        }
        // if current playlist is a live playlist, arm a timer to reload it
        if (details.live) {
            var reloadInterval = level_helper_1.computeReloadInterval(curLevel.details, details, data.stats.trequest);
            logger_1.logger.log("live playlist, reload in " + Math.round(reloadInterval) + " ms");
            this.timer = setTimeout(function () { return _this.loadLevel(); }, reloadInterval);
        }
        else {
            this.clearTimer();
        }
    };
    LevelController.prototype.onAudioTrackSwitched = function (data) {
        var audioGroupId = this.hls.audioTracks[data.id].groupId;
        var currentLevel = this.hls.levels[this.currentLevelIndex];
        if (!currentLevel) {
            return;
        }
        if (currentLevel.audioGroupIds) {
            var urlId = -1;
            for (var i = 0; i < currentLevel.audioGroupIds.length; i++) {
                if (currentLevel.audioGroupIds[i] === audioGroupId) {
                    urlId = i;
                    break;
                }
            }
            if (urlId !== currentLevel.urlId) {
                currentLevel.urlId = urlId;
                this.startLoad();
            }
        }
    };
    LevelController.prototype.loadLevel = function () {
        logger_1.logger.debug('call to loadLevel');
        if (this.currentLevelIndex !== null && this.canload) {
            var levelObject = this._levels[this.currentLevelIndex];
            if (typeof levelObject === 'object' &&
                levelObject.url.length > 0) {
                var level = this.currentLevelIndex;
                var id = levelObject.urlId;
                var url = levelObject.url[id];
                logger_1.logger.log("Attempt loading level index " + level + " with URL-id " + id);
                // console.log('Current audio track group ID:', this.hls.audioTracks[this.hls.audioTrack].groupId);
                // console.log('New video quality level audio group id:', levelObject.attrs.AUDIO, level);
                this.hls.trigger(events_1.default.LEVEL_LOADING, { url: url, level: level, id: id });
            }
        }
    };
    Object.defineProperty(LevelController.prototype, "nextLoadLevel", {
        get: function () {
            if (this.manualLevelIndex !== -1) {
                return this.manualLevelIndex;
            }
            else {
                return this.hls.nextAutoLevel;
            }
        },
        set: function (nextLevel) {
            this.level = nextLevel;
            if (this.manualLevelIndex === -1) {
                this.hls.nextAutoLevel = nextLevel;
            }
        },
        enumerable: true,
        configurable: true
    });
    return LevelController;
}(event_handler_1.default));
exports.default = LevelController;


/***/ }),

/***/ "./src/controller/level-helper.js":
/*!****************************************!*\
  !*** ./src/controller/level-helper.js ***!
  \****************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Number) {
/**
 * @module LevelHelper
 *
 * Providing methods dealing with playlist sliding and drift
 *
 * TODO: Create an actual `Level` class/model that deals with all this logic in an object-oriented-manner.
 *
 * */
Object.defineProperty(exports, "__esModule", { value: true });
var logger_1 = __webpack_require__(/*! ../utils/logger */ "./src/utils/logger.js");
function addGroupId(level, type, id) {
    switch (type) {
        case 'audio':
            if (!level.audioGroupIds) {
                level.audioGroupIds = [];
            }
            level.audioGroupIds.push(id);
            break;
        case 'text':
            if (!level.textGroupIds) {
                level.textGroupIds = [];
            }
            level.textGroupIds.push(id);
            break;
    }
}
exports.addGroupId = addGroupId;
function updatePTS(fragments, fromIdx, toIdx) {
    var fragFrom = fragments[fromIdx], fragTo = fragments[toIdx], fragToPTS = fragTo.startPTS;
    // if we know startPTS[toIdx]
    if (Number.isFinite(fragToPTS)) {
        // update fragment duration.
        // it helps to fix drifts between playlist reported duration and fragment real duration
        if (toIdx > fromIdx) {
            fragFrom.duration = fragToPTS - fragFrom.start;
            if (fragFrom.duration < 0) {
                logger_1.logger.warn("negative duration computed for frag " + fragFrom.sn + ",level " + fragFrom.level + ", there should be some duration drift between playlist and fragment!");
            }
        }
        else {
            fragTo.duration = fragFrom.start - fragToPTS;
            if (fragTo.duration < 0) {
                logger_1.logger.warn("negative duration computed for frag " + fragTo.sn + ",level " + fragTo.level + ", there should be some duration drift between playlist and fragment!");
            }
        }
    }
    else {
        // we dont know startPTS[toIdx]
        if (toIdx > fromIdx) {
            fragTo.start = fragFrom.start + fragFrom.duration;
        }
        else {
            fragTo.start = Math.max(fragFrom.start - fragTo.duration, 0);
        }
    }
}
exports.updatePTS = updatePTS;
function updateFragPTSDTS(details, frag, startPTS, endPTS, startDTS, endDTS) {
    // update frag PTS/DTS
    var maxStartPTS = startPTS;
    if (Number.isFinite(frag.startPTS)) {
        // delta PTS between audio and video
        var deltaPTS = Math.abs(frag.startPTS - startPTS);
        if (!Number.isFinite(frag.deltaPTS)) {
            frag.deltaPTS = deltaPTS;
        }
        else {
            frag.deltaPTS = Math.max(deltaPTS, frag.deltaPTS);
        }
        maxStartPTS = Math.max(startPTS, frag.startPTS);
        startPTS = Math.min(startPTS, frag.startPTS);
        endPTS = Math.max(endPTS, frag.endPTS);
        startDTS = Math.min(startDTS, frag.startDTS);
        endDTS = Math.max(endDTS, frag.endDTS);
    }
    var drift = startPTS - frag.start;
    frag.start = frag.startPTS = startPTS;
    frag.maxStartPTS = maxStartPTS;
    frag.endPTS = endPTS;
    frag.startDTS = startDTS;
    frag.endDTS = endDTS;
    frag.duration = endPTS - startPTS;
    var sn = frag.sn;
    // exit if sn out of range
    if (!details || sn < details.startSN || sn > details.endSN) {
        return 0;
    }
    var fragIdx, fragments, i;
    fragIdx = sn - details.startSN;
    fragments = details.fragments;
    // update frag reference in fragments array
    // rationale is that fragments array might not contain this frag object.
    // this will happen if playlist has been refreshed between frag loading and call to updateFragPTSDTS()
    // if we don't update frag, we won't be able to propagate PTS info on the playlist
    // resulting in invalid sliding computation
    fragments[fragIdx] = frag;
    // adjust fragment PTS/duration from seqnum-1 to frag 0
    for (i = fragIdx; i > 0; i--) {
        updatePTS(fragments, i, i - 1);
    }
    // adjust fragment PTS/duration from seqnum to last frag
    for (i = fragIdx; i < fragments.length - 1; i++) {
        updatePTS(fragments, i, i + 1);
    }
    details.PTSKnown = true;
    return drift;
}
exports.updateFragPTSDTS = updateFragPTSDTS;
function mergeDetails(oldDetails, newDetails) {
    // potentially retrieve cached initsegment
    if (newDetails.initSegment && oldDetails.initSegment) {
        newDetails.initSegment = oldDetails.initSegment;
    }
    // check if old/new playlists have fragments in common
    // loop through overlapping SN and update startPTS , cc, and duration if any found
    var ccOffset = 0;
    var PTSFrag;
    mapFragmentIntersection(oldDetails, newDetails, function (oldFrag, newFrag) {
        ccOffset = oldFrag.cc - newFrag.cc;
        if (Number.isFinite(oldFrag.startPTS)) {
            newFrag.start = newFrag.startPTS = oldFrag.startPTS;
            newFrag.endPTS = oldFrag.endPTS;
            newFrag.duration = oldFrag.duration;
            newFrag.backtracked = oldFrag.backtracked;
            newFrag.dropped = oldFrag.dropped;
            PTSFrag = newFrag;
        }
        // PTS is known when there are overlapping segments
        newDetails.PTSKnown = true;
    });
    if (!newDetails.PTSKnown) {
        return;
    }
    if (ccOffset) {
        logger_1.logger.log('discontinuity sliding from playlist, take drift into account');
        var newFragments = newDetails.fragments;
        for (var i = 0; i < newFragments.length; i++) {
            newFragments[i].cc += ccOffset;
        }
    }
    // if at least one fragment contains PTS info, recompute PTS information for all fragments
    if (PTSFrag) {
        updateFragPTSDTS(newDetails, PTSFrag, PTSFrag.startPTS, PTSFrag.endPTS, PTSFrag.startDTS, PTSFrag.endDTS);
    }
    else {
        // ensure that delta is within oldFragments range
        // also adjust sliding in case delta is 0 (we could have old=[50-60] and new=old=[50-61])
        // in that case we also need to adjust start offset of all fragments
        adjustSliding(oldDetails, newDetails);
    }
    // if we are here, it means we have fragments overlapping between
    // old and new level. reliable PTS info is thus relying on old level
    newDetails.PTSKnown = oldDetails.PTSKnown;
}
exports.mergeDetails = mergeDetails;
function mergeSubtitlePlaylists(oldPlaylist, newPlaylist, referenceStart) {
    if (referenceStart === void 0) { referenceStart = 0; }
    var lastIndex = -1;
    mapFragmentIntersection(oldPlaylist, newPlaylist, function (oldFrag, newFrag, index) {
        newFrag.start = oldFrag.start;
        lastIndex = index;
    });
    var frags = newPlaylist.fragments;
    if (lastIndex < 0) {
        frags.forEach(function (frag) {
            frag.start += referenceStart;
        });
        return;
    }
    for (var i = lastIndex + 1; i < frags.length; i++) {
        frags[i].start = (frags[i - 1].start + frags[i - 1].duration);
    }
}
exports.mergeSubtitlePlaylists = mergeSubtitlePlaylists;
function mapFragmentIntersection(oldPlaylist, newPlaylist, intersectionFn) {
    if (!oldPlaylist || !newPlaylist) {
        return;
    }
    var start = Math.max(oldPlaylist.startSN, newPlaylist.startSN) - newPlaylist.startSN;
    var end = Math.min(oldPlaylist.endSN, newPlaylist.endSN) - newPlaylist.startSN;
    var delta = newPlaylist.startSN - oldPlaylist.startSN;
    for (var i = start; i <= end; i++) {
        var oldFrag = oldPlaylist.fragments[delta + i];
        var newFrag = newPlaylist.fragments[i];
        if (!oldFrag || !newFrag) {
            break;
        }
        intersectionFn(oldFrag, newFrag, i);
    }
}
exports.mapFragmentIntersection = mapFragmentIntersection;
function adjustSliding(oldPlaylist, newPlaylist) {
    var delta = newPlaylist.startSN - oldPlaylist.startSN;
    var oldFragments = oldPlaylist.fragments;
    var newFragments = newPlaylist.fragments;
    if (delta < 0 || delta > oldFragments.length) {
        return;
    }
    for (var i = 0; i < newFragments.length; i++) {
        newFragments[i].start += oldFragments[delta].start;
    }
}
exports.adjustSliding = adjustSliding;
function computeReloadInterval(currentPlaylist, newPlaylist, lastRequestTime) {
    var reloadInterval = 1000 * (newPlaylist.averagetargetduration ? newPlaylist.averagetargetduration : newPlaylist.targetduration);
    var minReloadInterval = reloadInterval / 2;
    if (currentPlaylist && newPlaylist.endSN === currentPlaylist.endSN) {
        // follow HLS Spec, If the client reloads a Playlist file and finds that it has not
        // changed then it MUST wait for a period of one-half the target
        // duration before retrying.
        reloadInterval = minReloadInterval;
    }
    if (lastRequestTime) {
        reloadInterval = Math.max(minReloadInterval, reloadInterval - (window.performance.now() - lastRequestTime));
    }
    // in any case, don't reload more than half of target duration
    return Math.round(reloadInterval);
}
exports.computeReloadInterval = computeReloadInterval;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./src/polyfills/number */ "./src/polyfills/number.js")["Number"]))

/***/ }),

/***/ "./src/controller/stream-controller.js":
/*!*********************************************!*\
  !*** ./src/controller/stream-controller.js ***!
  \*********************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Number) {
/*
 * Stream Controller
*/
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var binary_search_1 = __webpack_require__(/*! ../utils/binary-search */ "./src/utils/binary-search.js");
var buffer_helper_1 = __webpack_require__(/*! ../utils/buffer-helper */ "./src/utils/buffer-helper.js");
var demuxer_1 = __webpack_require__(/*! ../demux/demuxer */ "./src/demux/demuxer.js");
var events_1 = __webpack_require__(/*! ../events */ "./src/events.js");
var fragment_tracker_1 = __webpack_require__(/*! ./fragment-tracker */ "./src/controller/fragment-tracker.js");
var fragment_1 = __webpack_require__(/*! ../loader/fragment */ "./src/loader/fragment.js");
var playlist_loader_1 = __webpack_require__(/*! ../loader/playlist-loader */ "./src/loader/playlist-loader.js");
var LevelHelper = __webpack_require__(/*! ./level-helper */ "./src/controller/level-helper.js");
var time_ranges_1 = __webpack_require__(/*! ../utils/time-ranges */ "./src/utils/time-ranges.js");
var errors_1 = __webpack_require__(/*! ../errors */ "./src/errors.js");
var logger_1 = __webpack_require__(/*! ../utils/logger */ "./src/utils/logger.js");
var discontinuities_1 = __webpack_require__(/*! ../utils/discontinuities */ "./src/utils/discontinuities.js");
var fragment_finders_1 = __webpack_require__(/*! ./fragment-finders */ "./src/controller/fragment-finders.js");
var gap_controller_1 = __webpack_require__(/*! ./gap-controller */ "./src/controller/gap-controller.js");
var base_stream_controller_1 = __webpack_require__(/*! ./base-stream-controller */ "./src/controller/base-stream-controller.js");
var TICK_INTERVAL = 100; // how often to tick in ms
var StreamController = /** @class */ (function (_super) {
    __extends(StreamController, _super);
    function StreamController(hls, fragmentTracker) {
        var _this = _super.call(this, hls, events_1.default.MEDIA_ATTACHED, events_1.default.MEDIA_DETACHING, events_1.default.MANIFEST_LOADING, events_1.default.MANIFEST_PARSED, events_1.default.LEVEL_LOADED, events_1.default.KEY_LOADED, events_1.default.FRAG_LOADED, events_1.default.FRAG_LOAD_EMERGENCY_ABORTED, events_1.default.FRAG_PARSING_INIT_SEGMENT, events_1.default.FRAG_PARSING_DATA, events_1.default.FRAG_PARSED, events_1.default.ERROR, events_1.default.AUDIO_TRACK_SWITCHING, events_1.default.AUDIO_TRACK_SWITCHED, events_1.default.BUFFER_CREATED, events_1.default.BUFFER_APPENDED, events_1.default.BUFFER_FLUSHED) || this;
        _this.fragmentTracker = fragmentTracker;
        _this.config = hls.config;
        _this.audioCodecSwap = false;
        _this._state = base_stream_controller_1.State.STOPPED;
        _this.stallReported = false;
        _this.gapController = null;
        return _this;
    }
    StreamController.prototype.startLoad = function (startPosition) {
        if (this.levels) {
            var lastCurrentTime = this.lastCurrentTime, hls_1 = this.hls;
            this.stopLoad();
            this.setInterval(TICK_INTERVAL);
            this.level = -1;
            this.fragLoadError = 0;
            if (!this.startFragRequested) {
                // determine load level
                var startLevel = hls_1.startLevel;
                if (startLevel === -1) {
                    // -1 : guess start Level by doing a bitrate test by loading first fragment of lowest quality level
                    startLevel = 0;
                    this.bitrateTest = true;
                }
                // set new level to playlist loader : this will trigger start level load
                // hls.nextLoadLevel remains until it is set to a new value or until a new frag is successfully loaded
                this.level = hls_1.nextLoadLevel = startLevel;
                this.loadedmetadata = false;
            }
            // if startPosition undefined but lastCurrentTime set, set startPosition to last currentTime
            if (lastCurrentTime > 0 && startPosition === -1) {
                logger_1.logger.log("override startPosition with lastCurrentTime @" + lastCurrentTime.toFixed(3));
                startPosition = lastCurrentTime;
            }
            this.state = base_stream_controller_1.State.IDLE;
            this.nextLoadPosition = this.startPosition = this.lastCurrentTime = startPosition;
            this.tick();
        }
        else {
            this.forceStartLoad = true;
            this.state = base_stream_controller_1.State.STOPPED;
        }
    };
    StreamController.prototype.stopLoad = function () {
        this.forceStartLoad = false;
        _super.prototype.stopLoad.call(this);
    };
    StreamController.prototype.doTick = function () {
        switch (this.state) {
            case base_stream_controller_1.State.BUFFER_FLUSHING:
                // in buffer flushing state, reset fragLoadError counter
                this.fragLoadError = 0;
                break;
            case base_stream_controller_1.State.IDLE:
                this._doTickIdle();
                break;
            case base_stream_controller_1.State.WAITING_LEVEL:
                var level = this.levels[this.level];
                // check if playlist is already loaded
                if (level && level.details) {
                    this.state = base_stream_controller_1.State.IDLE;
                }
                break;
            case base_stream_controller_1.State.FRAG_LOADING_WAITING_RETRY:
                var now = window.performance.now();
                var retryDate = this.retryDate;
                // if current time is gt than retryDate, or if media seeking let's switch to IDLE state to retry loading
                if (!retryDate || (now >= retryDate) || (this.media && this.media.seeking)) {
                    logger_1.logger.log('mediaController: retryDate reached, switch back to IDLE state');
                    this.state = base_stream_controller_1.State.IDLE;
                }
                break;
            case base_stream_controller_1.State.ERROR:
            case base_stream_controller_1.State.STOPPED:
            case base_stream_controller_1.State.FRAG_LOADING:
            case base_stream_controller_1.State.PARSING:
            case base_stream_controller_1.State.PARSED:
            case base_stream_controller_1.State.ENDED:
                break;
            default:
                break;
        }
        // check buffer
        this._checkBuffer();
        // check/update current fragment
        this._checkFragmentChanged();
    };
    // Ironically the "idle" state is the on we do the most logic in it seems ....
    // NOTE: Maybe we could rather schedule a check for buffer length after half of the currently
    //       played segment, or on pause/play/seek instead of naively checking every 100ms?
    StreamController.prototype._doTickIdle = function () {
        var hls = this.hls, config = hls.config, media = this.media;
        // if start level not parsed yet OR
        // if video not attached AND start fragment already requested OR start frag prefetch disable
        // exit loop, as we either need more info (level not parsed) or we need media to be attached to load new fragment
        if (this.levelLastLoaded === undefined || (!media && (this.startFragRequested || !config.startFragPrefetch))) {
            return;
        }
        // if we have not yet loaded any fragment, start loading from start position
        var pos;
        if (this.loadedmetadata) {
            pos = media.currentTime;
        }
        else {
            pos = this.nextLoadPosition;
        }
        // determine next load level
        var level = hls.nextLoadLevel, levelInfo = this.levels[level];
        if (!levelInfo) {
            return;
        }
        var levelBitrate = levelInfo.bitrate, maxBufLen;
        // compute max Buffer Length that we could get from this load level, based on level bitrate. don't buffer more than 60 MB and more than 30s
        if (levelBitrate) {
            maxBufLen = Math.max(8 * config.maxBufferSize / levelBitrate, config.maxBufferLength);
        }
        else {
            maxBufLen = config.maxBufferLength;
        }
        maxBufLen = Math.min(maxBufLen, config.maxMaxBufferLength);
        // determine next candidate fragment to be loaded, based on current position and end of buffer position
        // ensure up to `config.maxMaxBufferLength` of buffer upfront
        var bufferInfo = buffer_helper_1.BufferHelper.bufferInfo(this.mediaBuffer ? this.mediaBuffer : media, pos, config.maxBufferHole), bufferLen = bufferInfo.len;
        // Stay idle if we are still with buffer margins
        if (bufferLen >= maxBufLen) {
            return;
        }
        // if buffer length is less than maxBufLen try to load a new fragment ...
        logger_1.logger.trace("buffer length of " + bufferLen.toFixed(3) + " is below max of " + maxBufLen.toFixed(3) + ". checking for more payload ...");
        // set next load level : this will trigger a playlist load if needed
        this.level = hls.nextLoadLevel = level;
        var levelDetails = levelInfo.details;
        // if level info not retrieved yet, switch state and wait for level retrieval
        // if live playlist, ensure that new playlist has been refreshed to avoid loading/try to load
        // a useless and outdated fragment (that might even introduce load error if it is already out of the live playlist)
        if (!levelDetails || (levelDetails.live && this.levelLastLoaded !== level)) {
            this.state = base_stream_controller_1.State.WAITING_LEVEL;
            return;
        }
        if (this._streamEnded(bufferInfo, levelDetails)) {
            var data = {};
            if (this.altAudio) {
                data.type = 'video';
            }
            this.hls.trigger(events_1.default.BUFFER_EOS, data);
            this.state = base_stream_controller_1.State.ENDED;
            return;
        }
        // if we have the levelDetails for the selected variant, lets continue enrichen our stream (load keys/fragments or trigger EOS, etc..)
        this._fetchPayloadOrEos(pos, bufferInfo, levelDetails);
    };
    StreamController.prototype._fetchPayloadOrEos = function (pos, bufferInfo, levelDetails) {
        var fragPrevious = this.fragPrevious, level = this.level, fragments = levelDetails.fragments, fragLen = fragments.length;
        // empty playlist
        if (fragLen === 0) {
            return;
        }
        // find fragment index, contiguous with end of buffer position
        var start = fragments[0].start, end = fragments[fragLen - 1].start + fragments[fragLen - 1].duration, bufferEnd = bufferInfo.end, frag;
        if (levelDetails.initSegment && !levelDetails.initSegment.data) {
            frag = levelDetails.initSegment;
        }
        else {
            // in case of live playlist we need to ensure that requested position is not located before playlist start
            if (levelDetails.live) {
                var initialLiveManifestSize = this.config.initialLiveManifestSize;
                if (fragLen < initialLiveManifestSize) {
                    logger_1.logger.warn("Can not start playback of a level, reason: not enough fragments " + fragLen + " < " + initialLiveManifestSize);
                    return;
                }
                frag = this._ensureFragmentAtLivePoint(levelDetails, bufferEnd, start, end, fragPrevious, fragments, fragLen);
                // if it explicitely returns null don't load any fragment and exit function now
                if (frag === null) {
                    return;
                }
            }
            else {
                // VoD playlist: if bufferEnd before start of playlist, load first fragment
                if (bufferEnd < start) {
                    frag = fragments[0];
                }
            }
        }
        if (!frag) {
            frag = this._findFragment(start, fragPrevious, fragLen, fragments, bufferEnd, end, levelDetails);
        }
        if (frag) {
            if (frag.encrypted) {
                logger_1.logger.log("Loading key for " + frag.sn + " of [" + levelDetails.startSN + " ," + levelDetails.endSN + "],level " + level);
                this._loadKey(frag);
            }
            else {
                logger_1.logger.log("Loading " + frag.sn + " of [" + levelDetails.startSN + " ," + levelDetails.endSN + "],level " + level + ", currentTime:" + pos.toFixed(3) + ",bufferEnd:" + bufferEnd.toFixed(3));
                this._loadFragment(frag);
            }
        }
    };
    StreamController.prototype._ensureFragmentAtLivePoint = function (levelDetails, bufferEnd, start, end, fragPrevious, fragments, fragLen) {
        var config = this.hls.config, media = this.media;
        var frag;
        // check if requested position is within seekable boundaries :
        // logger.log(`start/pos/bufEnd/seeking:${start.toFixed(3)}/${pos.toFixed(3)}/${bufferEnd.toFixed(3)}/${this.media.seeking}`);
        var maxLatency = config.liveMaxLatencyDuration !== undefined ? config.liveMaxLatencyDuration : config.liveMaxLatencyDurationCount * levelDetails.targetduration;
        if (bufferEnd < Math.max(start - config.maxFragLookUpTolerance, end - maxLatency)) {
            var liveSyncPosition = this.liveSyncPosition = this.computeLivePosition(start, levelDetails);
            logger_1.logger.log("buffer end: " + bufferEnd.toFixed(3) + " is located too far from the end of live sliding playlist, reset currentTime to : " + liveSyncPosition.toFixed(3));
            bufferEnd = liveSyncPosition;
            if (media && media.readyState && media.duration > liveSyncPosition) {
                media.currentTime = liveSyncPosition;
            }
            this.nextLoadPosition = liveSyncPosition;
        }
        // if end of buffer greater than live edge, don't load any fragment
        // this could happen if live playlist intermittently slides in the past.
        // level 1 loaded [182580161,182580167]
        // level 1 loaded [182580162,182580169]
        // Loading 182580168 of [182580162 ,182580169],level 1 ..
        // Loading 182580169 of [182580162 ,182580169],level 1 ..
        // level 1 loaded [182580162,182580168] <============= here we should have bufferEnd > end. in that case break to avoid reloading 182580168
        // level 1 loaded [182580164,182580171]
        //
        // don't return null in case media not loaded yet (readystate === 0)
        if (levelDetails.PTSKnown && bufferEnd > end && media && media.readyState) {
            return null;
        }
        if (this.startFragRequested && !levelDetails.PTSKnown) {
            /* we are switching level on live playlist, but we don't have any PTS info for that quality level ...
               try to load frag matching with next SN.
               even if SN are not synchronized between playlists, loading this frag will help us
               compute playlist sliding and find the right one after in case it was not the right consecutive one */
            if (fragPrevious) {
                if (levelDetails.hasProgramDateTime) {
                    // Relies on PDT in order to switch bitrates (Support EXT-X-DISCONTINUITY without EXT-X-DISCONTINUITY-SEQUENCE)
                    logger_1.logger.log("live playlist, switching playlist, load frag with same PDT: " + fragPrevious.programDateTime);
                    frag = fragment_finders_1.findFragmentByPDT(fragments, fragPrevious.endProgramDateTime, config.maxFragLookUpTolerance);
                }
                else {
                    // Uses buffer and sequence number to calculate switch segment (required if using EXT-X-DISCONTINUITY-SEQUENCE)
                    var targetSN = fragPrevious.sn + 1;
                    if (targetSN >= levelDetails.startSN && targetSN <= levelDetails.endSN) {
                        var fragNext = fragments[targetSN - levelDetails.startSN];
                        if (fragPrevious.cc === fragNext.cc) {
                            frag = fragNext;
                            logger_1.logger.log("live playlist, switching playlist, load frag with next SN: " + frag.sn);
                        }
                    }
                    // next frag SN not available (or not with same continuity counter)
                    // look for a frag sharing the same CC
                    if (!frag) {
                        frag = binary_search_1.default.search(fragments, function (frag) {
                            return fragPrevious.cc - frag.cc;
                        });
                        if (frag) {
                            logger_1.logger.log("live playlist, switching playlist, load frag with same CC: " + frag.sn);
                        }
                    }
                }
            }
            if (!frag) {
                /* we have no idea about which fragment should be loaded.
                   so let's load mid fragment. it will help computing playlist sliding and find the right one
                */
                frag = fragments[Math.min(fragLen - 1, Math.round(fragLen / 2))];
                logger_1.logger.log("live playlist, switching playlist, unknown, load middle frag : " + frag.sn);
            }
        }
        return frag;
    };
    StreamController.prototype._findFragment = function (start, fragPrevious, fragLen, fragments, bufferEnd, end, levelDetails) {
        var config = this.hls.config;
        var frag;
        if (bufferEnd < end) {
            var lookupTolerance = (bufferEnd > end - config.maxFragLookUpTolerance) ? 0 : config.maxFragLookUpTolerance;
            // Remove the tolerance if it would put the bufferEnd past the actual end of stream
            // Uses buffer and sequence number to calculate switch segment (required if using EXT-X-DISCONTINUITY-SEQUENCE)
            frag = fragment_finders_1.findFragmentByPTS(fragPrevious, fragments, bufferEnd, lookupTolerance);
        }
        else {
            // reach end of playlist
            frag = fragments[fragLen - 1];
        }
        if (frag) {
            var curSNIdx = frag.sn - levelDetails.startSN;
            var sameLevel = fragPrevious && frag.level === fragPrevious.level;
            var prevFrag = fragments[curSNIdx - 1];
            var nextFrag = fragments[curSNIdx + 1];
            // logger.log('find SN matching with pos:' +  bufferEnd + ':' + frag.sn);
            if (fragPrevious && frag.sn === fragPrevious.sn) {
                if (sameLevel && !frag.backtracked) {
                    if (frag.sn < levelDetails.endSN) {
                        var deltaPTS = fragPrevious.deltaPTS;
                        // if there is a significant delta between audio and video, larger than max allowed hole,
                        // and if previous remuxed fragment did not start with a keyframe. (fragPrevious.dropped)
                        // let's try to load previous fragment again to get last keyframe
                        // then we will reload again current fragment (that way we should be able to fill the buffer hole ...)
                        if (deltaPTS && deltaPTS > config.maxBufferHole && fragPrevious.dropped && curSNIdx) {
                            frag = prevFrag;
                            logger_1.logger.warn('SN just loaded, with large PTS gap between audio and video, maybe frag is not starting with a keyframe ? load previous one to try to overcome this');
                        }
                        else {
                            frag = nextFrag;
                            logger_1.logger.log("SN just loaded, load next one: " + frag.sn, frag);
                        }
                    }
                    else {
                        frag = null;
                    }
                }
                else if (frag.backtracked) {
                    // Only backtrack a max of 1 consecutive fragment to prevent sliding back too far when little or no frags start with keyframes
                    if (nextFrag && nextFrag.backtracked) {
                        logger_1.logger.warn("Already backtracked from fragment " + nextFrag.sn + ", will not backtrack to fragment " + frag.sn + ". Loading fragment " + nextFrag.sn);
                        frag = nextFrag;
                    }
                    else {
                        // If a fragment has dropped frames and it's in a same level/sequence, load the previous fragment to try and find the keyframe
                        // Reset the dropped count now since it won't be reset until we parse the fragment again, which prevents infinite backtracking on the same segment
                        logger_1.logger.warn('Loaded fragment with dropped frames, backtracking 1 segment to find a keyframe');
                        frag.dropped = 0;
                        if (prevFrag) {
                            frag = prevFrag;
                            frag.backtracked = true;
                        }
                        else if (curSNIdx) {
                            // can't backtrack on very first fragment
                            frag = null;
                        }
                    }
                }
            }
        }
        return frag;
    };
    StreamController.prototype._loadKey = function (frag) {
        this.state = base_stream_controller_1.State.KEY_LOADING;
        this.hls.trigger(events_1.default.KEY_LOADING, { frag: frag });
    };
    StreamController.prototype._loadFragment = function (frag) {
        // Check if fragment is not loaded
        var fragState = this.fragmentTracker.getState(frag);
        this.fragCurrent = frag;
        this.startFragRequested = true;
        // Don't update nextLoadPosition for fragments which are not buffered
        if (Number.isFinite(frag.sn) && !frag.bitrateTest) {
            this.nextLoadPosition = frag.start + frag.duration;
        }
        // Allow backtracked fragments to load
        if (frag.backtracked || fragState === fragment_tracker_1.FragmentState.NOT_LOADED || fragState === fragment_tracker_1.FragmentState.PARTIAL) {
            frag.autoLevel = this.hls.autoLevelEnabled;
            frag.bitrateTest = this.bitrateTest;
            this.hls.trigger(events_1.default.FRAG_LOADING, { frag: frag });
            // lazy demuxer init, as this could take some time ... do it during frag loading
            if (!this.demuxer) {
                this.demuxer = new demuxer_1.default(this.hls, 'main');
            }
            this.state = base_stream_controller_1.State.FRAG_LOADING;
        }
        else if (fragState === fragment_tracker_1.FragmentState.APPENDING) {
            // Lower the buffer size and try again
            if (this._reduceMaxBufferLength(frag.duration)) {
                this.fragmentTracker.removeFragment(frag);
            }
        }
    };
    Object.defineProperty(StreamController.prototype, "state", {
        get: function () {
            return this._state;
        },
        set: function (nextState) {
            if (this.state !== nextState) {
                var previousState = this.state;
                this._state = nextState;
                logger_1.logger.log("main stream:" + previousState + "->" + nextState);
                this.hls.trigger(events_1.default.STREAM_STATE_TRANSITION, { previousState: previousState, nextState: nextState });
            }
        },
        enumerable: true,
        configurable: true
    });
    StreamController.prototype.getBufferedFrag = function (position) {
        return this.fragmentTracker.getBufferedFrag(position, playlist_loader_1.default.LevelType.MAIN);
    };
    Object.defineProperty(StreamController.prototype, "currentLevel", {
        get: function () {
            var media = this.media;
            if (media) {
                var frag = this.getBufferedFrag(media.currentTime);
                if (frag) {
                    return frag.level;
                }
            }
            return -1;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(StreamController.prototype, "nextBufferedFrag", {
        get: function () {
            var media = this.media;
            if (media) {
                // first get end range of current fragment
                return this.followingBufferedFrag(this.getBufferedFrag(media.currentTime));
            }
            else {
                return null;
            }
        },
        enumerable: true,
        configurable: true
    });
    StreamController.prototype.followingBufferedFrag = function (frag) {
        if (frag) {
            // try to get range of next fragment (500ms after this range)
            return this.getBufferedFrag(frag.endPTS + 0.5);
        }
        return null;
    };
    Object.defineProperty(StreamController.prototype, "nextLevel", {
        get: function () {
            var frag = this.nextBufferedFrag;
            if (frag) {
                return frag.level;
            }
            else {
                return -1;
            }
        },
        enumerable: true,
        configurable: true
    });
    StreamController.prototype._checkFragmentChanged = function () {
        var fragPlayingCurrent, currentTime, video = this.media;
        if (video && video.readyState && video.seeking === false) {
            currentTime = video.currentTime;
            /* if video element is in seeked state, currentTime can only increase.
              (assuming that playback rate is positive ...)
              As sometimes currentTime jumps back to zero after a
              media decode error, check this, to avoid seeking back to
              wrong position after a media decode error
            */
            if (currentTime > this.lastCurrentTime) {
                this.lastCurrentTime = currentTime;
            }
            if (buffer_helper_1.BufferHelper.isBuffered(video, currentTime)) {
                fragPlayingCurrent = this.getBufferedFrag(currentTime);
            }
            else if (buffer_helper_1.BufferHelper.isBuffered(video, currentTime + 0.1)) {
                /* ensure that FRAG_CHANGED event is triggered at startup,
                  when first video frame is displayed and playback is paused.
                  add a tolerance of 100ms, in case current position is not buffered,
                  check if current pos+100ms is buffered and use that buffer range
                  for FRAG_CHANGED event reporting */
                fragPlayingCurrent = this.getBufferedFrag(currentTime + 0.1);
            }
            if (fragPlayingCurrent) {
                var fragPlaying = fragPlayingCurrent;
                if (fragPlaying !== this.fragPlaying) {
                    this.hls.trigger(events_1.default.FRAG_CHANGED, { frag: fragPlaying });
                    var fragPlayingLevel = fragPlaying.level;
                    if (!this.fragPlaying || this.fragPlaying.level !== fragPlayingLevel) {
                        this.hls.trigger(events_1.default.LEVEL_SWITCHED, { level: fragPlayingLevel });
                    }
                    this.fragPlaying = fragPlaying;
                }
            }
        }
    };
    /*
      on immediate level switch :
       - pause playback if playing
       - cancel any pending load request
       - and trigger a buffer flush
    */
    StreamController.prototype.immediateLevelSwitch = function () {
        logger_1.logger.log('immediateLevelSwitch');
        if (!this.immediateSwitch) {
            this.immediateSwitch = true;
            var media = this.media, previouslyPaused = void 0;
            if (media) {
                previouslyPaused = media.paused;
                media.pause();
            }
            else {
                // don't restart playback after instant level switch in case media not attached
                previouslyPaused = true;
            }
            this.previouslyPaused = previouslyPaused;
        }
        var fragCurrent = this.fragCurrent;
        if (fragCurrent && fragCurrent.loader) {
            fragCurrent.loader.abort();
        }
        this.fragCurrent = null;
        // flush everything
        this.flushMainBuffer(0, Number.POSITIVE_INFINITY);
    };
    /**
     * on immediate level switch end, after new fragment has been buffered:
     * - nudge video decoder by slightly adjusting video currentTime (if currentTime buffered)
     * - resume the playback if needed
     */
    StreamController.prototype.immediateLevelSwitchEnd = function () {
        var media = this.media;
        if (media && media.buffered.length) {
            this.immediateSwitch = false;
            if (buffer_helper_1.BufferHelper.isBuffered(media, media.currentTime)) {
                // only nudge if currentTime is buffered
                media.currentTime -= 0.0001;
            }
            if (!this.previouslyPaused) {
                media.play();
            }
        }
    };
    /**
     * try to switch ASAP without breaking video playback:
     * in order to ensure smooth but quick level switching,
     * we need to find the next flushable buffer range
     * we should take into account new segment fetch time
     */
    StreamController.prototype.nextLevelSwitch = function () {
        var media = this.media;
        // ensure that media is defined and that metadata are available (to retrieve currentTime)
        if (media && media.readyState) {
            var fetchdelay = void 0, fragPlayingCurrent = void 0, nextBufferedFrag = void 0;
            fragPlayingCurrent = this.getBufferedFrag(media.currentTime);
            if (fragPlayingCurrent && fragPlayingCurrent.startPTS > 1) {
                // flush buffer preceding current fragment (flush until current fragment start offset)
                // minus 1s to avoid video freezing, that could happen if we flush keyframe of current video ...
                this.flushMainBuffer(0, fragPlayingCurrent.startPTS - 1);
            }
            if (!media.paused) {
                // add a safety delay of 1s
                var nextLevelId = this.hls.nextLoadLevel, nextLevel = this.levels[nextLevelId], fragLastKbps = this.fragLastKbps;
                if (fragLastKbps && this.fragCurrent) {
                    fetchdelay = this.fragCurrent.duration * nextLevel.bitrate / (1000 * fragLastKbps) + 1;
                }
                else {
                    fetchdelay = 0;
                }
            }
            else {
                fetchdelay = 0;
            }
            // logger.log('fetchdelay:'+fetchdelay);
            // find buffer range that will be reached once new fragment will be fetched
            nextBufferedFrag = this.getBufferedFrag(media.currentTime + fetchdelay);
            if (nextBufferedFrag) {
                // we can flush buffer range following this one without stalling playback
                nextBufferedFrag = this.followingBufferedFrag(nextBufferedFrag);
                if (nextBufferedFrag) {
                    // if we are here, we can also cancel any loading/demuxing in progress, as they are useless
                    var fragCurrent = this.fragCurrent;
                    if (fragCurrent && fragCurrent.loader) {
                        fragCurrent.loader.abort();
                    }
                    this.fragCurrent = null;
                    // start flush position is the start PTS of next buffered frag.
                    // we use frag.naxStartPTS which is max(audio startPTS, video startPTS).
                    // in case there is a small PTS Delta between audio and video, using maxStartPTS avoids flushing last samples from current fragment
                    this.flushMainBuffer(nextBufferedFrag.maxStartPTS, Number.POSITIVE_INFINITY);
                }
            }
        }
    };
    StreamController.prototype.flushMainBuffer = function (startOffset, endOffset) {
        this.state = base_stream_controller_1.State.BUFFER_FLUSHING;
        var flushScope = { startOffset: startOffset, endOffset: endOffset };
        // if alternate audio tracks are used, only flush video, otherwise flush everything
        if (this.altAudio) {
            flushScope.type = 'video';
        }
        this.hls.trigger(events_1.default.BUFFER_FLUSHING, flushScope);
    };
    StreamController.prototype.onMediaAttached = function (data) {
        var media = this.media = this.mediaBuffer = data.media;
        this.onvseeking = this.onMediaSeeking.bind(this);
        this.onvseeked = this.onMediaSeeked.bind(this);
        this.onvended = this.onMediaEnded.bind(this);
        media.addEventListener('seeking', this.onvseeking);
        media.addEventListener('seeked', this.onvseeked);
        media.addEventListener('ended', this.onvended);
        var config = this.config;
        if (this.levels && config.autoStartLoad) {
            this.hls.startLoad(config.startPosition);
        }
        this.gapController = new gap_controller_1.default(config, media, this.fragmentTracker, this.hls);
    };
    StreamController.prototype.onMediaDetaching = function () {
        var media = this.media;
        if (media && media.ended) {
            logger_1.logger.log('MSE detaching and video ended, reset startPosition');
            this.startPosition = this.lastCurrentTime = 0;
        }
        // reset fragment backtracked flag
        var levels = this.levels;
        if (levels) {
            levels.forEach(function (level) {
                if (level.details) {
                    level.details.fragments.forEach(function (fragment) {
                        fragment.backtracked = undefined;
                    });
                }
            });
        }
        // remove video listeners
        if (media) {
            media.removeEventListener('seeking', this.onvseeking);
            media.removeEventListener('seeked', this.onvseeked);
            media.removeEventListener('ended', this.onvended);
            this.onvseeking = this.onvseeked = this.onvended = null;
        }
        this.media = this.mediaBuffer = null;
        this.loadedmetadata = false;
        this.stopLoad();
    };
    StreamController.prototype.onMediaSeeked = function () {
        var media = this.media, currentTime = media ? media.currentTime : undefined;
        if (Number.isFinite(currentTime)) {
            logger_1.logger.log("media seeked to " + currentTime.toFixed(3));
        }
        // tick to speed up FRAGMENT_PLAYING triggering
        this.tick();
    };
    StreamController.prototype.onManifestLoading = function () {
        // reset buffer on manifest loading
        logger_1.logger.log('trigger BUFFER_RESET');
        this.hls.trigger(events_1.default.BUFFER_RESET);
        this.fragmentTracker.removeAllFragments();
        this.stalled = false;
        this.startPosition = this.lastCurrentTime = 0;
    };
    StreamController.prototype.onManifestParsed = function (data) {
        var aac = false, heaac = false, codec;
        data.levels.forEach(function (level) {
            // detect if we have different kind of audio codecs used amongst playlists
            codec = level.audioCodec;
            if (codec) {
                if (codec.indexOf('mp4a.40.2') !== -1) {
                    aac = true;
                }
                if (codec.indexOf('mp4a.40.5') !== -1) {
                    heaac = true;
                }
            }
        });
        this.audioCodecSwitch = (aac && heaac);
        if (this.audioCodecSwitch) {
            logger_1.logger.log('both AAC/HE-AAC audio found in levels; declaring level codec as HE-AAC');
        }
        this.levels = data.levels;
        this.startFragRequested = false;
        var config = this.config;
        if (config.autoStartLoad || this.forceStartLoad) {
            this.hls.startLoad(config.startPosition);
        }
    };
    StreamController.prototype.onLevelLoaded = function (data) {
        var newDetails = data.details;
        var newLevelId = data.level;
        var lastLevel = this.levels[this.levelLastLoaded];
        var curLevel = this.levels[newLevelId];
        var duration = newDetails.totalduration;
        var sliding = 0;
        logger_1.logger.log("level " + newLevelId + " loaded [" + newDetails.startSN + "," + newDetails.endSN + "],duration:" + duration);
        if (newDetails.live) {
            var curDetails = curLevel.details;
            if (curDetails && newDetails.fragments.length > 0) {
                // we already have details for that level, merge them
                LevelHelper.mergeDetails(curDetails, newDetails);
                sliding = newDetails.fragments[0].start;
                this.liveSyncPosition = this.computeLivePosition(sliding, curDetails);
                if (newDetails.PTSKnown && Number.isFinite(sliding)) {
                    logger_1.logger.log("live playlist sliding:" + sliding.toFixed(3));
                }
                else {
                    logger_1.logger.log('live playlist - outdated PTS, unknown sliding');
                    discontinuities_1.alignStream(this.fragPrevious, lastLevel, newDetails);
                }
            }
            else {
                logger_1.logger.log('live playlist - first load, unknown sliding');
                newDetails.PTSKnown = false;
                discontinuities_1.alignStream(this.fragPrevious, lastLevel, newDetails);
            }
        }
        else {
            newDetails.PTSKnown = false;
        }
        // override level info
        curLevel.details = newDetails;
        this.levelLastLoaded = newLevelId;
        this.hls.trigger(events_1.default.LEVEL_UPDATED, { details: newDetails, level: newLevelId });
        if (this.startFragRequested === false) {
            // compute start position if set to -1. use it straight away if value is defined
            if (this.startPosition === -1 || this.lastCurrentTime === -1) {
                // first, check if start time offset has been set in playlist, if yes, use this value
                var startTimeOffset = newDetails.startTimeOffset;
                if (Number.isFinite(startTimeOffset)) {
                    if (startTimeOffset < 0) {
                        logger_1.logger.log("negative start time offset " + startTimeOffset + ", count from end of last fragment");
                        startTimeOffset = sliding + duration + startTimeOffset;
                    }
                    logger_1.logger.log("start time offset found in playlist, adjust startPosition to " + startTimeOffset);
                    this.startPosition = startTimeOffset;
                }
                else {
                    // if live playlist, set start position to be fragment N-this.config.liveSyncDurationCount (usually 3)
                    if (newDetails.live) {
                        this.startPosition = this.computeLivePosition(sliding, newDetails);
                        logger_1.logger.log("configure startPosition to " + this.startPosition);
                    }
                    else {
                        this.startPosition = 0;
                    }
                }
                this.lastCurrentTime = this.startPosition;
            }
            this.nextLoadPosition = this.startPosition;
        }
        // only switch batck to IDLE state if we were waiting for level to start downloading a new fragment
        if (this.state === base_stream_controller_1.State.WAITING_LEVEL) {
            this.state = base_stream_controller_1.State.IDLE;
        }
        // trigger handler right now
        this.tick();
    };
    StreamController.prototype.onKeyLoaded = function () {
        if (this.state === base_stream_controller_1.State.KEY_LOADING) {
            this.state = base_stream_controller_1.State.IDLE;
            this.tick();
        }
    };
    StreamController.prototype.onFragLoaded = function (data) {
        var _a = this, fragCurrent = _a.fragCurrent, hls = _a.hls, levels = _a.levels, media = _a.media;
        var fragLoaded = data.frag;
        if (this.state === base_stream_controller_1.State.FRAG_LOADING &&
            fragCurrent &&
            fragLoaded.type === 'main' &&
            fragLoaded.level === fragCurrent.level &&
            fragLoaded.sn === fragCurrent.sn) {
            var stats = data.stats;
            var currentLevel = levels[fragCurrent.level];
            var details = currentLevel.details;
            // reset frag bitrate test in any case after frag loaded event
            // if this frag was loaded to perform a bitrate test AND if hls.nextLoadLevel is greater than 0
            // then this means that we should be able to load a fragment at a higher quality level
            this.bitrateTest = false;
            this.stats = stats;
            logger_1.logger.log("Loaded " + fragCurrent.sn + " of [" + details.startSN + " ," + details.endSN + "],level " + fragCurrent.level);
            if (fragLoaded.bitrateTest && hls.nextLoadLevel) {
                // switch back to IDLE state ... we just loaded a fragment to determine adequate start bitrate and initialize autoswitch algo
                this.state = base_stream_controller_1.State.IDLE;
                this.startFragRequested = false;
                stats.tparsed = stats.tbuffered = window.performance.now();
                hls.trigger(events_1.default.FRAG_BUFFERED, { stats: stats, frag: fragCurrent, id: 'main' });
                this.tick();
            }
            else if (fragLoaded.sn === 'initSegment') {
                this.state = base_stream_controller_1.State.IDLE;
                stats.tparsed = stats.tbuffered = window.performance.now();
                details.initSegment.data = data.payload;
                hls.trigger(events_1.default.FRAG_BUFFERED, { stats: stats, frag: fragCurrent, id: 'main' });
                this.tick();
            }
            else {
                logger_1.logger.log("Parsing " + fragCurrent.sn + " of [" + details.startSN + " ," + details.endSN + "],level " + fragCurrent.level + ", cc " + fragCurrent.cc);
                this.state = base_stream_controller_1.State.PARSING;
                this.pendingBuffering = true;
                this.appended = false;
                // Bitrate test frags are not usually buffered so the fragment tracker ignores them. If Hls.js decides to buffer
                // it (and therefore ends up at this line), then the fragment tracker needs to be manually informed.
                if (fragLoaded.bitrateTest) {
                    fragLoaded.bitrateTest = false;
                    this.fragmentTracker.onFragLoaded({
                        frag: fragLoaded
                    });
                }
                // time Offset is accurate if level PTS is known, or if playlist is not sliding (not live) and if media is not seeking (this is to overcome potential timestamp drifts between playlists and fragments)
                var accurateTimeOffset = !(media && media.seeking) && (details.PTSKnown || !details.live);
                var initSegmentData = details.initSegment ? details.initSegment.data : [];
                var audioCodec = this._getAudioCodec(currentLevel);
                // transmux the MPEG-TS data to ISO-BMFF segments
                var demuxer = this.demuxer = this.demuxer || new demuxer_1.default(this.hls, 'main');
                demuxer.push(data.payload, initSegmentData, audioCodec, currentLevel.videoCodec, fragCurrent, details.totalduration, accurateTimeOffset);
            }
        }
        this.fragLoadError = 0;
    };
    StreamController.prototype.onFragParsingInitSegment = function (data) {
        var fragCurrent = this.fragCurrent;
        var fragNew = data.frag;
        if (fragCurrent &&
            data.id === 'main' &&
            fragNew.sn === fragCurrent.sn &&
            fragNew.level === fragCurrent.level &&
            this.state === base_stream_controller_1.State.PARSING) {
            var tracks = data.tracks, trackName = void 0, track = void 0;
            // if audio track is expected to come from audio stream controller, discard any coming from main
            if (tracks.audio && this.altAudio) {
                delete tracks.audio;
            }
            // include levelCodec in audio and video tracks
            track = tracks.audio;
            if (track) {
                var audioCodec = this.levels[this.level].audioCodec, ua = navigator.userAgent.toLowerCase();
                if (audioCodec && this.audioCodecSwap) {
                    logger_1.logger.log('swapping playlist audio codec');
                    if (audioCodec.indexOf('mp4a.40.5') !== -1) {
                        audioCodec = 'mp4a.40.2';
                    }
                    else {
                        audioCodec = 'mp4a.40.5';
                    }
                }
                // in case AAC and HE-AAC audio codecs are signalled in manifest
                // force HE-AAC , as it seems that most browsers prefers that way,
                // except for mono streams OR on FF
                // these conditions might need to be reviewed ...
                if (this.audioCodecSwitch) {
                    // don't force HE-AAC if mono stream
                    if (track.metadata.channelCount !== 1 &&
                        // don't force HE-AAC if firefox
                        ua.indexOf('firefox') === -1) {
                        audioCodec = 'mp4a.40.5';
                    }
                }
                // HE-AAC is broken on Android, always signal audio codec as AAC even if variant manifest states otherwise
                if (ua.indexOf('android') !== -1 && track.container !== 'audio/mpeg') { // Exclude mpeg audio
                    audioCodec = 'mp4a.40.2';
                    logger_1.logger.log("Android: force audio codec to " + audioCodec);
                }
                track.levelCodec = audioCodec;
                track.id = data.id;
            }
            track = tracks.video;
            if (track) {
                track.levelCodec = this.levels[this.level].videoCodec;
                track.id = data.id;
            }
            this.hls.trigger(events_1.default.BUFFER_CODECS, tracks);
            // loop through tracks that are going to be provided to bufferController
            for (trackName in tracks) {
                track = tracks[trackName];
                logger_1.logger.log("main track:" + trackName + ",container:" + track.container + ",codecs[level/parsed]=[" + track.levelCodec + "/" + track.codec + "]");
                var initSegment = track.initSegment;
                if (initSegment) {
                    this.appended = true;
                    // arm pending Buffering flag before appending a segment
                    this.pendingBuffering = true;
                    this.hls.trigger(events_1.default.BUFFER_APPENDING, { type: trackName, data: initSegment, parent: 'main', content: 'initSegment' });
                }
            }
            // trigger handler right now
            this.tick();
        }
    };
    StreamController.prototype.onFragParsingData = function (data) {
        var _this = this;
        var fragCurrent = this.fragCurrent;
        var fragNew = data.frag;
        if (fragCurrent &&
            data.id === 'main' &&
            fragNew.sn === fragCurrent.sn &&
            fragNew.level === fragCurrent.level &&
            !(data.type === 'audio' && this.altAudio) && // filter out main audio if audio track is loaded through audio stream controller
            this.state === base_stream_controller_1.State.PARSING) {
            var level = this.levels[this.level], frag = fragCurrent;
            if (!Number.isFinite(data.endPTS)) {
                data.endPTS = data.startPTS + fragCurrent.duration;
                data.endDTS = data.startDTS + fragCurrent.duration;
            }
            if (data.hasAudio === true) {
                frag.addElementaryStream(fragment_1.default.ElementaryStreamTypes.AUDIO);
            }
            if (data.hasVideo === true) {
                frag.addElementaryStream(fragment_1.default.ElementaryStreamTypes.VIDEO);
            }
            logger_1.logger.log("Parsed " + data.type + ",PTS:[" + data.startPTS.toFixed(3) + "," + data.endPTS.toFixed(3) + "],DTS:[" + data.startDTS.toFixed(3) + "/" + data.endDTS.toFixed(3) + "],nb:" + data.nb + ",dropped:" + (data.dropped || 0));
            // Detect gaps in a fragment  and try to fix it by finding a keyframe in the previous fragment (see _findFragments)
            if (data.type === 'video') {
                frag.dropped = data.dropped;
                if (frag.dropped) {
                    if (!frag.backtracked) {
                        var levelDetails = level.details;
                        if (levelDetails && frag.sn === levelDetails.startSN) {
                            logger_1.logger.warn('missing video frame(s) on first frag, appending with gap', frag.sn);
                        }
                        else {
                            logger_1.logger.warn('missing video frame(s), backtracking fragment', frag.sn);
                            // Return back to the IDLE state without appending to buffer
                            // Causes findFragments to backtrack a segment and find the keyframe
                            // Audio fragments arriving before video sets the nextLoadPosition, causing _findFragments to skip the backtracked fragment
                            this.fragmentTracker.removeFragment(frag);
                            frag.backtracked = true;
                            this.nextLoadPosition = data.startPTS;
                            this.state = base_stream_controller_1.State.IDLE;
                            this.fragPrevious = frag;
                            this.tick();
                            return;
                        }
                    }
                    else {
                        logger_1.logger.warn('Already backtracked on this fragment, appending with the gap', frag.sn);
                    }
                }
                else {
                    // Only reset the backtracked flag if we've loaded the frag without any dropped frames
                    frag.backtracked = false;
                }
            }
            var drift = LevelHelper.updateFragPTSDTS(level.details, frag, data.startPTS, data.endPTS, data.startDTS, data.endDTS), hls_2 = this.hls;
            hls_2.trigger(events_1.default.LEVEL_PTS_UPDATED, { details: level.details, level: this.level, drift: drift, type: data.type, start: data.startPTS, end: data.endPTS });
            // has remuxer dropped video frames located before first keyframe ?
            [data.data1, data.data2].forEach(function (buffer) {
                // only append in PARSING state (rationale is that an appending error could happen synchronously on first segment appending)
                // in that case it is useless to append following segments
                if (buffer && buffer.length && _this.state === base_stream_controller_1.State.PARSING) {
                    _this.appended = true;
                    // arm pending Buffering flag before appending a segment
                    _this.pendingBuffering = true;
                    hls_2.trigger(events_1.default.BUFFER_APPENDING, { type: data.type, data: buffer, parent: 'main', content: 'data' });
                }
            });
            // trigger handler right now
            this.tick();
        }
    };
    StreamController.prototype.onFragParsed = function (data) {
        var fragCurrent = this.fragCurrent;
        var fragNew = data.frag;
        if (fragCurrent &&
            data.id === 'main' &&
            fragNew.sn === fragCurrent.sn &&
            fragNew.level === fragCurrent.level &&
            this.state === base_stream_controller_1.State.PARSING) {
            this.stats.tparsed = window.performance.now();
            this.state = base_stream_controller_1.State.PARSED;
            this._checkAppendedParsed();
        }
    };
    StreamController.prototype.onAudioTrackSwitching = function (data) {
        // if any URL found on new audio track, it is an alternate audio track
        var altAudio = !!data.url, trackId = data.id;
        // if we switch on main audio, ensure that main fragment scheduling is synced with media.buffered
        // don't do anything if we switch to alt audio: audio stream controller is handling it.
        // we will just have to change buffer scheduling on audioTrackSwitched
        if (!altAudio) {
            if (this.mediaBuffer !== this.media) {
                logger_1.logger.log('switching on main audio, use media.buffered to schedule main fragment loading');
                this.mediaBuffer = this.media;
                var fragCurrent = this.fragCurrent;
                // we need to refill audio buffer from main: cancel any frag loading to speed up audio switch
                if (fragCurrent.loader) {
                    logger_1.logger.log('switching to main audio track, cancel main fragment load');
                    fragCurrent.loader.abort();
                }
                this.fragCurrent = null;
                this.fragPrevious = null;
                // destroy demuxer to force init segment generation (following audio switch)
                if (this.demuxer) {
                    this.demuxer.destroy();
                    this.demuxer = null;
                }
                // switch to IDLE state to load new fragment
                this.state = base_stream_controller_1.State.IDLE;
            }
            var hls_3 = this.hls;
            // switching to main audio, flush all audio and trigger track switched
            hls_3.trigger(events_1.default.BUFFER_FLUSHING, { startOffset: 0, endOffset: Number.POSITIVE_INFINITY, type: 'audio' });
            hls_3.trigger(events_1.default.AUDIO_TRACK_SWITCHED, { id: trackId });
            this.altAudio = false;
        }
    };
    StreamController.prototype.onAudioTrackSwitched = function (data) {
        var trackId = data.id, altAudio = !!this.hls.audioTracks[trackId].url;
        if (altAudio) {
            var videoBuffer = this.videoBuffer;
            // if we switched on alternate audio, ensure that main fragment scheduling is synced with video sourcebuffer buffered
            if (videoBuffer && this.mediaBuffer !== videoBuffer) {
                logger_1.logger.log('switching on alternate audio, use video.buffered to schedule main fragment loading');
                this.mediaBuffer = videoBuffer;
            }
        }
        this.altAudio = altAudio;
        this.tick();
    };
    StreamController.prototype.onBufferCreated = function (data) {
        var tracks = data.tracks, mediaTrack, name, alternate = false;
        for (var type in tracks) {
            var track = tracks[type];
            if (track.id === 'main') {
                name = type;
                mediaTrack = track;
                // keep video source buffer reference
                if (type === 'video') {
                    this.videoBuffer = tracks[type].buffer;
                }
            }
            else {
                alternate = true;
            }
        }
        if (alternate && mediaTrack) {
            logger_1.logger.log("alternate track found, use " + name + ".buffered to schedule main fragment loading");
            this.mediaBuffer = mediaTrack.buffer;
        }
        else {
            this.mediaBuffer = this.media;
        }
    };
    StreamController.prototype.onBufferAppended = function (data) {
        if (data.parent === 'main') {
            var state = this.state;
            if (state === base_stream_controller_1.State.PARSING || state === base_stream_controller_1.State.PARSED) {
                // check if all buffers have been appended
                this.pendingBuffering = (data.pending > 0);
                this._checkAppendedParsed();
            }
        }
    };
    StreamController.prototype._checkAppendedParsed = function () {
        // trigger handler right now
        if (this.state === base_stream_controller_1.State.PARSED && (!this.appended || !this.pendingBuffering)) {
            var frag = this.fragCurrent;
            if (frag) {
                var media = this.mediaBuffer ? this.mediaBuffer : this.media;
                logger_1.logger.log("main buffered : " + time_ranges_1.default.toString(media.buffered));
                this.fragPrevious = frag;
                var stats = this.stats;
                stats.tbuffered = window.performance.now();
                // we should get rid of this.fragLastKbps
                this.fragLastKbps = Math.round(8 * stats.total / (stats.tbuffered - stats.tfirst));
                this.hls.trigger(events_1.default.FRAG_BUFFERED, { stats: stats, frag: frag, id: 'main' });
                this.state = base_stream_controller_1.State.IDLE;
            }
            this.tick();
        }
    };
    StreamController.prototype.onError = function (data) {
        var frag = data.frag || this.fragCurrent;
        // don't handle frag error not related to main fragment
        if (frag && frag.type !== 'main') {
            return;
        }
        // 0.5 : tolerance needed as some browsers stalls playback before reaching buffered end
        var mediaBuffered = !!this.media && buffer_helper_1.BufferHelper.isBuffered(this.media, this.media.currentTime) && buffer_helper_1.BufferHelper.isBuffered(this.media, this.media.currentTime + 0.5);
        switch (data.details) {
            case errors_1.ErrorDetails.FRAG_LOAD_ERROR:
            case errors_1.ErrorDetails.FRAG_LOAD_TIMEOUT:
            case errors_1.ErrorDetails.KEY_LOAD_ERROR:
            case errors_1.ErrorDetails.KEY_LOAD_TIMEOUT:
                if (!data.fatal) {
                    // keep retrying until the limit will be reached
                    if ((this.fragLoadError + 1) <= this.config.fragLoadingMaxRetry) {
                        // exponential backoff capped to config.fragLoadingMaxRetryTimeout
                        var delay = Math.min(Math.pow(2, this.fragLoadError) * this.config.fragLoadingRetryDelay, this.config.fragLoadingMaxRetryTimeout);
                        logger_1.logger.warn("mediaController: frag loading failed, retry in " + delay + " ms");
                        this.retryDate = window.performance.now() + delay;
                        // retry loading state
                        // if loadedmetadata is not set, it means that we are emergency switch down on first frag
                        // in that case, reset startFragRequested flag
                        if (!this.loadedmetadata) {
                            this.startFragRequested = false;
                            this.nextLoadPosition = this.startPosition;
                        }
                        this.fragLoadError++;
                        this.state = base_stream_controller_1.State.FRAG_LOADING_WAITING_RETRY;
                    }
                    else {
                        logger_1.logger.error("mediaController: " + data.details + " reaches max retry, redispatch as fatal ...");
                        // switch error to fatal
                        data.fatal = true;
                        this.state = base_stream_controller_1.State.ERROR;
                    }
                }
                break;
            case errors_1.ErrorDetails.LEVEL_LOAD_ERROR:
            case errors_1.ErrorDetails.LEVEL_LOAD_TIMEOUT:
                if (this.state !== base_stream_controller_1.State.ERROR) {
                    if (data.fatal) {
                        // if fatal error, stop processing
                        this.state = base_stream_controller_1.State.ERROR;
                        logger_1.logger.warn("streamController: " + data.details + ",switch to " + this.state + " state ...");
                    }
                    else {
                        // in case of non fatal error while loading level, if level controller is not retrying to load level , switch back to IDLE
                        if (!data.levelRetry && this.state === base_stream_controller_1.State.WAITING_LEVEL) {
                            this.state = base_stream_controller_1.State.IDLE;
                        }
                    }
                }
                break;
            case errors_1.ErrorDetails.BUFFER_FULL_ERROR:
                // if in appending state
                if (data.parent === 'main' && (this.state === base_stream_controller_1.State.PARSING || this.state === base_stream_controller_1.State.PARSED)) {
                    // reduce max buf len if current position is buffered
                    if (mediaBuffered) {
                        this._reduceMaxBufferLength(this.config.maxBufferLength);
                        this.state = base_stream_controller_1.State.IDLE;
                    }
                    else {
                        // current position is not buffered, but browser is still complaining about buffer full error
                        // this happens on IE/Edge, refer to https://github.com/video-dev/hls.js/pull/708
                        // in that case flush the whole buffer to recover
                        logger_1.logger.warn('buffer full error also media.currentTime is not buffered, flush everything');
                        this.fragCurrent = null;
                        // flush everything
                        this.flushMainBuffer(0, Number.POSITIVE_INFINITY);
                    }
                }
                break;
            default:
                break;
        }
    };
    StreamController.prototype._reduceMaxBufferLength = function (minLength) {
        var config = this.config;
        if (config.maxMaxBufferLength >= minLength) {
            // reduce max buffer length as it might be too high. we do this to avoid loop flushing ...
            config.maxMaxBufferLength /= 2;
            logger_1.logger.warn("main:reduce max buffer length to " + config.maxMaxBufferLength + "s");
            return true;
        }
        return false;
    };
    /**
     * Checks the health of the buffer and attempts to resolve playback stalls.
     * @private
     */
    StreamController.prototype._checkBuffer = function () {
        var media = this.media;
        if (!media || media.readyState === 0) {
            // Exit early if we don't have media or if the media hasn't bufferd anything yet (readyState 0)
            return;
        }
        var mediaBuffer = this.mediaBuffer ? this.mediaBuffer : media;
        var buffered = mediaBuffer.buffered;
        if (!this.loadedmetadata && buffered.length) {
            this.loadedmetadata = true;
            this._seekToStartPos();
        }
        else if (this.immediateSwitch) {
            this.immediateLevelSwitchEnd();
        }
        else {
            this.gapController.poll(this.lastCurrentTime, buffered);
        }
    };
    StreamController.prototype.onFragLoadEmergencyAborted = function () {
        this.state = base_stream_controller_1.State.IDLE;
        // if loadedmetadata is not set, it means that we are emergency switch down on first frag
        // in that case, reset startFragRequested flag
        if (!this.loadedmetadata) {
            this.startFragRequested = false;
            this.nextLoadPosition = this.startPosition;
        }
        this.tick();
    };
    StreamController.prototype.onBufferFlushed = function () {
        /* after successful buffer flushing, filter flushed fragments from bufferedFrags
          use mediaBuffered instead of media (so that we will check against video.buffered ranges in case of alt audio track)
        */
        var media = this.mediaBuffer ? this.mediaBuffer : this.media;
        if (media) {
            // filter fragments potentially evicted from buffer. this is to avoid memleak on live streams
            this.fragmentTracker.detectEvictedFragments(fragment_1.default.ElementaryStreamTypes.VIDEO, media.buffered);
        }
        // move to IDLE once flush complete. this should trigger new fragment loading
        this.state = base_stream_controller_1.State.IDLE;
        // reset reference to frag
        this.fragPrevious = null;
    };
    StreamController.prototype.swapAudioCodec = function () {
        this.audioCodecSwap = !this.audioCodecSwap;
    };
    StreamController.prototype.computeLivePosition = function (sliding, levelDetails) {
        var targetLatency = this.config.liveSyncDuration !== undefined ? this.config.liveSyncDuration : this.config.liveSyncDurationCount * levelDetails.targetduration;
        return sliding + Math.max(0, levelDetails.totalduration - targetLatency);
    };
    /**
     * Seeks to the set startPosition if not equal to the mediaElement's current time.
     * @private
     */
    StreamController.prototype._seekToStartPos = function () {
        var media = this.media;
        var currentTime = media.currentTime;
        // only adjust currentTime if different from startPosition or if startPosition not buffered
        // at that stage, there should be only one buffered range, as we reach that code after first fragment has been buffered
        var startPosition = media.seeking ? currentTime : this.startPosition;
        // if currentTime not matching with expected startPosition or startPosition not buffered but close to first buffered
        if (currentTime !== startPosition) {
            // if startPosition not buffered, let's seek to buffered.start(0)
            logger_1.logger.log("target start position not buffered, seek to buffered.start(0) " + startPosition + " from current time " + currentTime + " ");
            media.currentTime = startPosition;
        }
    };
    StreamController.prototype._getAudioCodec = function (currentLevel) {
        var audioCodec = this.config.defaultAudioCodec || currentLevel.audioCodec;
        if (this.audioCodecSwap) {
            logger_1.logger.log('swapping playlist audio codec');
            if (audioCodec) {
                if (audioCodec.indexOf('mp4a.40.5') !== -1) {
                    audioCodec = 'mp4a.40.2';
                }
                else {
                    audioCodec = 'mp4a.40.5';
                }
            }
        }
        return audioCodec;
    };
    Object.defineProperty(StreamController.prototype, "liveSyncPosition", {
        get: function () {
            return this._liveSyncPosition;
        },
        set: function (value) {
            this._liveSyncPosition = value;
        },
        enumerable: true,
        configurable: true
    });
    return StreamController;
}(base_stream_controller_1.default));
exports.default = StreamController;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./src/polyfills/number */ "./src/polyfills/number.js")["Number"]))

/***/ }),

/***/ "./src/controller/subtitle-stream-controller.js":
/*!******************************************************!*\
  !*** ./src/controller/subtitle-stream-controller.js ***!
  \******************************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @class SubtitleStreamController
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var events_1 = __webpack_require__(/*! ../events */ "./src/events.js");
var logger_1 = __webpack_require__(/*! ../utils/logger */ "./src/utils/logger.js");
var decrypter_1 = __webpack_require__(/*! ../crypt/decrypter */ "./src/crypt/decrypter.js");
var buffer_helper_1 = __webpack_require__(/*! ../utils/buffer-helper */ "./src/utils/buffer-helper.js");
var fragment_finders_1 = __webpack_require__(/*! ./fragment-finders */ "./src/controller/fragment-finders.js");
var fragment_tracker_1 = __webpack_require__(/*! ./fragment-tracker */ "./src/controller/fragment-tracker.js");
var base_stream_controller_1 = __webpack_require__(/*! ./base-stream-controller */ "./src/controller/base-stream-controller.js");
var level_helper_1 = __webpack_require__(/*! ./level-helper */ "./src/controller/level-helper.js");
var performance = window.performance;
var TICK_INTERVAL = 500; // how often to tick in ms
var SubtitleStreamController = /** @class */ (function (_super) {
    __extends(SubtitleStreamController, _super);
    function SubtitleStreamController(hls, fragmentTracker) {
        var _this = _super.call(this, hls, events_1.default.MEDIA_ATTACHED, events_1.default.MEDIA_DETACHING, events_1.default.ERROR, events_1.default.KEY_LOADED, events_1.default.FRAG_LOADED, events_1.default.SUBTITLE_TRACKS_UPDATED, events_1.default.SUBTITLE_TRACK_SWITCH, events_1.default.SUBTITLE_TRACK_LOADED, events_1.default.SUBTITLE_FRAG_PROCESSED, events_1.default.LEVEL_UPDATED) || this;
        _this.fragmentTracker = fragmentTracker;
        _this.config = hls.config;
        _this.state = base_stream_controller_1.State.STOPPED;
        _this.tracks = [];
        _this.tracksBuffered = [];
        _this.currentTrackId = -1;
        _this.decrypter = new decrypter_1.default(hls, hls.config);
        // lastAVStart stores the time in seconds for the start time of a level load
        _this.lastAVStart = 0;
        _this._onMediaSeeking = _this.onMediaSeeking.bind(_this);
        return _this;
    }
    SubtitleStreamController.prototype.onSubtitleFragProcessed = function (data) {
        var frag = data.frag, success = data.success;
        this.fragPrevious = frag;
        this.state = base_stream_controller_1.State.IDLE;
        if (!success) {
            return;
        }
        var buffered = this.tracksBuffered[this.currentTrackId];
        if (!buffered) {
            return;
        }
        // Create/update a buffered array matching the interface used by BufferHelper.bufferedInfo
        // so we can re-use the logic used to detect how much have been buffered
        var timeRange;
        var fragStart = frag.start;
        for (var i = 0; i < buffered.length; i++) {
            if (fragStart >= buffered[i].start && fragStart <= buffered[i].end) {
                timeRange = buffered[i];
                break;
            }
        }
        var fragEnd = frag.start + frag.duration;
        if (timeRange) {
            timeRange.end = fragEnd;
        }
        else {
            timeRange = {
                start: fragStart,
                end: fragEnd
            };
            buffered.push(timeRange);
        }
    };
    SubtitleStreamController.prototype.onMediaAttached = function (_a) {
        var media = _a.media;
        this.media = media;
        media.addEventListener('seeking', this._onMediaSeeking);
        this.state = base_stream_controller_1.State.IDLE;
    };
    SubtitleStreamController.prototype.onMediaDetaching = function () {
        this.media.removeEventListener('seeking', this._onMediaSeeking);
        this.media = null;
        this.state = base_stream_controller_1.State.STOPPED;
    };
    // If something goes wrong, proceed to next frag, if we were processing one.
    SubtitleStreamController.prototype.onError = function (data) {
        var frag = data.frag;
        // don't handle error not related to subtitle fragment
        if (!frag || frag.type !== 'subtitle') {
            return;
        }
        this.state = base_stream_controller_1.State.IDLE;
    };
    // Got all new subtitle tracks.
    SubtitleStreamController.prototype.onSubtitleTracksUpdated = function (data) {
        var _this = this;
        logger_1.logger.log('subtitle tracks updated');
        this.tracksBuffered = [];
        this.tracks = data.subtitleTracks;
        this.tracks.forEach(function (track) {
            _this.tracksBuffered[track.id] = [];
        });
    };
    SubtitleStreamController.prototype.onSubtitleTrackSwitch = function (data) {
        this.currentTrackId = data.id;
        if (!this.tracks || this.currentTrackId === -1) {
            this.clearInterval();
            return;
        }
        // Check if track has the necessary details to load fragments
        var currentTrack = this.tracks[this.currentTrackId];
        if (currentTrack && currentTrack.details) {
            this.setInterval(TICK_INTERVAL);
        }
    };
    // Got a new set of subtitle fragments.
    SubtitleStreamController.prototype.onSubtitleTrackLoaded = function (data) {
        var id = data.id, details = data.details;
        var _a = this, currentTrackId = _a.currentTrackId, tracks = _a.tracks;
        var currentTrack = tracks[currentTrackId];
        if (id >= tracks.length || id !== currentTrackId || !currentTrack) {
            return;
        }
        if (details.live) {
            level_helper_1.mergeSubtitlePlaylists(currentTrack.details, details, this.lastAVStart);
        }
        currentTrack.details = details;
        this.setInterval(TICK_INTERVAL);
    };
    SubtitleStreamController.prototype.onKeyLoaded = function () {
        if (this.state === base_stream_controller_1.State.KEY_LOADING) {
            this.state = base_stream_controller_1.State.IDLE;
        }
    };
    SubtitleStreamController.prototype.onFragLoaded = function (data) {
        var fragCurrent = this.fragCurrent;
        var decryptData = data.frag.decryptdata;
        var fragLoaded = data.frag;
        var hls = this.hls;
        if (this.state === base_stream_controller_1.State.FRAG_LOADING &&
            fragCurrent &&
            data.frag.type === 'subtitle' &&
            fragCurrent.sn === data.frag.sn) {
            // check to see if the payload needs to be decrypted
            if (data.payload.byteLength > 0 && (decryptData && decryptData.key && decryptData.method === 'AES-128')) {
                var startTime_1 = performance.now();
                // decrypt the subtitles
                this.decrypter.decrypt(data.payload, decryptData.key.buffer, decryptData.iv.buffer, function (decryptedData) {
                    var endTime = performance.now();
                    hls.trigger(events_1.default.FRAG_DECRYPTED, { frag: fragLoaded, payload: decryptedData, stats: { tstart: startTime_1, tdecrypt: endTime } });
                });
            }
        }
    };
    SubtitleStreamController.prototype.onLevelUpdated = function (_a) {
        var details = _a.details;
        var frags = details.fragments;
        this.lastAVStart = frags.length ? frags[0].start : 0;
    };
    SubtitleStreamController.prototype.doTick = function () {
        if (!this.media) {
            this.state = base_stream_controller_1.State.IDLE;
            return;
        }
        switch (this.state) {
            case base_stream_controller_1.State.IDLE: {
                var _a = this, config = _a.config, currentTrackId = _a.currentTrackId, fragmentTracker = _a.fragmentTracker, media = _a.media, tracks = _a.tracks;
                if (!tracks || !tracks[currentTrackId] || !tracks[currentTrackId].details) {
                    break;
                }
                var maxBufferHole = config.maxBufferHole, maxFragLookUpTolerance = config.maxFragLookUpTolerance;
                var maxConfigBuffer = Math.min(config.maxBufferLength, config.maxMaxBufferLength);
                var bufferedInfo = buffer_helper_1.BufferHelper.bufferedInfo(this._getBuffered(), media.currentTime, maxBufferHole);
                var bufferEnd = bufferedInfo.end, bufferLen = bufferedInfo.len;
                var trackDetails = tracks[currentTrackId].details;
                var fragments = trackDetails.fragments;
                var fragLen = fragments.length;
                var end = fragments[fragLen - 1].start + fragments[fragLen - 1].duration;
                if (bufferLen > maxConfigBuffer) {
                    return;
                }
                var foundFrag = void 0;
                var fragPrevious = this.fragPrevious;
                if (bufferEnd < end) {
                    if (fragPrevious && trackDetails.hasProgramDateTime) {
                        foundFrag = fragment_finders_1.findFragmentByPDT(fragments, fragPrevious.endProgramDateTime, maxFragLookUpTolerance);
                    }
                    if (!foundFrag) {
                        foundFrag = fragment_finders_1.findFragmentByPTS(fragPrevious, fragments, bufferEnd, maxFragLookUpTolerance);
                    }
                }
                else {
                    foundFrag = fragments[fragLen - 1];
                }
                if (foundFrag && foundFrag.encrypted) {
                    logger_1.logger.log("Loading key for " + foundFrag.sn);
                    this.state = base_stream_controller_1.State.KEY_LOADING;
                    this.hls.trigger(events_1.default.KEY_LOADING, { frag: foundFrag });
                }
                else if (foundFrag && fragmentTracker.getState(foundFrag) === fragment_tracker_1.FragmentState.NOT_LOADED) {
                    // only load if fragment is not loaded
                    this.fragCurrent = foundFrag;
                    this.state = base_stream_controller_1.State.FRAG_LOADING;
                    this.hls.trigger(events_1.default.FRAG_LOADING, { frag: foundFrag });
                }
            }
        }
    };
    SubtitleStreamController.prototype.stopLoad = function () {
        this.lastAVStart = 0;
        _super.prototype.stopLoad.call(this);
    };
    SubtitleStreamController.prototype._getBuffered = function () {
        return this.tracksBuffered[this.currentTrackId] || [];
    };
    SubtitleStreamController.prototype.onMediaSeeking = function () {
        this.fragPrevious = null;
    };
    return SubtitleStreamController;
}(base_stream_controller_1.default));
exports.SubtitleStreamController = SubtitleStreamController;


/***/ }),

/***/ "./src/controller/subtitle-track-controller.js":
/*!*****************************************************!*\
  !*** ./src/controller/subtitle-track-controller.js ***!
  \*****************************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Number) {
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var events_1 = __webpack_require__(/*! ../events */ "./src/events.js");
var event_handler_1 = __webpack_require__(/*! ../event-handler */ "./src/event-handler.js");
var logger_1 = __webpack_require__(/*! ../utils/logger */ "./src/utils/logger.js");
var level_helper_1 = __webpack_require__(/*! ./level-helper */ "./src/controller/level-helper.js");
var SubtitleTrackController = /** @class */ (function (_super) {
    __extends(SubtitleTrackController, _super);
    function SubtitleTrackController(hls) {
        var _this = _super.call(this, hls, events_1.default.MEDIA_ATTACHED, events_1.default.MEDIA_DETACHING, events_1.default.MANIFEST_LOADED, events_1.default.SUBTITLE_TRACK_LOADED) || this;
        _this.tracks = [];
        _this.trackId = -1;
        _this.media = null;
        _this.stopped = true;
        /**
         * @member {boolean} subtitleDisplay Enable/disable subtitle display rendering
         */
        _this.subtitleDisplay = true;
        return _this;
    }
    SubtitleTrackController.prototype.destroy = function () {
        event_handler_1.default.prototype.destroy.call(this);
    };
    // Listen for subtitle track change, then extract the current track ID.
    SubtitleTrackController.prototype.onMediaAttached = function (data) {
        var _this = this;
        this.media = data.media;
        if (!this.media) {
            return;
        }
        if (this.queuedDefaultTrack) {
            this.subtitleTrack = this.queuedDefaultTrack;
            delete this.queuedDefaultTrack;
        }
        this.trackChangeListener = this._onTextTracksChanged.bind(this);
        this.useTextTrackPolling = !(this.media.textTracks && 'onchange' in this.media.textTracks);
        if (this.useTextTrackPolling) {
            this.subtitlePollingInterval = setInterval(function () {
                _this.trackChangeListener();
            }, 500);
        }
        else {
            this.media.textTracks.addEventListener('change', this.trackChangeListener);
        }
    };
    SubtitleTrackController.prototype.onMediaDetaching = function () {
        if (!this.media) {
            return;
        }
        if (this.useTextTrackPolling) {
            clearInterval(this.subtitlePollingInterval);
        }
        else {
            this.media.textTracks.removeEventListener('change', this.trackChangeListener);
        }
        this.media = null;
    };
    // Fired whenever a new manifest is loaded.
    SubtitleTrackController.prototype.onManifestLoaded = function (data) {
        var _this = this;
        var tracks = data.subtitles || [];
        this.tracks = tracks;
        this.hls.trigger(events_1.default.SUBTITLE_TRACKS_UPDATED, { subtitleTracks: tracks });
        // loop through available subtitle tracks and autoselect default if needed
        // TODO: improve selection logic to handle forced, etc
        tracks.forEach(function (track) {
            if (track.default) {
                // setting this.subtitleTrack will trigger internal logic
                // if media has not been attached yet, it will fail
                // we keep a reference to the default track id
                // and we'll set subtitleTrack when onMediaAttached is triggered
                if (_this.media) {
                    _this.subtitleTrack = track.id;
                }
                else {
                    _this.queuedDefaultTrack = track.id;
                }
            }
        });
    };
    SubtitleTrackController.prototype.onSubtitleTrackLoaded = function (data) {
        var _this = this;
        var id = data.id, details = data.details;
        var _a = this, trackId = _a.trackId, tracks = _a.tracks;
        var currentTrack = tracks[trackId];
        if (id >= tracks.length || id !== trackId || !currentTrack || this.stopped) {
            this._clearReloadTimer();
            return;
        }
        logger_1.logger.log("subtitle track " + id + " loaded");
        if (details.live) {
            var reloadInterval = level_helper_1.computeReloadInterval(currentTrack.details, details, data.stats.trequest);
            logger_1.logger.log("Reloading live subtitle playlist in " + reloadInterval + "ms");
            this.timer = setTimeout(function () {
                _this._loadCurrentTrack();
            }, reloadInterval);
        }
        else {
            this._clearReloadTimer();
        }
    };
    SubtitleTrackController.prototype.startLoad = function () {
        this.stopped = false;
        this._loadCurrentTrack();
    };
    SubtitleTrackController.prototype.stopLoad = function () {
        this.stopped = true;
        this._clearReloadTimer();
    };
    Object.defineProperty(SubtitleTrackController.prototype, "subtitleTracks", {
        /** get alternate subtitle tracks list from playlist **/
        get: function () {
            return this.tracks;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SubtitleTrackController.prototype, "subtitleTrack", {
        /** get index of the selected subtitle track (index in subtitle track lists) **/
        get: function () {
            return this.trackId;
        },
        /** select a subtitle track, based on its index in subtitle track lists**/
        set: function (subtitleTrackId) {
            if (this.trackId !== subtitleTrackId) {
                this._toggleTrackModes(subtitleTrackId);
                this._setSubtitleTrackInternal(subtitleTrackId);
            }
        },
        enumerable: true,
        configurable: true
    });
    SubtitleTrackController.prototype._clearReloadTimer = function () {
        if (this.timer) {
            clearTimeout(this.timer);
            this.timer = null;
        }
    };
    SubtitleTrackController.prototype._loadCurrentTrack = function () {
        var _a = this, trackId = _a.trackId, tracks = _a.tracks, hls = _a.hls;
        var currentTrack = tracks[trackId];
        if (trackId < 0 || !currentTrack || (currentTrack.details && !currentTrack.details.live)) {
            return;
        }
        logger_1.logger.log("Loading subtitle track " + trackId);
        hls.trigger(events_1.default.SUBTITLE_TRACK_LOADING, { url: currentTrack.url, id: trackId });
    };
    /**
     * Disables the old subtitleTrack and sets current mode on the next subtitleTrack.
     * This operates on the DOM textTracks.
     * A value of -1 will disable all subtitle tracks.
     * @param newId - The id of the next track to enable
     * @private
     */
    SubtitleTrackController.prototype._toggleTrackModes = function (newId) {
        var _a = this, media = _a.media, subtitleDisplay = _a.subtitleDisplay, trackId = _a.trackId;
        if (!media) {
            return;
        }
        var textTracks = filterSubtitleTracks(media.textTracks);
        if (newId === -1) {
            [].slice.call(textTracks).forEach(function (track) {
                track.mode = 'disabled';
            });
        }
        else {
            var oldTrack = textTracks[trackId];
            if (oldTrack) {
                oldTrack.mode = 'disabled';
            }
        }
        var nextTrack = textTracks[newId];
        if (nextTrack) {
            nextTrack.mode = subtitleDisplay ? 'showing' : 'hidden';
        }
    };
    /**
       * This method is responsible for validating the subtitle index and periodically reloading if live.
       * Dispatches the SUBTITLE_TRACK_SWITCH event, which instructs the subtitle-stream-controller to load the selected track.
       * @param newId - The id of the subtitle track to activate.
       */
    SubtitleTrackController.prototype._setSubtitleTrackInternal = function (newId) {
        var _a = this, hls = _a.hls, tracks = _a.tracks;
        if (!Number.isFinite(newId) || newId < -1 || newId >= tracks.length) {
            return;
        }
        this.trackId = newId;
        logger_1.logger.log("Switching to subtitle track " + newId);
        hls.trigger(events_1.default.SUBTITLE_TRACK_SWITCH, { id: newId });
        this._loadCurrentTrack();
    };
    SubtitleTrackController.prototype._onTextTracksChanged = function () {
        // Media is undefined when switching streams via loadSource()
        if (!this.media) {
            return;
        }
        var trackId = -1;
        var tracks = filterSubtitleTracks(this.media.textTracks);
        for (var id = 0; id < tracks.length; id++) {
            if (tracks[id].mode === 'hidden') {
                // Do not break in case there is a following track with showing.
                trackId = id;
            }
            else if (tracks[id].mode === 'showing') {
                trackId = id;
                break;
            }
        }
        // Setting current subtitleTrack will invoke code.
        this.subtitleTrack = trackId;
    };
    return SubtitleTrackController;
}(event_handler_1.default));
function filterSubtitleTracks(textTrackList) {
    var tracks = [];
    for (var i = 0; i < textTrackList.length; i++) {
        var track = textTrackList[i];
        // Edge adds a track without a label; we don't want to use it
        if (track.kind === 'subtitles' && track.label) {
            tracks.push(textTrackList[i]);
        }
    }
    return tracks;
}
exports.default = SubtitleTrackController;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./src/polyfills/number */ "./src/polyfills/number.js")["Number"]))

/***/ }),

/***/ "./src/controller/timeline-controller.js":
/*!***********************************************!*\
  !*** ./src/controller/timeline-controller.js ***!
  \***********************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Number) {
/*
 * Timeline Controller
*/
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var events_1 = __webpack_require__(/*! ../events */ "./src/events.js");
var event_handler_1 = __webpack_require__(/*! ../event-handler */ "./src/event-handler.js");
var cea_608_parser_1 = __webpack_require__(/*! ../utils/cea-608-parser */ "./src/utils/cea-608-parser.js");
var output_filter_1 = __webpack_require__(/*! ../utils/output-filter */ "./src/utils/output-filter.js");
var webvtt_parser_1 = __webpack_require__(/*! ../utils/webvtt-parser */ "./src/utils/webvtt-parser.js");
var logger_1 = __webpack_require__(/*! ../utils/logger */ "./src/utils/logger.js");
var texttrack_utils_1 = __webpack_require__(/*! ../utils/texttrack-utils */ "./src/utils/texttrack-utils.js");
function canReuseVttTextTrack(inUseTrack, manifestTrack) {
    return inUseTrack && inUseTrack.label === manifestTrack.name && !(inUseTrack.textTrack1 || inUseTrack.textTrack2);
}
function intersection(x1, x2, y1, y2) {
    return Math.min(x2, y2) - Math.max(x1, y1);
}
var TimelineController = /** @class */ (function (_super) {
    __extends(TimelineController, _super);
    function TimelineController(hls) {
        var _this = _super.call(this, hls, events_1.default.MEDIA_ATTACHING, events_1.default.MEDIA_DETACHING, events_1.default.FRAG_PARSING_USERDATA, events_1.default.FRAG_DECRYPTED, events_1.default.MANIFEST_LOADING, events_1.default.MANIFEST_LOADED, events_1.default.FRAG_LOADED, events_1.default.LEVEL_SWITCHING, events_1.default.INIT_PTS_FOUND) || this;
        _this.hls = hls;
        _this.config = hls.config;
        _this.enabled = true;
        _this.Cues = hls.config.cueHandler;
        _this.textTracks = [];
        _this.tracks = [];
        _this.unparsedVttFrags = [];
        _this.initPTS = [];
        _this.cueRanges = [];
        _this.captionsTracks = {};
        _this.captionsProperties = {
            textTrack1: {
                label: _this.config.captionsTextTrack1Label,
                languageCode: _this.config.captionsTextTrack1LanguageCode
            },
            textTrack2: {
                label: _this.config.captionsTextTrack2Label,
                languageCode: _this.config.captionsTextTrack2LanguageCode
            }
        };
        if (_this.config.enableCEA708Captions) {
            var channel1 = new output_filter_1.default(_this, 'textTrack1');
            var channel2 = new output_filter_1.default(_this, 'textTrack2');
            _this.cea608Parser = new cea_608_parser_1.default(0, channel1, channel2);
        }
        return _this;
    }
    TimelineController.prototype.addCues = function (trackName, startTime, endTime, screen) {
        // skip cues which overlap more than 50% with previously parsed time ranges
        var ranges = this.cueRanges;
        var merged = false;
        for (var i = ranges.length; i--;) {
            var cueRange = ranges[i];
            var overlap = intersection(cueRange[0], cueRange[1], startTime, endTime);
            if (overlap >= 0) {
                cueRange[0] = Math.min(cueRange[0], startTime);
                cueRange[1] = Math.max(cueRange[1], endTime);
                merged = true;
                if ((overlap / (endTime - startTime)) > 0.5) {
                    return;
                }
            }
        }
        if (!merged) {
            ranges.push([startTime, endTime]);
        }
        this.Cues.newCue(this.captionsTracks[trackName], startTime, endTime, screen);
    };
    // Triggered when an initial PTS is found; used for synchronisation of WebVTT.
    TimelineController.prototype.onInitPtsFound = function (data) {
        var _this = this;
        if (data.id === 'main') {
            this.initPTS[data.frag.cc] = data.initPTS;
        }
        // Due to asynchronous processing, initial PTS may arrive later than the first VTT fragments are loaded.
        // Parse any unparsed fragments upon receiving the initial PTS.
        if (this.unparsedVttFrags.length) {
            var unparsedVttFrags = this.unparsedVttFrags;
            this.unparsedVttFrags = [];
            unparsedVttFrags.forEach(function (frag) {
                _this.onFragLoaded(frag);
            });
        }
    };
    TimelineController.prototype.getExistingTrack = function (trackName) {
        var media = this.media;
        if (media) {
            for (var i = 0; i < media.textTracks.length; i++) {
                var textTrack = media.textTracks[i];
                if (textTrack[trackName]) {
                    return textTrack;
                }
            }
        }
        return null;
    };
    TimelineController.prototype.createCaptionsTrack = function (trackName) {
        var _a = this.captionsProperties[trackName], label = _a.label, languageCode = _a.languageCode;
        var captionsTracks = this.captionsTracks;
        if (!captionsTracks[trackName]) {
            // Enable reuse of existing text track.
            var existingTrack = this.getExistingTrack(trackName);
            if (!existingTrack) {
                var textTrack = this.createTextTrack('captions', label, languageCode);
                if (textTrack) {
                    // Set a special property on the track so we know it's managed by Hls.js
                    textTrack[trackName] = true;
                    captionsTracks[trackName] = textTrack;
                }
            }
            else {
                captionsTracks[trackName] = existingTrack;
                texttrack_utils_1.clearCurrentCues(captionsTracks[trackName]);
                texttrack_utils_1.sendAddTrackEvent(captionsTracks[trackName], this.media);
            }
        }
    };
    TimelineController.prototype.createTextTrack = function (kind, label, lang) {
        var media = this.media;
        if (media) {
            return media.addTextTrack(kind, label, lang);
        }
    };
    TimelineController.prototype.destroy = function () {
        event_handler_1.default.prototype.destroy.call(this);
    };
    TimelineController.prototype.onMediaAttaching = function (data) {
        this.media = data.media;
        this._cleanTracks();
    };
    TimelineController.prototype.onMediaDetaching = function () {
        var captionsTracks = this.captionsTracks;
        Object.keys(captionsTracks).forEach(function (trackName) {
            texttrack_utils_1.clearCurrentCues(captionsTracks[trackName]);
            delete captionsTracks[trackName];
        });
    };
    TimelineController.prototype.onManifestLoading = function () {
        this.lastSn = -1; // Detect discontiguity in fragment parsing
        this.prevCC = -1;
        this.vttCCs = {
            ccOffset: 0,
            presentationOffset: 0,
            0: {
                start: 0, prevCC: -1, new: false
            }
        };
        this._cleanTracks();
    };
    TimelineController.prototype._cleanTracks = function () {
        // clear outdated subtitles
        var media = this.media;
        if (media) {
            var textTracks = media.textTracks;
            if (textTracks) {
                for (var i = 0; i < textTracks.length; i++) {
                    texttrack_utils_1.clearCurrentCues(textTracks[i]);
                }
            }
        }
    };
    TimelineController.prototype.onManifestLoaded = function (data) {
        var _this = this;
        this.textTracks = [];
        this.unparsedVttFrags = this.unparsedVttFrags || [];
        this.initPTS = [];
        this.cueRanges = [];
        if (this.config.enableWebVTT) {
            this.tracks = data.subtitles || [];
            var inUseTracks_1 = this.media ? this.media.textTracks : [];
            this.tracks.forEach(function (track, index) {
                var textTrack;
                if (index < inUseTracks_1.length) {
                    var inUseTrack = null;
                    for (var i = 0; i < inUseTracks_1.length; i++) {
                        if (canReuseVttTextTrack(inUseTracks_1[i], track)) {
                            inUseTrack = inUseTracks_1[i];
                            break;
                        }
                    }
                    // Reuse tracks with the same label, but do not reuse 608/708 tracks
                    if (inUseTrack) {
                        textTrack = inUseTrack;
                    }
                }
                if (!textTrack) {
                    textTrack = _this.createTextTrack('subtitles', track.name, track.lang);
                }
                if (track.default) {
                    textTrack.mode = _this.hls.subtitleDisplay ? 'showing' : 'hidden';
                }
                else {
                    textTrack.mode = 'disabled';
                }
                _this.textTracks.push(textTrack);
            });
        }
    };
    TimelineController.prototype.onLevelSwitching = function () {
        this.enabled = this.hls.currentLevel.closedCaptions !== 'NONE';
    };
    TimelineController.prototype.onFragLoaded = function (data) {
        var frag = data.frag, payload = data.payload;
        if (frag.type === 'main') {
            var sn = frag.sn;
            // if this frag isn't contiguous, clear the parser so cues with bad start/end times aren't added to the textTrack
            if (sn !== this.lastSn + 1) {
                var cea608Parser = this.cea608Parser;
                if (cea608Parser) {
                    cea608Parser.reset();
                }
            }
            this.lastSn = sn;
        } // eslint-disable-line brace-style
        // If fragment is subtitle type, parse as WebVTT.
        else if (frag.type === 'subtitle') {
            if (payload.byteLength) {
                // We need an initial synchronisation PTS. Store fragments as long as none has arrived.
                if (!Number.isFinite(this.initPTS[frag.cc])) {
                    this.unparsedVttFrags.push(data);
                    if (this.initPTS.length) {
                        // finish unsuccessfully, otherwise the subtitle-stream-controller could be blocked from loading new frags.
                        this.hls.trigger(events_1.default.SUBTITLE_FRAG_PROCESSED, { success: false, frag: frag });
                    }
                    return;
                }
                var decryptData = frag.decryptdata;
                // If the subtitles are not encrypted, parse VTTs now. Otherwise, we need to wait.
                if ((decryptData == null) || (decryptData.key == null) || (decryptData.method !== 'AES-128')) {
                    this._parseVTTs(frag, payload);
                }
            }
            else {
                // In case there is no payload, finish unsuccessfully.
                this.hls.trigger(events_1.default.SUBTITLE_FRAG_PROCESSED, { success: false, frag: frag });
            }
        }
    };
    TimelineController.prototype._parseVTTs = function (frag, payload) {
        var vttCCs = this.vttCCs;
        if (!vttCCs[frag.cc]) {
            vttCCs[frag.cc] = { start: frag.start, prevCC: this.prevCC, new: true };
            this.prevCC = frag.cc;
        }
        var textTracks = this.textTracks, hls = this.hls;
        // Parse the WebVTT file contents.
        webvtt_parser_1.default.parse(payload, this.initPTS[frag.cc], vttCCs, frag.cc, function (cues) {
            var currentTrack = textTracks[frag.level];
            // WebVTTParser.parse is an async method and if the currently selected text track mode is set to "disabled"
            // before parsing is done then don't try to access currentTrack.cues.getCueById as cues will be null
            // and trying to access getCueById method of cues will throw an exception
            if (currentTrack.mode === 'disabled') {
                hls.trigger(events_1.default.SUBTITLE_FRAG_PROCESSED, { success: false, frag: frag });
                return;
            }
            // Add cues and trigger event with success true.
            cues.forEach(function (cue) {
                // Sometimes there are cue overlaps on segmented vtts so the same
                // cue can appear more than once in different vtt files.
                // This avoid showing duplicated cues with same timecode and text.
                if (!currentTrack.cues.getCueById(cue.id)) {
                    try {
                        currentTrack.addCue(cue);
                    }
                    catch (err) {
                        var textTrackCue = new window.TextTrackCue(cue.startTime, cue.endTime, cue.text);
                        textTrackCue.id = cue.id;
                        currentTrack.addCue(textTrackCue);
                    }
                }
            });
            hls.trigger(events_1.default.SUBTITLE_FRAG_PROCESSED, { success: true, frag: frag });
        }, function (e) {
            // Something went wrong while parsing. Trigger event with success false.
            logger_1.logger.log("Failed to parse VTT cue: " + e);
            hls.trigger(events_1.default.SUBTITLE_FRAG_PROCESSED, { success: false, frag: frag });
        });
    };
    TimelineController.prototype.onFragDecrypted = function (data) {
        var decryptedData = data.payload, frag = data.frag;
        if (frag.type === 'subtitle') {
            if (!Number.isFinite(this.initPTS[frag.cc])) {
                this.unparsedVttFrags.push(data);
                return;
            }
            this._parseVTTs(frag, decryptedData);
        }
    };
    TimelineController.prototype.onFragParsingUserdata = function (data) {
        // push all of the CEA-708 messages into the interpreter
        // immediately. It will create the proper timestamps based on our PTS value
        if (this.enabled && this.config.enableCEA708Captions) {
            for (var i = 0; i < data.samples.length; i++) {
                var ccdatas = this.extractCea608Data(data.samples[i].bytes);
                this.cea608Parser.addData(data.samples[i].pts, ccdatas);
            }
        }
    };
    TimelineController.prototype.extractCea608Data = function (byteArray) {
        var count = byteArray[0] & 31;
        var position = 2;
        var tmpByte, ccbyte1, ccbyte2, ccValid, ccType;
        var actualCCBytes = [];
        for (var j = 0; j < count; j++) {
            tmpByte = byteArray[position++];
            ccbyte1 = 0x7F & byteArray[position++];
            ccbyte2 = 0x7F & byteArray[position++];
            ccValid = (4 & tmpByte) !== 0;
            ccType = 3 & tmpByte;
            if (ccbyte1 === 0 && ccbyte2 === 0) {
                continue;
            }
            if (ccValid) {
                if (ccType === 0) { // || ccType === 1
                    actualCCBytes.push(ccbyte1);
                    actualCCBytes.push(ccbyte2);
                }
            }
        }
        return actualCCBytes;
    };
    return TimelineController;
}(event_handler_1.default));
exports.default = TimelineController;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./src/polyfills/number */ "./src/polyfills/number.js")["Number"]))

/***/ }),

/***/ "./src/crypt/aes-crypto.js":
/*!*********************************!*\
  !*** ./src/crypt/aes-crypto.js ***!
  \*********************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var AESCrypto = /** @class */ (function () {
    function AESCrypto(subtle, iv) {
        this.subtle = subtle;
        this.aesIV = iv;
    }
    AESCrypto.prototype.decrypt = function (data, key) {
        return this.subtle.decrypt({ name: 'AES-CBC', iv: this.aesIV }, key, data);
    };
    return AESCrypto;
}());
exports.default = AESCrypto;


/***/ }),

/***/ "./src/crypt/aes-decryptor.js":
/*!************************************!*\
  !*** ./src/crypt/aes-decryptor.js ***!
  \************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
// PKCS7
function removePadding(buffer) {
    var outputBytes = buffer.byteLength;
    var paddingBytes = outputBytes && (new DataView(buffer)).getUint8(outputBytes - 1);
    if (paddingBytes) {
        return buffer.slice(0, outputBytes - paddingBytes);
    }
    else {
        return buffer;
    }
}
exports.removePadding = removePadding;
var AESDecryptor = /** @class */ (function () {
    function AESDecryptor() {
        // Static after running initTable
        this.rcon = [0x0, 0x1, 0x2, 0x4, 0x8, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36];
        this.subMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)];
        this.invSubMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)];
        this.sBox = new Uint32Array(256);
        this.invSBox = new Uint32Array(256);
        // Changes during runtime
        this.key = new Uint32Array(0);
        this.initTable();
    }
    // Using view.getUint32() also swaps the byte order.
    AESDecryptor.prototype.uint8ArrayToUint32Array_ = function (arrayBuffer) {
        var view = new DataView(arrayBuffer);
        var newArray = new Uint32Array(4);
        for (var i = 0; i < 4; i++) {
            newArray[i] = view.getUint32(i * 4);
        }
        return newArray;
    };
    AESDecryptor.prototype.initTable = function () {
        var sBox = this.sBox;
        var invSBox = this.invSBox;
        var subMix = this.subMix;
        var subMix0 = subMix[0];
        var subMix1 = subMix[1];
        var subMix2 = subMix[2];
        var subMix3 = subMix[3];
        var invSubMix = this.invSubMix;
        var invSubMix0 = invSubMix[0];
        var invSubMix1 = invSubMix[1];
        var invSubMix2 = invSubMix[2];
        var invSubMix3 = invSubMix[3];
        var d = new Uint32Array(256);
        var x = 0;
        var xi = 0;
        var i = 0;
        for (i = 0; i < 256; i++) {
            if (i < 128) {
                d[i] = i << 1;
            }
            else {
                d[i] = (i << 1) ^ 0x11b;
            }
        }
        for (i = 0; i < 256; i++) {
            var sx = xi ^ (xi << 1) ^ (xi << 2) ^ (xi << 3) ^ (xi << 4);
            sx = (sx >>> 8) ^ (sx & 0xff) ^ 0x63;
            sBox[x] = sx;
            invSBox[sx] = x;
            // Compute multiplication
            var x2 = d[x];
            var x4 = d[x2];
            var x8 = d[x4];
            // Compute sub/invSub bytes, mix columns tables
            var t = (d[sx] * 0x101) ^ (sx * 0x1010100);
            subMix0[x] = (t << 24) | (t >>> 8);
            subMix1[x] = (t << 16) | (t >>> 16);
            subMix2[x] = (t << 8) | (t >>> 24);
            subMix3[x] = t;
            // Compute inv sub bytes, inv mix columns tables
            t = (x8 * 0x1010101) ^ (x4 * 0x10001) ^ (x2 * 0x101) ^ (x * 0x1010100);
            invSubMix0[sx] = (t << 24) | (t >>> 8);
            invSubMix1[sx] = (t << 16) | (t >>> 16);
            invSubMix2[sx] = (t << 8) | (t >>> 24);
            invSubMix3[sx] = t;
            // Compute next counter
            if (!x) {
                x = xi = 1;
            }
            else {
                x = x2 ^ d[d[d[x8 ^ x2]]];
                xi ^= d[d[xi]];
            }
        }
    };
    AESDecryptor.prototype.expandKey = function (keyBuffer) {
        // convert keyBuffer to Uint32Array
        var key = this.uint8ArrayToUint32Array_(keyBuffer);
        var sameKey = true;
        var offset = 0;
        while (offset < key.length && sameKey) {
            sameKey = (key[offset] === this.key[offset]);
            offset++;
        }
        if (sameKey) {
            return;
        }
        this.key = key;
        var keySize = this.keySize = key.length;
        if (keySize !== 4 && keySize !== 6 && keySize !== 8) {
            throw new Error('Invalid aes key size=' + keySize);
        }
        var ksRows = this.ksRows = (keySize + 6 + 1) * 4;
        var ksRow;
        var invKsRow;
        var keySchedule = this.keySchedule = new Uint32Array(ksRows);
        var invKeySchedule = this.invKeySchedule = new Uint32Array(ksRows);
        var sbox = this.sBox;
        var rcon = this.rcon;
        var invSubMix = this.invSubMix;
        var invSubMix0 = invSubMix[0];
        var invSubMix1 = invSubMix[1];
        var invSubMix2 = invSubMix[2];
        var invSubMix3 = invSubMix[3];
        var prev;
        var t;
        for (ksRow = 0; ksRow < ksRows; ksRow++) {
            if (ksRow < keySize) {
                prev = keySchedule[ksRow] = key[ksRow];
                continue;
            }
            t = prev;
            if (ksRow % keySize === 0) {
                // Rot word
                t = (t << 8) | (t >>> 24);
                // Sub word
                t = (sbox[t >>> 24] << 24) | (sbox[(t >>> 16) & 0xff] << 16) | (sbox[(t >>> 8) & 0xff] << 8) | sbox[t & 0xff];
                // Mix Rcon
                t ^= rcon[(ksRow / keySize) | 0] << 24;
            }
            else if (keySize > 6 && ksRow % keySize === 4) {
                // Sub word
                t = (sbox[t >>> 24] << 24) | (sbox[(t >>> 16) & 0xff] << 16) | (sbox[(t >>> 8) & 0xff] << 8) | sbox[t & 0xff];
            }
            keySchedule[ksRow] = prev = (keySchedule[ksRow - keySize] ^ t) >>> 0;
        }
        for (invKsRow = 0; invKsRow < ksRows; invKsRow++) {
            ksRow = ksRows - invKsRow;
            if (invKsRow & 3) {
                t = keySchedule[ksRow];
            }
            else {
                t = keySchedule[ksRow - 4];
            }
            if (invKsRow < 4 || ksRow <= 4) {
                invKeySchedule[invKsRow] = t;
            }
            else {
                invKeySchedule[invKsRow] = invSubMix0[sbox[t >>> 24]] ^ invSubMix1[sbox[(t >>> 16) & 0xff]] ^ invSubMix2[sbox[(t >>> 8) & 0xff]] ^ invSubMix3[sbox[t & 0xff]];
            }
            invKeySchedule[invKsRow] = invKeySchedule[invKsRow] >>> 0;
        }
    };
    // Adding this as a method greatly improves performance.
    AESDecryptor.prototype.networkToHostOrderSwap = function (word) {
        return (word << 24) | ((word & 0xff00) << 8) | ((word & 0xff0000) >> 8) | (word >>> 24);
    };
    AESDecryptor.prototype.decrypt = function (inputArrayBuffer, offset, aesIV, removePKCS7Padding) {
        var nRounds = this.keySize + 6;
        var invKeySchedule = this.invKeySchedule;
        var invSBOX = this.invSBox;
        var invSubMix = this.invSubMix;
        var invSubMix0 = invSubMix[0];
        var invSubMix1 = invSubMix[1];
        var invSubMix2 = invSubMix[2];
        var invSubMix3 = invSubMix[3];
        var initVector = this.uint8ArrayToUint32Array_(aesIV);
        var initVector0 = initVector[0];
        var initVector1 = initVector[1];
        var initVector2 = initVector[2];
        var initVector3 = initVector[3];
        var inputInt32 = new Int32Array(inputArrayBuffer);
        var outputInt32 = new Int32Array(inputInt32.length);
        var t0, t1, t2, t3;
        var s0, s1, s2, s3;
        var inputWords0, inputWords1, inputWords2, inputWords3;
        var ksRow, i;
        var swapWord = this.networkToHostOrderSwap;
        while (offset < inputInt32.length) {
            inputWords0 = swapWord(inputInt32[offset]);
            inputWords1 = swapWord(inputInt32[offset + 1]);
            inputWords2 = swapWord(inputInt32[offset + 2]);
            inputWords3 = swapWord(inputInt32[offset + 3]);
            s0 = inputWords0 ^ invKeySchedule[0];
            s1 = inputWords3 ^ invKeySchedule[1];
            s2 = inputWords2 ^ invKeySchedule[2];
            s3 = inputWords1 ^ invKeySchedule[3];
            ksRow = 4;
            // Iterate through the rounds of decryption
            for (i = 1; i < nRounds; i++) {
                t0 = invSubMix0[s0 >>> 24] ^ invSubMix1[(s1 >> 16) & 0xff] ^ invSubMix2[(s2 >> 8) & 0xff] ^ invSubMix3[s3 & 0xff] ^ invKeySchedule[ksRow];
                t1 = invSubMix0[s1 >>> 24] ^ invSubMix1[(s2 >> 16) & 0xff] ^ invSubMix2[(s3 >> 8) & 0xff] ^ invSubMix3[s0 & 0xff] ^ invKeySchedule[ksRow + 1];
                t2 = invSubMix0[s2 >>> 24] ^ invSubMix1[(s3 >> 16) & 0xff] ^ invSubMix2[(s0 >> 8) & 0xff] ^ invSubMix3[s1 & 0xff] ^ invKeySchedule[ksRow + 2];
                t3 = invSubMix0[s3 >>> 24] ^ invSubMix1[(s0 >> 16) & 0xff] ^ invSubMix2[(s1 >> 8) & 0xff] ^ invSubMix3[s2 & 0xff] ^ invKeySchedule[ksRow + 3];
                // Update state
                s0 = t0;
                s1 = t1;
                s2 = t2;
                s3 = t3;
                ksRow = ksRow + 4;
            }
            // Shift rows, sub bytes, add round key
            t0 = ((invSBOX[s0 >>> 24] << 24) ^ (invSBOX[(s1 >> 16) & 0xff] << 16) ^ (invSBOX[(s2 >> 8) & 0xff] << 8) ^ invSBOX[s3 & 0xff]) ^ invKeySchedule[ksRow];
            t1 = ((invSBOX[s1 >>> 24] << 24) ^ (invSBOX[(s2 >> 16) & 0xff] << 16) ^ (invSBOX[(s3 >> 8) & 0xff] << 8) ^ invSBOX[s0 & 0xff]) ^ invKeySchedule[ksRow + 1];
            t2 = ((invSBOX[s2 >>> 24] << 24) ^ (invSBOX[(s3 >> 16) & 0xff] << 16) ^ (invSBOX[(s0 >> 8) & 0xff] << 8) ^ invSBOX[s1 & 0xff]) ^ invKeySchedule[ksRow + 2];
            t3 = ((invSBOX[s3 >>> 24] << 24) ^ (invSBOX[(s0 >> 16) & 0xff] << 16) ^ (invSBOX[(s1 >> 8) & 0xff] << 8) ^ invSBOX[s2 & 0xff]) ^ invKeySchedule[ksRow + 3];
            ksRow = ksRow + 3;
            // Write
            outputInt32[offset] = swapWord(t0 ^ initVector0);
            outputInt32[offset + 1] = swapWord(t3 ^ initVector1);
            outputInt32[offset + 2] = swapWord(t2 ^ initVector2);
            outputInt32[offset + 3] = swapWord(t1 ^ initVector3);
            // reset initVector to last 4 unsigned int
            initVector0 = inputWords0;
            initVector1 = inputWords1;
            initVector2 = inputWords2;
            initVector3 = inputWords3;
            offset = offset + 4;
        }
        return removePKCS7Padding ? removePadding(outputInt32.buffer) : outputInt32.buffer;
    };
    AESDecryptor.prototype.destroy = function () {
        this.key = undefined;
        this.keySize = undefined;
        this.ksRows = undefined;
        this.sBox = undefined;
        this.invSBox = undefined;
        this.subMix = undefined;
        this.invSubMix = undefined;
        this.keySchedule = undefined;
        this.invKeySchedule = undefined;
        this.rcon = undefined;
    };
    return AESDecryptor;
}());
exports.default = AESDecryptor;


/***/ }),

/***/ "./src/crypt/decrypter.js":
/*!********************************!*\
  !*** ./src/crypt/decrypter.js ***!
  \********************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var aes_crypto_1 = __webpack_require__(/*! ./aes-crypto */ "./src/crypt/aes-crypto.js");
var fast_aes_key_1 = __webpack_require__(/*! ./fast-aes-key */ "./src/crypt/fast-aes-key.js");
var aes_decryptor_1 = __webpack_require__(/*! ./aes-decryptor */ "./src/crypt/aes-decryptor.js");
var errors_1 = __webpack_require__(/*! ../errors */ "./src/errors.js");
var logger_1 = __webpack_require__(/*! ../utils/logger */ "./src/utils/logger.js");
var events_1 = __webpack_require__(/*! ../events */ "./src/events.js");
var get_self_scope_1 = __webpack_require__(/*! ../utils/get-self-scope */ "./src/utils/get-self-scope.js");
// see https://stackoverflow.com/a/11237259/589493
var global = get_self_scope_1.getSelfScope(); // safeguard for code that might run both on worker and main thread
var Decrypter = /** @class */ (function () {
    function Decrypter(observer, config, _a) {
        var _b = (_a === void 0 ? {} : _a).removePKCS7Padding, removePKCS7Padding = _b === void 0 ? true : _b;
        this.logEnabled = true;
        this.observer = observer;
        this.config = config;
        this.removePKCS7Padding = removePKCS7Padding;
        // built in decryptor expects PKCS7 padding
        if (removePKCS7Padding) {
            try {
                var browserCrypto = global.crypto;
                if (browserCrypto) {
                    this.subtle = browserCrypto.subtle || browserCrypto.webkitSubtle;
                }
            }
            catch (e) { }
        }
        this.disableWebCrypto = !this.subtle;
    }
    Decrypter.prototype.isSync = function () {
        return (this.disableWebCrypto && this.config.enableSoftwareAES);
    };
    Decrypter.prototype.decrypt = function (data, key, iv, callback) {
        var _this = this;
        if (this.disableWebCrypto && this.config.enableSoftwareAES) {
            if (this.logEnabled) {
                logger_1.logger.log('JS AES decrypt');
                this.logEnabled = false;
            }
            var decryptor = this.decryptor;
            if (!decryptor) {
                this.decryptor = decryptor = new aes_decryptor_1.default();
            }
            decryptor.expandKey(key);
            callback(decryptor.decrypt(data, 0, iv, this.removePKCS7Padding));
        }
        else {
            if (this.logEnabled) {
                logger_1.logger.log('WebCrypto AES decrypt');
                this.logEnabled = false;
            }
            var subtle_1 = this.subtle;
            if (this.key !== key) {
                this.key = key;
                this.fastAesKey = new fast_aes_key_1.default(subtle_1, key);
            }
            this.fastAesKey.expandKey()
                .then(function (aesKey) {
                // decrypt using web crypto
                var crypto = new aes_crypto_1.default(subtle_1, iv);
                crypto.decrypt(data, aesKey)
                    .catch(function (err) {
                    _this.onWebCryptoError(err, data, key, iv, callback);
                })
                    .then(function (result) {
                    callback(result);
                });
            })
                .catch(function (err) {
                _this.onWebCryptoError(err, data, key, iv, callback);
            });
        }
    };
    Decrypter.prototype.onWebCryptoError = function (err, data, key, iv, callback) {
        if (this.config.enableSoftwareAES) {
            logger_1.logger.log('WebCrypto Error, disable WebCrypto API');
            this.disableWebCrypto = true;
            this.logEnabled = true;
            this.decrypt(data, key, iv, callback);
        }
        else {
            logger_1.logger.error("decrypting error : " + err.message);
            this.observer.trigger(events_1.default.ERROR, { type: errors_1.ErrorTypes.MEDIA_ERROR, details: errors_1.ErrorDetails.FRAG_DECRYPT_ERROR, fatal: true, reason: err.message });
        }
    };
    Decrypter.prototype.destroy = function () {
        var decryptor = this.decryptor;
        if (decryptor) {
            decryptor.destroy();
            this.decryptor = undefined;
        }
    };
    return Decrypter;
}());
exports.default = Decrypter;


/***/ }),

/***/ "./src/crypt/fast-aes-key.js":
/*!***********************************!*\
  !*** ./src/crypt/fast-aes-key.js ***!
  \***********************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var FastAESKey = /** @class */ (function () {
    function FastAESKey(subtle, key) {
        this.subtle = subtle;
        this.key = key;
    }
    FastAESKey.prototype.expandKey = function () {
        return this.subtle.importKey('raw', this.key, { name: 'AES-CBC' }, false, ['encrypt', 'decrypt']);
    };
    return FastAESKey;
}());
exports.default = FastAESKey;


/***/ }),

/***/ "./src/demux/aacdemuxer.js":
/*!*********************************!*\
  !*** ./src/demux/aacdemuxer.js ***!
  \*********************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Number) {
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * AAC demuxer
 */
var ADTS = __webpack_require__(/*! ./adts */ "./src/demux/adts.js");
var logger_1 = __webpack_require__(/*! ../utils/logger */ "./src/utils/logger.js");
var id3_1 = __webpack_require__(/*! ../demux/id3 */ "./src/demux/id3.js");
var AACDemuxer = /** @class */ (function () {
    function AACDemuxer(observer, remuxer, config) {
        this.observer = observer;
        this.config = config;
        this.remuxer = remuxer;
    }
    AACDemuxer.prototype.resetInitSegment = function (initSegment, audioCodec, videoCodec, duration) {
        this._audioTrack = { container: 'audio/adts', type: 'audio', id: 0, sequenceNumber: 0, isAAC: true, samples: [], len: 0, manifestCodec: audioCodec, duration: duration, inputTimeScale: 90000 };
    };
    AACDemuxer.prototype.resetTimeStamp = function () {
    };
    AACDemuxer.probe = function (data) {
        if (!data) {
            return false;
        }
        // Check for the ADTS sync word
        // Look for ADTS header | 1111 1111 | 1111 X00X | where X can be either 0 or 1
        // Layer bits (position 14 and 15) in header should be always 0 for ADTS
        // More info https://wiki.multimedia.cx/index.php?title=ADTS
        var id3Data = id3_1.default.getID3Data(data, 0) || [];
        var offset = id3Data.length;
        for (var length_1 = data.length; offset < length_1; offset++) {
            if (ADTS.probe(data, offset)) {
                logger_1.logger.log('ADTS sync word found !');
                return true;
            }
        }
        return false;
    };
    // feed incoming data to the front of the parsing pipeline
    AACDemuxer.prototype.append = function (data, timeOffset, contiguous, accurateTimeOffset) {
        var track = this._audioTrack;
        var id3Data = id3_1.default.getID3Data(data, 0) || [];
        var timestamp = id3_1.default.getTimeStamp(id3Data);
        var pts = Number.isFinite(timestamp) ? timestamp * 90 : timeOffset * 90000;
        var frameIndex = 0;
        var stamp = pts;
        var length = data.length;
        var offset = id3Data.length;
        var id3Samples = [{ pts: stamp, dts: stamp, data: id3Data }];
        while (offset < length - 1) {
            if (ADTS.isHeader(data, offset) && (offset + 5) < length) {
                ADTS.initTrackConfig(track, this.observer, data, offset, track.manifestCodec);
                var frame = ADTS.appendFrame(track, data, offset, pts, frameIndex);
                if (frame) {
                    offset += frame.length;
                    stamp = frame.sample.pts;
                    frameIndex++;
                }
                else {
                    logger_1.logger.log('Unable to parse AAC frame');
                    break;
                }
            }
            else if (id3_1.default.isHeader(data, offset)) {
                id3Data = id3_1.default.getID3Data(data, offset);
                id3Samples.push({ pts: stamp, dts: stamp, data: id3Data });
                offset += id3Data.length;
            }
            else {
                // nothing found, keep looking
                offset++;
            }
        }
        this.remuxer.remux(track, { samples: [] }, { samples: id3Samples, inputTimeScale: 90000 }, { samples: [] }, timeOffset, contiguous, accurateTimeOffset);
    };
    AACDemuxer.prototype.destroy = function () {
    };
    return AACDemuxer;
}());
exports.default = AACDemuxer;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./src/polyfills/number */ "./src/polyfills/number.js")["Number"]))

/***/ }),

/***/ "./src/demux/adts.js":
/*!***************************!*\
  !*** ./src/demux/adts.js ***!
  \***************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 *  ADTS parser helper
 */
var logger_1 = __webpack_require__(/*! ../utils/logger */ "./src/utils/logger.js");
var errors_1 = __webpack_require__(/*! ../errors */ "./src/errors.js");
var events_1 = __webpack_require__(/*! ../events */ "./src/events.js");
function getAudioConfig(observer, data, offset, audioCodec) {
    var adtsObjectType, // :int
    adtsSampleingIndex, // :int
    adtsExtensionSampleingIndex, // :int
    adtsChanelConfig, // :int
    config, userAgent = navigator.userAgent.toLowerCase(), manifestCodec = audioCodec, adtsSampleingRates = [
        96000, 88200,
        64000, 48000,
        44100, 32000,
        24000, 22050,
        16000, 12000,
        11025, 8000,
        7350
    ];
    // byte 2
    adtsObjectType = ((data[offset + 2] & 0xC0) >>> 6) + 1;
    adtsSampleingIndex = ((data[offset + 2] & 0x3C) >>> 2);
    if (adtsSampleingIndex > adtsSampleingRates.length - 1) {
        observer.trigger(events_1.default.ERROR, { type: errors_1.ErrorTypes.MEDIA_ERROR, details: errors_1.ErrorDetails.FRAG_PARSING_ERROR, fatal: true, reason: "invalid ADTS sampling index:" + adtsSampleingIndex });
        return;
    }
    adtsChanelConfig = ((data[offset + 2] & 0x01) << 2);
    // byte 3
    adtsChanelConfig |= ((data[offset + 3] & 0xC0) >>> 6);
    logger_1.logger.log("manifest codec:" + audioCodec + ",ADTS data:type:" + adtsObjectType + ",sampleingIndex:" + adtsSampleingIndex + "[" + adtsSampleingRates[adtsSampleingIndex] + "Hz],channelConfig:" + adtsChanelConfig);
    // firefox: freq less than 24kHz = AAC SBR (HE-AAC)
    if (/firefox/i.test(userAgent)) {
        if (adtsSampleingIndex >= 6) {
            adtsObjectType = 5;
            config = new Array(4);
            // HE-AAC uses SBR (Spectral Band Replication) , high frequencies are constructed from low frequencies
            // there is a factor 2 between frame sample rate and output sample rate
            // multiply frequency by 2 (see table below, equivalent to substract 3)
            adtsExtensionSampleingIndex = adtsSampleingIndex - 3;
        }
        else {
            adtsObjectType = 2;
            config = new Array(2);
            adtsExtensionSampleingIndex = adtsSampleingIndex;
        }
        // Android : always use AAC
    }
    else if (userAgent.indexOf('android') !== -1) {
        adtsObjectType = 2;
        config = new Array(2);
        adtsExtensionSampleingIndex = adtsSampleingIndex;
    }
    else {
        /*  for other browsers (Chrome/Vivaldi/Opera ...)
            always force audio type to be HE-AAC SBR, as some browsers do not support audio codec switch properly (like Chrome ...)
        */
        adtsObjectType = 5;
        config = new Array(4);
        // if (manifest codec is HE-AAC or HE-AACv2) OR (manifest codec not specified AND frequency less than 24kHz)
        if ((audioCodec && ((audioCodec.indexOf('mp4a.40.29') !== -1) ||
            (audioCodec.indexOf('mp4a.40.5') !== -1))) ||
            (!audioCodec && adtsSampleingIndex >= 6)) {
            // HE-AAC uses SBR (Spectral Band Replication) , high frequencies are constructed from low frequencies
            // there is a factor 2 between frame sample rate and output sample rate
            // multiply frequency by 2 (see table below, equivalent to substract 3)
            adtsExtensionSampleingIndex = adtsSampleingIndex - 3;
        }
        else {
            // if (manifest codec is AAC) AND (frequency less than 24kHz AND nb channel is 1) OR (manifest codec not specified and mono audio)
            // Chrome fails to play back with low frequency AAC LC mono when initialized with HE-AAC.  This is not a problem with stereo.
            if (audioCodec && audioCodec.indexOf('mp4a.40.2') !== -1 && ((adtsSampleingIndex >= 6 && adtsChanelConfig === 1) ||
                /vivaldi/i.test(userAgent)) ||
                (!audioCodec && adtsChanelConfig === 1)) {
                adtsObjectType = 2;
                config = new Array(2);
            }
            adtsExtensionSampleingIndex = adtsSampleingIndex;
        }
    }
    /* refer to http://wiki.multimedia.cx/index.php?title=MPEG-4_Audio#Audio_Specific_Config
        ISO 14496-3 (AAC).pdf - Table 1.13  Syntax of AudioSpecificConfig()
      Audio Profile / Audio Object Type
      0: Null
      1: AAC Main
      2: AAC LC (Low Complexity)
      3: AAC SSR (Scalable Sample Rate)
      4: AAC LTP (Long Term Prediction)
      5: SBR (Spectral Band Replication)
      6: AAC Scalable
     sampling freq
      0: 96000 Hz
      1: 88200 Hz
      2: 64000 Hz
      3: 48000 Hz
      4: 44100 Hz
      5: 32000 Hz
      6: 24000 Hz
      7: 22050 Hz
      8: 16000 Hz
      9: 12000 Hz
      10: 11025 Hz
      11: 8000 Hz
      12: 7350 Hz
      13: Reserved
      14: Reserved
      15: frequency is written explictly
      Channel Configurations
      These are the channel configurations:
      0: Defined in AOT Specifc Config
      1: 1 channel: front-center
      2: 2 channels: front-left, front-right
    */
    // audioObjectType = profile => profile, the MPEG-4 Audio Object Type minus 1
    config[0] = adtsObjectType << 3;
    // samplingFrequencyIndex
    config[0] |= (adtsSampleingIndex & 0x0E) >> 1;
    config[1] |= (adtsSampleingIndex & 0x01) << 7;
    // channelConfiguration
    config[1] |= adtsChanelConfig << 3;
    if (adtsObjectType === 5) {
        // adtsExtensionSampleingIndex
        config[1] |= (adtsExtensionSampleingIndex & 0x0E) >> 1;
        config[2] = (adtsExtensionSampleingIndex & 0x01) << 7;
        // adtsObjectType (force to 2, chrome is checking that object type is less than 5 ???
        //    https://chromium.googlesource.com/chromium/src.git/+/master/media/formats/mp4/aac.cc
        config[2] |= 2 << 2;
        config[3] = 0;
    }
    return { config: config, samplerate: adtsSampleingRates[adtsSampleingIndex], channelCount: adtsChanelConfig, codec: ('mp4a.40.' + adtsObjectType), manifestCodec: manifestCodec };
}
exports.getAudioConfig = getAudioConfig;
function isHeaderPattern(data, offset) {
    return data[offset] === 0xff && (data[offset + 1] & 0xf6) === 0xf0;
}
exports.isHeaderPattern = isHeaderPattern;
function getHeaderLength(data, offset) {
    return (data[offset + 1] & 0x01 ? 7 : 9);
}
exports.getHeaderLength = getHeaderLength;
function getFullFrameLength(data, offset) {
    return ((data[offset + 3] & 0x03) << 11) |
        (data[offset + 4] << 3) |
        ((data[offset + 5] & 0xE0) >>> 5);
}
exports.getFullFrameLength = getFullFrameLength;
function isHeader(data, offset) {
    // Look for ADTS header | 1111 1111 | 1111 X00X | where X can be either 0 or 1
    // Layer bits (position 14 and 15) in header should be always 0 for ADTS
    // More info https://wiki.multimedia.cx/index.php?title=ADTS
    if (offset + 1 < data.length && isHeaderPattern(data, offset)) {
        return true;
    }
    return false;
}
exports.isHeader = isHeader;
function probe(data, offset) {
    // same as isHeader but we also check that ADTS frame follows last ADTS frame
    // or end of data is reached
    if (offset + 1 < data.length && isHeaderPattern(data, offset)) {
        // ADTS header Length
        var headerLength = getHeaderLength(data, offset);
        // ADTS frame Length
        var frameLength = headerLength;
        if (offset + 5 < data.length) {
            frameLength = getFullFrameLength(data, offset);
        }
        var newOffset = offset + frameLength;
        if (newOffset === data.length || (newOffset + 1 < data.length && isHeaderPattern(data, newOffset))) {
            return true;
        }
    }
    return false;
}
exports.probe = probe;
function initTrackConfig(track, observer, data, offset, audioCodec) {
    if (!track.samplerate) {
        var config = getAudioConfig(observer, data, offset, audioCodec);
        track.config = config.config;
        track.samplerate = config.samplerate;
        track.channelCount = config.channelCount;
        track.codec = config.codec;
        track.manifestCodec = config.manifestCodec;
        logger_1.logger.log("parsed codec:" + track.codec + ",rate:" + config.samplerate + ",nb channel:" + config.channelCount);
    }
}
exports.initTrackConfig = initTrackConfig;
function getFrameDuration(samplerate) {
    return 1024 * 90000 / samplerate;
}
exports.getFrameDuration = getFrameDuration;
function parseFrameHeader(data, offset, pts, frameIndex, frameDuration) {
    var headerLength, frameLength, stamp;
    var length = data.length;
    // The protection skip bit tells us if we have 2 bytes of CRC data at the end of the ADTS header
    headerLength = getHeaderLength(data, offset);
    // retrieve frame size
    frameLength = getFullFrameLength(data, offset);
    frameLength -= headerLength;
    if ((frameLength > 0) && ((offset + headerLength + frameLength) <= length)) {
        stamp = pts + frameIndex * frameDuration;
        // logger.log(`AAC frame, offset/length/total/pts:${offset+headerLength}/${frameLength}/${data.byteLength}/${(stamp/90).toFixed(0)}`);
        return { headerLength: headerLength, frameLength: frameLength, stamp: stamp };
    }
    return undefined;
}
exports.parseFrameHeader = parseFrameHeader;
function appendFrame(track, data, offset, pts, frameIndex) {
    var frameDuration = getFrameDuration(track.samplerate);
    var header = parseFrameHeader(data, offset, pts, frameIndex, frameDuration);
    if (header) {
        var stamp = header.stamp;
        var headerLength = header.headerLength;
        var frameLength = header.frameLength;
        // logger.log(`AAC frame, offset/length/total/pts:${offset+headerLength}/${frameLength}/${data.byteLength}/${(stamp/90).toFixed(0)}`);
        var aacSample = {
            unit: data.subarray(offset + headerLength, offset + headerLength + frameLength),
            pts: stamp,
            dts: stamp
        };
        track.samples.push(aacSample);
        track.len += frameLength;
        return { sample: aacSample, length: frameLength + headerLength };
    }
    return undefined;
}
exports.appendFrame = appendFrame;


/***/ }),

/***/ "./src/demux/demuxer-inline.js":
/*!*************************************!*\
  !*** ./src/demux/demuxer-inline.js ***!
  \*************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 *
 * inline demuxer: probe fragments and instantiate
 * appropriate demuxer depending on content type (TSDemuxer, AACDemuxer, ...)
 *
 */
Object.defineProperty(exports, "__esModule", { value: true });
var events_1 = __webpack_require__(/*! ../events */ "./src/events.js");
var errors_1 = __webpack_require__(/*! ../errors */ "./src/errors.js");
var decrypter_1 = __webpack_require__(/*! ../crypt/decrypter */ "./src/crypt/decrypter.js");
var aacdemuxer_1 = __webpack_require__(/*! ../demux/aacdemuxer */ "./src/demux/aacdemuxer.js");
var mp4demuxer_1 = __webpack_require__(/*! ../demux/mp4demuxer */ "./src/demux/mp4demuxer.js");
var tsdemuxer_1 = __webpack_require__(/*! ../demux/tsdemuxer */ "./src/demux/tsdemuxer.js");
var mp3demuxer_1 = __webpack_require__(/*! ../demux/mp3demuxer */ "./src/demux/mp3demuxer.js");
var mp4_remuxer_1 = __webpack_require__(/*! ../remux/mp4-remuxer */ "./src/remux/mp4-remuxer.js");
var passthrough_remuxer_1 = __webpack_require__(/*! ../remux/passthrough-remuxer */ "./src/remux/passthrough-remuxer.js");
var get_self_scope_1 = __webpack_require__(/*! ../utils/get-self-scope */ "./src/utils/get-self-scope.js");
var logger_1 = __webpack_require__(/*! ../utils/logger */ "./src/utils/logger.js");
// see https://stackoverflow.com/a/11237259/589493
var global = get_self_scope_1.getSelfScope(); // safeguard for code that might run both on worker and main thread
var now;
// performance.now() not available on WebWorker, at least on Safari Desktop
try {
    now = global.performance.now.bind(global.performance);
}
catch (err) {
    logger_1.logger.debug('Unable to use Performance API on this environment');
    now = global.Date.now;
}
var DemuxerInline = /** @class */ (function () {
    function DemuxerInline(observer, typeSupported, config, vendor) {
        this.observer = observer;
        this.typeSupported = typeSupported;
        this.config = config;
        this.vendor = vendor;
    }
    DemuxerInline.prototype.destroy = function () {
        var demuxer = this.demuxer;
        if (demuxer) {
            demuxer.destroy();
        }
    };
    DemuxerInline.prototype.push = function (data, decryptdata, initSegment, audioCodec, videoCodec, timeOffset, discontinuity, trackSwitch, contiguous, duration, accurateTimeOffset, defaultInitPTS) {
        var _this = this;
        if ((data.byteLength > 0) && (decryptdata != null) && (decryptdata.key != null) && (decryptdata.method === 'AES-128')) {
            var decrypter = this.decrypter;
            if (decrypter == null) {
                decrypter = this.decrypter = new decrypter_1.default(this.observer, this.config);
            }
            var startTime_1 = now();
            decrypter.decrypt(data, decryptdata.key.buffer, decryptdata.iv.buffer, function (decryptedData) {
                var endTime = now();
                _this.observer.trigger(events_1.default.FRAG_DECRYPTED, { stats: { tstart: startTime_1, tdecrypt: endTime } });
                _this.pushDecrypted(new Uint8Array(decryptedData), decryptdata, new Uint8Array(initSegment), audioCodec, videoCodec, timeOffset, discontinuity, trackSwitch, contiguous, duration, accurateTimeOffset, defaultInitPTS);
            });
        }
        else {
            this.pushDecrypted(new Uint8Array(data), decryptdata, new Uint8Array(initSegment), audioCodec, videoCodec, timeOffset, discontinuity, trackSwitch, contiguous, duration, accurateTimeOffset, defaultInitPTS);
        }
    };
    DemuxerInline.prototype.pushDecrypted = function (data, decryptdata, initSegment, audioCodec, videoCodec, timeOffset, discontinuity, trackSwitch, contiguous, duration, accurateTimeOffset, defaultInitPTS) {
        var demuxer = this.demuxer;
        if (!demuxer ||
            // in case of continuity change, or track switch
            // we might switch from content type (AAC container to TS container, or TS to fmp4 for example)
            // so let's check that current demuxer is still valid
            ((discontinuity || trackSwitch) && !this.probe(data))) {
            var observer = this.observer;
            var typeSupported = this.typeSupported;
            var config = this.config;
            // probing order is TS/AAC/MP3/MP4
            var muxConfig = [
                { demux: tsdemuxer_1.default, remux: mp4_remuxer_1.default },
                { demux: mp4demuxer_1.default, remux: passthrough_remuxer_1.default },
                { demux: aacdemuxer_1.default, remux: mp4_remuxer_1.default },
                { demux: mp3demuxer_1.default, remux: mp4_remuxer_1.default }
            ];
            // probe for content type
            for (var i = 0, len = muxConfig.length; i < len; i++) {
                var mux = muxConfig[i];
                var probe = mux.demux.probe;
                if (probe(data)) {
                    var remuxer_1 = this.remuxer = new mux.remux(observer, config, typeSupported, this.vendor);
                    demuxer = new mux.demux(observer, remuxer_1, config, typeSupported);
                    this.probe = probe;
                    break;
                }
            }
            if (!demuxer) {
                observer.trigger(events_1.default.ERROR, { type: errors_1.ErrorTypes.MEDIA_ERROR, details: errors_1.ErrorDetails.FRAG_PARSING_ERROR, fatal: true, reason: 'no demux matching with content found' });
                return;
            }
            this.demuxer = demuxer;
        }
        var remuxer = this.remuxer;
        if (discontinuity || trackSwitch) {
            demuxer.resetInitSegment(initSegment, audioCodec, videoCodec, duration);
            remuxer.resetInitSegment();
        }
        if (discontinuity) {
            demuxer.resetTimeStamp(defaultInitPTS);
            remuxer.resetTimeStamp(defaultInitPTS);
        }
        if (typeof demuxer.setDecryptData === 'function') {
            demuxer.setDecryptData(decryptdata);
        }
        demuxer.append(data, timeOffset, contiguous, accurateTimeOffset);
    };
    return DemuxerInline;
}());
exports.default = DemuxerInline;


/***/ }),

/***/ "./src/demux/demuxer-worker.js":
/*!*************************************!*\
  !*** ./src/demux/demuxer-worker.js ***!
  \*************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/* demuxer web worker.
 *  - listen to worker message, and trigger DemuxerInline upon reception of Fragments.
 *  - provides MP4 Boxes back to main thread using [transferable objects](https://developers.google.com/web/updates/2011/12/Transferable-Objects-Lightning-Fast) in order to minimize message passing overhead.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var demuxer_inline_1 = __webpack_require__(/*! ../demux/demuxer-inline */ "./src/demux/demuxer-inline.js");
var events_1 = __webpack_require__(/*! ../events */ "./src/events.js");
var logger_1 = __webpack_require__(/*! ../utils/logger */ "./src/utils/logger.js");
var events_2 = __webpack_require__(/*! events */ "./node_modules/node-libs-browser/node_modules/events/events.js");
var DemuxerWorker = function (self) {
    // observer setup
    var observer = new events_2.EventEmitter();
    observer.trigger = function trigger(event) {
        var data = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            data[_i - 1] = arguments[_i];
        }
        observer.emit.apply(observer, [event, event].concat(data));
    };
    observer.off = function off(event) {
        var data = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            data[_i - 1] = arguments[_i];
        }
        observer.removeListener.apply(observer, [event].concat(data));
    };
    var forwardMessage = function (ev, data) {
        self.postMessage({ event: ev, data: data });
    };
    self.addEventListener('message', function (ev) {
        var data = ev.data;
        // console.log('demuxer cmd:' + data.cmd);
        switch (data.cmd) {
            case 'init':
                var config = JSON.parse(data.config);
                self.demuxer = new demuxer_inline_1.default(observer, data.typeSupported, config, data.vendor);
                logger_1.enableLogs(config.debug);
                // signal end of worker init
                forwardMessage('init', null);
                break;
            case 'demux':
                self.demuxer.push(data.data, data.decryptdata, data.initSegment, data.audioCodec, data.videoCodec, data.timeOffset, data.discontinuity, data.trackSwitch, data.contiguous, data.duration, data.accurateTimeOffset, data.defaultInitPTS);
                break;
            default:
                break;
        }
    });
    // forward events to main thread
    observer.on(events_1.default.FRAG_DECRYPTED, forwardMessage);
    observer.on(events_1.default.FRAG_PARSING_INIT_SEGMENT, forwardMessage);
    observer.on(events_1.default.FRAG_PARSED, forwardMessage);
    observer.on(events_1.default.ERROR, forwardMessage);
    observer.on(events_1.default.FRAG_PARSING_METADATA, forwardMessage);
    observer.on(events_1.default.FRAG_PARSING_USERDATA, forwardMessage);
    observer.on(events_1.default.INIT_PTS_FOUND, forwardMessage);
    // special case for FRAG_PARSING_DATA: pass data1/data2 as transferable object (no copy)
    observer.on(events_1.default.FRAG_PARSING_DATA, function (ev, data) {
        var transferable = [];
        var message = { event: ev, data: data };
        if (data.data1) {
            message.data1 = data.data1.buffer;
            transferable.push(data.data1.buffer);
            delete data.data1;
        }
        if (data.data2) {
            message.data2 = data.data2.buffer;
            transferable.push(data.data2.buffer);
            delete data.data2;
        }
        self.postMessage(message, transferable);
    });
};
exports.default = DemuxerWorker;


/***/ }),

/***/ "./src/demux/demuxer.js":
/*!******************************!*\
  !*** ./src/demux/demuxer.js ***!
  \******************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Number) {
Object.defineProperty(exports, "__esModule", { value: true });
var work = __webpack_require__(/*! webworkify-webpack */ "./node_modules/webworkify-webpack/index.js");
var events_1 = __webpack_require__(/*! ../events */ "./src/events.js");
var demuxer_inline_1 = __webpack_require__(/*! ../demux/demuxer-inline */ "./src/demux/demuxer-inline.js");
var logger_1 = __webpack_require__(/*! ../utils/logger */ "./src/utils/logger.js");
var errors_1 = __webpack_require__(/*! ../errors */ "./src/errors.js");
var mediasource_helper_1 = __webpack_require__(/*! ../utils/mediasource-helper */ "./src/utils/mediasource-helper.js");
var get_self_scope_1 = __webpack_require__(/*! ../utils/get-self-scope */ "./src/utils/get-self-scope.js");
var observer_1 = __webpack_require__(/*! ../observer */ "./src/observer.js");
// see https://stackoverflow.com/a/11237259/589493
var global = get_self_scope_1.getSelfScope(); // safeguard for code that might run both on worker and main thread
var MediaSource = mediasource_helper_1.getMediaSource();
var Demuxer = /** @class */ (function () {
    function Demuxer(hls, id) {
        var _this = this;
        this.hls = hls;
        this.id = id;
        var observer = this.observer = new observer_1.Observer();
        var config = hls.config;
        var forwardMessage = function (ev, data) {
            data = data || {};
            data.frag = _this.frag;
            data.id = _this.id;
            hls.trigger(ev, data);
        };
        // forward events to main thread
        observer.on(events_1.default.FRAG_DECRYPTED, forwardMessage);
        observer.on(events_1.default.FRAG_PARSING_INIT_SEGMENT, forwardMessage);
        observer.on(events_1.default.FRAG_PARSING_DATA, forwardMessage);
        observer.on(events_1.default.FRAG_PARSED, forwardMessage);
        observer.on(events_1.default.ERROR, forwardMessage);
        observer.on(events_1.default.FRAG_PARSING_METADATA, forwardMessage);
        observer.on(events_1.default.FRAG_PARSING_USERDATA, forwardMessage);
        observer.on(events_1.default.INIT_PTS_FOUND, forwardMessage);
        var typeSupported = {
            mp4: MediaSource.isTypeSupported('video/mp4'),
            mpeg: MediaSource.isTypeSupported('audio/mpeg'),
            mp3: MediaSource.isTypeSupported('audio/mp4; codecs="mp3"')
        };
        // navigator.vendor is not always available in Web Worker
        // refer to https://developer.mozilla.org/en-US/docs/Web/API/WorkerGlobalScope/navigator
        var vendor = navigator.vendor;
        if (config.enableWorker && (typeof (Worker) !== 'undefined')) {
            logger_1.logger.log('demuxing in webworker');
            var w = void 0;
            try {
                w = this.w = work(/*require.resolve*/(/*! ../demux/demuxer-worker.js */ "./src/demux/demuxer-worker.js"));
                this.onwmsg = this.onWorkerMessage.bind(this);
                w.addEventListener('message', this.onwmsg);
                w.onerror = function (event) {
                    hls.trigger(events_1.default.ERROR, { type: errors_1.ErrorTypes.OTHER_ERROR, details: errors_1.ErrorDetails.INTERNAL_EXCEPTION, fatal: true, event: 'demuxerWorker', err: { message: event.message + ' (' + event.filename + ':' + event.lineno + ')' } });
                };
                w.postMessage({ cmd: 'init', typeSupported: typeSupported, vendor: vendor, id: id, config: JSON.stringify(config) });
            }
            catch (err) {
                logger_1.logger.warn('Error in worker:', err);
                logger_1.logger.error('Error while initializing DemuxerWorker, fallback on DemuxerInline');
                if (w) {
                    // revoke the Object URL that was used to create demuxer worker, so as not to leak it
                    global.URL.revokeObjectURL(w.objectURL);
                }
                this.demuxer = new demuxer_inline_1.default(observer, typeSupported, config, vendor);
                this.w = undefined;
            }
        }
        else {
            this.demuxer = new demuxer_inline_1.default(observer, typeSupported, config, vendor);
        }
    }
    Demuxer.prototype.destroy = function () {
        var w = this.w;
        if (w) {
            w.removeEventListener('message', this.onwmsg);
            w.terminate();
            this.w = null;
        }
        else {
            var demuxer = this.demuxer;
            if (demuxer) {
                demuxer.destroy();
                this.demuxer = null;
            }
        }
        var observer = this.observer;
        if (observer) {
            observer.removeAllListeners();
            this.observer = null;
        }
    };
    Demuxer.prototype.push = function (data, initSegment, audioCodec, videoCodec, frag, duration, accurateTimeOffset, defaultInitPTS) {
        var w = this.w;
        var timeOffset = Number.isFinite(frag.startPTS) ? frag.startPTS : frag.start;
        var decryptdata = frag.decryptdata;
        var lastFrag = this.frag;
        var discontinuity = !(lastFrag && (frag.cc === lastFrag.cc));
        var trackSwitch = !(lastFrag && (frag.level === lastFrag.level));
        var nextSN = lastFrag && (frag.sn === (lastFrag.sn + 1));
        var contiguous = !trackSwitch && nextSN;
        if (discontinuity) {
            logger_1.logger.log(this.id + ":discontinuity detected");
        }
        if (trackSwitch) {
            logger_1.logger.log(this.id + ":switch detected");
        }
        this.frag = frag;
        if (w) {
            // post fragment payload as transferable objects for ArrayBuffer (no copy)
            w.postMessage({ cmd: 'demux', data: data, decryptdata: decryptdata, initSegment: initSegment, audioCodec: audioCodec, videoCodec: videoCodec, timeOffset: timeOffset, discontinuity: discontinuity, trackSwitch: trackSwitch, contiguous: contiguous, duration: duration, accurateTimeOffset: accurateTimeOffset, defaultInitPTS: defaultInitPTS }, data instanceof ArrayBuffer ? [data] : []);
        }
        else {
            var demuxer = this.demuxer;
            if (demuxer) {
                demuxer.push(data, decryptdata, initSegment, audioCodec, videoCodec, timeOffset, discontinuity, trackSwitch, contiguous, duration, accurateTimeOffset, defaultInitPTS);
            }
        }
    };
    Demuxer.prototype.onWorkerMessage = function (ev) {
        var data = ev.data, hls = this.hls;
        switch (data.event) {
            case 'init':
                // revoke the Object URL that was used to create demuxer worker, so as not to leak it
                global.URL.revokeObjectURL(this.w.objectURL);
                break;
            // special case for FRAG_PARSING_DATA: data1 and data2 are transferable objects
            case events_1.default.FRAG_PARSING_DATA:
                data.data.data1 = new Uint8Array(data.data1);
                if (data.data2) {
                    data.data.data2 = new Uint8Array(data.data2);
                }
            /* falls through */
            default:
                data.data = data.data || {};
                data.data.frag = this.frag;
                data.data.id = this.id;
                hls.trigger(data.event, data.data);
                break;
        }
    };
    return Demuxer;
}());
exports.default = Demuxer;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./src/polyfills/number */ "./src/polyfills/number.js")["Number"]))

/***/ }),

/***/ "./src/demux/exp-golomb.js":
/*!*********************************!*\
  !*** ./src/demux/exp-golomb.js ***!
  \*********************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Parser for exponential Golomb codes, a variable-bitwidth number encoding scheme used by h264.
*/
Object.defineProperty(exports, "__esModule", { value: true });
var logger_1 = __webpack_require__(/*! ../utils/logger */ "./src/utils/logger.js");
var ExpGolomb = /** @class */ (function () {
    function ExpGolomb(data) {
        this.data = data;
        // the number of bytes left to examine in this.data
        this.bytesAvailable = data.byteLength;
        // the current word being examined
        this.word = 0; // :uint
        // the number of bits left to examine in the current word
        this.bitsAvailable = 0; // :uint
    }
    // ():void
    ExpGolomb.prototype.loadWord = function () {
        var data = this.data, bytesAvailable = this.bytesAvailable, position = data.byteLength - bytesAvailable, workingBytes = new Uint8Array(4), availableBytes = Math.min(4, bytesAvailable);
        if (availableBytes === 0) {
            throw new Error('no bytes available');
        }
        workingBytes.set(data.subarray(position, position + availableBytes));
        this.word = new DataView(workingBytes.buffer).getUint32(0);
        // track the amount of this.data that has been processed
        this.bitsAvailable = availableBytes * 8;
        this.bytesAvailable -= availableBytes;
    };
    // (count:int):void
    ExpGolomb.prototype.skipBits = function (count) {
        var skipBytes; // :int
        if (this.bitsAvailable > count) {
            this.word <<= count;
            this.bitsAvailable -= count;
        }
        else {
            count -= this.bitsAvailable;
            skipBytes = count >> 3;
            count -= (skipBytes >> 3);
            this.bytesAvailable -= skipBytes;
            this.loadWord();
            this.word <<= count;
            this.bitsAvailable -= count;
        }
    };
    // (size:int):uint
    ExpGolomb.prototype.readBits = function (size) {
        var bits = Math.min(this.bitsAvailable, size), // :uint
        valu = this.word >>> (32 - bits); // :uint
        if (size > 32) {
            logger_1.logger.error('Cannot read more than 32 bits at a time');
        }
        this.bitsAvailable -= bits;
        if (this.bitsAvailable > 0) {
            this.word <<= bits;
        }
        else if (this.bytesAvailable > 0) {
            this.loadWord();
        }
        bits = size - bits;
        if (bits > 0 && this.bitsAvailable) {
            return valu << bits | this.readBits(bits);
        }
        else {
            return valu;
        }
    };
    // ():uint
    ExpGolomb.prototype.skipLZ = function () {
        var leadingZeroCount; // :uint
        for (leadingZeroCount = 0; leadingZeroCount < this.bitsAvailable; ++leadingZeroCount) {
            if ((this.word & (0x80000000 >>> leadingZeroCount)) !== 0) {
                // the first bit of working word is 1
                this.word <<= leadingZeroCount;
                this.bitsAvailable -= leadingZeroCount;
                return leadingZeroCount;
            }
        }
        // we exhausted word and still have not found a 1
        this.loadWord();
        return leadingZeroCount + this.skipLZ();
    };
    // ():void
    ExpGolomb.prototype.skipUEG = function () {
        this.skipBits(1 + this.skipLZ());
    };
    // ():void
    ExpGolomb.prototype.skipEG = function () {
        this.skipBits(1 + this.skipLZ());
    };
    // ():uint
    ExpGolomb.prototype.readUEG = function () {
        var clz = this.skipLZ(); // :uint
        return this.readBits(clz + 1) - 1;
    };
    // ():int
    ExpGolomb.prototype.readEG = function () {
        var valu = this.readUEG(); // :int
        if (0x01 & valu) {
            // the number is odd if the low order bit is set
            return (1 + valu) >>> 1; // add 1 to make it even, and divide by 2
        }
        else {
            return -1 * (valu >>> 1); // divide by two then make it negative
        }
    };
    // Some convenience functions
    // :Boolean
    ExpGolomb.prototype.readBoolean = function () {
        return this.readBits(1) === 1;
    };
    // ():int
    ExpGolomb.prototype.readUByte = function () {
        return this.readBits(8);
    };
    // ():int
    ExpGolomb.prototype.readUShort = function () {
        return this.readBits(16);
    };
    // ():int
    ExpGolomb.prototype.readUInt = function () {
        return this.readBits(32);
    };
    /**
     * Advance the ExpGolomb decoder past a scaling list. The scaling
     * list is optionally transmitted as part of a sequence parameter
     * set and is not relevant to transmuxing.
     * @param count {number} the number of entries in this scaling list
     * @see Recommendation ITU-T H.264, Section 7.3.2.1.1.1
     */
    ExpGolomb.prototype.skipScalingList = function (count) {
        var lastScale = 8, nextScale = 8, j, deltaScale;
        for (j = 0; j < count; j++) {
            if (nextScale !== 0) {
                deltaScale = this.readEG();
                nextScale = (lastScale + deltaScale + 256) % 256;
            }
            lastScale = (nextScale === 0) ? lastScale : nextScale;
        }
    };
    /**
     * Read a sequence parameter set and return some interesting video
     * properties. A sequence parameter set is the H264 metadata that
     * describes the properties of upcoming video frames.
     * @param data {Uint8Array} the bytes of a sequence parameter set
     * @return {object} an object with configuration parsed from the
     * sequence parameter set, including the dimensions of the
     * associated video frames.
     */
    ExpGolomb.prototype.readSPS = function () {
        var frameCropLeftOffset = 0, frameCropRightOffset = 0, frameCropTopOffset = 0, frameCropBottomOffset = 0, profileIdc, profileCompat, levelIdc, numRefFramesInPicOrderCntCycle, picWidthInMbsMinus1, picHeightInMapUnitsMinus1, frameMbsOnlyFlag, scalingListCount, i, readUByte = this.readUByte.bind(this), readBits = this.readBits.bind(this), readUEG = this.readUEG.bind(this), readBoolean = this.readBoolean.bind(this), skipBits = this.skipBits.bind(this), skipEG = this.skipEG.bind(this), skipUEG = this.skipUEG.bind(this), skipScalingList = this.skipScalingList.bind(this);
        readUByte();
        profileIdc = readUByte(); // profile_idc
        profileCompat = readBits(5); // constraint_set[0-4]_flag, u(5)
        skipBits(3); // reserved_zero_3bits u(3),
        levelIdc = readUByte(); // level_idc u(8)
        skipUEG(); // seq_parameter_set_id
        // some profiles have more optional data we don't need
        if (profileIdc === 100 ||
            profileIdc === 110 ||
            profileIdc === 122 ||
            profileIdc === 244 ||
            profileIdc === 44 ||
            profileIdc === 83 ||
            profileIdc === 86 ||
            profileIdc === 118 ||
            profileIdc === 128) {
            var chromaFormatIdc = readUEG();
            if (chromaFormatIdc === 3) {
                skipBits(1);
            } // separate_colour_plane_flag
            skipUEG(); // bit_depth_luma_minus8
            skipUEG(); // bit_depth_chroma_minus8
            skipBits(1); // qpprime_y_zero_transform_bypass_flag
            if (readBoolean()) { // seq_scaling_matrix_present_flag
                scalingListCount = (chromaFormatIdc !== 3) ? 8 : 12;
                for (i = 0; i < scalingListCount; i++) {
                    if (readBoolean()) { // seq_scaling_list_present_flag[ i ]
                        if (i < 6) {
                            skipScalingList(16);
                        }
                        else {
                            skipScalingList(64);
                        }
                    }
                }
            }
        }
        skipUEG(); // log2_max_frame_num_minus4
        var picOrderCntType = readUEG();
        if (picOrderCntType === 0) {
            readUEG(); // log2_max_pic_order_cnt_lsb_minus4
        }
        else if (picOrderCntType === 1) {
            skipBits(1); // delta_pic_order_always_zero_flag
            skipEG(); // offset_for_non_ref_pic
            skipEG(); // offset_for_top_to_bottom_field
            numRefFramesInPicOrderCntCycle = readUEG();
            for (i = 0; i < numRefFramesInPicOrderCntCycle; i++) {
                skipEG();
            } // offset_for_ref_frame[ i ]
        }
        skipUEG(); // max_num_ref_frames
        skipBits(1); // gaps_in_frame_num_value_allowed_flag
        picWidthInMbsMinus1 = readUEG();
        picHeightInMapUnitsMinus1 = readUEG();
        frameMbsOnlyFlag = readBits(1);
        if (frameMbsOnlyFlag === 0) {
            skipBits(1);
        } // mb_adaptive_frame_field_flag
        skipBits(1); // direct_8x8_inference_flag
        if (readBoolean()) { // frame_cropping_flag
            frameCropLeftOffset = readUEG();
            frameCropRightOffset = readUEG();
            frameCropTopOffset = readUEG();
            frameCropBottomOffset = readUEG();
        }
        var pixelRatio = [1, 1];
        if (readBoolean()) {
            // vui_parameters_present_flag
            if (readBoolean()) {
                // aspect_ratio_info_present_flag
                var aspectRatioIdc = readUByte();
                switch (aspectRatioIdc) {
                    case 1:
                        pixelRatio = [1, 1];
                        break;
                    case 2:
                        pixelRatio = [12, 11];
                        break;
                    case 3:
                        pixelRatio = [10, 11];
                        break;
                    case 4:
                        pixelRatio = [16, 11];
                        break;
                    case 5:
                        pixelRatio = [40, 33];
                        break;
                    case 6:
                        pixelRatio = [24, 11];
                        break;
                    case 7:
                        pixelRatio = [20, 11];
                        break;
                    case 8:
                        pixelRatio = [32, 11];
                        break;
                    case 9:
                        pixelRatio = [80, 33];
                        break;
                    case 10:
                        pixelRatio = [18, 11];
                        break;
                    case 11:
                        pixelRatio = [15, 11];
                        break;
                    case 12:
                        pixelRatio = [64, 33];
                        break;
                    case 13:
                        pixelRatio = [160, 99];
                        break;
                    case 14:
                        pixelRatio = [4, 3];
                        break;
                    case 15:
                        pixelRatio = [3, 2];
                        break;
                    case 16:
                        pixelRatio = [2, 1];
                        break;
                    case 255: {
                        pixelRatio = [readUByte() << 8 | readUByte(), readUByte() << 8 | readUByte()];
                        break;
                    }
                }
            }
        }
        return {
            width: Math.ceil((((picWidthInMbsMinus1 + 1) * 16) - frameCropLeftOffset * 2 - frameCropRightOffset * 2)),
            height: ((2 - frameMbsOnlyFlag) * (picHeightInMapUnitsMinus1 + 1) * 16) - ((frameMbsOnlyFlag ? 2 : 4) * (frameCropTopOffset + frameCropBottomOffset)),
            pixelRatio: pixelRatio
        };
    };
    ExpGolomb.prototype.readSliceType = function () {
        // skip NALu type
        this.readUByte();
        // discard first_mb_in_slice
        this.readUEG();
        // return slice_type
        return this.readUEG();
    };
    return ExpGolomb;
}());
exports.default = ExpGolomb;


/***/ }),

/***/ "./src/demux/id3.js":
/*!**************************!*\
  !*** ./src/demux/id3.js ***!
  \**************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * ID3 parser
 */
var ID3 = /** @class */ (function () {
    function ID3() {
    }
    /**
     * Returns true if an ID3 header can be found at offset in data
     * @param {Uint8Array} data - The data to search in
     * @param {number} offset - The offset at which to start searching
     * @return {boolean} - True if an ID3 header is found
     */
    ID3.isHeader = function (data, offset) {
        /*
        * http://id3.org/id3v2.3.0
        * [0]     = 'I'
        * [1]     = 'D'
        * [2]     = '3'
        * [3,4]   = {Version}
        * [5]     = {Flags}
        * [6-9]   = {ID3 Size}
        *
        * An ID3v2 tag can be detected with the following pattern:
        *  $49 44 33 yy yy xx zz zz zz zz
        * Where yy is less than $FF, xx is the 'flags' byte and zz is less than $80
        */
        if (offset + 10 <= data.length) {
            // look for 'ID3' identifier
            if (data[offset] === 0x49 && data[offset + 1] === 0x44 && data[offset + 2] === 0x33) {
                // check version is within range
                if (data[offset + 3] < 0xFF && data[offset + 4] < 0xFF) {
                    // check size is within range
                    if (data[offset + 6] < 0x80 && data[offset + 7] < 0x80 && data[offset + 8] < 0x80 && data[offset + 9] < 0x80) {
                        return true;
                    }
                }
            }
        }
        return false;
    };
    /**
     * Returns true if an ID3 footer can be found at offset in data
     * @param {Uint8Array} data - The data to search in
     * @param {number} offset - The offset at which to start searching
     * @return {boolean} - True if an ID3 footer is found
     */
    ID3.isFooter = function (data, offset) {
        /*
        * The footer is a copy of the header, but with a different identifier
        */
        if (offset + 10 <= data.length) {
            // look for '3DI' identifier
            if (data[offset] === 0x33 && data[offset + 1] === 0x44 && data[offset + 2] === 0x49) {
                // check version is within range
                if (data[offset + 3] < 0xFF && data[offset + 4] < 0xFF) {
                    // check size is within range
                    if (data[offset + 6] < 0x80 && data[offset + 7] < 0x80 && data[offset + 8] < 0x80 && data[offset + 9] < 0x80) {
                        return true;
                    }
                }
            }
        }
        return false;
    };
    /**
     * Returns any adjacent ID3 tags found in data starting at offset, as one block of data
     * @param {Uint8Array} data - The data to search in
     * @param {number} offset - The offset at which to start searching
     * @return {Uint8Array} - The block of data containing any ID3 tags found
     */
    ID3.getID3Data = function (data, offset) {
        var front = offset;
        var length = 0;
        while (ID3.isHeader(data, offset)) {
            // ID3 header is 10 bytes
            length += 10;
            var size = ID3._readSize(data, offset + 6);
            length += size;
            if (ID3.isFooter(data, offset + 10)) {
                // ID3 footer is 10 bytes
                length += 10;
            }
            offset += length;
        }
        if (length > 0) {
            return data.subarray(front, front + length);
        }
        return undefined;
    };
    ID3._readSize = function (data, offset) {
        var size = 0;
        size = ((data[offset] & 0x7f) << 21);
        size |= ((data[offset + 1] & 0x7f) << 14);
        size |= ((data[offset + 2] & 0x7f) << 7);
        size |= (data[offset + 3] & 0x7f);
        return size;
    };
    /**
     * Searches for the Elementary Stream timestamp found in the ID3 data chunk
     * @param {Uint8Array} data - Block of data containing one or more ID3 tags
     * @return {number} - The timestamp
     */
    ID3.getTimeStamp = function (data) {
        var frames = ID3.getID3Frames(data);
        for (var i = 0; i < frames.length; i++) {
            var frame = frames[i];
            if (ID3.isTimeStampFrame(frame)) {
                return ID3._readTimeStamp(frame);
            }
        }
        return undefined;
    };
    /**
     * Returns true if the ID3 frame is an Elementary Stream timestamp frame
     * @param {ID3 frame} frame
     */
    ID3.isTimeStampFrame = function (frame) {
        return (frame && frame.key === 'PRIV' && frame.info === 'com.apple.streaming.transportStreamTimestamp');
    };
    ID3._getFrameData = function (data) {
        /*
        Frame ID       $xx xx xx xx (four characters)
        Size           $xx xx xx xx
        Flags          $xx xx
        */
        var type = String.fromCharCode(data[0], data[1], data[2], data[3]);
        var size = ID3._readSize(data, 4);
        // skip frame id, size, and flags
        var offset = 10;
        return { type: type, size: size, data: data.subarray(offset, offset + size) };
    };
    /**
     * Returns an array of ID3 frames found in all the ID3 tags in the id3Data
     * @param {Uint8Array} id3Data - The ID3 data containing one or more ID3 tags
     * @return {ID3 frame[]} - Array of ID3 frame objects
     */
    ID3.getID3Frames = function (id3Data) {
        var offset = 0;
        var frames = [];
        while (ID3.isHeader(id3Data, offset)) {
            var size = ID3._readSize(id3Data, offset + 6);
            // skip past ID3 header
            offset += 10;
            var end = offset + size;
            // loop through frames in the ID3 tag
            while (offset + 8 < end) {
                var frameData = ID3._getFrameData(id3Data.subarray(offset));
                var frame = ID3._decodeFrame(frameData);
                if (frame) {
                    frames.push(frame);
                }
                // skip frame header and frame data
                offset += frameData.size + 10;
            }
            if (ID3.isFooter(id3Data, offset)) {
                offset += 10;
            }
        }
        return frames;
    };
    ID3._decodeFrame = function (frame) {
        if (frame.type === 'PRIV') {
            return ID3._decodePrivFrame(frame);
        }
        else if (frame.type[0] === 'T') {
            return ID3._decodeTextFrame(frame);
        }
        else if (frame.type[0] === 'W') {
            return ID3._decodeURLFrame(frame);
        }
        return undefined;
    };
    ID3._readTimeStamp = function (timeStampFrame) {
        if (timeStampFrame.data.byteLength === 8) {
            var data = new Uint8Array(timeStampFrame.data);
            // timestamp is 33 bit expressed as a big-endian eight-octet number,
            // with the upper 31 bits set to zero.
            var pts33Bit = data[3] & 0x1;
            var timestamp = (data[4] << 23) +
                (data[5] << 15) +
                (data[6] << 7) +
                data[7];
            timestamp /= 45;
            if (pts33Bit) {
                timestamp += 47721858.84;
            } // 2^32 / 90
            return Math.round(timestamp);
        }
        return undefined;
    };
    ID3._decodePrivFrame = function (frame) {
        /*
        Format: <text string>\0<binary data>
        */
        if (frame.size < 2) {
            return undefined;
        }
        var owner = ID3._utf8ArrayToStr(frame.data, true);
        var privateData = new Uint8Array(frame.data.subarray(owner.length + 1));
        return { key: frame.type, info: owner, data: privateData.buffer };
    };
    ID3._decodeTextFrame = function (frame) {
        if (frame.size < 2) {
            return undefined;
        }
        if (frame.type === 'TXXX') {
            /*
            Format:
            [0]   = {Text Encoding}
            [1-?] = {Description}\0{Value}
            */
            var index = 1;
            var description = ID3._utf8ArrayToStr(frame.data.subarray(index));
            index += description.length + 1;
            var value = ID3._utf8ArrayToStr(frame.data.subarray(index));
            return { key: frame.type, info: description, data: value };
        }
        else {
            /*
            Format:
            [0]   = {Text Encoding}
            [1-?] = {Value}
            */
            var text = ID3._utf8ArrayToStr(frame.data.subarray(1));
            return { key: frame.type, data: text };
        }
    };
    ID3._decodeURLFrame = function (frame) {
        if (frame.type === 'WXXX') {
            /*
            Format:
            [0]   = {Text Encoding}
            [1-?] = {Description}\0{URL}
            */
            if (frame.size < 2) {
                return undefined;
            }
            var index = 1;
            var description = ID3._utf8ArrayToStr(frame.data.subarray(index));
            index += description.length + 1;
            var value = ID3._utf8ArrayToStr(frame.data.subarray(index));
            return { key: frame.type, info: description, data: value };
        }
        else {
            /*
            Format:
            [0-?] = {URL}
            */
            var url = ID3._utf8ArrayToStr(frame.data);
            return { key: frame.type, data: url };
        }
    };
    // http://stackoverflow.com/questions/8936984/uint8array-to-string-in-javascript/22373197
    // http://www.onicos.com/staff/iz/amuse/javascript/expert/utf.txt
    /* utf.js - UTF-8 <=> UTF-16 convertion
     *
     * Copyright (C) 1999 Masanao Izumo <iz@onicos.co.jp>
     * Version: 1.0
     * LastModified: Dec 25 1999
     * This library is free.  You can redistribute it and/or modify it.
     */
    ID3._utf8ArrayToStr = function (array, exitOnNull) {
        if (exitOnNull === void 0) { exitOnNull = false; }
        var len = array.length;
        var c;
        var char2;
        var char3;
        var out = '';
        var i = 0;
        while (i < len) {
            c = array[i++];
            if (c === 0x00 && exitOnNull) {
                return out;
            }
            else if (c === 0x00 || c === 0x03) {
                // If the character is 3 (END_OF_TEXT) or 0 (NULL) then skip it
                continue;
            }
            switch (c >> 4) {
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                    // 0xxxxxxx
                    out += String.fromCharCode(c);
                    break;
                case 12:
                case 13:
                    // 110x xxxx   10xx xxxx
                    char2 = array[i++];
                    out += String.fromCharCode(((c & 0x1F) << 6) | (char2 & 0x3F));
                    break;
                case 14:
                    // 1110 xxxx  10xx xxxx  10xx xxxx
                    char2 = array[i++];
                    char3 = array[i++];
                    out += String.fromCharCode(((c & 0x0F) << 12) |
                        ((char2 & 0x3F) << 6) |
                        ((char3 & 0x3F) << 0));
                    break;
                default:
            }
        }
        return out;
    };
    return ID3;
}());
var utf8ArrayToStr = ID3._utf8ArrayToStr;
exports.utf8ArrayToStr = utf8ArrayToStr;
exports.default = ID3;


/***/ }),

/***/ "./src/demux/mp3demuxer.js":
/*!*********************************!*\
  !*** ./src/demux/mp3demuxer.js ***!
  \*********************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * MP3 demuxer
 */
var id3_1 = __webpack_require__(/*! ../demux/id3 */ "./src/demux/id3.js");
var logger_1 = __webpack_require__(/*! ../utils/logger */ "./src/utils/logger.js");
var mpegaudio_1 = __webpack_require__(/*! ./mpegaudio */ "./src/demux/mpegaudio.js");
var MP3Demuxer = /** @class */ (function () {
    function MP3Demuxer(observer, remuxer, config) {
        this.observer = observer;
        this.config = config;
        this.remuxer = remuxer;
    }
    MP3Demuxer.prototype.resetInitSegment = function (initSegment, audioCodec, videoCodec, duration) {
        this._audioTrack = { container: 'audio/mpeg', type: 'audio', id: -1, sequenceNumber: 0, isAAC: false, samples: [], len: 0, manifestCodec: audioCodec, duration: duration, inputTimeScale: 90000 };
    };
    MP3Demuxer.prototype.resetTimeStamp = function () {
    };
    MP3Demuxer.probe = function (data) {
        // check if data contains ID3 timestamp and MPEG sync word
        var offset, length;
        var id3Data = id3_1.default.getID3Data(data, 0);
        if (id3Data && id3_1.default.getTimeStamp(id3Data) !== undefined) {
            // Look for MPEG header | 1111 1111 | 111X XYZX | where X can be either 0 or 1 and Y or Z should be 1
            // Layer bits (position 14 and 15) in header should be always different from 0 (Layer I or Layer II or Layer III)
            // More info http://www.mp3-tech.org/programmer/frame_header.html
            for (offset = id3Data.length, length = Math.min(data.length - 1, offset + 100); offset < length; offset++) {
                if (mpegaudio_1.default.probe(data, offset)) {
                    logger_1.logger.log('MPEG Audio sync word found !');
                    return true;
                }
            }
        }
        return false;
    };
    // feed incoming data to the front of the parsing pipeline
    MP3Demuxer.prototype.append = function (data, timeOffset, contiguous, accurateTimeOffset) {
        var id3Data = id3_1.default.getID3Data(data, 0);
        var timestamp = id3_1.default.getTimeStamp(id3Data);
        var pts = timestamp ? 90 * timestamp : timeOffset * 90000;
        var offset = id3Data.length;
        var length = data.length;
        var frameIndex = 0, stamp = 0;
        var track = this._audioTrack;
        var id3Samples = [{ pts: pts, dts: pts, data: id3Data }];
        while (offset < length) {
            if (mpegaudio_1.default.isHeader(data, offset)) {
                var frame = mpegaudio_1.default.appendFrame(track, data, offset, pts, frameIndex);
                if (frame) {
                    offset += frame.length;
                    stamp = frame.sample.pts;
                    frameIndex++;
                }
                else {
                    // logger.log('Unable to parse Mpeg audio frame');
                    break;
                }
            }
            else if (id3_1.default.isHeader(data, offset)) {
                id3Data = id3_1.default.getID3Data(data, offset);
                id3Samples.push({ pts: stamp, dts: stamp, data: id3Data });
                offset += id3Data.length;
            }
            else {
                // nothing found, keep looking
                offset++;
            }
        }
        this.remuxer.remux(track, { samples: [] }, { samples: id3Samples, inputTimeScale: 90000 }, { samples: [] }, timeOffset, contiguous, accurateTimeOffset);
    };
    MP3Demuxer.prototype.destroy = function () {
    };
    return MP3Demuxer;
}());
exports.default = MP3Demuxer;


/***/ }),

/***/ "./src/demux/mp4demuxer.js":
/*!*********************************!*\
  !*** ./src/demux/mp4demuxer.js ***!
  \*********************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * MP4 demuxer
 */
var logger_1 = __webpack_require__(/*! ../utils/logger */ "./src/utils/logger.js");
var events_1 = __webpack_require__(/*! ../events */ "./src/events.js");
var UINT32_MAX = Math.pow(2, 32) - 1;
var MP4Demuxer = /** @class */ (function () {
    function MP4Demuxer(observer, remuxer) {
        this.observer = observer;
        this.remuxer = remuxer;
    }
    MP4Demuxer.prototype.resetTimeStamp = function (initPTS) {
        this.initPTS = initPTS;
    };
    MP4Demuxer.prototype.resetInitSegment = function (initSegment, audioCodec, videoCodec, duration) {
        // jshint unused:false
        if (initSegment && initSegment.byteLength) {
            var initData = this.initData = MP4Demuxer.parseInitSegment(initSegment);
            // default audio codec if nothing specified
            // TODO : extract that from initsegment
            if (audioCodec == null) {
                audioCodec = 'mp4a.40.5';
            }
            if (videoCodec == null) {
                videoCodec = 'avc1.42e01e';
            }
            var tracks = {};
            if (initData.audio && initData.video) {
                tracks.audiovideo = { container: 'video/mp4', codec: audioCodec + ',' + videoCodec, initSegment: duration ? initSegment : null };
            }
            else {
                if (initData.audio) {
                    tracks.audio = { container: 'audio/mp4', codec: audioCodec, initSegment: duration ? initSegment : null };
                }
                if (initData.video) {
                    tracks.video = { container: 'video/mp4', codec: videoCodec, initSegment: duration ? initSegment : null };
                }
            }
            this.observer.trigger(events_1.default.FRAG_PARSING_INIT_SEGMENT, { tracks: tracks });
        }
        else {
            if (audioCodec) {
                this.audioCodec = audioCodec;
            }
            if (videoCodec) {
                this.videoCodec = videoCodec;
            }
        }
    };
    MP4Demuxer.probe = function (data) {
        // ensure we find a moof box in the first 16 kB
        return MP4Demuxer.findBox({ data: data, start: 0, end: Math.min(data.length, 16384) }, ['moof']).length > 0;
    };
    MP4Demuxer.bin2str = function (buffer) {
        return String.fromCharCode.apply(null, buffer);
    };
    MP4Demuxer.readUint16 = function (buffer, offset) {
        if (buffer.data) {
            offset += buffer.start;
            buffer = buffer.data;
        }
        var val = buffer[offset] << 8 |
            buffer[offset + 1];
        return val < 0 ? 65536 + val : val;
    };
    MP4Demuxer.readUint32 = function (buffer, offset) {
        if (buffer.data) {
            offset += buffer.start;
            buffer = buffer.data;
        }
        var val = buffer[offset] << 24 |
            buffer[offset + 1] << 16 |
            buffer[offset + 2] << 8 |
            buffer[offset + 3];
        return val < 0 ? 4294967296 + val : val;
    };
    MP4Demuxer.writeUint32 = function (buffer, offset, value) {
        if (buffer.data) {
            offset += buffer.start;
            buffer = buffer.data;
        }
        buffer[offset] = value >> 24;
        buffer[offset + 1] = (value >> 16) & 0xff;
        buffer[offset + 2] = (value >> 8) & 0xff;
        buffer[offset + 3] = value & 0xff;
    };
    // Find the data for a box specified by its path
    MP4Demuxer.findBox = function (data, path) {
        var results = [], i, size, type, end, subresults, start, endbox;
        if (data.data) {
            start = data.start;
            end = data.end;
            data = data.data;
        }
        else {
            start = 0;
            end = data.byteLength;
        }
        if (!path.length) {
            // short-circuit the search for empty paths
            return null;
        }
        for (i = start; i < end;) {
            size = MP4Demuxer.readUint32(data, i);
            type = MP4Demuxer.bin2str(data.subarray(i + 4, i + 8));
            endbox = size > 1 ? i + size : end;
            if (type === path[0]) {
                if (path.length === 1) {
                    // this is the end of the path and we've found the box we were
                    // looking for
                    results.push({ data: data, start: i + 8, end: endbox });
                }
                else {
                    // recursively search for the next box along the path
                    subresults = MP4Demuxer.findBox({ data: data, start: i + 8, end: endbox }, path.slice(1));
                    if (subresults.length) {
                        results = results.concat(subresults);
                    }
                }
            }
            i = endbox;
        }
        // we've finished searching all of data
        return results;
    };
    MP4Demuxer.parseSegmentIndex = function (initSegment) {
        var moov = MP4Demuxer.findBox(initSegment, ['moov'])[0];
        var moovEndOffset = moov ? moov.end : null; // we need this in case we need to chop of garbage of the end of current data
        var index = 0;
        var sidx = MP4Demuxer.findBox(initSegment, ['sidx']);
        var references;
        if (!sidx || !sidx[0]) {
            return null;
        }
        references = [];
        sidx = sidx[0];
        var version = sidx.data[0];
        // set initial offset, we skip the reference ID (not needed)
        index = version === 0 ? 8 : 16;
        var timescale = MP4Demuxer.readUint32(sidx, index);
        index += 4;
        // TODO: parse earliestPresentationTime and firstOffset
        // usually zero in our case
        var earliestPresentationTime = 0;
        var firstOffset = 0;
        if (version === 0) {
            index += 8;
        }
        else {
            index += 16;
        }
        // skip reserved
        index += 2;
        var startByte = sidx.end + firstOffset;
        var referencesCount = MP4Demuxer.readUint16(sidx, index);
        index += 2;
        for (var i = 0; i < referencesCount; i++) {
            var referenceIndex = index;
            var referenceInfo = MP4Demuxer.readUint32(sidx, referenceIndex);
            referenceIndex += 4;
            var referenceSize = referenceInfo & 0x7FFFFFFF;
            var referenceType = (referenceInfo & 0x80000000) >>> 31;
            if (referenceType === 1) {
                console.warn('SIDX has hierarchical references (not supported)');
                return;
            }
            var subsegmentDuration = MP4Demuxer.readUint32(sidx, referenceIndex);
            referenceIndex += 4;
            references.push({
                referenceSize: referenceSize,
                subsegmentDuration: subsegmentDuration,
                info: {
                    duration: subsegmentDuration / timescale,
                    start: startByte,
                    end: startByte + referenceSize - 1
                }
            });
            startByte += referenceSize;
            // Skipping 1 bit for |startsWithSap|, 3 bits for |sapType|, and 28 bits
            // for |sapDelta|.
            referenceIndex += 4;
            // skip to next ref
            index = referenceIndex;
        }
        return {
            earliestPresentationTime: earliestPresentationTime,
            timescale: timescale,
            version: version,
            referencesCount: referencesCount,
            references: references,
            moovEndOffset: moovEndOffset
        };
    };
    /**
     * Parses an MP4 initialization segment and extracts stream type and
     * timescale values for any declared tracks. Timescale values indicate the
     * number of clock ticks per second to assume for time-based values
     * elsewhere in the MP4.
     *
     * To determine the start time of an MP4, you need two pieces of
     * information: the timescale unit and the earliest base media decode
     * time. Multiple timescales can be specified within an MP4 but the
     * base media decode time is always expressed in the timescale from
     * the media header box for the track:
     * ```
     * moov > trak > mdia > mdhd.timescale
     * moov > trak > mdia > hdlr
     * ```
     * @param init {Uint8Array} the bytes of the init segment
     * @return {object} a hash of track type to timescale values or null if
     * the init segment is malformed.
     */
    MP4Demuxer.parseInitSegment = function (initSegment) {
        var result = [];
        var traks = MP4Demuxer.findBox(initSegment, ['moov', 'trak']);
        traks.forEach(function (trak) {
            var tkhd = MP4Demuxer.findBox(trak, ['tkhd'])[0];
            if (tkhd) {
                var version = tkhd.data[tkhd.start];
                var index = version === 0 ? 12 : 20;
                var trackId = MP4Demuxer.readUint32(tkhd, index);
                var mdhd = MP4Demuxer.findBox(trak, ['mdia', 'mdhd'])[0];
                if (mdhd) {
                    version = mdhd.data[mdhd.start];
                    index = version === 0 ? 12 : 20;
                    var timescale = MP4Demuxer.readUint32(mdhd, index);
                    var hdlr = MP4Demuxer.findBox(trak, ['mdia', 'hdlr'])[0];
                    if (hdlr) {
                        var hdlrType = MP4Demuxer.bin2str(hdlr.data.subarray(hdlr.start + 8, hdlr.start + 12));
                        var type = { 'soun': 'audio', 'vide': 'video' }[hdlrType];
                        if (type) {
                            // extract codec info. TODO : parse codec details to be able to build MIME type
                            var codecBox = MP4Demuxer.findBox(trak, ['mdia', 'minf', 'stbl', 'stsd']);
                            if (codecBox.length) {
                                codecBox = codecBox[0];
                                var codecType = MP4Demuxer.bin2str(codecBox.data.subarray(codecBox.start + 12, codecBox.start + 16));
                                logger_1.logger.log("MP4Demuxer:" + type + ":" + codecType + " found");
                            }
                            result[trackId] = { timescale: timescale, type: type };
                            result[type] = { timescale: timescale, id: trackId };
                        }
                    }
                }
            }
        });
        return result;
    };
    /**
   * Determine the base media decode start time, in seconds, for an MP4
   * fragment. If multiple fragments are specified, the earliest time is
   * returned.
   *
   * The base media decode time can be parsed from track fragment
   * metadata:
   * ```
   * moof > traf > tfdt.baseMediaDecodeTime
   * ```
   * It requires the timescale value from the mdhd to interpret.
   *
   * @param timescale {object} a hash of track ids to timescale values.
   * @return {number} the earliest base media decode start time for the
   * fragment, in seconds
   */
    MP4Demuxer.getStartDTS = function (initData, fragment) {
        var trafs, baseTimes, result;
        // we need info from two childrend of each track fragment box
        trafs = MP4Demuxer.findBox(fragment, ['moof', 'traf']);
        // determine the start times for each track
        baseTimes = [].concat.apply([], trafs.map(function (traf) {
            return MP4Demuxer.findBox(traf, ['tfhd']).map(function (tfhd) {
                var id, scale, baseTime;
                // get the track id from the tfhd
                id = MP4Demuxer.readUint32(tfhd, 4);
                // assume a 90kHz clock if no timescale was specified
                scale = initData[id].timescale || 90e3;
                // get the base media decode time from the tfdt
                baseTime = MP4Demuxer.findBox(traf, ['tfdt']).map(function (tfdt) {
                    var version, result;
                    version = tfdt.data[tfdt.start];
                    result = MP4Demuxer.readUint32(tfdt, 4);
                    if (version === 1) {
                        result *= Math.pow(2, 32);
                        result += MP4Demuxer.readUint32(tfdt, 8);
                    }
                    return result;
                })[0];
                // convert base time to seconds
                return baseTime / scale;
            });
        }));
        // return the minimum
        result = Math.min.apply(null, baseTimes);
        return isFinite(result) ? result : 0;
    };
    MP4Demuxer.offsetStartDTS = function (initData, fragment, timeOffset) {
        MP4Demuxer.findBox(fragment, ['moof', 'traf']).map(function (traf) {
            return MP4Demuxer.findBox(traf, ['tfhd']).map(function (tfhd) {
                // get the track id from the tfhd
                var id = MP4Demuxer.readUint32(tfhd, 4);
                // assume a 90kHz clock if no timescale was specified
                var timescale = initData[id].timescale || 90e3;
                // get the base media decode time from the tfdt
                MP4Demuxer.findBox(traf, ['tfdt']).map(function (tfdt) {
                    var version = tfdt.data[tfdt.start];
                    var baseMediaDecodeTime = MP4Demuxer.readUint32(tfdt, 4);
                    if (version === 0) {
                        MP4Demuxer.writeUint32(tfdt, 4, baseMediaDecodeTime - timeOffset * timescale);
                    }
                    else {
                        baseMediaDecodeTime *= Math.pow(2, 32);
                        baseMediaDecodeTime += MP4Demuxer.readUint32(tfdt, 8);
                        baseMediaDecodeTime -= timeOffset * timescale;
                        baseMediaDecodeTime = Math.max(baseMediaDecodeTime, 0);
                        var upper = Math.floor(baseMediaDecodeTime / (UINT32_MAX + 1));
                        var lower = Math.floor(baseMediaDecodeTime % (UINT32_MAX + 1));
                        MP4Demuxer.writeUint32(tfdt, 4, upper);
                        MP4Demuxer.writeUint32(tfdt, 8, lower);
                    }
                });
            });
        });
    };
    // feed incoming data to the front of the parsing pipeline
    MP4Demuxer.prototype.append = function (data, timeOffset, contiguous, accurateTimeOffset) {
        var initData = this.initData;
        if (!initData) {
            this.resetInitSegment(data, this.audioCodec, this.videoCodec, false);
            initData = this.initData;
        }
        var startDTS, initPTS = this.initPTS;
        if (initPTS === undefined) {
            var startDTS_1 = MP4Demuxer.getStartDTS(initData, data);
            this.initPTS = initPTS = startDTS_1 - timeOffset;
            this.observer.trigger(events_1.default.INIT_PTS_FOUND, { initPTS: initPTS });
        }
        MP4Demuxer.offsetStartDTS(initData, data, initPTS);
        startDTS = MP4Demuxer.getStartDTS(initData, data);
        this.remuxer.remux(initData.audio, initData.video, null, null, startDTS, contiguous, accurateTimeOffset, data);
    };
    MP4Demuxer.prototype.destroy = function () { };
    return MP4Demuxer;
}());
exports.default = MP4Demuxer;


/***/ }),

/***/ "./src/demux/mpegaudio.js":
/*!********************************!*\
  !*** ./src/demux/mpegaudio.js ***!
  \********************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 *  MPEG parser helper
 */
Object.defineProperty(exports, "__esModule", { value: true });
var MpegAudio = {
    BitratesMap: [
        32, 64, 96, 128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448,
        32, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 384,
        32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320,
        32, 48, 56, 64, 80, 96, 112, 128, 144, 160, 176, 192, 224, 256,
        8, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112, 128, 144, 160
    ],
    SamplingRateMap: [44100, 48000, 32000, 22050, 24000, 16000, 11025, 12000, 8000],
    SamplesCoefficients: [
        // MPEG 2.5
        [
            0,
            72,
            144,
            12 // Layer1
        ],
        // Reserved
        [
            0,
            0,
            0,
            0 // Layer1
        ],
        // MPEG 2
        [
            0,
            72,
            144,
            12 // Layer1
        ],
        // MPEG 1
        [
            0,
            144,
            144,
            12 // Layer1
        ]
    ],
    BytesInSlot: [
        0,
        1,
        1,
        4 // Layer1
    ],
    appendFrame: function (track, data, offset, pts, frameIndex) {
        // Using http://www.datavoyage.com/mpgscript/mpeghdr.htm as a reference
        if (offset + 24 > data.length) {
            return undefined;
        }
        var header = this.parseHeader(data, offset);
        if (header && offset + header.frameLength <= data.length) {
            var frameDuration = header.samplesPerFrame * 90000 / header.sampleRate;
            var stamp = pts + frameIndex * frameDuration;
            var sample = { unit: data.subarray(offset, offset + header.frameLength), pts: stamp, dts: stamp };
            track.config = [];
            track.channelCount = header.channelCount;
            track.samplerate = header.sampleRate;
            track.samples.push(sample);
            track.len += header.frameLength;
            return { sample: sample, length: header.frameLength };
        }
        return undefined;
    },
    parseHeader: function (data, offset) {
        var headerB = (data[offset + 1] >> 3) & 3;
        var headerC = (data[offset + 1] >> 1) & 3;
        var headerE = (data[offset + 2] >> 4) & 15;
        var headerF = (data[offset + 2] >> 2) & 3;
        var headerG = (data[offset + 2] >> 1) & 1;
        if (headerB !== 1 && headerE !== 0 && headerE !== 15 && headerF !== 3) {
            var columnInBitrates = headerB === 3 ? (3 - headerC) : (headerC === 3 ? 3 : 4);
            var bitRate = MpegAudio.BitratesMap[columnInBitrates * 14 + headerE - 1] * 1000;
            var columnInSampleRates = headerB === 3 ? 0 : headerB === 2 ? 1 : 2;
            var sampleRate = MpegAudio.SamplingRateMap[columnInSampleRates * 3 + headerF];
            var channelCount = data[offset + 3] >> 6 === 3 ? 1 : 2; // If bits of channel mode are `11` then it is a single channel (Mono)
            var sampleCoefficient = MpegAudio.SamplesCoefficients[headerB][headerC];
            var bytesInSlot = MpegAudio.BytesInSlot[headerC];
            var samplesPerFrame = sampleCoefficient * 8 * bytesInSlot;
            var frameLength = parseInt(sampleCoefficient * bitRate / sampleRate + headerG, 10) * bytesInSlot;
            return { sampleRate: sampleRate, channelCount: channelCount, frameLength: frameLength, samplesPerFrame: samplesPerFrame };
        }
        return undefined;
    },
    isHeaderPattern: function (data, offset) {
        return data[offset] === 0xff && (data[offset + 1] & 0xe0) === 0xe0 && (data[offset + 1] & 0x06) !== 0x00;
    },
    isHeader: function (data, offset) {
        // Look for MPEG header | 1111 1111 | 111X XYZX | where X can be either 0 or 1 and Y or Z should be 1
        // Layer bits (position 14 and 15) in header should be always different from 0 (Layer I or Layer II or Layer III)
        // More info http://www.mp3-tech.org/programmer/frame_header.html
        if (offset + 1 < data.length && this.isHeaderPattern(data, offset)) {
            return true;
        }
        return false;
    },
    probe: function (data, offset) {
        // same as isHeader but we also check that MPEG frame follows last MPEG frame
        // or end of data is reached
        if (offset + 1 < data.length && this.isHeaderPattern(data, offset)) {
            // MPEG header Length
            var headerLength = 4;
            // MPEG frame Length
            var header = this.parseHeader(data, offset);
            var frameLength = headerLength;
            if (header && header.frameLength) {
                frameLength = header.frameLength;
            }
            var newOffset = offset + frameLength;
            if (newOffset === data.length || (newOffset + 1 < data.length && this.isHeaderPattern(data, newOffset))) {
                return true;
            }
        }
        return false;
    }
};
exports.default = MpegAudio;


/***/ }),

/***/ "./src/demux/sample-aes.js":
/*!*********************************!*\
  !*** ./src/demux/sample-aes.js ***!
  \*********************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * SAMPLE-AES decrypter
*/
Object.defineProperty(exports, "__esModule", { value: true });
var decrypter_1 = __webpack_require__(/*! ../crypt/decrypter */ "./src/crypt/decrypter.js");
var SampleAesDecrypter = /** @class */ (function () {
    function SampleAesDecrypter(observer, config, decryptdata, discardEPB) {
        this.decryptdata = decryptdata;
        this.discardEPB = discardEPB;
        this.decrypter = new decrypter_1.default(observer, config, { removePKCS7Padding: false });
    }
    SampleAesDecrypter.prototype.decryptBuffer = function (encryptedData, callback) {
        this.decrypter.decrypt(encryptedData, this.decryptdata.key.buffer, this.decryptdata.iv.buffer, callback);
    };
    // AAC - encrypt all full 16 bytes blocks starting from offset 16
    SampleAesDecrypter.prototype.decryptAacSample = function (samples, sampleIndex, callback, sync) {
        var curUnit = samples[sampleIndex].unit;
        var encryptedData = curUnit.subarray(16, curUnit.length - curUnit.length % 16);
        var encryptedBuffer = encryptedData.buffer.slice(encryptedData.byteOffset, encryptedData.byteOffset + encryptedData.length);
        var localthis = this;
        this.decryptBuffer(encryptedBuffer, function (decryptedData) {
            decryptedData = new Uint8Array(decryptedData);
            curUnit.set(decryptedData, 16);
            if (!sync) {
                localthis.decryptAacSamples(samples, sampleIndex + 1, callback);
            }
        });
    };
    SampleAesDecrypter.prototype.decryptAacSamples = function (samples, sampleIndex, callback) {
        for (;; sampleIndex++) {
            if (sampleIndex >= samples.length) {
                callback();
                return;
            }
            if (samples[sampleIndex].unit.length < 32) {
                continue;
            }
            var sync = this.decrypter.isSync();
            this.decryptAacSample(samples, sampleIndex, callback, sync);
            if (!sync) {
                return;
            }
        }
    };
    // AVC - encrypt one 16 bytes block out of ten, starting from offset 32
    SampleAesDecrypter.prototype.getAvcEncryptedData = function (decodedData) {
        var encryptedDataLen = Math.floor((decodedData.length - 48) / 160) * 16 + 16;
        var encryptedData = new Int8Array(encryptedDataLen);
        var outputPos = 0;
        for (var inputPos = 32; inputPos <= decodedData.length - 16; inputPos += 160, outputPos += 16) {
            encryptedData.set(decodedData.subarray(inputPos, inputPos + 16), outputPos);
        }
        return encryptedData;
    };
    SampleAesDecrypter.prototype.getAvcDecryptedUnit = function (decodedData, decryptedData) {
        decryptedData = new Uint8Array(decryptedData);
        var inputPos = 0;
        for (var outputPos = 32; outputPos <= decodedData.length - 16; outputPos += 160, inputPos += 16) {
            decodedData.set(decryptedData.subarray(inputPos, inputPos + 16), outputPos);
        }
        return decodedData;
    };
    SampleAesDecrypter.prototype.decryptAvcSample = function (samples, sampleIndex, unitIndex, callback, curUnit, sync) {
        var decodedData = this.discardEPB(curUnit.data);
        var encryptedData = this.getAvcEncryptedData(decodedData);
        var localthis = this;
        this.decryptBuffer(encryptedData.buffer, function (decryptedData) {
            curUnit.data = localthis.getAvcDecryptedUnit(decodedData, decryptedData);
            if (!sync) {
                localthis.decryptAvcSamples(samples, sampleIndex, unitIndex + 1, callback);
            }
        });
    };
    SampleAesDecrypter.prototype.decryptAvcSamples = function (samples, sampleIndex, unitIndex, callback) {
        for (;; sampleIndex++, unitIndex = 0) {
            if (sampleIndex >= samples.length) {
                callback();
                return;
            }
            var curUnits = samples[sampleIndex].units;
            for (;; unitIndex++) {
                if (unitIndex >= curUnits.length) {
                    break;
                }
                var curUnit = curUnits[unitIndex];
                if (curUnit.length <= 48 || (curUnit.type !== 1 && curUnit.type !== 5)) {
                    continue;
                }
                var sync = this.decrypter.isSync();
                this.decryptAvcSample(samples, sampleIndex, unitIndex, callback, curUnit, sync);
                if (!sync) {
                    return;
                }
            }
        }
    };
    return SampleAesDecrypter;
}());
exports.default = SampleAesDecrypter;


/***/ }),

/***/ "./src/demux/tsdemuxer.js":
/*!********************************!*\
  !*** ./src/demux/tsdemuxer.js ***!
  \********************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * highly optimized TS demuxer:
 * parse PAT, PMT
 * extract PES packet from audio and video PIDs
 * extract AVC/H264 NAL units and AAC/ADTS samples from PES packet
 * trigger the remuxer upon parsing completion
 * it also tries to workaround as best as it can audio codec switch (HE-AAC to AAC and vice versa), without having to restart the MediaSource.
 * it also controls the remuxing process :
 * upon discontinuity or level switch detection, it will also notifies the remuxer so that it can reset its state.
*/
Object.defineProperty(exports, "__esModule", { value: true });
var ADTS = __webpack_require__(/*! ./adts */ "./src/demux/adts.js");
var mpegaudio_1 = __webpack_require__(/*! ./mpegaudio */ "./src/demux/mpegaudio.js");
var events_1 = __webpack_require__(/*! ../events */ "./src/events.js");
var exp_golomb_1 = __webpack_require__(/*! ./exp-golomb */ "./src/demux/exp-golomb.js");
var sample_aes_1 = __webpack_require__(/*! ./sample-aes */ "./src/demux/sample-aes.js");
// import Hex from '../utils/hex';
var logger_1 = __webpack_require__(/*! ../utils/logger */ "./src/utils/logger.js");
var errors_1 = __webpack_require__(/*! ../errors */ "./src/errors.js");
// We are using fixed track IDs for driving the MP4 remuxer
// instead of following the TS PIDs.
// There is no reason not to do this and some browsers/SourceBuffer-demuxers
// may not like if there are TrackID "switches"
// See https://github.com/video-dev/hls.js/issues/1331
// Here we are mapping our internal track types to constant MP4 track IDs
// With MSE currently one can only have one track of each, and we are muxing
// whatever video/audio rendition in them.
var RemuxerTrackIdConfig = {
    video: 1,
    audio: 2,
    id3: 3,
    text: 4
};
var TSDemuxer = /** @class */ (function () {
    function TSDemuxer(observer, remuxer, config, typeSupported) {
        this.observer = observer;
        this.config = config;
        this.typeSupported = typeSupported;
        this.remuxer = remuxer;
        this.sampleAes = null;
    }
    TSDemuxer.prototype.setDecryptData = function (decryptdata) {
        if ((decryptdata != null) && (decryptdata.key != null) && (decryptdata.method === 'SAMPLE-AES')) {
            this.sampleAes = new sample_aes_1.default(this.observer, this.config, decryptdata, this.discardEPB);
        }
        else {
            this.sampleAes = null;
        }
    };
    TSDemuxer.probe = function (data) {
        var syncOffset = TSDemuxer._syncOffset(data);
        if (syncOffset < 0) {
            return false;
        }
        else {
            if (syncOffset) {
                logger_1.logger.warn("MPEG2-TS detected but first sync word found @ offset " + syncOffset + ", junk ahead ?");
            }
            return true;
        }
    };
    TSDemuxer._syncOffset = function (data) {
        // scan 1000 first bytes
        var scanwindow = Math.min(1000, data.length - 3 * 188);
        var i = 0;
        while (i < scanwindow) {
            // a TS fragment should contain at least 3 TS packets, a PAT, a PMT, and one PID, each starting with 0x47
            if (data[i] === 0x47 && data[i + 188] === 0x47 && data[i + 2 * 188] === 0x47) {
                return i;
            }
            else {
                i++;
            }
        }
        return -1;
    };
    /**
     * Creates a track model internal to demuxer used to drive remuxing input
     *
     * @param {string} type 'audio' | 'video' | 'id3' | 'text'
     * @param {number} duration
     * @return {object} TSDemuxer's internal track model
     */
    TSDemuxer.createTrack = function (type, duration) {
        return {
            container: type === 'video' || type === 'audio' ? 'video/mp2t' : undefined,
            type: type,
            id: RemuxerTrackIdConfig[type],
            pid: -1,
            inputTimeScale: 90000,
            sequenceNumber: 0,
            samples: [],
            len: 0,
            dropped: type === 'video' ? 0 : undefined,
            isAAC: type === 'audio' ? true : undefined,
            duration: type === 'audio' ? duration : undefined
        };
    };
    /**
     * Initializes a new init segment on the demuxer/remuxer interface. Needed for discontinuities/track-switches (or at stream start)
     * Resets all internal track instances of the demuxer.
     *
     * @override Implements generic demuxing/remuxing interface (see DemuxerInline)
     * @param {object} initSegment
     * @param {string} audioCodec
     * @param {string} videoCodec
     * @param {number} duration (in TS timescale = 90kHz)
     */
    TSDemuxer.prototype.resetInitSegment = function (initSegment, audioCodec, videoCodec, duration) {
        this.pmtParsed = false;
        this._pmtId = -1;
        this._avcTrack = TSDemuxer.createTrack('video', duration);
        this._audioTrack = TSDemuxer.createTrack('audio', duration);
        this._id3Track = TSDemuxer.createTrack('id3', duration);
        this._txtTrack = TSDemuxer.createTrack('text', duration);
        // flush any partial content
        this.aacOverFlow = null;
        this.aacLastPTS = null;
        this.avcSample = null;
        this.audioCodec = audioCodec;
        this.videoCodec = videoCodec;
        this._duration = duration;
    };
    /**
     *
     * @override
     */
    TSDemuxer.prototype.resetTimeStamp = function () { };
    // feed incoming data to the front of the parsing pipeline
    TSDemuxer.prototype.append = function (data, timeOffset, contiguous, accurateTimeOffset) {
        var start, len = data.length, stt, pid, atf, offset, pes, unknownPIDs = false;
        this.contiguous = contiguous;
        var pmtParsed = this.pmtParsed, avcTrack = this._avcTrack, audioTrack = this._audioTrack, id3Track = this._id3Track, avcId = avcTrack.pid, audioId = audioTrack.pid, id3Id = id3Track.pid, pmtId = this._pmtId, avcData = avcTrack.pesData, audioData = audioTrack.pesData, id3Data = id3Track.pesData, parsePAT = this._parsePAT, parsePMT = this._parsePMT, parsePES = this._parsePES, parseAVCPES = this._parseAVCPES.bind(this), parseAACPES = this._parseAACPES.bind(this), parseMPEGPES = this._parseMPEGPES.bind(this), parseID3PES = this._parseID3PES.bind(this);
        var syncOffset = TSDemuxer._syncOffset(data);
        // don't parse last TS packet if incomplete
        len -= (len + syncOffset) % 188;
        // loop through TS packets
        for (start = syncOffset; start < len; start += 188) {
            if (data[start] === 0x47) {
                stt = !!(data[start + 1] & 0x40);
                // pid is a 13-bit field starting at the last bit of TS[1]
                pid = ((data[start + 1] & 0x1f) << 8) + data[start + 2];
                atf = (data[start + 3] & 0x30) >> 4;
                // if an adaption field is present, its length is specified by the fifth byte of the TS packet header.
                if (atf > 1) {
                    offset = start + 5 + data[start + 4];
                    // continue if there is only adaptation field
                    if (offset === (start + 188)) {
                        continue;
                    }
                }
                else {
                    offset = start + 4;
                }
                switch (pid) {
                    case avcId:
                        if (stt) {
                            if (avcData && (pes = parsePES(avcData)) && pes.pts !== undefined) {
                                parseAVCPES(pes, false);
                            }
                            avcData = { data: [], size: 0 };
                        }
                        if (avcData) {
                            avcData.data.push(data.subarray(offset, start + 188));
                            avcData.size += start + 188 - offset;
                        }
                        break;
                    case audioId:
                        if (stt) {
                            if (audioData && (pes = parsePES(audioData)) && pes.pts !== undefined) {
                                if (audioTrack.isAAC) {
                                    parseAACPES(pes);
                                }
                                else {
                                    parseMPEGPES(pes);
                                }
                            }
                            audioData = { data: [], size: 0 };
                        }
                        if (audioData) {
                            audioData.data.push(data.subarray(offset, start + 188));
                            audioData.size += start + 188 - offset;
                        }
                        break;
                    case id3Id:
                        if (stt) {
                            if (id3Data && (pes = parsePES(id3Data)) && pes.pts !== undefined) {
                                parseID3PES(pes);
                            }
                            id3Data = { data: [], size: 0 };
                        }
                        if (id3Data) {
                            id3Data.data.push(data.subarray(offset, start + 188));
                            id3Data.size += start + 188 - offset;
                        }
                        break;
                    case 0:
                        if (stt) {
                            offset += data[offset] + 1;
                        }
                        pmtId = this._pmtId = parsePAT(data, offset);
                        break;
                    case pmtId:
                        if (stt) {
                            offset += data[offset] + 1;
                        }
                        var parsedPIDs = parsePMT(data, offset, this.typeSupported.mpeg === true || this.typeSupported.mp3 === true, this.sampleAes != null);
                        // only update track id if track PID found while parsing PMT
                        // this is to avoid resetting the PID to -1 in case
                        // track PID transiently disappears from the stream
                        // this could happen in case of transient missing audio samples for example
                        // NOTE this is only the PID of the track as found in TS,
                        // but we are not using this for MP4 track IDs.
                        avcId = parsedPIDs.avc;
                        if (avcId > 0) {
                            avcTrack.pid = avcId;
                        }
                        audioId = parsedPIDs.audio;
                        if (audioId > 0) {
                            audioTrack.pid = audioId;
                            audioTrack.isAAC = parsedPIDs.isAAC;
                        }
                        id3Id = parsedPIDs.id3;
                        if (id3Id > 0) {
                            id3Track.pid = id3Id;
                        }
                        if (unknownPIDs && !pmtParsed) {
                            logger_1.logger.log('reparse from beginning');
                            unknownPIDs = false;
                            // we set it to -188, the += 188 in the for loop will reset start to 0
                            start = syncOffset - 188;
                        }
                        pmtParsed = this.pmtParsed = true;
                        break;
                    case 17:
                    case 0x1fff:
                        break;
                    default:
                        unknownPIDs = true;
                        break;
                }
            }
            else {
                this.observer.trigger(events_1.default.ERROR, { type: errors_1.ErrorTypes.MEDIA_ERROR, details: errors_1.ErrorDetails.FRAG_PARSING_ERROR, fatal: false, reason: 'TS packet did not start with 0x47' });
            }
        }
        // try to parse last PES packets
        if (avcData && (pes = parsePES(avcData)) && pes.pts !== undefined) {
            parseAVCPES(pes, true);
            avcTrack.pesData = null;
        }
        else {
            // either avcData null or PES truncated, keep it for next frag parsing
            avcTrack.pesData = avcData;
        }
        if (audioData && (pes = parsePES(audioData)) && pes.pts !== undefined) {
            if (audioTrack.isAAC) {
                parseAACPES(pes);
            }
            else {
                parseMPEGPES(pes);
            }
            audioTrack.pesData = null;
        }
        else {
            if (audioData && audioData.size) {
                logger_1.logger.log('last AAC PES packet truncated,might overlap between fragments');
            }
            // either audioData null or PES truncated, keep it for next frag parsing
            audioTrack.pesData = audioData;
        }
        if (id3Data && (pes = parsePES(id3Data)) && pes.pts !== undefined) {
            parseID3PES(pes);
            id3Track.pesData = null;
        }
        else {
            // either id3Data null or PES truncated, keep it for next frag parsing
            id3Track.pesData = id3Data;
        }
        if (this.sampleAes == null) {
            this.remuxer.remux(audioTrack, avcTrack, id3Track, this._txtTrack, timeOffset, contiguous, accurateTimeOffset);
        }
        else {
            this.decryptAndRemux(audioTrack, avcTrack, id3Track, this._txtTrack, timeOffset, contiguous, accurateTimeOffset);
        }
    };
    TSDemuxer.prototype.decryptAndRemux = function (audioTrack, videoTrack, id3Track, textTrack, timeOffset, contiguous, accurateTimeOffset) {
        if (audioTrack.samples && audioTrack.isAAC) {
            var localthis_1 = this;
            this.sampleAes.decryptAacSamples(audioTrack.samples, 0, function () {
                localthis_1.decryptAndRemuxAvc(audioTrack, videoTrack, id3Track, textTrack, timeOffset, contiguous, accurateTimeOffset);
            });
        }
        else {
            this.decryptAndRemuxAvc(audioTrack, videoTrack, id3Track, textTrack, timeOffset, contiguous, accurateTimeOffset);
        }
    };
    TSDemuxer.prototype.decryptAndRemuxAvc = function (audioTrack, videoTrack, id3Track, textTrack, timeOffset, contiguous, accurateTimeOffset) {
        if (videoTrack.samples) {
            var localthis_2 = this;
            this.sampleAes.decryptAvcSamples(videoTrack.samples, 0, 0, function () {
                localthis_2.remuxer.remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, contiguous, accurateTimeOffset);
            });
        }
        else {
            this.remuxer.remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, contiguous, accurateTimeOffset);
        }
    };
    TSDemuxer.prototype.destroy = function () {
        this._initPTS = this._initDTS = undefined;
        this._duration = 0;
    };
    TSDemuxer.prototype._parsePAT = function (data, offset) {
        // skip the PSI header and parse the first PMT entry
        return (data[offset + 10] & 0x1F) << 8 | data[offset + 11];
        // logger.log('PMT PID:'  + this._pmtId);
    };
    TSDemuxer.prototype._parsePMT = function (data, offset, mpegSupported, isSampleAes) {
        var sectionLength, tableEnd, programInfoLength, pid, result = { audio: -1, avc: -1, id3: -1, isAAC: true };
        sectionLength = (data[offset + 1] & 0x0f) << 8 | data[offset + 2];
        tableEnd = offset + 3 + sectionLength - 4;
        // to determine where the table is, we have to figure out how
        // long the program info descriptors are
        programInfoLength = (data[offset + 10] & 0x0f) << 8 | data[offset + 11];
        // advance the offset to the first entry in the mapping table
        offset += 12 + programInfoLength;
        while (offset < tableEnd) {
            pid = (data[offset + 1] & 0x1F) << 8 | data[offset + 2];
            switch (data[offset]) {
                case 0xcf: // SAMPLE-AES AAC
                    if (!isSampleAes) {
                        logger_1.logger.log('unkown stream type:' + data[offset]);
                        break;
                    }
                /* falls through */
                // ISO/IEC 13818-7 ADTS AAC (MPEG-2 lower bit-rate audio)
                case 0x0f:
                    // logger.log('AAC PID:'  + pid);
                    if (result.audio === -1) {
                        result.audio = pid;
                    }
                    break;
                // Packetized metadata (ID3)
                case 0x15:
                    // logger.log('ID3 PID:'  + pid);
                    if (result.id3 === -1) {
                        result.id3 = pid;
                    }
                    break;
                case 0xdb: // SAMPLE-AES AVC
                    if (!isSampleAes) {
                        logger_1.logger.log('unkown stream type:' + data[offset]);
                        break;
                    }
                /* falls through */
                // ITU-T Rec. H.264 and ISO/IEC 14496-10 (lower bit-rate video)
                case 0x1b:
                    // logger.log('AVC PID:'  + pid);
                    if (result.avc === -1) {
                        result.avc = pid;
                    }
                    break;
                // ISO/IEC 11172-3 (MPEG-1 audio)
                // or ISO/IEC 13818-3 (MPEG-2 halved sample rate audio)
                case 0x03:
                case 0x04:
                    // logger.log('MPEG PID:'  + pid);
                    if (!mpegSupported) {
                        logger_1.logger.log('MPEG audio found, not supported in this browser for now');
                    }
                    else if (result.audio === -1) {
                        result.audio = pid;
                        result.isAAC = false;
                    }
                    break;
                case 0x24:
                    logger_1.logger.warn('HEVC stream type found, not supported for now');
                    break;
                default:
                    logger_1.logger.log('unkown stream type:' + data[offset]);
                    break;
            }
            // move to the next table entry
            // skip past the elementary stream descriptors, if present
            offset += ((data[offset + 3] & 0x0F) << 8 | data[offset + 4]) + 5;
        }
        return result;
    };
    TSDemuxer.prototype._parsePES = function (stream) {
        var i = 0, frag, pesFlags, pesPrefix, pesLen, pesHdrLen, pesData, pesPts, pesDts, payloadStartOffset, data = stream.data;
        // safety check
        if (!stream || stream.size === 0) {
            return null;
        }
        // we might need up to 19 bytes to read PES header
        // if first chunk of data is less than 19 bytes, let's merge it with following ones until we get 19 bytes
        // usually only one merge is needed (and this is rare ...)
        while (data[0].length < 19 && data.length > 1) {
            var newData = new Uint8Array(data[0].length + data[1].length);
            newData.set(data[0]);
            newData.set(data[1], data[0].length);
            data[0] = newData;
            data.splice(1, 1);
        }
        // retrieve PTS/DTS from first fragment
        frag = data[0];
        pesPrefix = (frag[0] << 16) + (frag[1] << 8) + frag[2];
        if (pesPrefix === 1) {
            pesLen = (frag[4] << 8) + frag[5];
            // if PES parsed length is not zero and greater than total received length, stop parsing. PES might be truncated
            // minus 6 : PES header size
            if (pesLen && pesLen > stream.size - 6) {
                return null;
            }
            pesFlags = frag[7];
            if (pesFlags & 0xC0) {
                /* PES header described here : http://dvd.sourceforge.net/dvdinfo/pes-hdr.html
                    as PTS / DTS is 33 bit we cannot use bitwise operator in JS,
                    as Bitwise operators treat their operands as a sequence of 32 bits */
                pesPts = (frag[9] & 0x0E) * 536870912 + // 1 << 29
                    (frag[10] & 0xFF) * 4194304 + // 1 << 22
                    (frag[11] & 0xFE) * 16384 + // 1 << 14
                    (frag[12] & 0xFF) * 128 + // 1 << 7
                    (frag[13] & 0xFE) / 2;
                // check if greater than 2^32 -1
                if (pesPts > 4294967295) {
                    // decrement 2^33
                    pesPts -= 8589934592;
                }
                if (pesFlags & 0x40) {
                    pesDts = (frag[14] & 0x0E) * 536870912 + // 1 << 29
                        (frag[15] & 0xFF) * 4194304 + // 1 << 22
                        (frag[16] & 0xFE) * 16384 + // 1 << 14
                        (frag[17] & 0xFF) * 128 + // 1 << 7
                        (frag[18] & 0xFE) / 2;
                    // check if greater than 2^32 -1
                    if (pesDts > 4294967295) {
                        // decrement 2^33
                        pesDts -= 8589934592;
                    }
                    if (pesPts - pesDts > 60 * 90000) {
                        logger_1.logger.warn(Math.round((pesPts - pesDts) / 90000) + "s delta between PTS and DTS, align them");
                        pesPts = pesDts;
                    }
                }
                else {
                    pesDts = pesPts;
                }
            }
            pesHdrLen = frag[8];
            // 9 bytes : 6 bytes for PES header + 3 bytes for PES extension
            payloadStartOffset = pesHdrLen + 9;
            stream.size -= payloadStartOffset;
            // reassemble PES packet
            pesData = new Uint8Array(stream.size);
            for (var j = 0, dataLen = data.length; j < dataLen; j++) {
                frag = data[j];
                var len = frag.byteLength;
                if (payloadStartOffset) {
                    if (payloadStartOffset > len) {
                        // trim full frag if PES header bigger than frag
                        payloadStartOffset -= len;
                        continue;
                    }
                    else {
                        // trim partial frag if PES header smaller than frag
                        frag = frag.subarray(payloadStartOffset);
                        len -= payloadStartOffset;
                        payloadStartOffset = 0;
                    }
                }
                pesData.set(frag, i);
                i += len;
            }
            if (pesLen) {
                // payload size : remove PES header + PES extension
                pesLen -= pesHdrLen + 3;
            }
            return { data: pesData, pts: pesPts, dts: pesDts, len: pesLen };
        }
        else {
            return null;
        }
    };
    TSDemuxer.prototype.pushAccesUnit = function (avcSample, avcTrack) {
        if (avcSample.units.length && avcSample.frame) {
            var samples = avcTrack.samples;
            var nbSamples = samples.length;
            // only push AVC sample if starting with a keyframe is not mandatory OR
            //    if keyframe already found in this fragment OR
            //       keyframe found in last fragment (track.sps) AND
            //          samples already appended (we already found a keyframe in this fragment) OR fragment is contiguous
            if (!this.config.forceKeyFrameOnDiscontinuity ||
                avcSample.key === true ||
                (avcTrack.sps && (nbSamples || this.contiguous))) {
                avcSample.id = nbSamples;
                samples.push(avcSample);
            }
            else {
                // dropped samples, track it
                avcTrack.dropped++;
            }
        }
        if (avcSample.debug.length) {
            logger_1.logger.log(avcSample.pts + '/' + avcSample.dts + ':' + avcSample.debug);
        }
    };
    TSDemuxer.prototype._parseAVCPES = function (pes, last) {
        var _this = this;
        // logger.log('parse new PES');
        var track = this._avcTrack, units = this._parseAVCNALu(pes.data), debug = false, expGolombDecoder, avcSample = this.avcSample, push, spsfound = false, i, pushAccesUnit = this.pushAccesUnit.bind(this), createAVCSample = function (key, pts, dts, debug) {
            return { key: key, pts: pts, dts: dts, units: [], debug: debug };
        };
        // free pes.data to save up some memory
        pes.data = null;
        // if new NAL units found and last sample still there, let's push ...
        // this helps parsing streams with missing AUD (only do this if AUD never found)
        if (avcSample && units.length && !track.audFound) {
            pushAccesUnit(avcSample, track);
            avcSample = this.avcSample = createAVCSample(false, pes.pts, pes.dts, '');
        }
        units.forEach(function (unit) {
            switch (unit.type) {
                // NDR
                case 1:
                    push = true;
                    if (!avcSample) {
                        avcSample = _this.avcSample = createAVCSample(true, pes.pts, pes.dts, '');
                    }
                    if (debug) {
                        avcSample.debug += 'NDR ';
                    }
                    avcSample.frame = true;
                    var data = unit.data;
                    // only check slice type to detect KF in case SPS found in same packet (any keyframe is preceded by SPS ...)
                    if (spsfound && data.length > 4) {
                        // retrieve slice type by parsing beginning of NAL unit (follow H264 spec, slice_header definition) to detect keyframe embedded in NDR
                        var sliceType = new exp_golomb_1.default(data).readSliceType();
                        // 2 : I slice, 4 : SI slice, 7 : I slice, 9: SI slice
                        // SI slice : A slice that is coded using intra prediction only and using quantisation of the prediction samples.
                        // An SI slice can be coded such that its decoded samples can be constructed identically to an SP slice.
                        // I slice: A slice that is not an SI slice that is decoded using intra prediction only.
                        // if (sliceType === 2 || sliceType === 7) {
                        if (sliceType === 2 || sliceType === 4 || sliceType === 7 || sliceType === 9) {
                            avcSample.key = true;
                        }
                    }
                    break;
                // IDR
                case 5:
                    push = true;
                    // handle PES not starting with AUD
                    if (!avcSample) {
                        avcSample = _this.avcSample = createAVCSample(true, pes.pts, pes.dts, '');
                    }
                    if (debug) {
                        avcSample.debug += 'IDR ';
                    }
                    avcSample.key = true;
                    avcSample.frame = true;
                    break;
                // SEI
                case 6:
                    push = true;
                    if (debug && avcSample) {
                        avcSample.debug += 'SEI ';
                    }
                    expGolombDecoder = new exp_golomb_1.default(_this.discardEPB(unit.data));
                    // skip frameType
                    expGolombDecoder.readUByte();
                    var payloadType = 0;
                    var payloadSize = 0;
                    var endOfCaptions = false;
                    var b = 0;
                    while (!endOfCaptions && expGolombDecoder.bytesAvailable > 1) {
                        payloadType = 0;
                        do {
                            b = expGolombDecoder.readUByte();
                            payloadType += b;
                        } while (b === 0xFF);
                        // Parse payload size.
                        payloadSize = 0;
                        do {
                            b = expGolombDecoder.readUByte();
                            payloadSize += b;
                        } while (b === 0xFF);
                        // TODO: there can be more than one payload in an SEI packet...
                        // TODO: need to read type and size in a while loop to get them all
                        if (payloadType === 4 && expGolombDecoder.bytesAvailable !== 0) {
                            endOfCaptions = true;
                            var countryCode = expGolombDecoder.readUByte();
                            if (countryCode === 181) {
                                var providerCode = expGolombDecoder.readUShort();
                                if (providerCode === 49) {
                                    var userStructure = expGolombDecoder.readUInt();
                                    if (userStructure === 0x47413934) {
                                        var userDataType = expGolombDecoder.readUByte();
                                        // Raw CEA-608 bytes wrapped in CEA-708 packet
                                        if (userDataType === 3) {
                                            var firstByte = expGolombDecoder.readUByte();
                                            var secondByte = expGolombDecoder.readUByte();
                                            var totalCCs = 31 & firstByte;
                                            var byteArray = [firstByte, secondByte];
                                            for (i = 0; i < totalCCs; i++) {
                                                // 3 bytes per CC
                                                byteArray.push(expGolombDecoder.readUByte());
                                                byteArray.push(expGolombDecoder.readUByte());
                                                byteArray.push(expGolombDecoder.readUByte());
                                            }
                                            _this._insertSampleInOrder(_this._txtTrack.samples, { type: 3, pts: pes.pts, bytes: byteArray });
                                        }
                                    }
                                }
                            }
                        }
                        else if (payloadSize < expGolombDecoder.bytesAvailable) {
                            for (i = 0; i < payloadSize; i++) {
                                expGolombDecoder.readUByte();
                            }
                        }
                    }
                    break;
                // SPS
                case 7:
                    push = true;
                    spsfound = true;
                    if (debug && avcSample) {
                        avcSample.debug += 'SPS ';
                    }
                    if (!track.sps) {
                        expGolombDecoder = new exp_golomb_1.default(unit.data);
                        var config = expGolombDecoder.readSPS();
                        track.width = config.width;
                        track.height = config.height;
                        track.pixelRatio = config.pixelRatio;
                        track.sps = [unit.data];
                        track.duration = _this._duration;
                        var codecarray = unit.data.subarray(1, 4);
                        var codecstring = 'avc1.';
                        for (i = 0; i < 3; i++) {
                            var h = codecarray[i].toString(16);
                            if (h.length < 2) {
                                h = '0' + h;
                            }
                            codecstring += h;
                        }
                        track.codec = codecstring;
                    }
                    break;
                // PPS
                case 8:
                    push = true;
                    if (debug && avcSample) {
                        avcSample.debug += 'PPS ';
                    }
                    if (!track.pps) {
                        track.pps = [unit.data];
                    }
                    break;
                // AUD
                case 9:
                    push = false;
                    track.audFound = true;
                    if (avcSample) {
                        pushAccesUnit(avcSample, track);
                    }
                    avcSample = _this.avcSample = createAVCSample(false, pes.pts, pes.dts, debug ? 'AUD ' : '');
                    break;
                // Filler Data
                case 12:
                    push = false;
                    break;
                default:
                    push = false;
                    if (avcSample) {
                        avcSample.debug += 'unknown NAL ' + unit.type + ' ';
                    }
                    break;
            }
            if (avcSample && push) {
                var units_1 = avcSample.units;
                units_1.push(unit);
            }
        });
        // if last PES packet, push samples
        if (last && avcSample) {
            pushAccesUnit(avcSample, track);
            this.avcSample = null;
        }
    };
    TSDemuxer.prototype._insertSampleInOrder = function (arr, data) {
        var len = arr.length;
        if (len > 0) {
            if (data.pts >= arr[len - 1].pts) {
                arr.push(data);
            }
            else {
                for (var pos = len - 1; pos >= 0; pos--) {
                    if (data.pts < arr[pos].pts) {
                        arr.splice(pos, 0, data);
                        break;
                    }
                }
            }
        }
        else {
            arr.push(data);
        }
    };
    TSDemuxer.prototype._getLastNalUnit = function () {
        var avcSample = this.avcSample, lastUnit;
        // try to fallback to previous sample if current one is empty
        if (!avcSample || avcSample.units.length === 0) {
            var track = this._avcTrack, samples = track.samples;
            avcSample = samples[samples.length - 1];
        }
        if (avcSample) {
            var units = avcSample.units;
            lastUnit = units[units.length - 1];
        }
        return lastUnit;
    };
    TSDemuxer.prototype._parseAVCNALu = function (array) {
        var i = 0, len = array.byteLength, value, overflow, track = this._avcTrack, state = track.naluState || 0, lastState = state;
        var units = [], unit, unitType, lastUnitStart = -1, lastUnitType;
        // logger.log('PES:' + Hex.hexDump(array));
        if (state === -1) {
            // special use case where we found 3 or 4-byte start codes exactly at the end of previous PES packet
            lastUnitStart = 0;
            // NALu type is value read from offset 0
            lastUnitType = array[0] & 0x1f;
            state = 0;
            i = 1;
        }
        while (i < len) {
            value = array[i++];
            // optimization. state 0 and 1 are the predominant case. let's handle them outside of the switch/case
            if (!state) {
                state = value ? 0 : 1;
                continue;
            }
            if (state === 1) {
                state = value ? 0 : 2;
                continue;
            }
            // here we have state either equal to 2 or 3
            if (!value) {
                state = 3;
            }
            else if (value === 1) {
                if (lastUnitStart >= 0) {
                    unit = { data: array.subarray(lastUnitStart, i - state - 1), type: lastUnitType };
                    // logger.log('pushing NALU, type/size:' + unit.type + '/' + unit.data.byteLength);
                    units.push(unit);
                }
                else {
                    // lastUnitStart is undefined => this is the first start code found in this PES packet
                    // first check if start code delimiter is overlapping between 2 PES packets,
                    // ie it started in last packet (lastState not zero)
                    // and ended at the beginning of this PES packet (i <= 4 - lastState)
                    var lastUnit = this._getLastNalUnit();
                    if (lastUnit) {
                        if (lastState && (i <= 4 - lastState)) {
                            // start delimiter overlapping between PES packets
                            // strip start delimiter bytes from the end of last NAL unit
                            // check if lastUnit had a state different from zero
                            if (lastUnit.state) {
                                // strip last bytes
                                lastUnit.data = lastUnit.data.subarray(0, lastUnit.data.byteLength - lastState);
                            }
                        }
                        // If NAL units are not starting right at the beginning of the PES packet, push preceding data into previous NAL unit.
                        overflow = i - state - 1;
                        if (overflow > 0) {
                            // logger.log('first NALU found with overflow:' + overflow);
                            var tmp = new Uint8Array(lastUnit.data.byteLength + overflow);
                            tmp.set(lastUnit.data, 0);
                            tmp.set(array.subarray(0, overflow), lastUnit.data.byteLength);
                            lastUnit.data = tmp;
                        }
                    }
                }
                // check if we can read unit type
                if (i < len) {
                    unitType = array[i] & 0x1f;
                    // logger.log('find NALU @ offset:' + i + ',type:' + unitType);
                    lastUnitStart = i;
                    lastUnitType = unitType;
                    state = 0;
                }
                else {
                    // not enough byte to read unit type. let's read it on next PES parsing
                    state = -1;
                }
            }
            else {
                state = 0;
            }
        }
        if (lastUnitStart >= 0 && state >= 0) {
            unit = { data: array.subarray(lastUnitStart, len), type: lastUnitType, state: state };
            units.push(unit);
            // logger.log('pushing NALU, type/size/state:' + unit.type + '/' + unit.data.byteLength + '/' + state);
        }
        // no NALu found
        if (units.length === 0) {
            // append pes.data to previous NAL unit
            var lastUnit = this._getLastNalUnit();
            if (lastUnit) {
                var tmp = new Uint8Array(lastUnit.data.byteLength + array.byteLength);
                tmp.set(lastUnit.data, 0);
                tmp.set(array, lastUnit.data.byteLength);
                lastUnit.data = tmp;
            }
        }
        track.naluState = state;
        return units;
    };
    /**
     * remove Emulation Prevention bytes from a RBSP
     */
    TSDemuxer.prototype.discardEPB = function (data) {
        var length = data.byteLength, EPBPositions = [], i = 1, newLength, newData;
        // Find all `Emulation Prevention Bytes`
        while (i < length - 2) {
            if (data[i] === 0 &&
                data[i + 1] === 0 &&
                data[i + 2] === 0x03) {
                EPBPositions.push(i + 2);
                i += 2;
            }
            else {
                i++;
            }
        }
        // If no Emulation Prevention Bytes were found just return the original
        // array
        if (EPBPositions.length === 0) {
            return data;
        }
        // Create a new array to hold the NAL unit data
        newLength = length - EPBPositions.length;
        newData = new Uint8Array(newLength);
        var sourceIndex = 0;
        for (i = 0; i < newLength; sourceIndex++, i++) {
            if (sourceIndex === EPBPositions[0]) {
                // Skip this byte
                sourceIndex++;
                // Remove this position index
                EPBPositions.shift();
            }
            newData[i] = data[sourceIndex];
        }
        return newData;
    };
    TSDemuxer.prototype._parseAACPES = function (pes) {
        var track = this._audioTrack, data = pes.data, pts = pes.pts, startOffset = 0, aacOverFlow = this.aacOverFlow, aacLastPTS = this.aacLastPTS, frameDuration, frameIndex, offset, stamp, len;
        if (aacOverFlow) {
            var tmp = new Uint8Array(aacOverFlow.byteLength + data.byteLength);
            tmp.set(aacOverFlow, 0);
            tmp.set(data, aacOverFlow.byteLength);
            // logger.log(`AAC: append overflowing ${aacOverFlow.byteLength} bytes to beginning of new PES`);
            data = tmp;
        }
        // look for ADTS header (0xFFFx)
        for (offset = startOffset, len = data.length; offset < len - 1; offset++) {
            if (ADTS.isHeader(data, offset)) {
                break;
            }
        }
        // if ADTS header does not start straight from the beginning of the PES payload, raise an error
        if (offset) {
            var reason = void 0, fatal = void 0;
            if (offset < len - 1) {
                reason = "AAC PES did not start with ADTS header,offset:" + offset;
                fatal = false;
            }
            else {
                reason = 'no ADTS header found in AAC PES';
                fatal = true;
            }
            logger_1.logger.warn("parsing error:" + reason);
            this.observer.trigger(events_1.default.ERROR, { type: errors_1.ErrorTypes.MEDIA_ERROR, details: errors_1.ErrorDetails.FRAG_PARSING_ERROR, fatal: fatal, reason: reason });
            if (fatal) {
                return;
            }
        }
        ADTS.initTrackConfig(track, this.observer, data, offset, this.audioCodec);
        frameIndex = 0;
        frameDuration = ADTS.getFrameDuration(track.samplerate);
        // if last AAC frame is overflowing, we should ensure timestamps are contiguous:
        // first sample PTS should be equal to last sample PTS + frameDuration
        if (aacOverFlow && aacLastPTS) {
            var newPTS = aacLastPTS + frameDuration;
            if (Math.abs(newPTS - pts) > 1) {
                logger_1.logger.log("AAC: align PTS for overlapping frames by " + Math.round((newPTS - pts) / 90));
                pts = newPTS;
            }
        }
        // scan for aac samples
        while (offset < len) {
            if (ADTS.isHeader(data, offset) && (offset + 5) < len) {
                var frame = ADTS.appendFrame(track, data, offset, pts, frameIndex);
                if (frame) {
                    // logger.log(`${Math.round(frame.sample.pts)} : AAC`);
                    offset += frame.length;
                    stamp = frame.sample.pts;
                    frameIndex++;
                }
                else {
                    // logger.log('Unable to parse AAC frame');
                    break;
                }
            }
            else {
                // nothing found, keep looking
                offset++;
            }
        }
        if (offset < len) {
            aacOverFlow = data.subarray(offset, len);
            // logger.log(`AAC: overflow detected:${len-offset}`);
        }
        else {
            aacOverFlow = null;
        }
        this.aacOverFlow = aacOverFlow;
        this.aacLastPTS = stamp;
    };
    TSDemuxer.prototype._parseMPEGPES = function (pes) {
        var data = pes.data;
        var length = data.length;
        var frameIndex = 0;
        var offset = 0;
        var pts = pes.pts;
        while (offset < length) {
            if (mpegaudio_1.default.isHeader(data, offset)) {
                var frame = mpegaudio_1.default.appendFrame(this._audioTrack, data, offset, pts, frameIndex);
                if (frame) {
                    offset += frame.length;
                    frameIndex++;
                }
                else {
                    // logger.log('Unable to parse Mpeg audio frame');
                    break;
                }
            }
            else {
                // nothing found, keep looking
                offset++;
            }
        }
    };
    TSDemuxer.prototype._parseID3PES = function (pes) {
        this._id3Track.samples.push(pes);
    };
    return TSDemuxer;
}());
exports.default = TSDemuxer;


/***/ }),

/***/ "./src/errors.js":
/*!***********************!*\
  !*** ./src/errors.js ***!
  \***********************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.ErrorTypes = {
    // Identifier for a network error (loading error / timeout ...)
    NETWORK_ERROR: 'networkError',
    // Identifier for a media Error (video/parsing/mediasource error)
    MEDIA_ERROR: 'mediaError',
    // EME (encrypted media extensions) errors
    KEY_SYSTEM_ERROR: 'keySystemError',
    // Identifier for a mux Error (demuxing/remuxing)
    MUX_ERROR: 'muxError',
    // Identifier for all other errors
    OTHER_ERROR: 'otherError'
};
/**
 * @enum {ErrorDetails}
 * @typedef {string} ErrorDetail
 */
exports.ErrorDetails = {
    KEY_SYSTEM_NO_KEYS: 'keySystemNoKeys',
    KEY_SYSTEM_NO_ACCESS: 'keySystemNoAccess',
    KEY_SYSTEM_NO_SESSION: 'keySystemNoSession',
    KEY_SYSTEM_LICENSE_REQUEST_FAILED: 'keySystemLicenseRequestFailed',
    // Identifier for a manifest load error - data: { url : faulty URL, response : { code: error code, text: error text }}
    MANIFEST_LOAD_ERROR: 'manifestLoadError',
    // Identifier for a manifest load timeout - data: { url : faulty URL, response : { code: error code, text: error text }}
    MANIFEST_LOAD_TIMEOUT: 'manifestLoadTimeOut',
    // Identifier for a manifest parsing error - data: { url : faulty URL, reason : error reason}
    MANIFEST_PARSING_ERROR: 'manifestParsingError',
    // Identifier for a manifest with only incompatible codecs error - data: { url : faulty URL, reason : error reason}
    MANIFEST_INCOMPATIBLE_CODECS_ERROR: 'manifestIncompatibleCodecsError',
    // Identifier for a level load error - data: { url : faulty URL, response : { code: error code, text: error text }}
    LEVEL_LOAD_ERROR: 'levelLoadError',
    // Identifier for a level load timeout - data: { url : faulty URL, response : { code: error code, text: error text }}
    LEVEL_LOAD_TIMEOUT: 'levelLoadTimeOut',
    // Identifier for a level switch error - data: { level : faulty level Id, event : error description}
    LEVEL_SWITCH_ERROR: 'levelSwitchError',
    // Identifier for an audio track load error - data: { url : faulty URL, response : { code: error code, text: error text }}
    AUDIO_TRACK_LOAD_ERROR: 'audioTrackLoadError',
    // Identifier for an audio track load timeout - data: { url : faulty URL, response : { code: error code, text: error text }}
    AUDIO_TRACK_LOAD_TIMEOUT: 'audioTrackLoadTimeOut',
    // Identifier for fragment load error - data: { frag : fragment object, response : { code: error code, text: error text }}
    FRAG_LOAD_ERROR: 'fragLoadError',
    // Identifier for fragment load timeout error - data: { frag : fragment object}
    FRAG_LOAD_TIMEOUT: 'fragLoadTimeOut',
    // Identifier for a fragment decryption error event - data: {id : demuxer Id,frag: fragment object, reason : parsing error description }
    FRAG_DECRYPT_ERROR: 'fragDecryptError',
    // Identifier for a fragment parsing error event - data: { id : demuxer Id, reason : parsing error description }
    // will be renamed DEMUX_PARSING_ERROR and switched to MUX_ERROR in the next major release
    FRAG_PARSING_ERROR: 'fragParsingError',
    // Identifier for a remux alloc error event - data: { id : demuxer Id, frag : fragment object, bytes : nb of bytes on which allocation failed , reason : error text }
    REMUX_ALLOC_ERROR: 'remuxAllocError',
    // Identifier for decrypt key load error - data: { frag : fragment object, response : { code: error code, text: error text }}
    KEY_LOAD_ERROR: 'keyLoadError',
    // Identifier for decrypt key load timeout error - data: { frag : fragment object}
    KEY_LOAD_TIMEOUT: 'keyLoadTimeOut',
    // Triggered when an exception occurs while adding a sourceBuffer to MediaSource - data : {  err : exception , mimeType : mimeType }
    BUFFER_ADD_CODEC_ERROR: 'bufferAddCodecError',
    // Identifier for a buffer append error - data: append error description
    BUFFER_APPEND_ERROR: 'bufferAppendError',
    // Identifier for a buffer appending error event - data: appending error description
    BUFFER_APPENDING_ERROR: 'bufferAppendingError',
    // Identifier for a buffer stalled error event
    BUFFER_STALLED_ERROR: 'bufferStalledError',
    // Identifier for a buffer full event
    BUFFER_FULL_ERROR: 'bufferFullError',
    // Identifier for a buffer seek over hole event
    BUFFER_SEEK_OVER_HOLE: 'bufferSeekOverHole',
    // Identifier for a buffer nudge on stall (playback is stuck although currentTime is in a buffered area)
    BUFFER_NUDGE_ON_STALL: 'bufferNudgeOnStall',
    // Identifier for an internal exception happening inside hls.js while handling an event
    INTERNAL_EXCEPTION: 'internalException'
};


/***/ }),

/***/ "./src/event-handler.js":
/*!******************************!*\
  !*** ./src/event-handler.js ***!
  \******************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
*
* All objects in the event handling chain should inherit from this class
*
*/
Object.defineProperty(exports, "__esModule", { value: true });
var logger_1 = __webpack_require__(/*! ./utils/logger */ "./src/utils/logger.js");
var errors_1 = __webpack_require__(/*! ./errors */ "./src/errors.js");
var events_1 = __webpack_require__(/*! ./events */ "./src/events.js");
var FORBIDDEN_EVENT_NAMES = {
    'hlsEventGeneric': true,
    'hlsHandlerDestroying': true,
    'hlsHandlerDestroyed': true
};
var EventHandler = /** @class */ (function () {
    function EventHandler(hls) {
        var events = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            events[_i - 1] = arguments[_i];
        }
        this.hls = hls;
        this.onEvent = this.onEvent.bind(this);
        this.handledEvents = events;
        this.useGenericHandler = true;
        this.registerListeners();
    }
    EventHandler.prototype.destroy = function () {
        this.onHandlerDestroying();
        this.unregisterListeners();
        this.onHandlerDestroyed();
    };
    EventHandler.prototype.onHandlerDestroying = function () { };
    EventHandler.prototype.onHandlerDestroyed = function () { };
    EventHandler.prototype.isEventHandler = function () {
        return typeof this.handledEvents === 'object' && this.handledEvents.length && typeof this.onEvent === 'function';
    };
    EventHandler.prototype.registerListeners = function () {
        if (this.isEventHandler()) {
            this.handledEvents.forEach(function (event) {
                if (FORBIDDEN_EVENT_NAMES[event]) {
                    throw new Error('Forbidden event-name: ' + event);
                }
                this.hls.on(event, this.onEvent);
            }, this);
        }
    };
    EventHandler.prototype.unregisterListeners = function () {
        if (this.isEventHandler()) {
            this.handledEvents.forEach(function (event) {
                this.hls.off(event, this.onEvent);
            }, this);
        }
    };
    /**
     * arguments: event (string), data (any)
     */
    EventHandler.prototype.onEvent = function (event, data) {
        this.onEventGeneric(event, data);
    };
    EventHandler.prototype.onEventGeneric = function (event, data) {
        var eventToFunction = function (event, data) {
            var funcName = 'on' + event.replace('hls', '');
            if (typeof this[funcName] !== 'function') {
                throw new Error("Event " + event + " has no generic handler in this " + this.constructor.name + " class (tried " + funcName + ")");
            }
            return this[funcName].bind(this, data);
        };
        try {
            eventToFunction.call(this, event, data).call();
        }
        catch (err) {
            logger_1.logger.error("An internal error happened while handling event " + event + ". Error message: \"" + err.message + "\". Here is a stacktrace:", err);
            this.hls.trigger(events_1.default.ERROR, { type: errors_1.ErrorTypes.OTHER_ERROR, details: errors_1.ErrorDetails.INTERNAL_EXCEPTION, fatal: false, event: event, err: err });
        }
    };
    return EventHandler;
}());
exports.default = EventHandler;


/***/ }),

/***/ "./src/events.js":
/*!***********************!*\
  !*** ./src/events.js ***!
  \***********************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @readonly
 * @enum {string}
 */
var HlsEvents = {
    // fired before MediaSource is attaching to media element - data: { media }
    MEDIA_ATTACHING: 'hlsMediaAttaching',
    // fired when MediaSource has been succesfully attached to media element - data: { }
    MEDIA_ATTACHED: 'hlsMediaAttached',
    // fired before detaching MediaSource from media element - data: { }
    MEDIA_DETACHING: 'hlsMediaDetaching',
    // fired when MediaSource has been detached from media element - data: { }
    MEDIA_DETACHED: 'hlsMediaDetached',
    // fired when we buffer is going to be reset - data: { }
    BUFFER_RESET: 'hlsBufferReset',
    // fired when we know about the codecs that we need buffers for to push into - data: {tracks : { container, codec, levelCodec, initSegment, metadata }}
    BUFFER_CODECS: 'hlsBufferCodecs',
    // fired when sourcebuffers have been created - data: { tracks : tracks }
    BUFFER_CREATED: 'hlsBufferCreated',
    // fired when we append a segment to the buffer - data: { segment: segment object }
    BUFFER_APPENDING: 'hlsBufferAppending',
    // fired when we are done with appending a media segment to the buffer - data : { parent : segment parent that triggered BUFFER_APPENDING, pending : nb of segments waiting for appending for this segment parent}
    BUFFER_APPENDED: 'hlsBufferAppended',
    // fired when the stream is finished and we want to notify the media buffer that there will be no more data - data: { }
    BUFFER_EOS: 'hlsBufferEos',
    // fired when the media buffer should be flushed - data { startOffset, endOffset }
    BUFFER_FLUSHING: 'hlsBufferFlushing',
    // fired when the media buffer has been flushed - data: { }
    BUFFER_FLUSHED: 'hlsBufferFlushed',
    // fired to signal that a manifest loading starts - data: { url : manifestURL}
    MANIFEST_LOADING: 'hlsManifestLoading',
    // fired after manifest has been loaded - data: { levels : [available quality levels], audioTracks : [ available audio tracks], url : manifestURL, stats : { trequest, tfirst, tload, mtime}}
    MANIFEST_LOADED: 'hlsManifestLoaded',
    // fired after manifest has been parsed - data: { levels : [available quality levels], firstLevel : index of first quality level appearing in Manifest}
    MANIFEST_PARSED: 'hlsManifestParsed',
    // fired when a level switch is requested - data: { level : id of new level }
    LEVEL_SWITCHING: 'hlsLevelSwitching',
    // fired when a level switch is effective - data: { level : id of new level }
    LEVEL_SWITCHED: 'hlsLevelSwitched',
    // fired when a level playlist loading starts - data: { url : level URL, level : id of level being loaded}
    LEVEL_LOADING: 'hlsLevelLoading',
    // fired when a level playlist loading finishes - data: { details : levelDetails object, level : id of loaded level, stats : { trequest, tfirst, tload, mtime} }
    LEVEL_LOADED: 'hlsLevelLoaded',
    // fired when a level's details have been updated based on previous details, after it has been loaded - data: { details : levelDetails object, level : id of updated level }
    LEVEL_UPDATED: 'hlsLevelUpdated',
    // fired when a level's PTS information has been updated after parsing a fragment - data: { details : levelDetails object, level : id of updated level, drift: PTS drift observed when parsing last fragment }
    LEVEL_PTS_UPDATED: 'hlsLevelPtsUpdated',
    // fired to notify that audio track lists has been updated - data: { audioTracks : audioTracks }
    AUDIO_TRACKS_UPDATED: 'hlsAudioTracksUpdated',
    // fired when an audio track switching is requested - data: { id : audio track id }
    AUDIO_TRACK_SWITCHING: 'hlsAudioTrackSwitching',
    // fired when an audio track switch actually occurs - data: { id : audio track id }
    AUDIO_TRACK_SWITCHED: 'hlsAudioTrackSwitched',
    // fired when an audio track loading starts - data: { url : audio track URL, id : audio track id }
    AUDIO_TRACK_LOADING: 'hlsAudioTrackLoading',
    // fired when an audio track loading finishes - data: { details : levelDetails object, id : audio track id, stats : { trequest, tfirst, tload, mtime } }
    AUDIO_TRACK_LOADED: 'hlsAudioTrackLoaded',
    // fired to notify that subtitle track lists has been updated - data: { subtitleTracks : subtitleTracks }
    SUBTITLE_TRACKS_UPDATED: 'hlsSubtitleTracksUpdated',
    // fired when an subtitle track switch occurs - data: { id : subtitle track id }
    SUBTITLE_TRACK_SWITCH: 'hlsSubtitleTrackSwitch',
    // fired when a subtitle track loading starts - data: { url : subtitle track URL, id : subtitle track id }
    SUBTITLE_TRACK_LOADING: 'hlsSubtitleTrackLoading',
    // fired when a subtitle track loading finishes - data: { details : levelDetails object, id : subtitle track id, stats : { trequest, tfirst, tload, mtime } }
    SUBTITLE_TRACK_LOADED: 'hlsSubtitleTrackLoaded',
    // fired when a subtitle fragment has been processed - data: { success : boolean, frag : the processed frag }
    SUBTITLE_FRAG_PROCESSED: 'hlsSubtitleFragProcessed',
    // fired when the first timestamp is found - data: { id : demuxer id, initPTS: initPTS, frag : fragment object }
    INIT_PTS_FOUND: 'hlsInitPtsFound',
    // fired when a fragment loading starts - data: { frag : fragment object }
    FRAG_LOADING: 'hlsFragLoading',
    // fired when a fragment loading is progressing - data: { frag : fragment object, { trequest, tfirst, loaded } }
    FRAG_LOAD_PROGRESS: 'hlsFragLoadProgress',
    // Identifier for fragment load aborting for emergency switch down - data: { frag : fragment object }
    FRAG_LOAD_EMERGENCY_ABORTED: 'hlsFragLoadEmergencyAborted',
    // fired when a fragment loading is completed - data: { frag : fragment object, payload : fragment payload, stats : { trequest, tfirst, tload, length } }
    FRAG_LOADED: 'hlsFragLoaded',
    // fired when a fragment has finished decrypting - data: { id : demuxer id, frag: fragment object, payload : fragment payload, stats : { tstart, tdecrypt } }
    FRAG_DECRYPTED: 'hlsFragDecrypted',
    // fired when Init Segment has been extracted from fragment - data: { id : demuxer id, frag: fragment object, moov : moov MP4 box, codecs : codecs found while parsing fragment }
    FRAG_PARSING_INIT_SEGMENT: 'hlsFragParsingInitSegment',
    // fired when parsing sei text is completed - data: { id : demuxer id, frag: fragment object, samples : [ sei samples pes ] }
    FRAG_PARSING_USERDATA: 'hlsFragParsingUserdata',
    // fired when parsing id3 is completed - data: { id : demuxer id, frag: fragment object, samples : [ id3 samples pes ] }
    FRAG_PARSING_METADATA: 'hlsFragParsingMetadata',
    // fired when data have been extracted from fragment - data: { id : demuxer id, frag: fragment object, data1 : moof MP4 box or TS fragments, data2 : mdat MP4 box or null}
    FRAG_PARSING_DATA: 'hlsFragParsingData',
    // fired when fragment parsing is completed - data: { id : demuxer id, frag: fragment object }
    FRAG_PARSED: 'hlsFragParsed',
    // fired when fragment remuxed MP4 boxes have all been appended into SourceBuffer - data: { id : demuxer id, frag : fragment object, stats : { trequest, tfirst, tload, tparsed, tbuffered, length, bwEstimate } }
    FRAG_BUFFERED: 'hlsFragBuffered',
    // fired when fragment matching with current media position is changing - data : { id : demuxer id, frag : fragment object }
    FRAG_CHANGED: 'hlsFragChanged',
    // Identifier for a FPS drop event - data: { curentDropped, currentDecoded, totalDroppedFrames }
    FPS_DROP: 'hlsFpsDrop',
    // triggered when FPS drop triggers auto level capping - data: { level, droppedlevel }
    FPS_DROP_LEVEL_CAPPING: 'hlsFpsDropLevelCapping',
    // Identifier for an error event - data: { type : error type, details : error details, fatal : if true, hls.js cannot/will not try to recover, if false, hls.js will try to recover,other error specific data }
    ERROR: 'hlsError',
    // fired when hls.js instance starts destroying. Different from MEDIA_DETACHED as one could want to detach and reattach a media to the instance of hls.js to handle mid-rolls for example - data: { }
    DESTROYING: 'hlsDestroying',
    // fired when a decrypt key loading starts - data: { frag : fragment object }
    KEY_LOADING: 'hlsKeyLoading',
    // fired when a decrypt key loading is completed - data: { frag : fragment object, payload : key payload, stats : { trequest, tfirst, tload, length } }
    KEY_LOADED: 'hlsKeyLoaded',
    // fired upon stream controller state transitions - data: { previousState, nextState }
    STREAM_STATE_TRANSITION: 'hlsStreamStateTransition'
};
exports.default = HlsEvents;


/***/ }),

/***/ "./src/hls.js":
/*!********************!*\
  !*** ./src/hls.js ***!
  \********************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var URLToolkit = __webpack_require__(/*! url-toolkit */ "./node_modules/url-toolkit/src/url-toolkit.js");
var errors_1 = __webpack_require__(/*! ./errors */ "./src/errors.js");
var playlist_loader_1 = __webpack_require__(/*! ./loader/playlist-loader */ "./src/loader/playlist-loader.js");
var fragment_loader_1 = __webpack_require__(/*! ./loader/fragment-loader */ "./src/loader/fragment-loader.js");
var key_loader_1 = __webpack_require__(/*! ./loader/key-loader */ "./src/loader/key-loader.js");
var fragment_tracker_1 = __webpack_require__(/*! ./controller/fragment-tracker */ "./src/controller/fragment-tracker.js");
var stream_controller_1 = __webpack_require__(/*! ./controller/stream-controller */ "./src/controller/stream-controller.js");
var level_controller_1 = __webpack_require__(/*! ./controller/level-controller */ "./src/controller/level-controller.js");
var id3_track_controller_1 = __webpack_require__(/*! ./controller/id3-track-controller */ "./src/controller/id3-track-controller.js");
var is_supported_1 = __webpack_require__(/*! ./is-supported */ "./src/is-supported.js");
var logger_1 = __webpack_require__(/*! ./utils/logger */ "./src/utils/logger.js");
var config_1 = __webpack_require__(/*! ./config */ "./src/config.js");
var events_1 = __webpack_require__(/*! ./events */ "./src/events.js");
var observer_1 = __webpack_require__(/*! ./observer */ "./src/observer.js");
/**
 * @module Hls
 * @class
 * @constructor
 */
var Hls = /** @class */ (function (_super) {
    __extends(Hls, _super);
    /**
     * Creates an instance of an HLS client that can attach to exactly one `HTMLMediaElement`.
     *
     * @constructs Hls
     * @param {HlsConfig} config
     */
    function Hls(config) {
        if (config === void 0) { config = {}; }
        var _this = _super.call(this) || this;
        var defaultConfig = Hls.DefaultConfig;
        if ((config.liveSyncDurationCount || config.liveMaxLatencyDurationCount) && (config.liveSyncDuration || config.liveMaxLatencyDuration)) {
            throw new Error('Illegal hls.js config: don\'t mix up liveSyncDurationCount/liveMaxLatencyDurationCount and liveSyncDuration/liveMaxLatencyDuration');
        }
        for (var prop in defaultConfig) {
            if (prop in config)
                continue;
            config[prop] = defaultConfig[prop];
        }
        if (config.liveMaxLatencyDurationCount !== undefined && config.liveMaxLatencyDurationCount <= config.liveSyncDurationCount) {
            throw new Error('Illegal hls.js config: "liveMaxLatencyDurationCount" must be gt "liveSyncDurationCount"');
        }
        if (config.liveMaxLatencyDuration !== undefined && (config.liveMaxLatencyDuration <= config.liveSyncDuration || config.liveSyncDuration === undefined)) {
            throw new Error('Illegal hls.js config: "liveMaxLatencyDuration" must be gt "liveSyncDuration"');
        }
        logger_1.enableLogs(config.debug);
        _this.config = config;
        _this._autoLevelCapping = -1;
        // core controllers and network loaders
        /**
         * @member {AbrController} abrController
         */
        var abrController = _this.abrController = new config.abrController(_this);
        var bufferController = new config.bufferController(_this);
        var capLevelController = new config.capLevelController(_this);
        var fpsController = new config.fpsController(_this);
        var playListLoader = new playlist_loader_1.default(_this);
        var fragmentLoader = new fragment_loader_1.default(_this);
        var keyLoader = new key_loader_1.default(_this);
        var id3TrackController = new id3_track_controller_1.default(_this);
        // network controllers
        /**
         * @member {LevelController} levelController
         */
        var levelController = _this.levelController = new level_controller_1.default(_this);
        // FIXME: FragmentTracker must be defined before StreamController because the order of event handling is important
        var fragmentTracker = new fragment_tracker_1.FragmentTracker(_this);
        /**
         * @member {StreamController} streamController
         */
        var streamController = _this.streamController = new stream_controller_1.default(_this, fragmentTracker);
        var networkControllers = [levelController, streamController];
        // optional audio stream controller
        /**
         * @var {ICoreComponent | Controller}
         */
        var Controller = config.audioStreamController;
        if (Controller) {
            networkControllers.push(new Controller(_this, fragmentTracker));
        }
        /**
         * @member {INetworkController[]} networkControllers
         */
        _this.networkControllers = networkControllers;
        /**
         * @var {ICoreComponent[]}
         */
        var coreComponents = [
            playListLoader,
            fragmentLoader,
            keyLoader,
            abrController,
            bufferController,
            capLevelController,
            fpsController,
            id3TrackController,
            fragmentTracker
        ];
        // optional audio track and subtitle controller
        Controller = config.audioTrackController;
        if (Controller) {
            var audioTrackController = new Controller(_this);
            /**
             * @member {AudioTrackController} audioTrackController
             */
            _this.audioTrackController = audioTrackController;
            coreComponents.push(audioTrackController);
        }
        Controller = config.subtitleTrackController;
        if (Controller) {
            var subtitleTrackController = new Controller(_this);
            /**
             * @member {SubtitleTrackController} subtitleTrackController
             */
            _this.subtitleTrackController = subtitleTrackController;
            networkControllers.push(subtitleTrackController);
        }
        Controller = config.emeController;
        if (Controller) {
            var emeController = new Controller(_this);
            /**
             * @member {EMEController} emeController
             */
            _this.emeController = emeController;
            coreComponents.push(emeController);
        }
        // optional subtitle controllers
        Controller = config.subtitleStreamController;
        if (Controller) {
            networkControllers.push(new Controller(_this, fragmentTracker));
        }
        Controller = config.timelineController;
        if (Controller) {
            coreComponents.push(new Controller(_this));
        }
        /**
         * @member {ICoreComponent[]}
         */
        _this.coreComponents = coreComponents;
        return _this;
    }
    Object.defineProperty(Hls, "version", {
        /**
         * @type {string}
         */
        get: function () {
            return "0.12.4";
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @type {boolean}
     */
    Hls.isSupported = function () {
        return is_supported_1.isSupported();
    };
    Object.defineProperty(Hls, "Events", {
        /**
         * @type {HlsEvents}
         */
        get: function () {
            return events_1.default;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Hls, "ErrorTypes", {
        /**
         * @type {HlsErrorTypes}
         */
        get: function () {
            return errors_1.ErrorTypes;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Hls, "ErrorDetails", {
        /**
         * @type {HlsErrorDetails}
         */
        get: function () {
            return errors_1.ErrorDetails;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Hls, "DefaultConfig", {
        /**
         * @type {HlsConfig}
         */
        get: function () {
            if (!Hls.defaultConfig) {
                return config_1.hlsDefaultConfig;
            }
            return Hls.defaultConfig;
        },
        /**
         * @type {HlsConfig}
         */
        set: function (defaultConfig) {
            Hls.defaultConfig = defaultConfig;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Dispose of the instance
     */
    Hls.prototype.destroy = function () {
        logger_1.logger.log('destroy');
        this.trigger(events_1.default.DESTROYING);
        this.detachMedia();
        this.coreComponents.concat(this.networkControllers).forEach(function (component) {
            component.destroy();
        });
        this.url = null;
        this.removeAllListeners();
        this._autoLevelCapping = -1;
    };
    /**
     * Attach a media element
     * @param {HTMLMediaElement} media
     */
    Hls.prototype.attachMedia = function (media) {
        logger_1.logger.log('attachMedia');
        this.media = media;
        this.trigger(events_1.default.MEDIA_ATTACHING, { media: media });
    };
    /**
     * Detach from the media
     */
    Hls.prototype.detachMedia = function () {
        logger_1.logger.log('detachMedia');
        this.trigger(events_1.default.MEDIA_DETACHING);
        this.media = null;
    };
    /**
     * Set the source URL. Can be relative or absolute.
     * @param {string} url
     */
    Hls.prototype.loadSource = function (url) {
        url = URLToolkit.buildAbsoluteURL(window.location.href, url, { alwaysNormalize: true });
        logger_1.logger.log("loadSource:" + url);
        this.url = url;
        // when attaching to a source URL, trigger a playlist load
        this.trigger(events_1.default.MANIFEST_LOADING, { url: url });
    };
    /**
     * Start loading data from the stream source.
     * Depending on default config, client starts loading automatically when a source is set.
     *
     * @param {number} startPosition Set the start position to stream from
     * @default -1 None (from earliest point)
     */
    Hls.prototype.startLoad = function (startPosition) {
        if (startPosition === void 0) { startPosition = -1; }
        logger_1.logger.log("startLoad(" + startPosition + ")");
        this.networkControllers.forEach(function (controller) {
            controller.startLoad(startPosition);
        });
    };
    /**
     * Stop loading of any stream data.
     */
    Hls.prototype.stopLoad = function () {
        logger_1.logger.log('stopLoad');
        this.networkControllers.forEach(function (controller) {
            controller.stopLoad();
        });
    };
    /**
     * Swap through possible audio codecs in the stream (for example to switch from stereo to 5.1)
     */
    Hls.prototype.swapAudioCodec = function () {
        logger_1.logger.log('swapAudioCodec');
        this.streamController.swapAudioCodec();
    };
    /**
     * When the media-element fails, this allows to detach and then re-attach it
     * as one call (convenience method).
     *
     * Automatic recovery of media-errors by this process is configurable.
     */
    Hls.prototype.recoverMediaError = function () {
        logger_1.logger.log('recoverMediaError');
        var media = this.media;
        this.detachMedia();
        this.attachMedia(media);
    };
    Object.defineProperty(Hls.prototype, "levels", {
        /**
         * @type {QualityLevel[]}
         */
        get: function () {
            return this.levelController.levels;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Hls.prototype, "currentLevel", {
        /**
         * Index of quality level currently played
         * @type {number}
         */
        get: function () {
            return this.streamController.currentLevel;
        },
        /**
         * Set quality level index immediately .
         * This will flush the current buffer to replace the quality asap.
         * That means playback will interrupt at least shortly to re-buffer and re-sync eventually.
         * @type {number} -1 for automatic level selection
         */
        set: function (newLevel) {
            logger_1.logger.log("set currentLevel:" + newLevel);
            this.loadLevel = newLevel;
            this.streamController.immediateLevelSwitch();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Hls.prototype, "nextLevel", {
        /**
         * Index of next quality level loaded as scheduled by stream controller.
         * @type {number}
         */
        get: function () {
            return this.streamController.nextLevel;
        },
        /**
         * Set quality level index for next loaded data.
         * This will switch the video quality asap, without interrupting playback.
         * May abort current loading of data, and flush parts of buffer (outside currently played fragment region).
         * @type {number} -1 for automatic level selection
         */
        set: function (newLevel) {
            logger_1.logger.log("set nextLevel:" + newLevel);
            this.levelController.manualLevel = newLevel;
            this.streamController.nextLevelSwitch();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Hls.prototype, "loadLevel", {
        /**
         * Return the quality level of the currently or last (of none is loaded currently) segment
         * @type {number}
         */
        get: function () {
            return this.levelController.level;
        },
        /**
         * Set quality level index for next loaded data in a conservative way.
         * This will switch the quality without flushing, but interrupt current loading.
         * Thus the moment when the quality switch will appear in effect will only be after the already existing buffer.
         * @type {number} newLevel -1 for automatic level selection
         */
        set: function (newLevel) {
            logger_1.logger.log("set loadLevel:" + newLevel);
            this.levelController.manualLevel = newLevel;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Hls.prototype, "nextLoadLevel", {
        /**
         * get next quality level loaded
         * @type {number}
         */
        get: function () {
            return this.levelController.nextLoadLevel;
        },
        /**
         * Set quality level of next loaded segment in a fully "non-destructive" way.
         * Same as `loadLevel` but will wait for next switch (until current loading is done).
         * @type {number} level
         */
        set: function (level) {
            this.levelController.nextLoadLevel = level;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Hls.prototype, "firstLevel", {
        /**
         * Return "first level": like a default level, if not set,
         * falls back to index of first level referenced in manifest
         * @type {number}
         */
        get: function () {
            return Math.max(this.levelController.firstLevel, this.minAutoLevel);
        },
        /**
         * Sets "first-level", see getter.
         * @type {number}
         */
        set: function (newLevel) {
            logger_1.logger.log("set firstLevel:" + newLevel);
            this.levelController.firstLevel = newLevel;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Hls.prototype, "startLevel", {
        /**
         * Return start level (level of first fragment that will be played back)
         * if not overrided by user, first level appearing in manifest will be used as start level
         * if -1 : automatic start level selection, playback will start from level matching download bandwidth
         * (determined from download of first segment)
         * @type {number}
         */
        get: function () {
            return this.levelController.startLevel;
        },
        /**
         * set  start level (level of first fragment that will be played back)
         * if not overrided by user, first level appearing in manifest will be used as start level
         * if -1 : automatic start level selection, playback will start from level matching download bandwidth
         * (determined from download of first segment)
         * @type {number} newLevel
         */
        set: function (newLevel) {
            logger_1.logger.log("set startLevel:" + newLevel);
            var hls = this;
            // if not in automatic start level detection, ensure startLevel is greater than minAutoLevel
            if (newLevel !== -1) {
                newLevel = Math.max(newLevel, hls.minAutoLevel);
            }
            hls.levelController.startLevel = newLevel;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Hls.prototype, "autoLevelCapping", {
        /**
         * Capping/max level value that should be used by automatic level selection algorithm (`ABRController`)
         * @type {number}
         */
        get: function () {
            return this._autoLevelCapping;
        },
        /**
         * Capping/max level value that should be used by automatic level selection algorithm (`ABRController`)
         * @type {number}
         */
        set: function (newLevel) {
            logger_1.logger.log("set autoLevelCapping:" + newLevel);
            this._autoLevelCapping = newLevel;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Hls.prototype, "autoLevelEnabled", {
        /**
         * True when automatic level selection enabled
         * @type {boolean}
         */
        get: function () {
            return (this.levelController.manualLevel === -1);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Hls.prototype, "manualLevel", {
        /**
         * Level set manually (if any)
         * @type {number}
         */
        get: function () {
            return this.levelController.manualLevel;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Hls.prototype, "minAutoLevel", {
        /**
         * min level selectable in auto mode according to config.minAutoBitrate
         * @type {number}
         */
        get: function () {
            var hls = this, levels = hls.levels, minAutoBitrate = hls.config.minAutoBitrate, len = levels ? levels.length : 0;
            for (var i = 0; i < len; i++) {
                var levelNextBitrate = levels[i].realBitrate ? Math.max(levels[i].realBitrate, levels[i].bitrate) : levels[i].bitrate;
                if (levelNextBitrate > minAutoBitrate) {
                    return i;
                }
            }
            return 0;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Hls.prototype, "maxAutoLevel", {
        /**
         * max level selectable in auto mode according to autoLevelCapping
         * @type {number}
         */
        get: function () {
            var hls = this;
            var levels = hls.levels;
            var autoLevelCapping = hls.autoLevelCapping;
            var maxAutoLevel;
            if (autoLevelCapping === -1 && levels && levels.length) {
                maxAutoLevel = levels.length - 1;
            }
            else {
                maxAutoLevel = autoLevelCapping;
            }
            return maxAutoLevel;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Hls.prototype, "nextAutoLevel", {
        /**
         * next automatically selected quality level
         * @type {number}
         */
        get: function () {
            var hls = this;
            // ensure next auto level is between  min and max auto level
            return Math.min(Math.max(hls.abrController.nextAutoLevel, hls.minAutoLevel), hls.maxAutoLevel);
        },
        /**
         * this setter is used to force next auto level.
         * this is useful to force a switch down in auto mode:
         * in case of load error on level N, hls.js can set nextAutoLevel to N-1 for example)
         * forced value is valid for one fragment. upon succesful frag loading at forced level,
         * this value will be resetted to -1 by ABR controller.
         * @type {number}
         */
        set: function (nextLevel) {
            var hls = this;
            hls.abrController.nextAutoLevel = Math.max(hls.minAutoLevel, nextLevel);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Hls.prototype, "audioTracks", {
        /**
         * @type {AudioTrack[]}
         */
        get: function () {
            var audioTrackController = this.audioTrackController;
            return audioTrackController ? audioTrackController.audioTracks : [];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Hls.prototype, "audioTrack", {
        /**
         * index of the selected audio track (index in audio track lists)
         * @type {number}
         */
        get: function () {
            var audioTrackController = this.audioTrackController;
            return audioTrackController ? audioTrackController.audioTrack : -1;
        },
        /**
         * selects an audio track, based on its index in audio track lists
         * @type {number}
         */
        set: function (audioTrackId) {
            var audioTrackController = this.audioTrackController;
            if (audioTrackController) {
                audioTrackController.audioTrack = audioTrackId;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Hls.prototype, "liveSyncPosition", {
        /**
         * @type {Seconds}
         */
        get: function () {
            return this.streamController.liveSyncPosition;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Hls.prototype, "subtitleTracks", {
        /**
         * get alternate subtitle tracks list from playlist
         * @type {SubtitleTrack[]}
         */
        get: function () {
            var subtitleTrackController = this.subtitleTrackController;
            return subtitleTrackController ? subtitleTrackController.subtitleTracks : [];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Hls.prototype, "subtitleTrack", {
        /**
         * index of the selected subtitle track (index in subtitle track lists)
         * @type {number}
         */
        get: function () {
            var subtitleTrackController = this.subtitleTrackController;
            return subtitleTrackController ? subtitleTrackController.subtitleTrack : -1;
        },
        /**
         * select an subtitle track, based on its index in subtitle track lists
         * @type{number}
         */
        set: function (subtitleTrackId) {
            var subtitleTrackController = this.subtitleTrackController;
            if (subtitleTrackController) {
                subtitleTrackController.subtitleTrack = subtitleTrackId;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Hls.prototype, "subtitleDisplay", {
        /**
         * @type {boolean}
         */
        get: function () {
            var subtitleTrackController = this.subtitleTrackController;
            return subtitleTrackController ? subtitleTrackController.subtitleDisplay : false;
        },
        /**
         * Enable/disable subtitle display rendering
         * @type {boolean}
         */
        set: function (value) {
            var subtitleTrackController = this.subtitleTrackController;
            if (subtitleTrackController) {
                subtitleTrackController.subtitleDisplay = value;
            }
        },
        enumerable: true,
        configurable: true
    });
    return Hls;
}(observer_1.Observer));
exports.default = Hls;


/***/ }),

/***/ "./src/is-supported.js":
/*!*****************************!*\
  !*** ./src/is-supported.js ***!
  \*****************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var mediasource_helper_1 = __webpack_require__(/*! ./utils/mediasource-helper */ "./src/utils/mediasource-helper.js");
function isSupported() {
    var mediaSource = mediasource_helper_1.getMediaSource();
    var sourceBuffer = window.SourceBuffer || window.WebKitSourceBuffer;
    var isTypeSupported = mediaSource &&
        typeof mediaSource.isTypeSupported === 'function' &&
        mediaSource.isTypeSupported('video/mp4; codecs="avc1.42E01E,mp4a.40.2"');
    // if SourceBuffer is exposed ensure its API is valid
    // safari and old version of Chrome doe not expose SourceBuffer globally so checking SourceBuffer.prototype is impossible
    var sourceBufferValidAPI = !sourceBuffer ||
        (sourceBuffer.prototype &&
            typeof sourceBuffer.prototype.appendBuffer === 'function' &&
            typeof sourceBuffer.prototype.remove === 'function');
    return !!isTypeSupported && !!sourceBufferValidAPI;
}
exports.isSupported = isSupported;


/***/ }),

/***/ "./src/loader/fragment-loader.js":
/*!***************************************!*\
  !*** ./src/loader/fragment-loader.js ***!
  \***************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Number) {
/*
 * Fragment Loader
*/
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var events_1 = __webpack_require__(/*! ../events */ "./src/events.js");
var event_handler_1 = __webpack_require__(/*! ../event-handler */ "./src/event-handler.js");
var errors_1 = __webpack_require__(/*! ../errors */ "./src/errors.js");
var logger_1 = __webpack_require__(/*! ../utils/logger */ "./src/utils/logger.js");
var FragmentLoader = /** @class */ (function (_super) {
    __extends(FragmentLoader, _super);
    function FragmentLoader(hls) {
        var _this = _super.call(this, hls, events_1.default.FRAG_LOADING) || this;
        _this.loaders = {};
        return _this;
    }
    FragmentLoader.prototype.destroy = function () {
        var loaders = this.loaders;
        for (var loaderName in loaders) {
            var loader = loaders[loaderName];
            if (loader) {
                loader.destroy();
            }
        }
        this.loaders = {};
        _super.prototype.destroy.call(this);
    };
    FragmentLoader.prototype.onFragLoading = function (data) {
        var frag = data.frag, type = frag.type, loaders = this.loaders, config = this.hls.config, FragmentILoader = config.fLoader, DefaultILoader = config.loader;
        // reset fragment state
        frag.loaded = 0;
        var loader = loaders[type];
        if (loader) {
            logger_1.logger.warn("abort previous fragment loader for type: " + type);
            loader.abort();
        }
        loader = loaders[type] = frag.loader =
            config.fLoader ? new FragmentILoader(config) : new DefaultILoader(config);
        var loaderContext, loaderConfig, loaderCallbacks;
        loaderContext = { url: frag.url, frag: frag, responseType: 'arraybuffer', progressData: false };
        var start = frag.byteRangeStartOffset, end = frag.byteRangeEndOffset;
        if (Number.isFinite(start) && Number.isFinite(end)) {
            loaderContext.rangeStart = start;
            loaderContext.rangeEnd = end;
        }
        loaderConfig = {
            timeout: config.fragLoadingTimeOut,
            maxRetry: 0,
            retryDelay: 0,
            maxRetryDelay: config.fragLoadingMaxRetryTimeout
        };
        loaderCallbacks = {
            onSuccess: this.loadsuccess.bind(this),
            onError: this.loaderror.bind(this),
            onTimeout: this.loadtimeout.bind(this),
            onProgress: this.loadprogress.bind(this)
        };
        loader.load(loaderContext, loaderConfig, loaderCallbacks);
    };
    FragmentLoader.prototype.loadsuccess = function (response, stats, context, networkDetails) {
        if (networkDetails === void 0) { networkDetails = null; }
        var payload = response.data, frag = context.frag;
        // detach fragment loader on load success
        frag.loader = undefined;
        this.loaders[frag.type] = undefined;
        this.hls.trigger(events_1.default.FRAG_LOADED, { payload: payload, frag: frag, stats: stats, networkDetails: networkDetails });
    };
    FragmentLoader.prototype.loaderror = function (response, context, networkDetails) {
        if (networkDetails === void 0) { networkDetails = null; }
        var frag = context.frag;
        var loader = frag.loader;
        if (loader) {
            loader.abort();
        }
        this.loaders[frag.type] = undefined;
        this.hls.trigger(events_1.default.ERROR, { type: errors_1.ErrorTypes.NETWORK_ERROR, details: errors_1.ErrorDetails.FRAG_LOAD_ERROR, fatal: false, frag: context.frag, response: response, networkDetails: networkDetails });
    };
    FragmentLoader.prototype.loadtimeout = function (stats, context, networkDetails) {
        if (networkDetails === void 0) { networkDetails = null; }
        var frag = context.frag;
        var loader = frag.loader;
        if (loader) {
            loader.abort();
        }
        this.loaders[frag.type] = undefined;
        this.hls.trigger(events_1.default.ERROR, { type: errors_1.ErrorTypes.NETWORK_ERROR, details: errors_1.ErrorDetails.FRAG_LOAD_TIMEOUT, fatal: false, frag: context.frag, networkDetails: networkDetails });
    };
    // data will be used for progressive parsing
    FragmentLoader.prototype.loadprogress = function (stats, context, data, networkDetails) {
        if (networkDetails === void 0) { networkDetails = null; }
        var frag = context.frag;
        frag.loaded = stats.loaded;
        this.hls.trigger(events_1.default.FRAG_LOAD_PROGRESS, { frag: frag, stats: stats, networkDetails: networkDetails });
    };
    return FragmentLoader;
}(event_handler_1.default));
exports.default = FragmentLoader;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./src/polyfills/number */ "./src/polyfills/number.js")["Number"]))

/***/ }),

/***/ "./src/loader/fragment.js":
/*!********************************!*\
  !*** ./src/loader/fragment.js ***!
  \********************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Number) {
Object.defineProperty(exports, "__esModule", { value: true });
var URLToolkit = __webpack_require__(/*! url-toolkit */ "./node_modules/url-toolkit/src/url-toolkit.js");
var level_key_1 = __webpack_require__(/*! ./level-key */ "./src/loader/level-key.js");
var Fragment = /** @class */ (function () {
    function Fragment() {
        var _a;
        this._url = null;
        this._byteRange = null;
        this._decryptdata = null;
        this.tagList = [];
        this.programDateTime = null;
        this.rawProgramDateTime = null;
        // Holds the types of data this fragment supports
        this._elementaryStreams = (_a = {},
            _a[Fragment.ElementaryStreamTypes.AUDIO] = false,
            _a[Fragment.ElementaryStreamTypes.VIDEO] = false,
            _a);
    }
    Object.defineProperty(Fragment, "ElementaryStreamTypes", {
        /**
         * `type` property for this._elementaryStreams
         *
         * @enum
         */
        get: function () {
            return {
                AUDIO: 'audio',
                VIDEO: 'video'
            };
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Fragment.prototype, "url", {
        get: function () {
            if (!this._url && this.relurl) {
                this._url = URLToolkit.buildAbsoluteURL(this.baseurl, this.relurl, { alwaysNormalize: true });
            }
            return this._url;
        },
        set: function (value) {
            this._url = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Fragment.prototype, "byteRange", {
        get: function () {
            if (!this._byteRange && !this.rawByteRange) {
                return [];
            }
            if (this._byteRange) {
                return this._byteRange;
            }
            var byteRange = [];
            if (this.rawByteRange) {
                var params = this.rawByteRange.split('@', 2);
                if (params.length === 1) {
                    var lastByteRangeEndOffset = this.lastByteRangeEndOffset;
                    byteRange[0] = lastByteRangeEndOffset || 0;
                }
                else {
                    byteRange[0] = parseInt(params[1]);
                }
                byteRange[1] = parseInt(params[0]) + byteRange[0];
                this._byteRange = byteRange;
            }
            return byteRange;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Fragment.prototype, "byteRangeStartOffset", {
        /**
         * @type {number}
         */
        get: function () {
            return this.byteRange[0];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Fragment.prototype, "byteRangeEndOffset", {
        get: function () {
            return this.byteRange[1];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Fragment.prototype, "decryptdata", {
        get: function () {
            if (!this._decryptdata) {
                this._decryptdata = this.fragmentDecryptdataFromLevelkey(this.levelkey, this.sn);
            }
            return this._decryptdata;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Fragment.prototype, "endProgramDateTime", {
        get: function () {
            if (!Number.isFinite(this.programDateTime)) {
                return null;
            }
            var duration = !Number.isFinite(this.duration) ? 0 : this.duration;
            return this.programDateTime + (duration * 1000);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Fragment.prototype, "encrypted", {
        get: function () {
            return !!((this.decryptdata && this.decryptdata.uri !== null) && (this.decryptdata.key === null));
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {ElementaryStreamType} type
     */
    Fragment.prototype.addElementaryStream = function (type) {
        this._elementaryStreams[type] = true;
    };
    /**
     * @param {ElementaryStreamType} type
     */
    Fragment.prototype.hasElementaryStream = function (type) {
        return this._elementaryStreams[type] === true;
    };
    /**
     * Utility method for parseLevelPlaylist to create an initialization vector for a given segment
     * @returns {Uint8Array}
     */
    Fragment.prototype.createInitializationVector = function (segmentNumber) {
        var uint8View = new Uint8Array(16);
        for (var i = 12; i < 16; i++) {
            uint8View[i] = (segmentNumber >> 8 * (15 - i)) & 0xff;
        }
        return uint8View;
    };
    /**
     * Utility method for parseLevelPlaylist to get a fragment's decryption data from the currently parsed encryption key data
     * @param levelkey - a playlist's encryption info
     * @param segmentNumber - the fragment's segment number
     * @returns {*} - an object to be applied as a fragment's decryptdata
     */
    Fragment.prototype.fragmentDecryptdataFromLevelkey = function (levelkey, segmentNumber) {
        var decryptdata = levelkey;
        if (levelkey && levelkey.method && levelkey.uri && !levelkey.iv) {
            decryptdata = new level_key_1.default();
            decryptdata.method = levelkey.method;
            decryptdata.baseuri = levelkey.baseuri;
            decryptdata.reluri = levelkey.reluri;
            decryptdata.iv = this.createInitializationVector(segmentNumber);
        }
        return decryptdata;
    };
    return Fragment;
}());
exports.default = Fragment;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./src/polyfills/number */ "./src/polyfills/number.js")["Number"]))

/***/ }),

/***/ "./src/loader/key-loader.js":
/*!**********************************!*\
  !*** ./src/loader/key-loader.js ***!
  \**********************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Decrypt key Loader
*/
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var events_1 = __webpack_require__(/*! ../events */ "./src/events.js");
var event_handler_1 = __webpack_require__(/*! ../event-handler */ "./src/event-handler.js");
var errors_1 = __webpack_require__(/*! ../errors */ "./src/errors.js");
var logger_1 = __webpack_require__(/*! ../utils/logger */ "./src/utils/logger.js");
var KeyLoader = /** @class */ (function (_super) {
    __extends(KeyLoader, _super);
    function KeyLoader(hls) {
        var _this = _super.call(this, hls, events_1.default.KEY_LOADING) || this;
        _this.loaders = {};
        _this.decryptkey = null;
        _this.decrypturl = null;
        return _this;
    }
    KeyLoader.prototype.destroy = function () {
        for (var loaderName in this.loaders) {
            var loader = this.loaders[loaderName];
            if (loader) {
                loader.destroy();
            }
        }
        this.loaders = {};
        event_handler_1.default.prototype.destroy.call(this);
    };
    KeyLoader.prototype.onKeyLoading = function (data) {
        var frag = data.frag, type = frag.type, loader = this.loaders[type], decryptdata = frag.decryptdata, uri = decryptdata.uri;
        // if uri is different from previous one or if decrypt key not retrieved yet
        if (uri !== this.decrypturl || this.decryptkey === null) {
            var config = this.hls.config;
            if (loader) {
                logger_1.logger.warn("abort previous key loader for type:" + type);
                loader.abort();
            }
            frag.loader = this.loaders[type] = new config.loader(config);
            this.decrypturl = uri;
            this.decryptkey = null;
            var loaderContext = void 0, loaderConfig = void 0, loaderCallbacks = void 0;
            loaderContext = { url: uri, frag: frag, responseType: 'arraybuffer' };
            // maxRetry is 0 so that instead of retrying the same key on the same variant multiple times,
            // key-loader will trigger an error and rely on stream-controller to handle retry logic.
            // this will also align retry logic with fragment-loader
            loaderConfig = { timeout: config.fragLoadingTimeOut, maxRetry: 0, retryDelay: config.fragLoadingRetryDelay, maxRetryDelay: config.fragLoadingMaxRetryTimeout };
            loaderCallbacks = { onSuccess: this.loadsuccess.bind(this), onError: this.loaderror.bind(this), onTimeout: this.loadtimeout.bind(this) };
            frag.loader.load(loaderContext, loaderConfig, loaderCallbacks);
        }
        else if (this.decryptkey) {
            // we already loaded this key, return it
            decryptdata.key = this.decryptkey;
            this.hls.trigger(events_1.default.KEY_LOADED, { frag: frag });
        }
    };
    KeyLoader.prototype.loadsuccess = function (response, stats, context) {
        var frag = context.frag;
        this.decryptkey = frag.decryptdata.key = new Uint8Array(response.data);
        // detach fragment loader on load success
        frag.loader = undefined;
        this.loaders[frag.type] = undefined;
        this.hls.trigger(events_1.default.KEY_LOADED, { frag: frag });
    };
    KeyLoader.prototype.loaderror = function (response, context) {
        var frag = context.frag, loader = frag.loader;
        if (loader) {
            loader.abort();
        }
        this.loaders[context.type] = undefined;
        this.hls.trigger(events_1.default.ERROR, { type: errors_1.ErrorTypes.NETWORK_ERROR, details: errors_1.ErrorDetails.KEY_LOAD_ERROR, fatal: false, frag: frag, response: response });
    };
    KeyLoader.prototype.loadtimeout = function (stats, context) {
        var frag = context.frag, loader = frag.loader;
        if (loader) {
            loader.abort();
        }
        this.loaders[context.type] = undefined;
        this.hls.trigger(events_1.default.ERROR, { type: errors_1.ErrorTypes.NETWORK_ERROR, details: errors_1.ErrorDetails.KEY_LOAD_TIMEOUT, fatal: false, frag: frag });
    };
    return KeyLoader;
}(event_handler_1.default));
exports.default = KeyLoader;


/***/ }),

/***/ "./src/loader/level-key.js":
/*!*********************************!*\
  !*** ./src/loader/level-key.js ***!
  \*********************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var URLToolkit = __webpack_require__(/*! url-toolkit */ "./node_modules/url-toolkit/src/url-toolkit.js");
var LevelKey = /** @class */ (function () {
    function LevelKey() {
        this.method = null;
        this.key = null;
        this.iv = null;
        this._uri = null;
    }
    Object.defineProperty(LevelKey.prototype, "uri", {
        get: function () {
            if (!this._uri && this.reluri) {
                this._uri = URLToolkit.buildAbsoluteURL(this.baseuri, this.reluri, { alwaysNormalize: true });
            }
            return this._uri;
        },
        enumerable: true,
        configurable: true
    });
    return LevelKey;
}());
exports.default = LevelKey;


/***/ }),

/***/ "./src/loader/level.js":
/*!*****************************!*\
  !*** ./src/loader/level.js ***!
  \*****************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Number) {
Object.defineProperty(exports, "__esModule", { value: true });
var Level = /** @class */ (function () {
    function Level(baseUrl) {
        // Please keep properties in alphabetical order
        this.endCC = 0;
        this.endSN = 0;
        this.fragments = [];
        this.initSegment = null;
        this.live = true;
        this.needSidxRanges = false;
        this.startCC = 0;
        this.startSN = 0;
        this.startTimeOffset = null;
        this.targetduration = 0;
        this.totalduration = 0;
        this.type = null;
        this.url = baseUrl;
        this.version = null;
    }
    Object.defineProperty(Level.prototype, "hasProgramDateTime", {
        get: function () {
            return !!(this.fragments[0] && Number.isFinite(this.fragments[0].programDateTime));
        },
        enumerable: true,
        configurable: true
    });
    return Level;
}());
exports.default = Level;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./src/polyfills/number */ "./src/polyfills/number.js")["Number"]))

/***/ }),

/***/ "./src/loader/m3u8-parser.js":
/*!***********************************!*\
  !*** ./src/loader/m3u8-parser.js ***!
  \***********************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Number) {
Object.defineProperty(exports, "__esModule", { value: true });
var URLToolkit = __webpack_require__(/*! url-toolkit */ "./node_modules/url-toolkit/src/url-toolkit.js");
var fragment_1 = __webpack_require__(/*! ./fragment */ "./src/loader/fragment.js");
var level_1 = __webpack_require__(/*! ./level */ "./src/loader/level.js");
var level_key_1 = __webpack_require__(/*! ./level-key */ "./src/loader/level-key.js");
var attr_list_1 = __webpack_require__(/*! ../utils/attr-list */ "./src/utils/attr-list.js");
var logger_1 = __webpack_require__(/*! ../utils/logger */ "./src/utils/logger.js");
var codecs_1 = __webpack_require__(/*! ../utils/codecs */ "./src/utils/codecs.js");
/**
 * M3U8 parser
 * @module
 */
// https://regex101.com is your friend
var MASTER_PLAYLIST_REGEX = /#EXT-X-STREAM-INF:([^\n\r]*)[\r\n]+([^\r\n]+)/g;
var MASTER_PLAYLIST_MEDIA_REGEX = /#EXT-X-MEDIA:(.*)/g;
var LEVEL_PLAYLIST_REGEX_FAST = new RegExp([
    /#EXTINF:\s*(\d*(?:\.\d+)?)(?:,(.*)\s+)?/.source,
    /|(?!#)([\S+ ?]+)/.source,
    /|#EXT-X-BYTERANGE:*(.+)/.source,
    /|#EXT-X-PROGRAM-DATE-TIME:(.+)/.source,
    /|#.*/.source // All other non-segment oriented tags will match with all groups empty
].join(''), 'g');
var LEVEL_PLAYLIST_REGEX_SLOW = /(?:(?:#(EXTM3U))|(?:#EXT-X-(PLAYLIST-TYPE):(.+))|(?:#EXT-X-(MEDIA-SEQUENCE): *(\d+))|(?:#EXT-X-(TARGETDURATION): *(\d+))|(?:#EXT-X-(KEY):(.+))|(?:#EXT-X-(START):(.+))|(?:#EXT-X-(ENDLIST))|(?:#EXT-X-(DISCONTINUITY-SEQ)UENCE:(\d+))|(?:#EXT-X-(DIS)CONTINUITY))|(?:#EXT-X-(VERSION):(\d+))|(?:#EXT-X-(MAP):(.+))|(?:(#)([^:]*):(.*))|(?:(#)(.*))(?:.*)\r?\n?/;
var MP4_REGEX_SUFFIX = /\.(mp4|m4s|m4v|m4a)$/i;
var M3U8Parser = /** @class */ (function () {
    function M3U8Parser() {
    }
    M3U8Parser.findGroup = function (groups, mediaGroupId) {
        if (!groups) {
            return null;
        }
        var matchingGroup = null;
        for (var i = 0; i < groups.length; i++) {
            var group = groups[i];
            if (group.id === mediaGroupId) {
                matchingGroup = group;
            }
        }
        return matchingGroup;
    };
    M3U8Parser.convertAVC1ToAVCOTI = function (codec) {
        var result, avcdata = codec.split('.');
        if (avcdata.length > 2) {
            result = avcdata.shift() + '.';
            result += parseInt(avcdata.shift()).toString(16);
            result += ('000' + parseInt(avcdata.shift()).toString(16)).substr(-4);
        }
        else {
            result = codec;
        }
        return result;
    };
    M3U8Parser.resolve = function (url, baseUrl) {
        return URLToolkit.buildAbsoluteURL(baseUrl, url, { alwaysNormalize: true });
    };
    M3U8Parser.parseMasterPlaylist = function (string, baseurl) {
        var levels = [], result;
        MASTER_PLAYLIST_REGEX.lastIndex = 0;
        function setCodecs(codecs, level) {
            ['video', 'audio'].forEach(function (type) {
                var filtered = codecs.filter(function (codec) { return codecs_1.isCodecType(codec, type); });
                if (filtered.length) {
                    var preferred = filtered.filter(function (codec) {
                        return codec.lastIndexOf('avc1', 0) === 0 || codec.lastIndexOf('mp4a', 0) === 0;
                    });
                    level[type + "Codec"] = preferred.length > 0 ? preferred[0] : filtered[0];
                    // remove from list
                    codecs = codecs.filter(function (codec) { return filtered.indexOf(codec) === -1; });
                }
            });
            level.unknownCodecs = codecs;
        }
        while ((result = MASTER_PLAYLIST_REGEX.exec(string)) != null) {
            var level = {};
            var attrs = level.attrs = new attr_list_1.default(result[1]);
            level.url = M3U8Parser.resolve(result[2], baseurl);
            var resolution = attrs.decimalResolution('RESOLUTION');
            if (resolution) {
                level.width = resolution.width;
                level.height = resolution.height;
            }
            level.bitrate = attrs.decimalInteger('AVERAGE-BANDWIDTH') || attrs.decimalInteger('BANDWIDTH');
            level.name = attrs.NAME;
            setCodecs([].concat((attrs.CODECS || '').split(/[ ,]+/)), level);
            if (level.videoCodec && level.videoCodec.indexOf('avc1') !== -1) {
                level.videoCodec = M3U8Parser.convertAVC1ToAVCOTI(level.videoCodec);
            }
            levels.push(level);
        }
        return levels;
    };
    M3U8Parser.parseMasterPlaylistMedia = function (string, baseurl, type, audioGroups) {
        if (audioGroups === void 0) { audioGroups = []; }
        var result;
        var medias = [];
        var id = 0;
        MASTER_PLAYLIST_MEDIA_REGEX.lastIndex = 0;
        while ((result = MASTER_PLAYLIST_MEDIA_REGEX.exec(string)) !== null) {
            var media = {};
            var attrs = new attr_list_1.default(result[1]);
            if (attrs.TYPE === type) {
                media.groupId = attrs['GROUP-ID'];
                media.name = attrs.NAME;
                media.type = type;
                media.default = (attrs.DEFAULT === 'YES');
                media.autoselect = (attrs.AUTOSELECT === 'YES');
                media.forced = (attrs.FORCED === 'YES');
                if (attrs.URI) {
                    media.url = M3U8Parser.resolve(attrs.URI, baseurl);
                }
                media.lang = attrs.LANGUAGE;
                if (!media.name) {
                    media.name = media.lang;
                }
                if (audioGroups.length) {
                    var groupCodec = M3U8Parser.findGroup(audioGroups, media.groupId);
                    media.audioCodec = groupCodec ? groupCodec.codec : audioGroups[0].codec;
                }
                media.id = id++;
                medias.push(media);
            }
        }
        return medias;
    };
    M3U8Parser.parseLevelPlaylist = function (string, baseurl, id, type, levelUrlId) {
        var currentSN = 0;
        var totalduration = 0;
        var level = new level_1.default(baseurl);
        var levelkey = new level_key_1.default();
        var cc = 0;
        var prevFrag = null;
        var frag = new fragment_1.default();
        var result;
        var i;
        var firstPdtIndex = null;
        LEVEL_PLAYLIST_REGEX_FAST.lastIndex = 0;
        while ((result = LEVEL_PLAYLIST_REGEX_FAST.exec(string)) !== null) {
            var duration = result[1];
            if (duration) { // INF
                frag.duration = parseFloat(duration);
                // avoid sliced strings    https://github.com/video-dev/hls.js/issues/939
                var title = (' ' + result[2]).slice(1);
                frag.title = title || null;
                frag.tagList.push(title ? ['INF', duration, title] : ['INF', duration]);
            }
            else if (result[3]) { // url
                if (Number.isFinite(frag.duration)) {
                    var sn = currentSN++;
                    frag.type = type;
                    frag.start = totalduration;
                    frag.levelkey = levelkey;
                    frag.sn = sn;
                    frag.level = id;
                    frag.cc = cc;
                    frag.urlId = levelUrlId;
                    frag.baseurl = baseurl;
                    // avoid sliced strings    https://github.com/video-dev/hls.js/issues/939
                    frag.relurl = (' ' + result[3]).slice(1);
                    assignProgramDateTime(frag, prevFrag);
                    level.fragments.push(frag);
                    prevFrag = frag;
                    totalduration += frag.duration;
                    frag = new fragment_1.default();
                }
            }
            else if (result[4]) { // X-BYTERANGE
                frag.rawByteRange = (' ' + result[4]).slice(1);
                if (prevFrag) {
                    var lastByteRangeEndOffset = prevFrag.byteRangeEndOffset;
                    if (lastByteRangeEndOffset) {
                        frag.lastByteRangeEndOffset = lastByteRangeEndOffset;
                    }
                }
            }
            else if (result[5]) { // PROGRAM-DATE-TIME
                // avoid sliced strings    https://github.com/video-dev/hls.js/issues/939
                frag.rawProgramDateTime = (' ' + result[5]).slice(1);
                frag.tagList.push(['PROGRAM-DATE-TIME', frag.rawProgramDateTime]);
                if (firstPdtIndex === null) {
                    firstPdtIndex = level.fragments.length;
                }
            }
            else {
                result = result[0].match(LEVEL_PLAYLIST_REGEX_SLOW);
                for (i = 1; i < result.length; i++) {
                    if (result[i] !== undefined) {
                        break;
                    }
                }
                // avoid sliced strings    https://github.com/video-dev/hls.js/issues/939
                var value1 = (' ' + result[i + 1]).slice(1);
                var value2 = (' ' + result[i + 2]).slice(1);
                switch (result[i]) {
                    case '#':
                        frag.tagList.push(value2 ? [value1, value2] : [value1]);
                        break;
                    case 'PLAYLIST-TYPE':
                        level.type = value1.toUpperCase();
                        break;
                    case 'MEDIA-SEQUENCE':
                        currentSN = level.startSN = parseInt(value1);
                        break;
                    case 'TARGETDURATION':
                        level.targetduration = parseFloat(value1);
                        break;
                    case 'VERSION':
                        level.version = parseInt(value1);
                        break;
                    case 'EXTM3U':
                        break;
                    case 'ENDLIST':
                        level.live = false;
                        break;
                    case 'DIS':
                        cc++;
                        frag.tagList.push(['DIS']);
                        break;
                    case 'DISCONTINUITY-SEQ':
                        cc = parseInt(value1);
                        break;
                    case 'KEY':
                        // https://tools.ietf.org/html/draft-pantos-http-live-streaming-08#section-3.4.4
                        var decryptparams = value1;
                        var keyAttrs = new attr_list_1.default(decryptparams);
                        var decryptmethod = keyAttrs.enumeratedString('METHOD'), decrypturi = keyAttrs.URI, decryptiv = keyAttrs.hexadecimalInteger('IV');
                        if (decryptmethod) {
                            levelkey = new level_key_1.default();
                            if ((decrypturi) && (['AES-128', 'SAMPLE-AES', 'SAMPLE-AES-CENC'].indexOf(decryptmethod) >= 0)) {
                                levelkey.method = decryptmethod;
                                // URI to get the key
                                levelkey.baseuri = baseurl;
                                levelkey.reluri = decrypturi;
                                levelkey.key = null;
                                // Initialization Vector (IV)
                                levelkey.iv = decryptiv;
                            }
                        }
                        break;
                    case 'START':
                        var startParams = value1;
                        var startAttrs = new attr_list_1.default(startParams);
                        var startTimeOffset = startAttrs.decimalFloatingPoint('TIME-OFFSET');
                        // TIME-OFFSET can be 0
                        if (Number.isFinite(startTimeOffset)) {
                            level.startTimeOffset = startTimeOffset;
                        }
                        break;
                    case 'MAP':
                        var mapAttrs = new attr_list_1.default(value1);
                        frag.relurl = mapAttrs.URI;
                        frag.rawByteRange = mapAttrs.BYTERANGE;
                        frag.baseurl = baseurl;
                        frag.level = id;
                        frag.type = type;
                        frag.sn = 'initSegment';
                        level.initSegment = frag;
                        frag = new fragment_1.default();
                        frag.rawProgramDateTime = level.initSegment.rawProgramDateTime;
                        break;
                    default:
                        logger_1.logger.warn("line parsed but not handled: " + result);
                        break;
                }
            }
        }
        frag = prevFrag;
        // logger.log('found ' + level.fragments.length + ' fragments');
        if (frag && !frag.relurl) {
            level.fragments.pop();
            totalduration -= frag.duration;
        }
        level.totalduration = totalduration;
        level.averagetargetduration = totalduration / level.fragments.length;
        level.endSN = currentSN - 1;
        level.startCC = level.fragments[0] ? level.fragments[0].cc : 0;
        level.endCC = cc;
        if (!level.initSegment && level.fragments.length) {
            // this is a bit lurky but HLS really has no other way to tell us
            // if the fragments are TS or MP4, except if we download them :/
            // but this is to be able to handle SIDX.
            if (level.fragments.every(function (frag) { return MP4_REGEX_SUFFIX.test(frag.relurl); })) {
                logger_1.logger.warn('MP4 fragments found but no init segment (probably no MAP, incomplete M3U8), trying to fetch SIDX');
                frag = new fragment_1.default();
                frag.relurl = level.fragments[0].relurl;
                frag.baseurl = baseurl;
                frag.level = id;
                frag.type = type;
                frag.sn = 'initSegment';
                level.initSegment = frag;
                level.needSidxRanges = true;
            }
        }
        /**
         * Backfill any missing PDT values
           "If the first EXT-X-PROGRAM-DATE-TIME tag in a Playlist appears after
           one or more Media Segment URIs, the client SHOULD extrapolate
           backward from that tag (using EXTINF durations and/or media
           timestamps) to associate dates with those segments."
         * We have already extrapolated forward, but all fragments up to the first instance of PDT do not have their PDTs
         * computed.
         */
        if (firstPdtIndex) {
            backfillProgramDateTimes(level.fragments, firstPdtIndex);
        }
        return level;
    };
    return M3U8Parser;
}());
exports.default = M3U8Parser;
function backfillProgramDateTimes(fragments, startIndex) {
    var fragPrev = fragments[startIndex];
    for (var i = startIndex - 1; i >= 0; i--) {
        var frag = fragments[i];
        frag.programDateTime = fragPrev.programDateTime - (frag.duration * 1000);
        fragPrev = frag;
    }
}
function assignProgramDateTime(frag, prevFrag) {
    if (frag.rawProgramDateTime) {
        frag.programDateTime = Date.parse(frag.rawProgramDateTime);
    }
    else if (prevFrag && prevFrag.programDateTime) {
        frag.programDateTime = prevFrag.endProgramDateTime;
    }
    if (!Number.isFinite(frag.programDateTime)) {
        frag.programDateTime = null;
        frag.rawProgramDateTime = null;
    }
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./src/polyfills/number */ "./src/polyfills/number.js")["Number"]))

/***/ }),

/***/ "./src/loader/playlist-loader.js":
/*!***************************************!*\
  !*** ./src/loader/playlist-loader.js ***!
  \***************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Number) {
/**
 * PlaylistLoader - delegate for media manifest/playlist loading tasks. Takes care of parsing media to internal data-models.
 *
 * Once loaded, dispatches events with parsed data-models of manifest/levels/audio/subtitle tracks.
 *
 * Uses loader(s) set in config to do actual internal loading of resource tasks.
 *
 * @module
 *
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var events_1 = __webpack_require__(/*! ../events */ "./src/events.js");
var event_handler_1 = __webpack_require__(/*! ../event-handler */ "./src/event-handler.js");
var errors_1 = __webpack_require__(/*! ../errors */ "./src/errors.js");
var logger_1 = __webpack_require__(/*! ../utils/logger */ "./src/utils/logger.js");
var mp4demuxer_1 = __webpack_require__(/*! ../demux/mp4demuxer */ "./src/demux/mp4demuxer.js");
var m3u8_parser_1 = __webpack_require__(/*! ./m3u8-parser */ "./src/loader/m3u8-parser.js");
var performance = window.performance;
/**
 * `type` property values for this loaders' context object
 * @enum
 *
 */
var ContextType = {
    MANIFEST: 'manifest',
    LEVEL: 'level',
    AUDIO_TRACK: 'audioTrack',
    SUBTITLE_TRACK: 'subtitleTrack'
};
/**
 * @enum {string}
 */
var LevelType = {
    MAIN: 'main',
    AUDIO: 'audio',
    SUBTITLE: 'subtitle'
};
/**
 * @constructor
 */
var PlaylistLoader = /** @class */ (function (_super) {
    __extends(PlaylistLoader, _super);
    /**
     * @constructs
     * @param {Hls} hls
     */
    function PlaylistLoader(hls) {
        var _this = _super.call(this, hls, events_1.default.MANIFEST_LOADING, events_1.default.LEVEL_LOADING, events_1.default.AUDIO_TRACK_LOADING, events_1.default.SUBTITLE_TRACK_LOADING) || this;
        _this.loaders = {};
        return _this;
    }
    Object.defineProperty(PlaylistLoader, "ContextType", {
        get: function () {
            return ContextType;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PlaylistLoader, "LevelType", {
        get: function () {
            return LevelType;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {ContextType} type
     * @returns {boolean}
     */
    PlaylistLoader.canHaveQualityLevels = function (type) {
        return (type !== ContextType.AUDIO_TRACK &&
            type !== ContextType.SUBTITLE_TRACK);
    };
    /**
     * Map context.type to LevelType
     * @param {{type: ContextType}} context
     * @returns {LevelType}
     */
    PlaylistLoader.mapContextToLevelType = function (context) {
        var type = context.type;
        switch (type) {
            case ContextType.AUDIO_TRACK:
                return LevelType.AUDIO;
            case ContextType.SUBTITLE_TRACK:
                return LevelType.SUBTITLE;
            default:
                return LevelType.MAIN;
        }
    };
    PlaylistLoader.getResponseUrl = function (response, context) {
        var url = response.url;
        // responseURL not supported on some browsers (it is used to detect URL redirection)
        // data-uri mode also not supported (but no need to detect redirection)
        if (url === undefined || url.indexOf('data:') === 0) {
            // fallback to initial URL
            url = context.url;
        }
        return url;
    };
    /**
     * Returns defaults or configured loader-type overloads (pLoader and loader config params)
     * Default loader is XHRLoader (see utils)
     * @param {object} context
     * @returns {XHRLoader} or other compatible configured overload
     */
    PlaylistLoader.prototype.createInternalLoader = function (context) {
        var config = this.hls.config;
        var PLoader = config.pLoader;
        var Loader = config.loader;
        var InternalLoader = PLoader || Loader;
        var loader = new InternalLoader(config);
        context.loader = loader;
        this.loaders[context.type] = loader;
        return loader;
    };
    PlaylistLoader.prototype.getInternalLoader = function (context) {
        return this.loaders[context.type];
    };
    PlaylistLoader.prototype.resetInternalLoader = function (contextType) {
        if (this.loaders[contextType]) {
            delete this.loaders[contextType];
        }
    };
    /**
     * Call `destroy` on all internal loader instances mapped (one per context type)
     */
    PlaylistLoader.prototype.destroyInternalLoaders = function () {
        for (var contextType in this.loaders) {
            var loader = this.loaders[contextType];
            if (loader) {
                loader.destroy();
            }
            this.resetInternalLoader(contextType);
        }
    };
    PlaylistLoader.prototype.destroy = function () {
        this.destroyInternalLoaders();
        _super.prototype.destroy.call(this);
    };
    PlaylistLoader.prototype.onManifestLoading = function (data) {
        this.load(data.url, { type: ContextType.MANIFEST, level: 0, id: null });
    };
    PlaylistLoader.prototype.onLevelLoading = function (data) {
        this.load(data.url, { type: ContextType.LEVEL, level: data.level, id: data.id });
    };
    PlaylistLoader.prototype.onAudioTrackLoading = function (data) {
        this.load(data.url, { type: ContextType.AUDIO_TRACK, level: null, id: data.id });
    };
    PlaylistLoader.prototype.onSubtitleTrackLoading = function (data) {
        this.load(data.url, { type: ContextType.SUBTITLE_TRACK, level: null, id: data.id });
    };
    PlaylistLoader.prototype.load = function (url, context) {
        var config = this.hls.config;
        logger_1.logger.debug("Loading playlist of type " + context.type + ", level: " + context.level + ", id: " + context.id);
        // Check if a loader for this context already exists
        var loader = this.getInternalLoader(context);
        if (loader) {
            var loaderContext = loader.context;
            if (loaderContext && loaderContext.url === url) { // same URL can't overlap
                logger_1.logger.trace('playlist request ongoing');
                return false;
            }
            else {
                logger_1.logger.warn("aborting previous loader for type: " + context.type);
                loader.abort();
            }
        }
        var maxRetry, timeout, retryDelay, maxRetryDelay;
        // apply different configs for retries depending on
        // context (manifest, level, audio/subs playlist)
        switch (context.type) {
            case ContextType.MANIFEST:
                maxRetry = config.manifestLoadingMaxRetry;
                timeout = config.manifestLoadingTimeOut;
                retryDelay = config.manifestLoadingRetryDelay;
                maxRetryDelay = config.manifestLoadingMaxRetryTimeout;
                break;
            case ContextType.LEVEL:
                // Disable internal loader retry logic, since we are managing retries in Level Controller
                maxRetry = 0;
                timeout = config.levelLoadingTimeOut;
                // TODO Introduce retry settings for audio-track and subtitle-track, it should not use level retry config
                break;
            default:
                maxRetry = config.levelLoadingMaxRetry;
                timeout = config.levelLoadingTimeOut;
                retryDelay = config.levelLoadingRetryDelay;
                maxRetryDelay = config.levelLoadingMaxRetryTimeout;
                break;
        }
        loader = this.createInternalLoader(context);
        context.url = url;
        context.responseType = context.responseType || ''; // FIXME: (should not be necessary to do this)
        var loaderConfig = {
            timeout: timeout,
            maxRetry: maxRetry,
            retryDelay: retryDelay,
            maxRetryDelay: maxRetryDelay
        };
        var loaderCallbacks = {
            onSuccess: this.loadsuccess.bind(this),
            onError: this.loaderror.bind(this),
            onTimeout: this.loadtimeout.bind(this)
        };
        logger_1.logger.debug("Calling internal loader delegate for URL: " + url);
        loader.load(context, loaderConfig, loaderCallbacks);
        return true;
    };
    PlaylistLoader.prototype.loadsuccess = function (response, stats, context, networkDetails) {
        if (networkDetails === void 0) { networkDetails = null; }
        if (context.isSidxRequest) {
            this._handleSidxRequest(response, context);
            this._handlePlaylistLoaded(response, stats, context, networkDetails);
            return;
        }
        this.resetInternalLoader(context.type);
        var string = response.data;
        stats.tload = performance.now();
        // stats.mtime = new Date(target.getResponseHeader('Last-Modified'));
        // Validate if it is an M3U8 at all
        if (string.indexOf('#EXTM3U') !== 0) {
            this._handleManifestParsingError(response, context, 'no EXTM3U delimiter', networkDetails);
            return;
        }
        // Check if chunk-list or master. handle empty chunk list case (first EXTINF not signaled, but TARGETDURATION present)
        if (string.indexOf('#EXTINF:') > 0 || string.indexOf('#EXT-X-TARGETDURATION:') > 0) {
            this._handleTrackOrLevelPlaylist(response, stats, context, networkDetails);
        }
        else {
            this._handleMasterPlaylist(response, stats, context, networkDetails);
        }
    };
    PlaylistLoader.prototype.loaderror = function (response, context, networkDetails) {
        if (networkDetails === void 0) { networkDetails = null; }
        this._handleNetworkError(context, networkDetails, false, response);
    };
    PlaylistLoader.prototype.loadtimeout = function (stats, context, networkDetails) {
        if (networkDetails === void 0) { networkDetails = null; }
        this._handleNetworkError(context, networkDetails, true);
    };
    PlaylistLoader.prototype._handleMasterPlaylist = function (response, stats, context, networkDetails) {
        var hls = this.hls;
        var string = response.data;
        var url = PlaylistLoader.getResponseUrl(response, context);
        var levels = m3u8_parser_1.default.parseMasterPlaylist(string, url);
        if (!levels.length) {
            this._handleManifestParsingError(response, context, 'no level found in manifest', networkDetails);
            return;
        }
        // multi level playlist, parse level info
        var audioGroups = levels.map(function (level) { return ({
            id: level.attrs.AUDIO,
            codec: level.audioCodec
        }); });
        var audioTracks = m3u8_parser_1.default.parseMasterPlaylistMedia(string, url, 'AUDIO', audioGroups);
        var subtitles = m3u8_parser_1.default.parseMasterPlaylistMedia(string, url, 'SUBTITLES');
        if (audioTracks.length) {
            // check if we have found an audio track embedded in main playlist (audio track without URI attribute)
            var embeddedAudioFound_1 = false;
            audioTracks.forEach(function (audioTrack) {
                if (!audioTrack.url) {
                    embeddedAudioFound_1 = true;
                }
            });
            // if no embedded audio track defined, but audio codec signaled in quality level,
            // we need to signal this main audio track this could happen with playlists with
            // alt audio rendition in which quality levels (main)
            // contains both audio+video. but with mixed audio track not signaled
            if (embeddedAudioFound_1 === false && levels[0].audioCodec && !levels[0].attrs.AUDIO) {
                logger_1.logger.log('audio codec signaled in quality level, but no embedded audio track signaled, create one');
                audioTracks.unshift({
                    type: 'main',
                    name: 'main'
                });
            }
        }
        hls.trigger(events_1.default.MANIFEST_LOADED, {
            levels: levels,
            audioTracks: audioTracks,
            subtitles: subtitles,
            url: url,
            stats: stats,
            networkDetails: networkDetails
        });
    };
    PlaylistLoader.prototype._handleTrackOrLevelPlaylist = function (response, stats, context, networkDetails) {
        var hls = this.hls;
        var id = context.id, level = context.level, type = context.type;
        var url = PlaylistLoader.getResponseUrl(response, context);
        var levelUrlId = Number.isFinite(id) ? id : 0;
        var levelId = Number.isFinite(level) ? level : levelUrlId;
        var levelType = PlaylistLoader.mapContextToLevelType(context);
        var levelDetails = m3u8_parser_1.default.parseLevelPlaylist(response.data, url, levelId, levelType, levelUrlId);
        // set stats on level structure
        levelDetails.tload = stats.tload;
        // We have done our first request (Manifest-type) and receive
        // not a master playlist but a chunk-list (track/level)
        // We fire the manifest-loaded event anyway with the parsed level-details
        // by creating a single-level structure for it.
        if (type === ContextType.MANIFEST) {
            var singleLevel = {
                url: url,
                details: levelDetails
            };
            hls.trigger(events_1.default.MANIFEST_LOADED, {
                levels: [singleLevel],
                audioTracks: [],
                url: url,
                stats: stats,
                networkDetails: networkDetails
            });
        }
        // save parsing time
        stats.tparsed = performance.now();
        // in case we need SIDX ranges
        // return early after calling load for
        // the SIDX box.
        if (levelDetails.needSidxRanges) {
            var sidxUrl = levelDetails.initSegment.url;
            this.load(sidxUrl, {
                isSidxRequest: true,
                type: type,
                level: level,
                levelDetails: levelDetails,
                id: id,
                rangeStart: 0,
                rangeEnd: 2048,
                responseType: 'arraybuffer'
            });
            return;
        }
        // extend the context with the new levelDetails property
        context.levelDetails = levelDetails;
        this._handlePlaylistLoaded(response, stats, context, networkDetails);
    };
    PlaylistLoader.prototype._handleSidxRequest = function (response, context) {
        var sidxInfo = mp4demuxer_1.default.parseSegmentIndex(new Uint8Array(response.data));
        // if provided fragment does not contain sidx, early return
        if (!sidxInfo) {
            return;
        }
        var sidxReferences = sidxInfo.references;
        var levelDetails = context.levelDetails;
        sidxReferences.forEach(function (segmentRef, index) {
            var segRefInfo = segmentRef.info;
            var frag = levelDetails.fragments[index];
            if (frag.byteRange.length === 0) {
                frag.rawByteRange = String(1 + segRefInfo.end - segRefInfo.start) + '@' + String(segRefInfo.start);
            }
        });
        levelDetails.initSegment.rawByteRange = String(sidxInfo.moovEndOffset) + '@0';
    };
    PlaylistLoader.prototype._handleManifestParsingError = function (response, context, reason, networkDetails) {
        this.hls.trigger(events_1.default.ERROR, {
            type: errors_1.ErrorTypes.NETWORK_ERROR,
            details: errors_1.ErrorDetails.MANIFEST_PARSING_ERROR,
            fatal: true,
            url: response.url,
            reason: reason,
            networkDetails: networkDetails
        });
    };
    PlaylistLoader.prototype._handleNetworkError = function (context, networkDetails, timeout, response) {
        if (timeout === void 0) { timeout = false; }
        if (response === void 0) { response = null; }
        logger_1.logger.info("A network error occured while loading a " + context.type + "-type playlist");
        var details;
        var fatal;
        var loader = this.getInternalLoader(context);
        switch (context.type) {
            case ContextType.MANIFEST:
                details = (timeout ? errors_1.ErrorDetails.MANIFEST_LOAD_TIMEOUT : errors_1.ErrorDetails.MANIFEST_LOAD_ERROR);
                fatal = true;
                break;
            case ContextType.LEVEL:
                details = (timeout ? errors_1.ErrorDetails.LEVEL_LOAD_TIMEOUT : errors_1.ErrorDetails.LEVEL_LOAD_ERROR);
                fatal = false;
                break;
            case ContextType.AUDIO_TRACK:
                details = (timeout ? errors_1.ErrorDetails.AUDIO_TRACK_LOAD_TIMEOUT : errors_1.ErrorDetails.AUDIO_TRACK_LOAD_ERROR);
                fatal = false;
                break;
            default:
                // details = ...?
                fatal = false;
        }
        if (loader) {
            loader.abort();
            this.resetInternalLoader(context.type);
        }
        var errorData = {
            type: errors_1.ErrorTypes.NETWORK_ERROR,
            details: details,
            fatal: fatal,
            url: loader.url,
            loader: loader,
            context: context,
            networkDetails: networkDetails
        };
        if (response) {
            errorData.response = response;
        }
        this.hls.trigger(events_1.default.ERROR, errorData);
    };
    PlaylistLoader.prototype._handlePlaylistLoaded = function (response, stats, context, networkDetails) {
        var type = context.type, level = context.level, id = context.id, levelDetails = context.levelDetails;
        if (!levelDetails.targetduration) {
            this._handleManifestParsingError(response, context, 'invalid target duration', networkDetails);
            return;
        }
        var canHaveLevels = PlaylistLoader.canHaveQualityLevels(context.type);
        if (canHaveLevels) {
            this.hls.trigger(events_1.default.LEVEL_LOADED, {
                details: levelDetails,
                level: level || 0,
                id: id || 0,
                stats: stats,
                networkDetails: networkDetails
            });
        }
        else {
            switch (type) {
                case ContextType.AUDIO_TRACK:
                    this.hls.trigger(events_1.default.AUDIO_TRACK_LOADED, {
                        details: levelDetails,
                        id: id,
                        stats: stats,
                        networkDetails: networkDetails
                    });
                    break;
                case ContextType.SUBTITLE_TRACK:
                    this.hls.trigger(events_1.default.SUBTITLE_TRACK_LOADED, {
                        details: levelDetails,
                        id: id,
                        stats: stats,
                        networkDetails: networkDetails
                    });
                    break;
            }
        }
    };
    return PlaylistLoader;
}(event_handler_1.default));
exports.default = PlaylistLoader;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./src/polyfills/number */ "./src/polyfills/number.js")["Number"]))

/***/ }),

/***/ "./src/observer.js":
/*!*************************!*\
  !*** ./src/observer.js ***!
  \*************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var eventemitter3_1 = __webpack_require__(/*! eventemitter3 */ "./node_modules/eventemitter3/index.js");
/**
 * @class
 *
 * Simple adapter sub-class of Nodejs-like EventEmitter.
 *
 * We simply want to pass along the event-name itself
 * in every call to a handler, which is the purpose of our `trigger` method
 * extending the standard API.
 *
 */
var Observer = /** @class */ (function (_super) {
    __extends(Observer, _super);
    function Observer() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     *
     * @param {string} event
     * @param {any} data
     */
    Observer.prototype.trigger = function (event) {
        var data = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            data[_i - 1] = arguments[_i];
        }
        this.emit.apply(this, [event, event].concat(data));
    };
    return Observer;
}(eventemitter3_1.EventEmitter));
exports.Observer = Observer;


/***/ }),

/***/ "./src/polyfills/number.js":
/*!*********************************!*\
  !*** ./src/polyfills/number.js ***!
  \*********************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var get_self_scope_1 = __webpack_require__(/*! ../utils/get-self-scope */ "./src/utils/get-self-scope.js");
var self = get_self_scope_1.getSelfScope();
var Number = self.Number;
exports.Number = Number;
// TODO: get rid of global polyfills and replace them with wrappers ("ponyfills")
Number.isFinite = Number.isFinite || function (value) {
    return typeof value === 'number' && isFinite(value);
};


/***/ }),

/***/ "./src/remux/aac-helper.js":
/*!*********************************!*\
  !*** ./src/remux/aac-helper.js ***!
  \*********************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 *  AAC helper
 */
Object.defineProperty(exports, "__esModule", { value: true });
var AAC = /** @class */ (function () {
    function AAC() {
    }
    AAC.getSilentFrame = function (codec, channelCount) {
        switch (codec) {
            case 'mp4a.40.2':
                if (channelCount === 1) {
                    return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x23, 0x80]);
                }
                else if (channelCount === 2) {
                    return new Uint8Array([0x21, 0x00, 0x49, 0x90, 0x02, 0x19, 0x00, 0x23, 0x80]);
                }
                else if (channelCount === 3) {
                    return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x8e]);
                }
                else if (channelCount === 4) {
                    return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x80, 0x2c, 0x80, 0x08, 0x02, 0x38]);
                }
                else if (channelCount === 5) {
                    return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x82, 0x30, 0x04, 0x99, 0x00, 0x21, 0x90, 0x02, 0x38]);
                }
                else if (channelCount === 6) {
                    return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x82, 0x30, 0x04, 0x99, 0x00, 0x21, 0x90, 0x02, 0x00, 0xb2, 0x00, 0x20, 0x08, 0xe0]);
                }
                break;
            // handle HE-AAC below (mp4a.40.5 / mp4a.40.29)
            default:
                if (channelCount === 1) {
                    // ffmpeg -y -f lavfi -i "aevalsrc=0:d=0.05" -c:a libfdk_aac -profile:a aac_he -b:a 4k output.aac && hexdump -v -e '16/1 "0x%x," "\n"' -v output.aac
                    return new Uint8Array([0x1, 0x40, 0x22, 0x80, 0xa3, 0x4e, 0xe6, 0x80, 0xba, 0x8, 0x0, 0x0, 0x0, 0x1c, 0x6, 0xf1, 0xc1, 0xa, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5e]);
                }
                else if (channelCount === 2) {
                    // ffmpeg -y -f lavfi -i "aevalsrc=0|0:d=0.05" -c:a libfdk_aac -profile:a aac_he_v2 -b:a 4k output.aac && hexdump -v -e '16/1 "0x%x," "\n"' -v output.aac
                    return new Uint8Array([0x1, 0x40, 0x22, 0x80, 0xa3, 0x5e, 0xe6, 0x80, 0xba, 0x8, 0x0, 0x0, 0x0, 0x0, 0x95, 0x0, 0x6, 0xf1, 0xa1, 0xa, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5e]);
                }
                else if (channelCount === 3) {
                    // ffmpeg -y -f lavfi -i "aevalsrc=0|0|0:d=0.05" -c:a libfdk_aac -profile:a aac_he_v2 -b:a 4k output.aac && hexdump -v -e '16/1 "0x%x," "\n"' -v output.aac
                    return new Uint8Array([0x1, 0x40, 0x22, 0x80, 0xa3, 0x5e, 0xe6, 0x80, 0xba, 0x8, 0x0, 0x0, 0x0, 0x0, 0x95, 0x0, 0x6, 0xf1, 0xa1, 0xa, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5e]);
                }
                break;
        }
        return null;
    };
    return AAC;
}());
exports.default = AAC;


/***/ }),

/***/ "./src/remux/mp4-generator.js":
/*!************************************!*\
  !*** ./src/remux/mp4-generator.js ***!
  \************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Generate MP4 Box
*/
Object.defineProperty(exports, "__esModule", { value: true });
var UINT32_MAX = Math.pow(2, 32) - 1;
var MP4 = /** @class */ (function () {
    function MP4() {
    }
    MP4.init = function () {
        MP4.types = {
            avc1: [],
            avcC: [],
            btrt: [],
            dinf: [],
            dref: [],
            esds: [],
            ftyp: [],
            hdlr: [],
            mdat: [],
            mdhd: [],
            mdia: [],
            mfhd: [],
            minf: [],
            moof: [],
            moov: [],
            mp4a: [],
            '.mp3': [],
            mvex: [],
            mvhd: [],
            pasp: [],
            sdtp: [],
            stbl: [],
            stco: [],
            stsc: [],
            stsd: [],
            stsz: [],
            stts: [],
            tfdt: [],
            tfhd: [],
            traf: [],
            trak: [],
            trun: [],
            trex: [],
            tkhd: [],
            vmhd: [],
            smhd: []
        };
        var i;
        for (i in MP4.types) {
            if (MP4.types.hasOwnProperty(i)) {
                MP4.types[i] = [
                    i.charCodeAt(0),
                    i.charCodeAt(1),
                    i.charCodeAt(2),
                    i.charCodeAt(3)
                ];
            }
        }
        var videoHdlr = new Uint8Array([
            0x00,
            0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x76, 0x69, 0x64, 0x65,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x56, 0x69, 0x64, 0x65,
            0x6f, 0x48, 0x61, 0x6e,
            0x64, 0x6c, 0x65, 0x72, 0x00 // name: 'VideoHandler'
        ]);
        var audioHdlr = new Uint8Array([
            0x00,
            0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x73, 0x6f, 0x75, 0x6e,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x53, 0x6f, 0x75, 0x6e,
            0x64, 0x48, 0x61, 0x6e,
            0x64, 0x6c, 0x65, 0x72, 0x00 // name: 'SoundHandler'
        ]);
        MP4.HDLR_TYPES = {
            'video': videoHdlr,
            'audio': audioHdlr
        };
        var dref = new Uint8Array([
            0x00,
            0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x01,
            0x00, 0x00, 0x00, 0x0c,
            0x75, 0x72, 0x6c, 0x20,
            0x00,
            0x00, 0x00, 0x01 // entry_flags
        ]);
        var stco = new Uint8Array([
            0x00,
            0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00 // entry_count
        ]);
        MP4.STTS = MP4.STSC = MP4.STCO = stco;
        MP4.STSZ = new Uint8Array([
            0x00,
            0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00 // sample_count
        ]);
        MP4.VMHD = new Uint8Array([
            0x00,
            0x00, 0x00, 0x01,
            0x00, 0x00,
            0x00, 0x00,
            0x00, 0x00,
            0x00, 0x00 // opcolor
        ]);
        MP4.SMHD = new Uint8Array([
            0x00,
            0x00, 0x00, 0x00,
            0x00, 0x00,
            0x00, 0x00 // reserved
        ]);
        MP4.STSD = new Uint8Array([
            0x00,
            0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x01
        ]); // entry_count
        var majorBrand = new Uint8Array([105, 115, 111, 109]); // isom
        var avc1Brand = new Uint8Array([97, 118, 99, 49]); // avc1
        var minorVersion = new Uint8Array([0, 0, 0, 1]);
        MP4.FTYP = MP4.box(MP4.types.ftyp, majorBrand, minorVersion, majorBrand, avc1Brand);
        MP4.DINF = MP4.box(MP4.types.dinf, MP4.box(MP4.types.dref, dref));
    };
    MP4.box = function (type) {
        var payload = Array.prototype.slice.call(arguments, 1), size = 8, i = payload.length, len = i, result;
        // calculate the total size we need to allocate
        while (i--) {
            size += payload[i].byteLength;
        }
        result = new Uint8Array(size);
        result[0] = (size >> 24) & 0xff;
        result[1] = (size >> 16) & 0xff;
        result[2] = (size >> 8) & 0xff;
        result[3] = size & 0xff;
        result.set(type, 4);
        // copy the payload into the result
        for (i = 0, size = 8; i < len; i++) {
            // copy payload[i] array @ offset size
            result.set(payload[i], size);
            size += payload[i].byteLength;
        }
        return result;
    };
    MP4.hdlr = function (type) {
        return MP4.box(MP4.types.hdlr, MP4.HDLR_TYPES[type]);
    };
    MP4.mdat = function (data) {
        return MP4.box(MP4.types.mdat, data);
    };
    MP4.mdhd = function (timescale, duration) {
        duration *= timescale;
        var upperWordDuration = Math.floor(duration / (UINT32_MAX + 1));
        var lowerWordDuration = Math.floor(duration % (UINT32_MAX + 1));
        return MP4.box(MP4.types.mdhd, new Uint8Array([
            0x01,
            0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03,
            (timescale >> 24) & 0xFF,
            (timescale >> 16) & 0xFF,
            (timescale >> 8) & 0xFF,
            timescale & 0xFF,
            (upperWordDuration >> 24),
            (upperWordDuration >> 16) & 0xFF,
            (upperWordDuration >> 8) & 0xFF,
            upperWordDuration & 0xFF,
            (lowerWordDuration >> 24),
            (lowerWordDuration >> 16) & 0xFF,
            (lowerWordDuration >> 8) & 0xFF,
            lowerWordDuration & 0xFF,
            0x55, 0xc4,
            0x00, 0x00
        ]));
    };
    MP4.mdia = function (track) {
        return MP4.box(MP4.types.mdia, MP4.mdhd(track.timescale, track.duration), MP4.hdlr(track.type), MP4.minf(track));
    };
    MP4.mfhd = function (sequenceNumber) {
        return MP4.box(MP4.types.mfhd, new Uint8Array([
            0x00,
            0x00, 0x00, 0x00,
            (sequenceNumber >> 24),
            (sequenceNumber >> 16) & 0xFF,
            (sequenceNumber >> 8) & 0xFF,
            sequenceNumber & 0xFF // sequence_number
        ]));
    };
    MP4.minf = function (track) {
        if (track.type === 'audio') {
            return MP4.box(MP4.types.minf, MP4.box(MP4.types.smhd, MP4.SMHD), MP4.DINF, MP4.stbl(track));
        }
        else {
            return MP4.box(MP4.types.minf, MP4.box(MP4.types.vmhd, MP4.VMHD), MP4.DINF, MP4.stbl(track));
        }
    };
    MP4.moof = function (sn, baseMediaDecodeTime, track) {
        return MP4.box(MP4.types.moof, MP4.mfhd(sn), MP4.traf(track, baseMediaDecodeTime));
    };
    /**
   * @param tracks... (optional) {array} the tracks associated with this movie
   */
    MP4.moov = function (tracks) {
        var i = tracks.length, boxes = [];
        while (i--) {
            boxes[i] = MP4.trak(tracks[i]);
        }
        return MP4.box.apply(null, [MP4.types.moov, MP4.mvhd(tracks[0].timescale, tracks[0].duration)].concat(boxes).concat(MP4.mvex(tracks)));
    };
    MP4.mvex = function (tracks) {
        var i = tracks.length, boxes = [];
        while (i--) {
            boxes[i] = MP4.trex(tracks[i]);
        }
        return MP4.box.apply(null, [MP4.types.mvex].concat(boxes));
    };
    MP4.mvhd = function (timescale, duration) {
        duration *= timescale;
        var upperWordDuration = Math.floor(duration / (UINT32_MAX + 1));
        var lowerWordDuration = Math.floor(duration % (UINT32_MAX + 1));
        var bytes = new Uint8Array([
            0x01,
            0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03,
            (timescale >> 24) & 0xFF,
            (timescale >> 16) & 0xFF,
            (timescale >> 8) & 0xFF,
            timescale & 0xFF,
            (upperWordDuration >> 24),
            (upperWordDuration >> 16) & 0xFF,
            (upperWordDuration >> 8) & 0xFF,
            upperWordDuration & 0xFF,
            (lowerWordDuration >> 24),
            (lowerWordDuration >> 16) & 0xFF,
            (lowerWordDuration >> 8) & 0xFF,
            lowerWordDuration & 0xFF,
            0x00, 0x01, 0x00, 0x00,
            0x01, 0x00,
            0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x01, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x01, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x40, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0xff, 0xff, 0xff, 0xff // next_track_ID
        ]);
        return MP4.box(MP4.types.mvhd, bytes);
    };
    MP4.sdtp = function (track) {
        var samples = track.samples || [], bytes = new Uint8Array(4 + samples.length), flags, i;
        // leave the full box header (4 bytes) all zero
        // write the sample table
        for (i = 0; i < samples.length; i++) {
            flags = samples[i].flags;
            bytes[i + 4] = (flags.dependsOn << 4) |
                (flags.isDependedOn << 2) |
                (flags.hasRedundancy);
        }
        return MP4.box(MP4.types.sdtp, bytes);
    };
    MP4.stbl = function (track) {
        return MP4.box(MP4.types.stbl, MP4.stsd(track), MP4.box(MP4.types.stts, MP4.STTS), MP4.box(MP4.types.stsc, MP4.STSC), MP4.box(MP4.types.stsz, MP4.STSZ), MP4.box(MP4.types.stco, MP4.STCO));
    };
    MP4.avc1 = function (track) {
        var sps = [], pps = [], i, data, len;
        // assemble the SPSs
        for (i = 0; i < track.sps.length; i++) {
            data = track.sps[i];
            len = data.byteLength;
            sps.push((len >>> 8) & 0xFF);
            sps.push((len & 0xFF));
            // SPS
            sps = sps.concat(Array.prototype.slice.call(data));
        }
        // assemble the PPSs
        for (i = 0; i < track.pps.length; i++) {
            data = track.pps[i];
            len = data.byteLength;
            pps.push((len >>> 8) & 0xFF);
            pps.push((len & 0xFF));
            pps = pps.concat(Array.prototype.slice.call(data));
        }
        var avcc = MP4.box(MP4.types.avcC, new Uint8Array([
            0x01,
            sps[3],
            sps[4],
            sps[5],
            0xfc | 3,
            0xE0 | track.sps.length // 3bit reserved (111) + numOfSequenceParameterSets
        ].concat(sps).concat([
            track.pps.length // numOfPictureParameterSets
        ]).concat(pps))), // "PPS"
        width = track.width, height = track.height, hSpacing = track.pixelRatio[0], vSpacing = track.pixelRatio[1];
        return MP4.box(MP4.types.avc1, new Uint8Array([
            0x00, 0x00, 0x00,
            0x00, 0x00, 0x00,
            0x00, 0x01,
            0x00, 0x00,
            0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            (width >> 8) & 0xFF,
            width & 0xff,
            (height >> 8) & 0xFF,
            height & 0xff,
            0x00, 0x48, 0x00, 0x00,
            0x00, 0x48, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x01,
            0x12,
            0x64, 0x61, 0x69, 0x6C,
            0x79, 0x6D, 0x6F, 0x74,
            0x69, 0x6F, 0x6E, 0x2F,
            0x68, 0x6C, 0x73, 0x2E,
            0x6A, 0x73, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00,
            0x00, 0x18,
            0x11, 0x11
        ]), // pre_defined = -1
        avcc, MP4.box(MP4.types.btrt, new Uint8Array([
            0x00, 0x1c, 0x9c, 0x80,
            0x00, 0x2d, 0xc6, 0xc0,
            0x00, 0x2d, 0xc6, 0xc0
        ])), // avgBitrate
        MP4.box(MP4.types.pasp, new Uint8Array([
            (hSpacing >> 24),
            (hSpacing >> 16) & 0xFF,
            (hSpacing >> 8) & 0xFF,
            hSpacing & 0xFF,
            (vSpacing >> 24),
            (vSpacing >> 16) & 0xFF,
            (vSpacing >> 8) & 0xFF,
            vSpacing & 0xFF
        ])));
    };
    MP4.esds = function (track) {
        var configlen = track.config.length;
        return new Uint8Array([
            0x00,
            0x00, 0x00, 0x00,
            0x03,
            0x17 + configlen,
            0x00, 0x01,
            0x00,
            0x04,
            0x0f + configlen,
            0x40,
            0x15,
            0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x05 // descriptor_type
        ].concat([configlen]).concat(track.config).concat([0x06, 0x01, 0x02])); // GASpecificConfig)); // length + audio config descriptor
    };
    MP4.mp4a = function (track) {
        var samplerate = track.samplerate;
        return MP4.box(MP4.types.mp4a, new Uint8Array([
            0x00, 0x00, 0x00,
            0x00, 0x00, 0x00,
            0x00, 0x01,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, track.channelCount,
            0x00, 0x10,
            0x00, 0x00, 0x00, 0x00,
            (samplerate >> 8) & 0xFF,
            samplerate & 0xff,
            0x00, 0x00
        ]), MP4.box(MP4.types.esds, MP4.esds(track)));
    };
    MP4.mp3 = function (track) {
        var samplerate = track.samplerate;
        return MP4.box(MP4.types['.mp3'], new Uint8Array([
            0x00, 0x00, 0x00,
            0x00, 0x00, 0x00,
            0x00, 0x01,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, track.channelCount,
            0x00, 0x10,
            0x00, 0x00, 0x00, 0x00,
            (samplerate >> 8) & 0xFF,
            samplerate & 0xff,
            0x00, 0x00
        ]));
    };
    MP4.stsd = function (track) {
        if (track.type === 'audio') {
            if (!track.isAAC && track.codec === 'mp3') {
                return MP4.box(MP4.types.stsd, MP4.STSD, MP4.mp3(track));
            }
            return MP4.box(MP4.types.stsd, MP4.STSD, MP4.mp4a(track));
        }
        else {
            return MP4.box(MP4.types.stsd, MP4.STSD, MP4.avc1(track));
        }
    };
    MP4.tkhd = function (track) {
        var id = track.id, duration = track.duration * track.timescale, width = track.width, height = track.height, upperWordDuration = Math.floor(duration / (UINT32_MAX + 1)), lowerWordDuration = Math.floor(duration % (UINT32_MAX + 1));
        return MP4.box(MP4.types.tkhd, new Uint8Array([
            0x01,
            0x00, 0x00, 0x07,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03,
            (id >> 24) & 0xFF,
            (id >> 16) & 0xFF,
            (id >> 8) & 0xFF,
            id & 0xFF,
            0x00, 0x00, 0x00, 0x00,
            (upperWordDuration >> 24),
            (upperWordDuration >> 16) & 0xFF,
            (upperWordDuration >> 8) & 0xFF,
            upperWordDuration & 0xFF,
            (lowerWordDuration >> 24),
            (lowerWordDuration >> 16) & 0xFF,
            (lowerWordDuration >> 8) & 0xFF,
            lowerWordDuration & 0xFF,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00,
            0x00, 0x00,
            0x00, 0x00,
            0x00, 0x00,
            0x00, 0x01, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x01, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x40, 0x00, 0x00, 0x00,
            (width >> 8) & 0xFF,
            width & 0xFF,
            0x00, 0x00,
            (height >> 8) & 0xFF,
            height & 0xFF,
            0x00, 0x00 // height
        ]));
    };
    MP4.traf = function (track, baseMediaDecodeTime) {
        var sampleDependencyTable = MP4.sdtp(track), id = track.id, upperWordBaseMediaDecodeTime = Math.floor(baseMediaDecodeTime / (UINT32_MAX + 1)), lowerWordBaseMediaDecodeTime = Math.floor(baseMediaDecodeTime % (UINT32_MAX + 1));
        return MP4.box(MP4.types.traf, MP4.box(MP4.types.tfhd, new Uint8Array([
            0x00,
            0x00, 0x00, 0x00,
            (id >> 24),
            (id >> 16) & 0XFF,
            (id >> 8) & 0XFF,
            (id & 0xFF) // track_ID
        ])), MP4.box(MP4.types.tfdt, new Uint8Array([
            0x01,
            0x00, 0x00, 0x00,
            (upperWordBaseMediaDecodeTime >> 24),
            (upperWordBaseMediaDecodeTime >> 16) & 0XFF,
            (upperWordBaseMediaDecodeTime >> 8) & 0XFF,
            (upperWordBaseMediaDecodeTime & 0xFF),
            (lowerWordBaseMediaDecodeTime >> 24),
            (lowerWordBaseMediaDecodeTime >> 16) & 0XFF,
            (lowerWordBaseMediaDecodeTime >> 8) & 0XFF,
            (lowerWordBaseMediaDecodeTime & 0xFF)
        ])), MP4.trun(track, sampleDependencyTable.length +
            16 + // tfhd
            20 + // tfdt
            8 + // traf header
            16 + // mfhd
            8 + // moof header
            8), // mdat header
        sampleDependencyTable);
    };
    /**
     * Generate a track box.
     * @param track {object} a track definition
     * @return {Uint8Array} the track box
     */
    MP4.trak = function (track) {
        track.duration = track.duration || 0xffffffff;
        return MP4.box(MP4.types.trak, MP4.tkhd(track), MP4.mdia(track));
    };
    MP4.trex = function (track) {
        var id = track.id;
        return MP4.box(MP4.types.trex, new Uint8Array([
            0x00,
            0x00, 0x00, 0x00,
            (id >> 24),
            (id >> 16) & 0XFF,
            (id >> 8) & 0XFF,
            (id & 0xFF),
            0x00, 0x00, 0x00, 0x01,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x01, 0x00, 0x01 // default_sample_flags
        ]));
    };
    MP4.trun = function (track, offset) {
        var samples = track.samples || [], len = samples.length, arraylen = 12 + (16 * len), array = new Uint8Array(arraylen), i, sample, duration, size, flags, cts;
        offset += 8 + arraylen;
        array.set([
            0x00,
            0x00, 0x0f, 0x01,
            (len >>> 24) & 0xFF,
            (len >>> 16) & 0xFF,
            (len >>> 8) & 0xFF,
            len & 0xFF,
            (offset >>> 24) & 0xFF,
            (offset >>> 16) & 0xFF,
            (offset >>> 8) & 0xFF,
            offset & 0xFF // data_offset
        ], 0);
        for (i = 0; i < len; i++) {
            sample = samples[i];
            duration = sample.duration;
            size = sample.size;
            flags = sample.flags;
            cts = sample.cts;
            array.set([
                (duration >>> 24) & 0xFF,
                (duration >>> 16) & 0xFF,
                (duration >>> 8) & 0xFF,
                duration & 0xFF,
                (size >>> 24) & 0xFF,
                (size >>> 16) & 0xFF,
                (size >>> 8) & 0xFF,
                size & 0xFF,
                (flags.isLeading << 2) | flags.dependsOn,
                (flags.isDependedOn << 6) |
                    (flags.hasRedundancy << 4) |
                    (flags.paddingValue << 1) |
                    flags.isNonSync,
                flags.degradPrio & 0xF0 << 8,
                flags.degradPrio & 0x0F,
                (cts >>> 24) & 0xFF,
                (cts >>> 16) & 0xFF,
                (cts >>> 8) & 0xFF,
                cts & 0xFF // sample_composition_time_offset
            ], 12 + 16 * i);
        }
        return MP4.box(MP4.types.trun, array);
    };
    MP4.initSegment = function (tracks) {
        if (!MP4.types) {
            MP4.init();
        }
        var movie = MP4.moov(tracks), result;
        result = new Uint8Array(MP4.FTYP.byteLength + movie.byteLength);
        result.set(MP4.FTYP);
        result.set(movie, MP4.FTYP.byteLength);
        return result;
    };
    return MP4;
}());
exports.default = MP4;


/***/ }),

/***/ "./src/remux/mp4-remuxer.js":
/*!**********************************!*\
  !*** ./src/remux/mp4-remuxer.js ***!
  \**********************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * fMP4 remuxer
*/
Object.defineProperty(exports, "__esModule", { value: true });
var aac_helper_1 = __webpack_require__(/*! ./aac-helper */ "./src/remux/aac-helper.js");
var mp4_generator_1 = __webpack_require__(/*! ./mp4-generator */ "./src/remux/mp4-generator.js");
var events_1 = __webpack_require__(/*! ../events */ "./src/events.js");
var errors_1 = __webpack_require__(/*! ../errors */ "./src/errors.js");
var logger_1 = __webpack_require__(/*! ../utils/logger */ "./src/utils/logger.js");
// 10 seconds
var MAX_SILENT_FRAME_DURATION = 10 * 1000;
var MP4Remuxer = /** @class */ (function () {
    function MP4Remuxer(observer, config, typeSupported, vendor) {
        this.observer = observer;
        this.config = config;
        this.typeSupported = typeSupported;
        var userAgent = navigator.userAgent;
        this.isSafari = vendor && vendor.indexOf('Apple') > -1 && userAgent && !userAgent.match('CriOS');
        this.ISGenerated = false;
    }
    MP4Remuxer.prototype.destroy = function () {
    };
    MP4Remuxer.prototype.resetTimeStamp = function (defaultTimeStamp) {
        this._initPTS = this._initDTS = defaultTimeStamp;
    };
    MP4Remuxer.prototype.resetInitSegment = function () {
        this.ISGenerated = false;
    };
    MP4Remuxer.prototype.remux = function (audioTrack, videoTrack, id3Track, textTrack, timeOffset, contiguous, accurateTimeOffset) {
        // generate Init Segment if needed
        if (!this.ISGenerated) {
            this.generateIS(audioTrack, videoTrack, timeOffset);
        }
        if (this.ISGenerated) {
            var nbAudioSamples = audioTrack.samples.length;
            var nbVideoSamples = videoTrack.samples.length;
            var audioTimeOffset = timeOffset;
            var videoTimeOffset = timeOffset;
            if (nbAudioSamples && nbVideoSamples) {
                // timeOffset is expected to be the offset of the first timestamp of this fragment (first DTS)
                // if first audio DTS is not aligned with first video DTS then we need to take that into account
                // when providing timeOffset to remuxAudio / remuxVideo. if we don't do that, there might be a permanent / small
                // drift between audio and video streams
                var audiovideoDeltaDts = (audioTrack.samples[0].pts - videoTrack.samples[0].pts) / videoTrack.inputTimeScale;
                audioTimeOffset += Math.max(0, audiovideoDeltaDts);
                videoTimeOffset += Math.max(0, -audiovideoDeltaDts);
            }
            // Purposefully remuxing audio before video, so that remuxVideo can use nextAudioPts, which is
            // calculated in remuxAudio.
            // logger.log('nb AAC samples:' + audioTrack.samples.length);
            if (nbAudioSamples) {
                // if initSegment was generated without video samples, regenerate it again
                if (!audioTrack.timescale) {
                    logger_1.logger.warn('regenerate InitSegment as audio detected');
                    this.generateIS(audioTrack, videoTrack, timeOffset);
                }
                var audioData = this.remuxAudio(audioTrack, audioTimeOffset, contiguous, accurateTimeOffset);
                // logger.log('nb AVC samples:' + videoTrack.samples.length);
                if (nbVideoSamples) {
                    var audioTrackLength = void 0;
                    if (audioData) {
                        audioTrackLength = audioData.endPTS - audioData.startPTS;
                    }
                    // if initSegment was generated without video samples, regenerate it again
                    if (!videoTrack.timescale) {
                        logger_1.logger.warn('regenerate InitSegment as video detected');
                        this.generateIS(audioTrack, videoTrack, timeOffset);
                    }
                    this.remuxVideo(videoTrack, videoTimeOffset, contiguous, audioTrackLength, accurateTimeOffset);
                }
            }
            else {
                // logger.log('nb AVC samples:' + videoTrack.samples.length);
                if (nbVideoSamples) {
                    var videoData = this.remuxVideo(videoTrack, videoTimeOffset, contiguous, 0, accurateTimeOffset);
                    if (videoData && audioTrack.codec) {
                        this.remuxEmptyAudio(audioTrack, audioTimeOffset, contiguous, videoData);
                    }
                }
            }
        }
        // logger.log('nb ID3 samples:' + audioTrack.samples.length);
        if (id3Track.samples.length) {
            this.remuxID3(id3Track, timeOffset);
        }
        // logger.log('nb ID3 samples:' + audioTrack.samples.length);
        if (textTrack.samples.length) {
            this.remuxText(textTrack, timeOffset);
        }
        // notify end of parsing
        this.observer.trigger(events_1.default.FRAG_PARSED);
    };
    MP4Remuxer.prototype.generateIS = function (audioTrack, videoTrack, timeOffset) {
        var observer = this.observer, audioSamples = audioTrack.samples, videoSamples = videoTrack.samples, typeSupported = this.typeSupported, container = 'audio/mp4', tracks = {}, data = { tracks: tracks }, computePTSDTS = (this._initPTS === undefined), initPTS, initDTS;
        if (computePTSDTS) {
            initPTS = initDTS = Infinity;
        }
        if (audioTrack.config && audioSamples.length) {
            // let's use audio sampling rate as MP4 time scale.
            // rationale is that there is a integer nb of audio frames per audio sample (1024 for AAC)
            // using audio sampling rate here helps having an integer MP4 frame duration
            // this avoids potential rounding issue and AV sync issue
            audioTrack.timescale = audioTrack.samplerate;
            logger_1.logger.log("audio sampling rate : " + audioTrack.samplerate);
            if (!audioTrack.isAAC) {
                if (typeSupported.mpeg) { // Chrome and Safari
                    container = 'audio/mpeg';
                    audioTrack.codec = '';
                }
                else if (typeSupported.mp3) { // Firefox
                    audioTrack.codec = 'mp3';
                }
            }
            tracks.audio = {
                container: container,
                codec: audioTrack.codec,
                initSegment: !audioTrack.isAAC && typeSupported.mpeg ? new Uint8Array() : mp4_generator_1.default.initSegment([audioTrack]),
                metadata: {
                    channelCount: audioTrack.channelCount
                }
            };
            if (computePTSDTS) {
                // remember first PTS of this demuxing context. for audio, PTS = DTS
                initPTS = initDTS = audioSamples[0].pts - audioTrack.inputTimeScale * timeOffset;
            }
        }
        if (videoTrack.sps && videoTrack.pps && videoSamples.length) {
            // let's use input time scale as MP4 video timescale
            // we use input time scale straight away to avoid rounding issues on frame duration / cts computation
            var inputTimeScale = videoTrack.inputTimeScale;
            videoTrack.timescale = inputTimeScale;
            tracks.video = {
                container: 'video/mp4',
                codec: videoTrack.codec,
                initSegment: mp4_generator_1.default.initSegment([videoTrack]),
                metadata: {
                    width: videoTrack.width,
                    height: videoTrack.height
                }
            };
            if (computePTSDTS) {
                initPTS = Math.min(initPTS, videoSamples[0].pts - inputTimeScale * timeOffset);
                initDTS = Math.min(initDTS, videoSamples[0].dts - inputTimeScale * timeOffset);
                this.observer.trigger(events_1.default.INIT_PTS_FOUND, { initPTS: initPTS });
            }
        }
        if (Object.keys(tracks).length) {
            observer.trigger(events_1.default.FRAG_PARSING_INIT_SEGMENT, data);
            this.ISGenerated = true;
            if (computePTSDTS) {
                this._initPTS = initPTS;
                this._initDTS = initDTS;
            }
        }
        else {
            observer.trigger(events_1.default.ERROR, { type: errors_1.ErrorTypes.MEDIA_ERROR, details: errors_1.ErrorDetails.FRAG_PARSING_ERROR, fatal: false, reason: 'no audio/video samples found' });
        }
    };
    MP4Remuxer.prototype.remuxVideo = function (track, timeOffset, contiguous, audioTrackLength, accurateTimeOffset) {
        var offset = 8;
        var mp4SampleDuration;
        var mdat;
        var moof;
        var firstPTS;
        var firstDTS;
        var lastPTS;
        var lastDTS;
        var timeScale = track.timescale;
        var inputSamples = track.samples;
        var outputSamples = [];
        var nbSamples = inputSamples.length;
        var ptsNormalize = this._PTSNormalize;
        var initPTS = this._initPTS;
        // if parsed fragment is contiguous with last one, let's use last DTS value as reference
        var nextAvcDts = this.nextAvcDts;
        var isSafari = this.isSafari;
        if (nbSamples === 0) {
            return;
        }
        // Safari does not like overlapping DTS on consecutive fragments. let's use nextAvcDts to overcome this if fragments are consecutive
        if (isSafari) {
            // also consider consecutive fragments as being contiguous (even if a level switch occurs),
            // for sake of clarity:
            // consecutive fragments are frags with
            //  - less than 100ms gaps between new time offset (if accurate) and next expected PTS OR
            //  - less than 200 ms PTS gaps (timeScale/5)
            contiguous |= (inputSamples.length && nextAvcDts &&
                ((accurateTimeOffset && Math.abs(timeOffset - nextAvcDts / timeScale) < 0.1) ||
                    Math.abs((inputSamples[0].pts - nextAvcDts - initPTS)) < timeScale / 5));
        }
        if (!contiguous) {
            // if not contiguous, let's use target timeOffset
            nextAvcDts = timeOffset * timeScale;
        }
        // PTS is coded on 33bits, and can loop from -2^32 to 2^32
        // ptsNormalize will make PTS/DTS value monotonic, we use last known DTS value as reference value
        inputSamples.forEach(function (sample) {
            sample.pts = ptsNormalize(sample.pts - initPTS, nextAvcDts);
            sample.dts = ptsNormalize(sample.dts - initPTS, nextAvcDts);
        });
        // sort video samples by DTS then PTS then demux id order
        inputSamples.sort(function (a, b) {
            var deltadts = a.dts - b.dts;
            var deltapts = a.pts - b.pts;
            return deltadts || (deltapts || (a.id - b.id));
        });
        // handle broken streams with PTS < DTS, tolerance up 200ms (18000 in 90kHz timescale)
        var PTSDTSshift = inputSamples.reduce(function (prev, curr) { return Math.max(Math.min(prev, curr.pts - curr.dts), -18000); }, 0);
        if (PTSDTSshift < 0) {
            logger_1.logger.warn("PTS < DTS detected in video samples, shifting DTS by " + Math.round(PTSDTSshift / 90) + " ms to overcome this issue");
            for (var i = 0; i < inputSamples.length; i++) {
                inputSamples[i].dts += PTSDTSshift;
            }
        }
        // compute first DTS and last DTS, normalize them against reference value
        var sample = inputSamples[0];
        firstDTS = Math.max(sample.dts, 0);
        firstPTS = Math.max(sample.pts, 0);
        // check timestamp continuity accross consecutive fragments (this is to remove inter-fragment gap/hole)
        var delta = Math.round((firstDTS - nextAvcDts) / 90);
        // if fragment are contiguous, detect hole/overlapping between fragments
        if (contiguous) {
            if (delta) {
                if (delta > 1) {
                    logger_1.logger.log("AVC:" + delta + " ms hole between fragments detected,filling it");
                }
                else if (delta < -1) {
                    logger_1.logger.log("AVC:" + (-delta) + " ms overlapping between fragments detected");
                }
                // remove hole/gap : set DTS to next expected DTS
                firstDTS = nextAvcDts;
                inputSamples[0].dts = firstDTS;
                // offset PTS as well, ensure that PTS is smaller or equal than new DTS
                firstPTS = Math.max(firstPTS - delta, nextAvcDts);
                inputSamples[0].pts = firstPTS;
                logger_1.logger.log("Video/PTS/DTS adjusted: " + Math.round(firstPTS / 90) + "/" + Math.round(firstDTS / 90) + ",delta:" + delta + " ms");
            }
        }
        // compute lastPTS/lastDTS
        sample = inputSamples[inputSamples.length - 1];
        lastDTS = Math.max(sample.dts, 0);
        lastPTS = Math.max(sample.pts, 0, lastDTS);
        // on Safari let's signal the same sample duration for all samples
        // sample duration (as expected by trun MP4 boxes), should be the delta between sample DTS
        // set this constant duration as being the avg delta between consecutive DTS.
        if (isSafari) {
            mp4SampleDuration = Math.round((lastDTS - firstDTS) / (inputSamples.length - 1));
        }
        var nbNalu = 0, naluLen = 0;
        for (var i = 0; i < nbSamples; i++) {
            // compute total/avc sample length and nb of NAL units
            var sample_1 = inputSamples[i], units = sample_1.units, nbUnits = units.length, sampleLen = 0;
            for (var j = 0; j < nbUnits; j++) {
                sampleLen += units[j].data.length;
            }
            naluLen += sampleLen;
            nbNalu += nbUnits;
            sample_1.length = sampleLen;
            // normalize PTS/DTS
            if (isSafari) {
                // sample DTS is computed using a constant decoding offset (mp4SampleDuration) between samples
                sample_1.dts = firstDTS + i * mp4SampleDuration;
            }
            else {
                // ensure sample monotonic DTS
                sample_1.dts = Math.max(sample_1.dts, firstDTS);
            }
            // ensure that computed value is greater or equal than sample DTS
            sample_1.pts = Math.max(sample_1.pts, sample_1.dts);
        }
        /* concatenate the video data and construct the mdat in place
          (need 8 more bytes to fill length and mpdat type) */
        var mdatSize = naluLen + (4 * nbNalu) + 8;
        try {
            mdat = new Uint8Array(mdatSize);
        }
        catch (err) {
            this.observer.trigger(events_1.default.ERROR, { type: errors_1.ErrorTypes.MUX_ERROR, details: errors_1.ErrorDetails.REMUX_ALLOC_ERROR, fatal: false, bytes: mdatSize, reason: "fail allocating video mdat " + mdatSize });
            return;
        }
        var view = new DataView(mdat.buffer);
        view.setUint32(0, mdatSize);
        mdat.set(mp4_generator_1.default.types.mdat, 4);
        for (var i = 0; i < nbSamples; i++) {
            var avcSample = inputSamples[i], avcSampleUnits = avcSample.units, mp4SampleLength = 0, compositionTimeOffset = void 0;
            // convert NALU bitstream to MP4 format (prepend NALU with size field)
            for (var j = 0, nbUnits = avcSampleUnits.length; j < nbUnits; j++) {
                var unit = avcSampleUnits[j], unitData = unit.data, unitDataLen = unit.data.byteLength;
                view.setUint32(offset, unitDataLen);
                offset += 4;
                mdat.set(unitData, offset);
                offset += unitDataLen;
                mp4SampleLength += 4 + unitDataLen;
            }
            if (!isSafari) {
                // expected sample duration is the Decoding Timestamp diff of consecutive samples
                if (i < nbSamples - 1) {
                    mp4SampleDuration = inputSamples[i + 1].dts - avcSample.dts;
                }
                else {
                    var config = this.config, lastFrameDuration = avcSample.dts - inputSamples[i > 0 ? i - 1 : i].dts;
                    if (config.stretchShortVideoTrack) {
                        // In some cases, a segment's audio track duration may exceed the video track duration.
                        // Since we've already remuxed audio, and we know how long the audio track is, we look to
                        // see if the delta to the next segment is longer than maxBufferHole.
                        // If so, playback would potentially get stuck, so we artificially inflate
                        // the duration of the last frame to minimize any potential gap between segments.
                        var maxBufferHole = config.maxBufferHole, gapTolerance = Math.floor(maxBufferHole * timeScale), deltaToFrameEnd = (audioTrackLength ? firstPTS + audioTrackLength * timeScale : this.nextAudioPts) - avcSample.pts;
                        if (deltaToFrameEnd > gapTolerance) {
                            // We subtract lastFrameDuration from deltaToFrameEnd to try to prevent any video
                            // frame overlap. maxBufferHole should be >> lastFrameDuration anyway.
                            mp4SampleDuration = deltaToFrameEnd - lastFrameDuration;
                            if (mp4SampleDuration < 0) {
                                mp4SampleDuration = lastFrameDuration;
                            }
                            logger_1.logger.log("It is approximately " + deltaToFrameEnd / 90 + " ms to the next segment; using duration " + mp4SampleDuration / 90 + " ms for the last video frame.");
                        }
                        else {
                            mp4SampleDuration = lastFrameDuration;
                        }
                    }
                    else {
                        mp4SampleDuration = lastFrameDuration;
                    }
                }
                compositionTimeOffset = Math.round(avcSample.pts - avcSample.dts);
            }
            else {
                compositionTimeOffset = Math.max(0, mp4SampleDuration * Math.round((avcSample.pts - avcSample.dts) / mp4SampleDuration));
            }
            // console.log('PTS/DTS/initDTS/normPTS/normDTS/relative PTS : ${avcSample.pts}/${avcSample.dts}/${initDTS}/${ptsnorm}/${dtsnorm}/${(avcSample.pts/4294967296).toFixed(3)}');
            outputSamples.push({
                size: mp4SampleLength,
                // constant duration
                duration: mp4SampleDuration,
                cts: compositionTimeOffset,
                flags: {
                    isLeading: 0,
                    isDependedOn: 0,
                    hasRedundancy: 0,
                    degradPrio: 0,
                    dependsOn: avcSample.key ? 2 : 1,
                    isNonSync: avcSample.key ? 0 : 1
                }
            });
        }
        // next AVC sample DTS should be equal to last sample DTS + last sample duration (in PES timescale)
        this.nextAvcDts = lastDTS + mp4SampleDuration;
        var dropped = track.dropped;
        track.len = 0;
        track.nbNalu = 0;
        track.dropped = 0;
        if (outputSamples.length && navigator.userAgent.toLowerCase().indexOf('chrome') > -1) {
            var flags = outputSamples[0].flags;
            // chrome workaround, mark first sample as being a Random Access Point to avoid sourcebuffer append issue
            // https://code.google.com/p/chromium/issues/detail?id=229412
            flags.dependsOn = 2;
            flags.isNonSync = 0;
        }
        track.samples = outputSamples;
        moof = mp4_generator_1.default.moof(track.sequenceNumber++, firstDTS, track);
        track.samples = [];
        var data = {
            data1: moof,
            data2: mdat,
            startPTS: firstPTS / timeScale,
            endPTS: (lastPTS + mp4SampleDuration) / timeScale,
            startDTS: firstDTS / timeScale,
            endDTS: this.nextAvcDts / timeScale,
            type: 'video',
            hasAudio: false,
            hasVideo: true,
            nb: outputSamples.length,
            dropped: dropped
        };
        this.observer.trigger(events_1.default.FRAG_PARSING_DATA, data);
        return data;
    };
    MP4Remuxer.prototype.remuxAudio = function (track, timeOffset, contiguous, accurateTimeOffset) {
        var inputTimeScale = track.inputTimeScale;
        var mp4timeScale = track.timescale;
        var scaleFactor = inputTimeScale / mp4timeScale;
        var mp4SampleDuration = track.isAAC ? 1024 : 1152;
        var inputSampleDuration = mp4SampleDuration * scaleFactor;
        var ptsNormalize = this._PTSNormalize;
        var initPTS = this._initPTS;
        var rawMPEG = !track.isAAC && this.typeSupported.mpeg;
        var offset, mp4Sample, fillFrame, mdat, moof, firstPTS, lastPTS, inputSamples = track.samples, outputSamples = [], nextAudioPts = this.nextAudioPts;
        // for audio samples, also consider consecutive fragments as being contiguous (even if a level switch occurs),
        // for sake of clarity:
        // consecutive fragments are frags with
        //  - less than 100ms gaps between new time offset (if accurate) and next expected PTS OR
        //  - less than 20 audio frames distance
        // contiguous fragments are consecutive fragments from same quality level (same level, new SN = old SN + 1)
        // this helps ensuring audio continuity
        // and this also avoids audio glitches/cut when switching quality, or reporting wrong duration on first audio frame
        contiguous |= (inputSamples.length && nextAudioPts &&
            ((accurateTimeOffset && Math.abs(timeOffset - nextAudioPts / inputTimeScale) < 0.1) ||
                Math.abs((inputSamples[0].pts - nextAudioPts - initPTS)) < 20 * inputSampleDuration));
        // compute normalized PTS
        inputSamples.forEach(function (sample) {
            sample.pts = sample.dts = ptsNormalize(sample.pts - initPTS, timeOffset * inputTimeScale);
        });
        // filter out sample with negative PTS that are not playable anyway
        // if we don't remove these negative samples, they will shift all audio samples forward.
        // leading to audio overlap between current / next fragment
        inputSamples = inputSamples.filter(function (sample) {
            return sample.pts >= 0;
        });
        // in case all samples have negative PTS, and have been filtered out, return now
        if (inputSamples.length === 0) {
            return;
        }
        if (!contiguous) {
            if (!accurateTimeOffset) {
                // if frag are mot contiguous and if we cant trust time offset, let's use first sample PTS as next audio PTS
                nextAudioPts = inputSamples[0].pts;
            }
            else {
                // if timeOffset is accurate, let's use it as predicted next audio PTS
                nextAudioPts = timeOffset * inputTimeScale;
            }
        }
        // If the audio track is missing samples, the frames seem to get "left-shifted" within the
        // resulting mp4 segment, causing sync issues and leaving gaps at the end of the audio segment.
        // In an effort to prevent this from happening, we inject frames here where there are gaps.
        // When possible, we inject a silent frame; when that's not possible, we duplicate the last
        // frame.
        if (track.isAAC) {
            var maxAudioFramesDrift = this.config.maxAudioFramesDrift;
            for (var i = 0, nextPts = nextAudioPts; i < inputSamples.length;) {
                // First, let's see how far off this frame is from where we expect it to be
                var sample = inputSamples[i], delta;
                var pts = sample.pts;
                delta = pts - nextPts;
                var duration = Math.abs(1000 * delta / inputTimeScale);
                // If we're overlapping by more than a duration, drop this sample
                if (delta <= -maxAudioFramesDrift * inputSampleDuration) {
                    logger_1.logger.warn("Dropping 1 audio frame @ " + (nextPts / inputTimeScale).toFixed(3) + "s due to " + Math.round(duration) + " ms overlap.");
                    inputSamples.splice(i, 1);
                    track.len -= sample.unit.length;
                    // Don't touch nextPtsNorm or i
                } // eslint-disable-line brace-style
                // Insert missing frames if:
                // 1: We're more than maxAudioFramesDrift frame away
                // 2: Not more than MAX_SILENT_FRAME_DURATION away
                // 3: currentTime (aka nextPtsNorm) is not 0
                else if (delta >= maxAudioFramesDrift * inputSampleDuration && duration < MAX_SILENT_FRAME_DURATION && nextPts) {
                    var missing = Math.round(delta / inputSampleDuration);
                    logger_1.logger.warn("Injecting " + missing + " audio frame @ " + (nextPts / inputTimeScale).toFixed(3) + "s due to " + Math.round(1000 * delta / inputTimeScale) + " ms gap.");
                    for (var j = 0; j < missing; j++) {
                        var newStamp = Math.max(nextPts, 0);
                        fillFrame = aac_helper_1.default.getSilentFrame(track.manifestCodec || track.codec, track.channelCount);
                        if (!fillFrame) {
                            logger_1.logger.log('Unable to get silent frame for given audio codec; duplicating last frame instead.');
                            fillFrame = sample.unit.subarray();
                        }
                        inputSamples.splice(i, 0, { unit: fillFrame, pts: newStamp, dts: newStamp });
                        track.len += fillFrame.length;
                        nextPts += inputSampleDuration;
                        i++;
                    }
                    // Adjust sample to next expected pts
                    sample.pts = sample.dts = nextPts;
                    nextPts += inputSampleDuration;
                    i++;
                }
                else {
                    // Otherwise, just adjust pts
                    if (Math.abs(delta) > (0.1 * inputSampleDuration)) {
                        // logger.log(`Invalid frame delta ${Math.round(delta + inputSampleDuration)} at PTS ${Math.round(pts / 90)} (should be ${Math.round(inputSampleDuration)}).`);
                    }
                    sample.pts = sample.dts = nextPts;
                    nextPts += inputSampleDuration;
                    i++;
                }
            }
        }
        for (var j = 0, nbSamples_1 = inputSamples.length; j < nbSamples_1; j++) {
            var audioSample = inputSamples[j];
            var unit = audioSample.unit;
            var pts = audioSample.pts;
            // logger.log(`Audio/PTS:${Math.round(pts/90)}`);
            // if not first sample
            if (lastPTS !== undefined) {
                mp4Sample.duration = Math.round((pts - lastPTS) / scaleFactor);
            }
            else {
                var delta_1 = Math.round(1000 * (pts - nextAudioPts) / inputTimeScale), numMissingFrames = 0;
                // if fragment are contiguous, detect hole/overlapping between fragments
                // contiguous fragments are consecutive fragments from same quality level (same level, new SN = old SN + 1)
                if (contiguous && track.isAAC) {
                    // log delta
                    if (delta_1) {
                        if (delta_1 > 0 && delta_1 < MAX_SILENT_FRAME_DURATION) {
                            numMissingFrames = Math.round((pts - nextAudioPts) / inputSampleDuration);
                            logger_1.logger.log(delta_1 + " ms hole between AAC samples detected,filling it");
                            if (numMissingFrames > 0) {
                                fillFrame = aac_helper_1.default.getSilentFrame(track.manifestCodec || track.codec, track.channelCount);
                                if (!fillFrame) {
                                    fillFrame = unit.subarray();
                                }
                                track.len += numMissingFrames * fillFrame.length;
                            }
                            // if we have frame overlap, overlapping for more than half a frame duraion
                        }
                        else if (delta_1 < -12) {
                            // drop overlapping audio frames... browser will deal with it
                            logger_1.logger.log("drop overlapping AAC sample, expected/parsed/delta:" + (nextAudioPts / inputTimeScale).toFixed(3) + "s/" + (pts / inputTimeScale).toFixed(3) + "s/" + (-delta_1) + "ms");
                            track.len -= unit.byteLength;
                            continue;
                        }
                        // set PTS/DTS to expected PTS/DTS
                        pts = nextAudioPts;
                    }
                }
                // remember first PTS of our audioSamples
                firstPTS = pts;
                if (track.len > 0) {
                    /* concatenate the audio data and construct the mdat in place
                      (need 8 more bytes to fill length and mdat type) */
                    var mdatSize = rawMPEG ? track.len : track.len + 8;
                    offset = rawMPEG ? 0 : 8;
                    try {
                        mdat = new Uint8Array(mdatSize);
                    }
                    catch (err) {
                        this.observer.trigger(events_1.default.ERROR, { type: errors_1.ErrorTypes.MUX_ERROR, details: errors_1.ErrorDetails.REMUX_ALLOC_ERROR, fatal: false, bytes: mdatSize, reason: "fail allocating audio mdat " + mdatSize });
                        return;
                    }
                    if (!rawMPEG) {
                        var view = new DataView(mdat.buffer);
                        view.setUint32(0, mdatSize);
                        mdat.set(mp4_generator_1.default.types.mdat, 4);
                    }
                }
                else {
                    // no audio samples
                    return;
                }
                for (var i = 0; i < numMissingFrames; i++) {
                    fillFrame = aac_helper_1.default.getSilentFrame(track.manifestCodec || track.codec, track.channelCount);
                    if (!fillFrame) {
                        logger_1.logger.log('Unable to get silent frame for given audio codec; duplicating this frame instead.');
                        fillFrame = unit.subarray();
                    }
                    mdat.set(fillFrame, offset);
                    offset += fillFrame.byteLength;
                    mp4Sample = {
                        size: fillFrame.byteLength,
                        cts: 0,
                        duration: 1024,
                        flags: {
                            isLeading: 0,
                            isDependedOn: 0,
                            hasRedundancy: 0,
                            degradPrio: 0,
                            dependsOn: 1
                        }
                    };
                    outputSamples.push(mp4Sample);
                }
            }
            mdat.set(unit, offset);
            var unitLen = unit.byteLength;
            offset += unitLen;
            // console.log('PTS/DTS/initDTS/normPTS/normDTS/relative PTS : ${audioSample.pts}/${audioSample.dts}/${initDTS}/${ptsnorm}/${dtsnorm}/${(audioSample.pts/4294967296).toFixed(3)}');
            mp4Sample = {
                size: unitLen,
                cts: 0,
                duration: 0,
                flags: {
                    isLeading: 0,
                    isDependedOn: 0,
                    hasRedundancy: 0,
                    degradPrio: 0,
                    dependsOn: 1
                }
            };
            outputSamples.push(mp4Sample);
            lastPTS = pts;
        }
        var lastSampleDuration = 0;
        var nbSamples = outputSamples.length;
        // set last sample duration as being identical to previous sample
        if (nbSamples >= 2) {
            lastSampleDuration = outputSamples[nbSamples - 2].duration;
            mp4Sample.duration = lastSampleDuration;
        }
        if (nbSamples) {
            // next audio sample PTS should be equal to last sample PTS + duration
            this.nextAudioPts = nextAudioPts = lastPTS + scaleFactor * lastSampleDuration;
            // logger.log('Audio/PTS/PTSend:' + audioSample.pts.toFixed(0) + '/' + this.nextAacDts.toFixed(0));
            track.len = 0;
            track.samples = outputSamples;
            if (rawMPEG) {
                moof = new Uint8Array();
            }
            else {
                moof = mp4_generator_1.default.moof(track.sequenceNumber++, firstPTS / scaleFactor, track);
            }
            track.samples = [];
            var start = firstPTS / inputTimeScale;
            var end = nextAudioPts / inputTimeScale;
            var audioData = {
                data1: moof,
                data2: mdat,
                startPTS: start,
                endPTS: end,
                startDTS: start,
                endDTS: end,
                type: 'audio',
                hasAudio: true,
                hasVideo: false,
                nb: nbSamples
            };
            this.observer.trigger(events_1.default.FRAG_PARSING_DATA, audioData);
            return audioData;
        }
        return null;
    };
    MP4Remuxer.prototype.remuxEmptyAudio = function (track, timeOffset, contiguous, videoData) {
        var inputTimeScale = track.inputTimeScale, mp4timeScale = track.samplerate ? track.samplerate : inputTimeScale, scaleFactor = inputTimeScale / mp4timeScale, nextAudioPts = this.nextAudioPts, 
        // sync with video's timestamp
        startDTS = (nextAudioPts !== undefined ? nextAudioPts : videoData.startDTS * inputTimeScale) + this._initDTS, endDTS = videoData.endDTS * inputTimeScale + this._initDTS, 
        // one sample's duration value
        sampleDuration = 1024, frameDuration = scaleFactor * sampleDuration, 
        // samples count of this segment's duration
        nbSamples = Math.ceil((endDTS - startDTS) / frameDuration), 
        // silent frame
        silentFrame = aac_helper_1.default.getSilentFrame(track.manifestCodec || track.codec, track.channelCount);
        logger_1.logger.warn('remux empty Audio');
        // Can't remux if we can't generate a silent frame...
        if (!silentFrame) {
            logger_1.logger.trace('Unable to remuxEmptyAudio since we were unable to get a silent frame for given audio codec!');
            return;
        }
        var samples = [];
        for (var i = 0; i < nbSamples; i++) {
            var stamp = startDTS + i * frameDuration;
            samples.push({ unit: silentFrame, pts: stamp, dts: stamp });
            track.len += silentFrame.length;
        }
        track.samples = samples;
        this.remuxAudio(track, timeOffset, contiguous);
    };
    MP4Remuxer.prototype.remuxID3 = function (track) {
        var length = track.samples.length, sample;
        var inputTimeScale = track.inputTimeScale;
        var initPTS = this._initPTS;
        var initDTS = this._initDTS;
        // consume samples
        if (length) {
            for (var index = 0; index < length; index++) {
                sample = track.samples[index];
                // setting id3 pts, dts to relative time
                // using this._initPTS and this._initDTS to calculate relative time
                sample.pts = ((sample.pts - initPTS) / inputTimeScale);
                sample.dts = ((sample.dts - initDTS) / inputTimeScale);
            }
            this.observer.trigger(events_1.default.FRAG_PARSING_METADATA, {
                samples: track.samples
            });
        }
        track.samples = [];
    };
    MP4Remuxer.prototype.remuxText = function (track) {
        track.samples.sort(function (a, b) {
            return (a.pts - b.pts);
        });
        var length = track.samples.length, sample;
        var inputTimeScale = track.inputTimeScale;
        var initPTS = this._initPTS;
        // consume samples
        if (length) {
            for (var index = 0; index < length; index++) {
                sample = track.samples[index];
                // setting text pts, dts to relative time
                // using this._initPTS and this._initDTS to calculate relative time
                sample.pts = ((sample.pts - initPTS) / inputTimeScale);
            }
            this.observer.trigger(events_1.default.FRAG_PARSING_USERDATA, {
                samples: track.samples
            });
        }
        track.samples = [];
    };
    MP4Remuxer.prototype._PTSNormalize = function (value, reference) {
        var offset;
        if (reference === undefined) {
            return value;
        }
        if (reference < value) {
            // - 2^33
            offset = -8589934592;
        }
        else {
            // + 2^33
            offset = 8589934592;
        }
        /* PTS is 33bit (from 0 to 2^33 -1)
          if diff between value and reference is bigger than half of the amplitude (2^32) then it means that
          PTS looping occured. fill the gap */
        while (Math.abs(value - reference) > 4294967296) {
            value += offset;
        }
        return value;
    };
    return MP4Remuxer;
}());
exports.default = MP4Remuxer;


/***/ }),

/***/ "./src/remux/passthrough-remuxer.js":
/*!******************************************!*\
  !*** ./src/remux/passthrough-remuxer.js ***!
  \******************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * passthrough remuxer
*/
var events_1 = __webpack_require__(/*! ../events */ "./src/events.js");
var PassThroughRemuxer = /** @class */ (function () {
    function PassThroughRemuxer(observer) {
        this.observer = observer;
    }
    PassThroughRemuxer.prototype.destroy = function () {
    };
    PassThroughRemuxer.prototype.resetTimeStamp = function () {
    };
    PassThroughRemuxer.prototype.resetInitSegment = function () {
    };
    PassThroughRemuxer.prototype.remux = function (audioTrack, videoTrack, id3Track, textTrack, timeOffset, contiguous, accurateTimeOffset, rawData) {
        var observer = this.observer;
        var streamType = '';
        if (audioTrack) {
            streamType += 'audio';
        }
        if (videoTrack) {
            streamType += 'video';
        }
        observer.trigger(events_1.default.FRAG_PARSING_DATA, {
            data1: rawData,
            startPTS: timeOffset,
            startDTS: timeOffset,
            type: streamType,
            hasAudio: !!audioTrack,
            hasVideo: !!videoTrack,
            nb: 1,
            dropped: 0
        });
        // notify end of parsing
        observer.trigger(events_1.default.FRAG_PARSED);
    };
    return PassThroughRemuxer;
}());
exports.default = PassThroughRemuxer;


/***/ }),

/***/ "./src/task-loop.js":
/*!**************************!*\
  !*** ./src/task-loop.js ***!
  \**************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var event_handler_1 = __webpack_require__(/*! ./event-handler */ "./src/event-handler.js");
/**
 * Sub-class specialization of EventHandler base class.
 *
 * TaskLoop allows to schedule a task function being called (optionnaly repeatedly) on the main loop,
 * scheduled asynchroneously, avoiding recursive calls in the same tick.
 *
 * The task itself is implemented in `doTick`. It can be requested and called for single execution
 * using the `tick` method.
 *
 * It will be assured that the task execution method (`tick`) only gets called once per main loop "tick",
 * no matter how often it gets requested for execution. Execution in further ticks will be scheduled accordingly.
 *
 * If further execution requests have already been scheduled on the next tick, it can be checked with `hasNextTick`,
 * and cancelled with `clearNextTick`.
 *
 * The task can be scheduled as an interval repeatedly with a period as parameter (see `setInterval`, `clearInterval`).
 *
 * Sub-classes need to implement the `doTick` method which will effectively have the task execution routine.
 *
 * Further explanations:
 *
 * The baseclass has a `tick` method that will schedule the doTick call. It may be called synchroneously
 * only for a stack-depth of one. On re-entrant calls, sub-sequent calls are scheduled for next main loop ticks.
 *
 * When the task execution (`tick` method) is called in re-entrant way this is detected and
 * we are limiting the task execution per call stack to exactly one, but scheduling/post-poning further
 * task processing on the next main loop iteration (also known as "next tick" in the Node/JS runtime lingo).
 */
var TaskLoop = /** @class */ (function (_super) {
    __extends(TaskLoop, _super);
    function TaskLoop(hls) {
        var events = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            events[_i - 1] = arguments[_i];
        }
        var _this = _super.apply(this, [hls].concat(events)) || this;
        _this._tickInterval = null;
        _this._tickTimer = null;
        _this._tickCallCount = 0;
        _this._boundTick = _this.tick.bind(_this);
        return _this;
    }
    /**
     * @override
     */
    TaskLoop.prototype.onHandlerDestroying = function () {
        // clear all timers before unregistering from event bus
        this.clearNextTick();
        this.clearInterval();
    };
    /**
     * @returns {boolean}
     */
    TaskLoop.prototype.hasInterval = function () {
        return !!this._tickInterval;
    };
    /**
     * @returns {boolean}
     */
    TaskLoop.prototype.hasNextTick = function () {
        return !!this._tickTimer;
    };
    /**
     * @param {number} millis Interval time (ms)
     * @returns {boolean} True when interval has been scheduled, false when already scheduled (no effect)
     */
    TaskLoop.prototype.setInterval = function (millis) {
        if (!this._tickInterval) {
            this._tickInterval = setInterval(this._boundTick, millis);
            return true;
        }
        return false;
    };
    /**
     * @returns {boolean} True when interval was cleared, false when none was set (no effect)
     */
    TaskLoop.prototype.clearInterval = function () {
        if (this._tickInterval) {
            clearInterval(this._tickInterval);
            this._tickInterval = null;
            return true;
        }
        return false;
    };
    /**
     * @returns {boolean} True when timeout was cleared, false when none was set (no effect)
     */
    TaskLoop.prototype.clearNextTick = function () {
        if (this._tickTimer) {
            clearTimeout(this._tickTimer);
            this._tickTimer = null;
            return true;
        }
        return false;
    };
    /**
     * Will call the subclass doTick implementation in this main loop tick
     * or in the next one (via setTimeout(,0)) in case it has already been called
     * in this tick (in case this is a re-entrant call).
     */
    TaskLoop.prototype.tick = function () {
        this._tickCallCount++;
        if (this._tickCallCount === 1) {
            this.doTick();
            // re-entrant call to tick from previous doTick call stack
            // -> schedule a call on the next main loop iteration to process this task processing request
            if (this._tickCallCount > 1) {
                // make sure only one timer exists at any time at max
                this.clearNextTick();
                this._tickTimer = setTimeout(this._boundTick, 0);
            }
            this._tickCallCount = 0;
        }
    };
    /**
     * For subclass to implement task logic
     * @abstract
     */
    TaskLoop.prototype.doTick = function () { };
    return TaskLoop;
}(event_handler_1.default));
exports.default = TaskLoop;


/***/ }),

/***/ "./src/utils/attr-list.js":
/*!********************************!*\
  !*** ./src/utils/attr-list.js ***!
  \********************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Number) {
Object.defineProperty(exports, "__esModule", { value: true });
var DECIMAL_RESOLUTION_REGEX = /^(\d+)x(\d+)$/; // eslint-disable-line no-useless-escape
var ATTR_LIST_REGEX = /\s*(.+?)\s*=((?:\".*?\")|.*?)(?:,|$)/g; // eslint-disable-line no-useless-escape
// adapted from https://github.com/kanongil/node-m3u8parse/blob/master/attrlist.js
var AttrList = /** @class */ (function () {
    function AttrList(attrs) {
        if (typeof attrs === 'string') {
            attrs = AttrList.parseAttrList(attrs);
        }
        for (var attr in attrs) {
            if (attrs.hasOwnProperty(attr)) {
                this[attr] = attrs[attr];
            }
        }
    }
    AttrList.prototype.decimalInteger = function (attrName) {
        var intValue = parseInt(this[attrName], 10);
        if (intValue > Number.MAX_SAFE_INTEGER) {
            return Infinity;
        }
        return intValue;
    };
    AttrList.prototype.hexadecimalInteger = function (attrName) {
        if (this[attrName]) {
            var stringValue = (this[attrName] || '0x').slice(2);
            stringValue = ((stringValue.length & 1) ? '0' : '') + stringValue;
            var value = new Uint8Array(stringValue.length / 2);
            for (var i = 0; i < stringValue.length / 2; i++) {
                value[i] = parseInt(stringValue.slice(i * 2, i * 2 + 2), 16);
            }
            return value;
        }
        else {
            return null;
        }
    };
    AttrList.prototype.hexadecimalIntegerAsNumber = function (attrName) {
        var intValue = parseInt(this[attrName], 16);
        if (intValue > Number.MAX_SAFE_INTEGER) {
            return Infinity;
        }
        return intValue;
    };
    AttrList.prototype.decimalFloatingPoint = function (attrName) {
        return parseFloat(this[attrName]);
    };
    AttrList.prototype.enumeratedString = function (attrName) {
        return this[attrName];
    };
    AttrList.prototype.decimalResolution = function (attrName) {
        var res = DECIMAL_RESOLUTION_REGEX.exec(this[attrName]);
        if (res === null) {
            return undefined;
        }
        return {
            width: parseInt(res[1], 10),
            height: parseInt(res[2], 10)
        };
    };
    AttrList.parseAttrList = function (input) {
        var match, attrs = {};
        ATTR_LIST_REGEX.lastIndex = 0;
        while ((match = ATTR_LIST_REGEX.exec(input)) !== null) {
            var value = match[2], quote = '"';
            if (value.indexOf(quote) === 0 &&
                value.lastIndexOf(quote) === (value.length - 1)) {
                value = value.slice(1, -1);
            }
            attrs[match[1]] = value;
        }
        return attrs;
    };
    return AttrList;
}());
exports.default = AttrList;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./src/polyfills/number */ "./src/polyfills/number.js")["Number"]))

/***/ }),

/***/ "./src/utils/binary-search.js":
/*!************************************!*\
  !*** ./src/utils/binary-search.js ***!
  \************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var BinarySearch = {
    /**
       * Searches for an item in an array which matches a certain condition.
       * This requires the condition to only match one item in the array,
       * and for the array to be ordered.
       *
       * @param {Array} list The array to search.
       * @param {Function} comparisonFunction
       *      Called and provided a candidate item as the first argument.
       *      Should return:
       *          > -1 if the item should be located at a lower index than the provided item.
       *          > 1 if the item should be located at a higher index than the provided item.
       *          > 0 if the item is the item you're looking for.
       *
       * @return {*} The object if it is found or null otherwise.
       */
    search: function (list, comparisonFunction) {
        var minIndex = 0;
        var maxIndex = list.length - 1;
        var currentIndex = null;
        var currentElement = null;
        while (minIndex <= maxIndex) {
            currentIndex = (minIndex + maxIndex) / 2 | 0;
            currentElement = list[currentIndex];
            var comparisonResult = comparisonFunction(currentElement);
            if (comparisonResult > 0) {
                minIndex = currentIndex + 1;
            }
            else if (comparisonResult < 0) {
                maxIndex = currentIndex - 1;
            }
            else {
                return currentElement;
            }
        }
        return null;
    }
};
exports.default = BinarySearch;


/***/ }),

/***/ "./src/utils/buffer-helper.js":
/*!************************************!*\
  !*** ./src/utils/buffer-helper.js ***!
  \************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @module BufferHelper
 *
 * Providing methods dealing with buffer length retrieval for example.
 *
 * In general, a helper around HTML5 MediaElement TimeRanges gathered from `buffered` property.
 *
 * Also @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/buffered
*/
Object.defineProperty(exports, "__esModule", { value: true });
var BufferHelper = /** @class */ (function () {
    function BufferHelper() {
    }
    /**
     * Return true if `media`'s buffered include `position`
     * @param {HTMLMediaElement|SourceBuffer} media
     * @param {number} position
     * @returns {boolean}
     */
    BufferHelper.isBuffered = function (media, position) {
        try {
            if (media) {
                var buffered = media.buffered;
                for (var i = 0; i < buffered.length; i++) {
                    if (position >= buffered.start(i) && position <= buffered.end(i)) {
                        return true;
                    }
                }
            }
        }
        catch (error) {
            // this is to catch
            // InvalidStateError: Failed to read the 'buffered' property from 'SourceBuffer':
            // This SourceBuffer has been removed from the parent media source
        }
        return false;
    };
    BufferHelper.bufferInfo = function (media, pos, maxHoleDuration) {
        try {
            if (media) {
                var vbuffered = media.buffered, buffered = [], i = void 0;
                for (i = 0; i < vbuffered.length; i++) {
                    buffered.push({ start: vbuffered.start(i), end: vbuffered.end(i) });
                }
                return this.bufferedInfo(buffered, pos, maxHoleDuration);
            }
        }
        catch (error) {
            // this is to catch
            // InvalidStateError: Failed to read the 'buffered' property from 'SourceBuffer':
            // This SourceBuffer has been removed from the parent media source
        }
        return { len: 0, start: pos, end: pos, nextStart: undefined };
    };
    BufferHelper.bufferedInfo = function (buffered, pos, maxHoleDuration) {
        var buffered2 = [], 
        // bufferStart and bufferEnd are buffer boundaries around current video position
        bufferLen, bufferStart, bufferEnd, bufferStartNext, i;
        // sort on buffer.start/smaller end (IE does not always return sorted buffered range)
        buffered.sort(function (a, b) {
            var diff = a.start - b.start;
            if (diff) {
                return diff;
            }
            else {
                return b.end - a.end;
            }
        });
        // there might be some small holes between buffer time range
        // consider that holes smaller than maxHoleDuration are irrelevant and build another
        // buffer time range representations that discards those holes
        for (i = 0; i < buffered.length; i++) {
            var buf2len = buffered2.length;
            if (buf2len) {
                var buf2end = buffered2[buf2len - 1].end;
                // if small hole (value between 0 or maxHoleDuration ) or overlapping (negative)
                if ((buffered[i].start - buf2end) < maxHoleDuration) {
                    // merge overlapping time ranges
                    // update lastRange.end only if smaller than item.end
                    // e.g.  [ 1, 15] with  [ 2,8] => [ 1,15] (no need to modify lastRange.end)
                    // whereas [ 1, 8] with  [ 2,15] => [ 1,15] ( lastRange should switch from [1,8] to [1,15])
                    if (buffered[i].end > buf2end) {
                        buffered2[buf2len - 1].end = buffered[i].end;
                    }
                }
                else {
                    // big hole
                    buffered2.push(buffered[i]);
                }
            }
            else {
                // first value
                buffered2.push(buffered[i]);
            }
        }
        for (i = 0, bufferLen = 0, bufferStart = bufferEnd = pos; i < buffered2.length; i++) {
            var start = buffered2[i].start, end = buffered2[i].end;
            // logger.log('buf start/end:' + buffered.start(i) + '/' + buffered.end(i));
            if ((pos + maxHoleDuration) >= start && pos < end) {
                // play position is inside this buffer TimeRange, retrieve end of buffer position and buffer length
                bufferStart = start;
                bufferEnd = end;
                bufferLen = bufferEnd - pos;
            }
            else if ((pos + maxHoleDuration) < start) {
                bufferStartNext = start;
                break;
            }
        }
        return { len: bufferLen, start: bufferStart, end: bufferEnd, nextStart: bufferStartNext };
    };
    return BufferHelper;
}());
exports.BufferHelper = BufferHelper;


/***/ }),

/***/ "./src/utils/cea-608-parser.js":
/*!*************************************!*\
  !*** ./src/utils/cea-608-parser.js ***!
  \*************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 *
 * This code was ported from the dash.js project at:
 *   https://github.com/Dash-Industry-Forum/dash.js/blob/development/externals/cea608-parser.js
 *   https://github.com/Dash-Industry-Forum/dash.js/commit/8269b26a761e0853bb21d78780ed945144ecdd4d#diff-71bc295a2d6b6b7093a1d3290d53a4b2
 *
 * The original copyright appears below:
 *
 * The copyright in this software is being made available under the BSD License,
 * included below. This software may be subject to other third party and contributor
 * rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2015-2016, DASH Industry Forum.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *  1. Redistributions of source code must retain the above copyright notice, this
 *  list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *  this list of conditions and the following disclaimer in the documentation and/or
 *  other materials provided with the distribution.
 *  2. Neither the name of Dash Industry Forum nor the names of its
 *  contributors may be used to endorse or promote products derived from this software
 *  without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY
 *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 *  POSSIBILITY OF SUCH DAMAGE.
 */
/**
     *  Exceptions from regular ASCII. CodePoints are mapped to UTF-16 codes
     */
Object.defineProperty(exports, "__esModule", { value: true });
var specialCea608CharsCodes = {
    0x2a: 0xe1,
    0x5c: 0xe9,
    0x5e: 0xed,
    0x5f: 0xf3,
    0x60: 0xfa,
    0x7b: 0xe7,
    0x7c: 0xf7,
    0x7d: 0xd1,
    0x7e: 0xf1,
    0x7f: 0x2588,
    // THIS BLOCK INCLUDES THE 16 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS
    // THAT COME FROM HI BYTE=0x11 AND LOW BETWEEN 0x30 AND 0x3F
    // THIS MEANS THAT \x50 MUST BE ADDED TO THE VALUES
    0x80: 0xae,
    0x81: 0xb0,
    0x82: 0xbd,
    0x83: 0xbf,
    0x84: 0x2122,
    0x85: 0xa2,
    0x86: 0xa3,
    0x87: 0x266a,
    0x88: 0xe0,
    0x89: 0x20,
    0x8a: 0xe8,
    0x8b: 0xe2,
    0x8c: 0xea,
    0x8d: 0xee,
    0x8e: 0xf4,
    0x8f: 0xfb,
    // THIS BLOCK INCLUDES THE 32 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS
    // THAT COME FROM HI BYTE=0x12 AND LOW BETWEEN 0x20 AND 0x3F
    0x90: 0xc1,
    0x91: 0xc9,
    0x92: 0xd3,
    0x93: 0xda,
    0x94: 0xdc,
    0x95: 0xfc,
    0x96: 0x2018,
    0x97: 0xa1,
    0x98: 0x2a,
    0x99: 0x2019,
    0x9a: 0x2501,
    0x9b: 0xa9,
    0x9c: 0x2120,
    0x9d: 0x2022,
    0x9e: 0x201c,
    0x9f: 0x201d,
    0xa0: 0xc0,
    0xa1: 0xc2,
    0xa2: 0xc7,
    0xa3: 0xc8,
    0xa4: 0xca,
    0xa5: 0xcb,
    0xa6: 0xeb,
    0xa7: 0xce,
    0xa8: 0xcf,
    0xa9: 0xef,
    0xaa: 0xd4,
    0xab: 0xd9,
    0xac: 0xf9,
    0xad: 0xdb,
    0xae: 0xab,
    0xaf: 0xbb,
    // THIS BLOCK INCLUDES THE 32 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS
    // THAT COME FROM HI BYTE=0x13 AND LOW BETWEEN 0x20 AND 0x3F
    0xb0: 0xc3,
    0xb1: 0xe3,
    0xb2: 0xcd,
    0xb3: 0xcc,
    0xb4: 0xec,
    0xb5: 0xd2,
    0xb6: 0xf2,
    0xb7: 0xd5,
    0xb8: 0xf5,
    0xb9: 0x7b,
    0xba: 0x7d,
    0xbb: 0x5c,
    0xbc: 0x5e,
    0xbd: 0x5f,
    0xbe: 0x7c,
    0xbf: 0x223c,
    0xc0: 0xc4,
    0xc1: 0xe4,
    0xc2: 0xd6,
    0xc3: 0xf6,
    0xc4: 0xdf,
    0xc5: 0xa5,
    0xc6: 0xa4,
    0xc7: 0x2503,
    0xc8: 0xc5,
    0xc9: 0xe5,
    0xca: 0xd8,
    0xcb: 0xf8,
    0xcc: 0x250f,
    0xcd: 0x2513,
    0xce: 0x2517,
    0xcf: 0x251b // Box drawings heavy up and left
};
/**
 * Utils
 */
var getCharForByte = function (byte) {
    var charCode = byte;
    if (specialCea608CharsCodes.hasOwnProperty(byte)) {
        charCode = specialCea608CharsCodes[byte];
    }
    return String.fromCharCode(charCode);
};
var NR_ROWS = 15, NR_COLS = 100;
// Tables to look up row from PAC data
var rowsLowCh1 = { 0x11: 1, 0x12: 3, 0x15: 5, 0x16: 7, 0x17: 9, 0x10: 11, 0x13: 12, 0x14: 14 };
var rowsHighCh1 = { 0x11: 2, 0x12: 4, 0x15: 6, 0x16: 8, 0x17: 10, 0x13: 13, 0x14: 15 };
var rowsLowCh2 = { 0x19: 1, 0x1A: 3, 0x1D: 5, 0x1E: 7, 0x1F: 9, 0x18: 11, 0x1B: 12, 0x1C: 14 };
var rowsHighCh2 = { 0x19: 2, 0x1A: 4, 0x1D: 6, 0x1E: 8, 0x1F: 10, 0x1B: 13, 0x1C: 15 };
var backgroundColors = ['white', 'green', 'blue', 'cyan', 'red', 'yellow', 'magenta', 'black', 'transparent'];
/**
 * Simple logger class to be able to write with time-stamps and filter on level.
 */
var logger = {
    verboseFilter: { 'DATA': 3, 'DEBUG': 3, 'INFO': 2, 'WARNING': 2, 'TEXT': 1, 'ERROR': 0 },
    time: null,
    verboseLevel: 0,
    setTime: function (newTime) {
        this.time = newTime;
    },
    log: function (severity, msg) {
        var minLevel = this.verboseFilter[severity];
        if (this.verboseLevel >= minLevel) {
            // console.log(this.time + ' [' + severity + '] ' + msg);
        }
    }
};
var numArrayToHexArray = function (numArray) {
    var hexArray = [];
    for (var j = 0; j < numArray.length; j++) {
        hexArray.push(numArray[j].toString(16));
    }
    return hexArray;
};
var PenState = /** @class */ (function () {
    function PenState(foreground, underline, italics, background, flash) {
        this.foreground = foreground || 'white';
        this.underline = underline || false;
        this.italics = italics || false;
        this.background = background || 'black';
        this.flash = flash || false;
    }
    PenState.prototype.reset = function () {
        this.foreground = 'white';
        this.underline = false;
        this.italics = false;
        this.background = 'black';
        this.flash = false;
    };
    PenState.prototype.setStyles = function (styles) {
        var attribs = ['foreground', 'underline', 'italics', 'background', 'flash'];
        for (var i = 0; i < attribs.length; i++) {
            var style = attribs[i];
            if (styles.hasOwnProperty(style)) {
                this[style] = styles[style];
            }
        }
    };
    PenState.prototype.isDefault = function () {
        return (this.foreground === 'white' && !this.underline && !this.italics &&
            this.background === 'black' && !this.flash);
    };
    PenState.prototype.equals = function (other) {
        return ((this.foreground === other.foreground) &&
            (this.underline === other.underline) &&
            (this.italics === other.italics) &&
            (this.background === other.background) &&
            (this.flash === other.flash));
    };
    PenState.prototype.copy = function (newPenState) {
        this.foreground = newPenState.foreground;
        this.underline = newPenState.underline;
        this.italics = newPenState.italics;
        this.background = newPenState.background;
        this.flash = newPenState.flash;
    };
    PenState.prototype.toString = function () {
        return ('color=' + this.foreground + ', underline=' + this.underline + ', italics=' + this.italics +
            ', background=' + this.background + ', flash=' + this.flash);
    };
    return PenState;
}());
/**
 * Unicode character with styling and background.
 * @constructor
 */
var StyledUnicodeChar = /** @class */ (function () {
    function StyledUnicodeChar(uchar, foreground, underline, italics, background, flash) {
        this.uchar = uchar || ' '; // unicode character
        this.penState = new PenState(foreground, underline, italics, background, flash);
    }
    StyledUnicodeChar.prototype.reset = function () {
        this.uchar = ' ';
        this.penState.reset();
    };
    StyledUnicodeChar.prototype.setChar = function (uchar, newPenState) {
        this.uchar = uchar;
        this.penState.copy(newPenState);
    };
    StyledUnicodeChar.prototype.setPenState = function (newPenState) {
        this.penState.copy(newPenState);
    };
    StyledUnicodeChar.prototype.equals = function (other) {
        return this.uchar === other.uchar && this.penState.equals(other.penState);
    };
    StyledUnicodeChar.prototype.copy = function (newChar) {
        this.uchar = newChar.uchar;
        this.penState.copy(newChar.penState);
    };
    StyledUnicodeChar.prototype.isEmpty = function () {
        return this.uchar === ' ' && this.penState.isDefault();
    };
    return StyledUnicodeChar;
}());
/**
 * CEA-608 row consisting of NR_COLS instances of StyledUnicodeChar.
 * @constructor
 */
var Row = /** @class */ (function () {
    function Row() {
        this.chars = [];
        for (var i = 0; i < NR_COLS; i++) {
            this.chars.push(new StyledUnicodeChar());
        }
        this.pos = 0;
        this.currPenState = new PenState();
    }
    Row.prototype.equals = function (other) {
        var equal = true;
        for (var i = 0; i < NR_COLS; i++) {
            if (!this.chars[i].equals(other.chars[i])) {
                equal = false;
                break;
            }
        }
        return equal;
    };
    Row.prototype.copy = function (other) {
        for (var i = 0; i < NR_COLS; i++) {
            this.chars[i].copy(other.chars[i]);
        }
    };
    Row.prototype.isEmpty = function () {
        var empty = true;
        for (var i = 0; i < NR_COLS; i++) {
            if (!this.chars[i].isEmpty()) {
                empty = false;
                break;
            }
        }
        return empty;
    };
    /**
       *  Set the cursor to a valid column.
       */
    Row.prototype.setCursor = function (absPos) {
        if (this.pos !== absPos) {
            this.pos = absPos;
        }
        if (this.pos < 0) {
            logger.log('ERROR', 'Negative cursor position ' + this.pos);
            this.pos = 0;
        }
        else if (this.pos > NR_COLS) {
            logger.log('ERROR', 'Too large cursor position ' + this.pos);
            this.pos = NR_COLS;
        }
    };
    /**
       * Move the cursor relative to current position.
       */
    Row.prototype.moveCursor = function (relPos) {
        var newPos = this.pos + relPos;
        if (relPos > 1) {
            for (var i = this.pos + 1; i < newPos + 1; i++) {
                this.chars[i].setPenState(this.currPenState);
            }
        }
        this.setCursor(newPos);
    };
    /**
       * Backspace, move one step back and clear character.
       */
    Row.prototype.backSpace = function () {
        this.moveCursor(-1);
        this.chars[this.pos].setChar(' ', this.currPenState);
    };
    Row.prototype.insertChar = function (byte) {
        if (byte >= 0x90) { // Extended char
            this.backSpace();
        }
        var char = getCharForByte(byte);
        if (this.pos >= NR_COLS) {
            logger.log('ERROR', 'Cannot insert ' + byte.toString(16) +
                ' (' + char + ') at position ' + this.pos + '. Skipping it!');
            return;
        }
        this.chars[this.pos].setChar(char, this.currPenState);
        this.moveCursor(1);
    };
    Row.prototype.clearFromPos = function (startPos) {
        var i;
        for (i = startPos; i < NR_COLS; i++) {
            this.chars[i].reset();
        }
    };
    Row.prototype.clear = function () {
        this.clearFromPos(0);
        this.pos = 0;
        this.currPenState.reset();
    };
    Row.prototype.clearToEndOfRow = function () {
        this.clearFromPos(this.pos);
    };
    Row.prototype.getTextString = function () {
        var chars = [];
        var empty = true;
        for (var i = 0; i < NR_COLS; i++) {
            var char = this.chars[i].uchar;
            if (char !== ' ') {
                empty = false;
            }
            chars.push(char);
        }
        if (empty) {
            return '';
        }
        else {
            return chars.join('');
        }
    };
    Row.prototype.setPenStyles = function (styles) {
        this.currPenState.setStyles(styles);
        var currChar = this.chars[this.pos];
        currChar.setPenState(this.currPenState);
    };
    return Row;
}());
/**
 * Keep a CEA-608 screen of 32x15 styled characters
 * @constructor
*/
var CaptionScreen = /** @class */ (function () {
    function CaptionScreen() {
        this.rows = [];
        for (var i = 0; i < NR_ROWS; i++) {
            this.rows.push(new Row());
        } // Note that we use zero-based numbering (0-14)
        this.currRow = NR_ROWS - 1;
        this.nrRollUpRows = null;
        this.reset();
    }
    CaptionScreen.prototype.reset = function () {
        for (var i = 0; i < NR_ROWS; i++) {
            this.rows[i].clear();
        }
        this.currRow = NR_ROWS - 1;
    };
    CaptionScreen.prototype.equals = function (other) {
        var equal = true;
        for (var i = 0; i < NR_ROWS; i++) {
            if (!this.rows[i].equals(other.rows[i])) {
                equal = false;
                break;
            }
        }
        return equal;
    };
    CaptionScreen.prototype.copy = function (other) {
        for (var i = 0; i < NR_ROWS; i++) {
            this.rows[i].copy(other.rows[i]);
        }
    };
    CaptionScreen.prototype.isEmpty = function () {
        var empty = true;
        for (var i = 0; i < NR_ROWS; i++) {
            if (!this.rows[i].isEmpty()) {
                empty = false;
                break;
            }
        }
        return empty;
    };
    CaptionScreen.prototype.backSpace = function () {
        var row = this.rows[this.currRow];
        row.backSpace();
    };
    CaptionScreen.prototype.clearToEndOfRow = function () {
        var row = this.rows[this.currRow];
        row.clearToEndOfRow();
    };
    /**
       * Insert a character (without styling) in the current row.
       */
    CaptionScreen.prototype.insertChar = function (char) {
        var row = this.rows[this.currRow];
        row.insertChar(char);
    };
    CaptionScreen.prototype.setPen = function (styles) {
        var row = this.rows[this.currRow];
        row.setPenStyles(styles);
    };
    CaptionScreen.prototype.moveCursor = function (relPos) {
        var row = this.rows[this.currRow];
        row.moveCursor(relPos);
    };
    CaptionScreen.prototype.setCursor = function (absPos) {
        logger.log('INFO', 'setCursor: ' + absPos);
        var row = this.rows[this.currRow];
        row.setCursor(absPos);
    };
    CaptionScreen.prototype.setPAC = function (pacData) {
        logger.log('INFO', 'pacData = ' + JSON.stringify(pacData));
        var newRow = pacData.row - 1;
        if (this.nrRollUpRows && newRow < this.nrRollUpRows - 1) {
            newRow = this.nrRollUpRows - 1;
        }
        // Make sure this only affects Roll-up Captions by checking this.nrRollUpRows
        if (this.nrRollUpRows && this.currRow !== newRow) {
            // clear all rows first
            for (var i = 0; i < NR_ROWS; i++) {
                this.rows[i].clear();
            }
            // Copy this.nrRollUpRows rows from lastOutputScreen and place it in the newRow location
            // topRowIndex - the start of rows to copy (inclusive index)
            var topRowIndex = this.currRow + 1 - (this.nrRollUpRows);
            // We only copy if the last position was already shown.
            // We use the cueStartTime value to check this.
            var lastOutputScreen = this.lastOutputScreen;
            if (lastOutputScreen) {
                var prevLineTime = lastOutputScreen.rows[topRowIndex].cueStartTime;
                if (prevLineTime && prevLineTime < logger.time) {
                    for (var i = 0; i < this.nrRollUpRows; i++) {
                        this.rows[newRow - this.nrRollUpRows + i + 1].copy(lastOutputScreen.rows[topRowIndex + i]);
                    }
                }
            }
        }
        this.currRow = newRow;
        var row = this.rows[this.currRow];
        if (pacData.indent !== null) {
            var indent = pacData.indent;
            var prevPos = Math.max(indent - 1, 0);
            row.setCursor(pacData.indent);
            pacData.color = row.chars[prevPos].penState.foreground;
        }
        var styles = { foreground: pacData.color, underline: pacData.underline, italics: pacData.italics, background: 'black', flash: false };
        this.setPen(styles);
    };
    /**
       * Set background/extra foreground, but first do back_space, and then insert space (backwards compatibility).
       */
    CaptionScreen.prototype.setBkgData = function (bkgData) {
        logger.log('INFO', 'bkgData = ' + JSON.stringify(bkgData));
        this.backSpace();
        this.setPen(bkgData);
        this.insertChar(0x20); // Space
    };
    CaptionScreen.prototype.setRollUpRows = function (nrRows) {
        this.nrRollUpRows = nrRows;
    };
    CaptionScreen.prototype.rollUp = function () {
        if (this.nrRollUpRows === null) {
            logger.log('DEBUG', 'roll_up but nrRollUpRows not set yet');
            return; // Not properly setup
        }
        logger.log('TEXT', this.getDisplayText());
        var topRowIndex = this.currRow + 1 - this.nrRollUpRows;
        var topRow = this.rows.splice(topRowIndex, 1)[0];
        topRow.clear();
        this.rows.splice(this.currRow, 0, topRow);
        logger.log('INFO', 'Rolling up');
        // logger.log('TEXT', this.get_display_text())
    };
    /**
      * Get all non-empty rows with as unicode text.
      */
    CaptionScreen.prototype.getDisplayText = function (asOneRow) {
        asOneRow = asOneRow || false;
        var displayText = [];
        var text = '';
        var rowNr = -1;
        for (var i = 0; i < NR_ROWS; i++) {
            var rowText = this.rows[i].getTextString();
            if (rowText) {
                rowNr = i + 1;
                if (asOneRow) {
                    displayText.push('Row ' + rowNr + ': \'' + rowText + '\'');
                }
                else {
                    displayText.push(rowText.trim());
                }
            }
        }
        if (displayText.length > 0) {
            if (asOneRow) {
                text = '[' + displayText.join(' | ') + ']';
            }
            else {
                text = displayText.join('\n');
            }
        }
        return text;
    };
    CaptionScreen.prototype.getTextAndFormat = function () {
        return this.rows;
    };
    return CaptionScreen;
}());
// var modes = ['MODE_ROLL-UP', 'MODE_POP-ON', 'MODE_PAINT-ON', 'MODE_TEXT'];
var Cea608Channel = /** @class */ (function () {
    function Cea608Channel(channelNumber, outputFilter) {
        this.chNr = channelNumber;
        this.outputFilter = outputFilter;
        this.mode = null;
        this.verbose = 0;
        this.displayedMemory = new CaptionScreen();
        this.nonDisplayedMemory = new CaptionScreen();
        this.lastOutputScreen = new CaptionScreen();
        this.currRollUpRow = this.displayedMemory.rows[NR_ROWS - 1];
        this.writeScreen = this.displayedMemory;
        this.mode = null;
        this.cueStartTime = null; // Keeps track of where a cue started.
    }
    Cea608Channel.prototype.reset = function () {
        this.mode = null;
        this.displayedMemory.reset();
        this.nonDisplayedMemory.reset();
        this.lastOutputScreen.reset();
        this.currRollUpRow = this.displayedMemory.rows[NR_ROWS - 1];
        this.writeScreen = this.displayedMemory;
        this.mode = null;
        this.cueStartTime = null;
        this.lastCueEndTime = null;
    };
    Cea608Channel.prototype.getHandler = function () {
        return this.outputFilter;
    };
    Cea608Channel.prototype.setHandler = function (newHandler) {
        this.outputFilter = newHandler;
    };
    Cea608Channel.prototype.setPAC = function (pacData) {
        this.writeScreen.setPAC(pacData);
    };
    Cea608Channel.prototype.setBkgData = function (bkgData) {
        this.writeScreen.setBkgData(bkgData);
    };
    Cea608Channel.prototype.setMode = function (newMode) {
        if (newMode === this.mode) {
            return;
        }
        this.mode = newMode;
        logger.log('INFO', 'MODE=' + newMode);
        if (this.mode === 'MODE_POP-ON') {
            this.writeScreen = this.nonDisplayedMemory;
        }
        else {
            this.writeScreen = this.displayedMemory;
            this.writeScreen.reset();
        }
        if (this.mode !== 'MODE_ROLL-UP') {
            this.displayedMemory.nrRollUpRows = null;
            this.nonDisplayedMemory.nrRollUpRows = null;
        }
        this.mode = newMode;
    };
    Cea608Channel.prototype.insertChars = function (chars) {
        for (var i = 0; i < chars.length; i++) {
            this.writeScreen.insertChar(chars[i]);
        }
        var screen = this.writeScreen === this.displayedMemory ? 'DISP' : 'NON_DISP';
        logger.log('INFO', screen + ': ' + this.writeScreen.getDisplayText(true));
        if (this.mode === 'MODE_PAINT-ON' || this.mode === 'MODE_ROLL-UP') {
            logger.log('TEXT', 'DISPLAYED: ' + this.displayedMemory.getDisplayText(true));
            this.outputDataUpdate();
        }
    };
    Cea608Channel.prototype.ccRCL = function () {
        logger.log('INFO', 'RCL - Resume Caption Loading');
        this.setMode('MODE_POP-ON');
    };
    Cea608Channel.prototype.ccBS = function () {
        logger.log('INFO', 'BS - BackSpace');
        if (this.mode === 'MODE_TEXT') {
            return;
        }
        this.writeScreen.backSpace();
        if (this.writeScreen === this.displayedMemory) {
            this.outputDataUpdate();
        }
    };
    Cea608Channel.prototype.ccAOF = function () {
    };
    Cea608Channel.prototype.ccAON = function () {
    };
    Cea608Channel.prototype.ccDER = function () {
        logger.log('INFO', 'DER- Delete to End of Row');
        this.writeScreen.clearToEndOfRow();
        this.outputDataUpdate();
    };
    Cea608Channel.prototype.ccRU = function (nrRows) {
        logger.log('INFO', 'RU(' + nrRows + ') - Roll Up');
        this.writeScreen = this.displayedMemory;
        this.setMode('MODE_ROLL-UP');
        this.writeScreen.setRollUpRows(nrRows);
    };
    Cea608Channel.prototype.ccFON = function () {
        logger.log('INFO', 'FON - Flash On');
        this.writeScreen.setPen({ flash: true });
    };
    Cea608Channel.prototype.ccRDC = function () {
        logger.log('INFO', 'RDC - Resume Direct Captioning');
        this.setMode('MODE_PAINT-ON');
    };
    Cea608Channel.prototype.ccTR = function () {
        logger.log('INFO', 'TR');
        this.setMode('MODE_TEXT');
    };
    Cea608Channel.prototype.ccRTD = function () {
        logger.log('INFO', 'RTD');
        this.setMode('MODE_TEXT');
    };
    Cea608Channel.prototype.ccEDM = function () {
        logger.log('INFO', 'EDM - Erase Displayed Memory');
        this.displayedMemory.reset();
        this.outputDataUpdate(true);
    };
    Cea608Channel.prototype.ccCR = function () {
        logger.log('CR - Carriage Return');
        this.writeScreen.rollUp();
        this.outputDataUpdate(true);
    };
    Cea608Channel.prototype.ccENM = function () {
        logger.log('INFO', 'ENM - Erase Non-displayed Memory');
        this.nonDisplayedMemory.reset();
    };
    Cea608Channel.prototype.ccEOC = function () {
        logger.log('INFO', 'EOC - End Of Caption');
        if (this.mode === 'MODE_POP-ON') {
            var tmp = this.displayedMemory;
            this.displayedMemory = this.nonDisplayedMemory;
            this.nonDisplayedMemory = tmp;
            this.writeScreen = this.nonDisplayedMemory;
            logger.log('TEXT', 'DISP: ' + this.displayedMemory.getDisplayText());
        }
        this.outputDataUpdate(true);
    };
    Cea608Channel.prototype.ccTO = function (nrCols) {
        logger.log('INFO', 'TO(' + nrCols + ') - Tab Offset');
        this.writeScreen.moveCursor(nrCols);
    };
    Cea608Channel.prototype.ccMIDROW = function (secondByte) {
        var styles = { flash: false };
        styles.underline = secondByte % 2 === 1;
        styles.italics = secondByte >= 0x2e;
        if (!styles.italics) {
            var colorIndex = Math.floor(secondByte / 2) - 0x10;
            var colors = ['white', 'green', 'blue', 'cyan', 'red', 'yellow', 'magenta'];
            styles.foreground = colors[colorIndex];
        }
        else {
            styles.foreground = 'white';
        }
        logger.log('INFO', 'MIDROW: ' + JSON.stringify(styles));
        this.writeScreen.setPen(styles);
    };
    Cea608Channel.prototype.outputDataUpdate = function (dispatch) {
        if (dispatch === void 0) { dispatch = false; }
        var t = logger.time;
        if (t === null) {
            return;
        }
        if (this.outputFilter) {
            if (this.cueStartTime === null && !this.displayedMemory.isEmpty()) { // Start of a new cue
                this.cueStartTime = t;
            }
            else {
                if (!this.displayedMemory.equals(this.lastOutputScreen)) {
                    if (this.outputFilter.newCue) {
                        this.outputFilter.newCue(this.cueStartTime, t, this.lastOutputScreen);
                        if (dispatch === true && this.outputFilter.dispatchCue) {
                            this.outputFilter.dispatchCue();
                        }
                    }
                    this.cueStartTime = this.displayedMemory.isEmpty() ? null : t;
                }
            }
            this.lastOutputScreen.copy(this.displayedMemory);
        }
    };
    Cea608Channel.prototype.cueSplitAtTime = function (t) {
        if (this.outputFilter) {
            if (!this.displayedMemory.isEmpty()) {
                if (this.outputFilter.newCue) {
                    this.outputFilter.newCue(this.cueStartTime, t, this.displayedMemory);
                }
                this.cueStartTime = t;
            }
        }
    };
    return Cea608Channel;
}());
var Cea608Parser = /** @class */ (function () {
    function Cea608Parser(field, out1, out2) {
        this.field = field || 1;
        this.outputs = [out1, out2];
        this.channels = [new Cea608Channel(1, out1), new Cea608Channel(2, out2)];
        this.currChNr = -1; // Will be 1 or 2
        this.lastCmdA = null; // First byte of last command
        this.lastCmdB = null; // Second byte of last command
        this.bufferedData = [];
        this.startTime = null;
        this.lastTime = null;
        this.dataCounters = { 'padding': 0, 'char': 0, 'cmd': 0, 'other': 0 };
    }
    Cea608Parser.prototype.getHandler = function (index) {
        return this.channels[index].getHandler();
    };
    Cea608Parser.prototype.setHandler = function (index, newHandler) {
        this.channels[index].setHandler(newHandler);
    };
    /**
       * Add data for time t in forms of list of bytes (unsigned ints). The bytes are treated as pairs.
       */
    Cea608Parser.prototype.addData = function (t, byteList) {
        var cmdFound, a, b, charsFound = false;
        this.lastTime = t;
        logger.setTime(t);
        for (var i = 0; i < byteList.length; i += 2) {
            a = byteList[i] & 0x7f;
            b = byteList[i + 1] & 0x7f;
            if (a === 0 && b === 0) {
                this.dataCounters.padding += 2;
                continue;
            }
            else {
                logger.log('DATA', '[' + numArrayToHexArray([byteList[i], byteList[i + 1]]) + '] -> (' + numArrayToHexArray([a, b]) + ')');
            }
            cmdFound = this.parseCmd(a, b);
            if (!cmdFound) {
                cmdFound = this.parseMidrow(a, b);
            }
            if (!cmdFound) {
                cmdFound = this.parsePAC(a, b);
            }
            if (!cmdFound) {
                cmdFound = this.parseBackgroundAttributes(a, b);
            }
            if (!cmdFound) {
                charsFound = this.parseChars(a, b);
                if (charsFound) {
                    if (this.currChNr && this.currChNr >= 0) {
                        var channel = this.channels[this.currChNr - 1];
                        channel.insertChars(charsFound);
                    }
                    else {
                        logger.log('WARNING', 'No channel found yet. TEXT-MODE?');
                    }
                }
            }
            if (cmdFound) {
                this.dataCounters.cmd += 2;
            }
            else if (charsFound) {
                this.dataCounters.char += 2;
            }
            else {
                this.dataCounters.other += 2;
                logger.log('WARNING', 'Couldn\'t parse cleaned data ' + numArrayToHexArray([a, b]) +
                    ' orig: ' + numArrayToHexArray([byteList[i], byteList[i + 1]]));
            }
        }
    };
    /**
       * Parse Command.
       * @returns {Boolean} Tells if a command was found
       */
    Cea608Parser.prototype.parseCmd = function (a, b) {
        var chNr = null;
        var cond1 = (a === 0x14 || a === 0x1C) && (b >= 0x20 && b <= 0x2F);
        var cond2 = (a === 0x17 || a === 0x1F) && (b >= 0x21 && b <= 0x23);
        if (!(cond1 || cond2)) {
            return false;
        }
        if (a === this.lastCmdA && b === this.lastCmdB) {
            this.lastCmdA = null;
            this.lastCmdB = null; // Repeated commands are dropped (once)
            logger.log('DEBUG', 'Repeated command (' + numArrayToHexArray([a, b]) + ') is dropped');
            return true;
        }
        if (a === 0x14 || a === 0x17) {
            chNr = 1;
        }
        else {
            chNr = 2;
        } // (a === 0x1C || a=== 0x1f)
        var channel = this.channels[chNr - 1];
        if (a === 0x14 || a === 0x1C) {
            if (b === 0x20) {
                channel.ccRCL();
            }
            else if (b === 0x21) {
                channel.ccBS();
            }
            else if (b === 0x22) {
                channel.ccAOF();
            }
            else if (b === 0x23) {
                channel.ccAON();
            }
            else if (b === 0x24) {
                channel.ccDER();
            }
            else if (b === 0x25) {
                channel.ccRU(2);
            }
            else if (b === 0x26) {
                channel.ccRU(3);
            }
            else if (b === 0x27) {
                channel.ccRU(4);
            }
            else if (b === 0x28) {
                channel.ccFON();
            }
            else if (b === 0x29) {
                channel.ccRDC();
            }
            else if (b === 0x2A) {
                channel.ccTR();
            }
            else if (b === 0x2B) {
                channel.ccRTD();
            }
            else if (b === 0x2C) {
                channel.ccEDM();
            }
            else if (b === 0x2D) {
                channel.ccCR();
            }
            else if (b === 0x2E) {
                channel.ccENM();
            }
            else if (b === 0x2F) {
                channel.ccEOC();
            }
        }
        else { // a == 0x17 || a == 0x1F
            channel.ccTO(b - 0x20);
        }
        this.lastCmdA = a;
        this.lastCmdB = b;
        this.currChNr = chNr;
        return true;
    };
    /**
       * Parse midrow styling command
       * @returns {Boolean}
       */
    Cea608Parser.prototype.parseMidrow = function (a, b) {
        var chNr = null;
        if (((a === 0x11) || (a === 0x19)) && b >= 0x20 && b <= 0x2f) {
            if (a === 0x11) {
                chNr = 1;
            }
            else {
                chNr = 2;
            }
            if (chNr !== this.currChNr) {
                logger.log('ERROR', 'Mismatch channel in midrow parsing');
                return false;
            }
            var channel = this.channels[chNr - 1];
            channel.ccMIDROW(b);
            logger.log('DEBUG', 'MIDROW (' + numArrayToHexArray([a, b]) + ')');
            return true;
        }
        return false;
    };
    /**
       * Parse Preable Access Codes (Table 53).
       * @returns {Boolean} Tells if PAC found
       */
    Cea608Parser.prototype.parsePAC = function (a, b) {
        var chNr = null;
        var row = null;
        var case1 = ((a >= 0x11 && a <= 0x17) || (a >= 0x19 && a <= 0x1F)) && (b >= 0x40 && b <= 0x7F);
        var case2 = (a === 0x10 || a === 0x18) && (b >= 0x40 && b <= 0x5F);
        if (!(case1 || case2)) {
            return false;
        }
        if (a === this.lastCmdA && b === this.lastCmdB) {
            this.lastCmdA = null;
            this.lastCmdB = null;
            return true; // Repeated commands are dropped (once)
        }
        chNr = (a <= 0x17) ? 1 : 2;
        if (b >= 0x40 && b <= 0x5F) {
            row = (chNr === 1) ? rowsLowCh1[a] : rowsLowCh2[a];
        }
        else { // 0x60 <= b <= 0x7F
            row = (chNr === 1) ? rowsHighCh1[a] : rowsHighCh2[a];
        }
        var pacData = this.interpretPAC(row, b);
        var channel = this.channels[chNr - 1];
        channel.setPAC(pacData);
        this.lastCmdA = a;
        this.lastCmdB = b;
        this.currChNr = chNr;
        return true;
    };
    /**
       * Interpret the second byte of the pac, and return the information.
       * @returns {Object} pacData with style parameters.
       */
    Cea608Parser.prototype.interpretPAC = function (row, byte) {
        var pacIndex = byte;
        var pacData = { color: null, italics: false, indent: null, underline: false, row: row };
        if (byte > 0x5F) {
            pacIndex = byte - 0x60;
        }
        else {
            pacIndex = byte - 0x40;
        }
        pacData.underline = (pacIndex & 1) === 1;
        if (pacIndex <= 0xd) {
            pacData.color = ['white', 'green', 'blue', 'cyan', 'red', 'yellow', 'magenta', 'white'][Math.floor(pacIndex / 2)];
        }
        else if (pacIndex <= 0xf) {
            pacData.italics = true;
            pacData.color = 'white';
        }
        else {
            pacData.indent = (Math.floor((pacIndex - 0x10) / 2)) * 4;
        }
        return pacData; // Note that row has zero offset. The spec uses 1.
    };
    /**
       * Parse characters.
       * @returns An array with 1 to 2 codes corresponding to chars, if found. null otherwise.
       */
    Cea608Parser.prototype.parseChars = function (a, b) {
        var channelNr = null, charCodes = null, charCode1 = null;
        if (a >= 0x19) {
            channelNr = 2;
            charCode1 = a - 8;
        }
        else {
            channelNr = 1;
            charCode1 = a;
        }
        if (charCode1 >= 0x11 && charCode1 <= 0x13) {
            // Special character
            var oneCode = b;
            if (charCode1 === 0x11) {
                oneCode = b + 0x50;
            }
            else if (charCode1 === 0x12) {
                oneCode = b + 0x70;
            }
            else {
                oneCode = b + 0x90;
            }
            logger.log('INFO', 'Special char \'' + getCharForByte(oneCode) + '\' in channel ' + channelNr);
            charCodes = [oneCode];
        }
        else if (a >= 0x20 && a <= 0x7f) {
            charCodes = (b === 0) ? [a] : [a, b];
        }
        if (charCodes) {
            var hexCodes = numArrayToHexArray(charCodes);
            logger.log('DEBUG', 'Char codes =  ' + hexCodes.join(','));
            this.lastCmdA = null;
            this.lastCmdB = null;
        }
        return charCodes;
    };
    /**
      * Parse extended background attributes as well as new foreground color black.
      * @returns{Boolean} Tells if background attributes are found
      */
    Cea608Parser.prototype.parseBackgroundAttributes = function (a, b) {
        var bkgData, index, chNr, channel;
        var case1 = (a === 0x10 || a === 0x18) && (b >= 0x20 && b <= 0x2f);
        var case2 = (a === 0x17 || a === 0x1f) && (b >= 0x2d && b <= 0x2f);
        if (!(case1 || case2)) {
            return false;
        }
        bkgData = {};
        if (a === 0x10 || a === 0x18) {
            index = Math.floor((b - 0x20) / 2);
            bkgData.background = backgroundColors[index];
            if (b % 2 === 1) {
                bkgData.background = bkgData.background + '_semi';
            }
        }
        else if (b === 0x2d) {
            bkgData.background = 'transparent';
        }
        else {
            bkgData.foreground = 'black';
            if (b === 0x2f) {
                bkgData.underline = true;
            }
        }
        chNr = (a < 0x18) ? 1 : 2;
        channel = this.channels[chNr - 1];
        channel.setBkgData(bkgData);
        this.lastCmdA = null;
        this.lastCmdB = null;
        return true;
    };
    /**
       * Reset state of parser and its channels.
       */
    Cea608Parser.prototype.reset = function () {
        for (var i = 0; i < this.channels.length; i++) {
            if (this.channels[i]) {
                this.channels[i].reset();
            }
        }
        this.lastCmdA = null;
        this.lastCmdB = null;
    };
    /**
       * Trigger the generation of a cue, and the start of a new one if displayScreens are not empty.
       */
    Cea608Parser.prototype.cueSplitAtTime = function (t) {
        for (var i = 0; i < this.channels.length; i++) {
            if (this.channels[i]) {
                this.channels[i].cueSplitAtTime(t);
            }
        }
    };
    return Cea608Parser;
}());
exports.default = Cea608Parser;


/***/ }),

/***/ "./src/utils/codecs.js":
/*!*****************************!*\
  !*** ./src/utils/codecs.js ***!
  \*****************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
// from http://mp4ra.org/codecs.html
var sampleEntryCodesISO = {
    audio: {
        'a3ds': true,
        'ac-3': true,
        'ac-4': true,
        'alac': true,
        'alaw': true,
        'dra1': true,
        'dts+': true,
        'dts-': true,
        'dtsc': true,
        'dtse': true,
        'dtsh': true,
        'ec-3': true,
        'enca': true,
        'g719': true,
        'g726': true,
        'm4ae': true,
        'mha1': true,
        'mha2': true,
        'mhm1': true,
        'mhm2': true,
        'mlpa': true,
        'mp4a': true,
        'raw ': true,
        'Opus': true,
        'samr': true,
        'sawb': true,
        'sawp': true,
        'sevc': true,
        'sqcp': true,
        'ssmv': true,
        'twos': true,
        'ulaw': true
    },
    video: {
        'avc1': true,
        'avc2': true,
        'avc3': true,
        'avc4': true,
        'avcp': true,
        'drac': true,
        'dvav': true,
        'dvhe': true,
        'encv': true,
        'hev1': true,
        'hvc1': true,
        'mjp2': true,
        'mp4v': true,
        'mvc1': true,
        'mvc2': true,
        'mvc3': true,
        'mvc4': true,
        'resv': true,
        'rv60': true,
        's263': true,
        'svc1': true,
        'svc2': true,
        'vc-1': true,
        'vp08': true,
        'vp09': true
    }
};
function isCodecType(codec, type) {
    var typeCodes = sampleEntryCodesISO[type];
    return !!typeCodes && typeCodes[codec.slice(0, 4)] === true;
}
exports.isCodecType = isCodecType;
function isCodecSupportedInMp4(codec, type) {
    return window.MediaSource.isTypeSupported((type || 'video') + "/mp4;codecs=\"" + codec + "\"");
}
exports.isCodecSupportedInMp4 = isCodecSupportedInMp4;


/***/ }),

/***/ "./src/utils/cues.js":
/*!***************************!*\
  !*** ./src/utils/cues.js ***!
  \***************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var vttparser_1 = __webpack_require__(/*! ./vttparser */ "./src/utils/vttparser.js");
function newCue(track, startTime, endTime, captionScreen) {
    var row;
    var cue;
    var indenting;
    var indent;
    var text;
    var VTTCue = window.VTTCue || window.TextTrackCue;
    for (var r = 0; r < captionScreen.rows.length; r++) {
        row = captionScreen.rows[r];
        indenting = true;
        indent = 0;
        text = '';
        if (!row.isEmpty()) {
            for (var c = 0; c < row.chars.length; c++) {
                if (row.chars[c].uchar.match(/\s/) && indenting) {
                    indent++;
                }
                else {
                    text += row.chars[c].uchar;
                    indenting = false;
                }
            }
            // To be used for cleaning-up orphaned roll-up captions
            row.cueStartTime = startTime;
            // Give a slight bump to the endTime if it's equal to startTime to avoid a SyntaxError in IE
            if (startTime === endTime) {
                endTime += 0.0001;
            }
            cue = new VTTCue(startTime, endTime, vttparser_1.fixLineBreaks(text.trim()));
            if (indent >= 16) {
                indent--;
            }
            else {
                indent++;
            }
            // VTTCue.line get's flakey when using controls, so let's now include line 13&14
            // also, drop line 1 since it's to close to the top
            if (navigator.userAgent.match(/Firefox\//)) {
                cue.line = r + 1;
            }
            else {
                cue.line = (r > 7 ? r - 2 : r + 1);
            }
            cue.align = 'left';
            // Clamp the position between 0 and 100 - if out of these bounds, Firefox throws an exception and captions break
            cue.position = Math.max(0, Math.min(100, 100 * (indent / 32) + (navigator.userAgent.match(/Firefox\//) ? 50 : 0)));
            track.addCue(cue);
        }
    }
}
exports.newCue = newCue;


/***/ }),

/***/ "./src/utils/discontinuities.js":
/*!**************************************!*\
  !*** ./src/utils/discontinuities.js ***!
  \**************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Number) {
Object.defineProperty(exports, "__esModule", { value: true });
var binary_search_1 = __webpack_require__(/*! ./binary-search */ "./src/utils/binary-search.js");
var logger_1 = __webpack_require__(/*! ../utils/logger */ "./src/utils/logger.js");
function findFirstFragWithCC(fragments, cc) {
    var firstFrag = null;
    for (var i = 0; i < fragments.length; i += 1) {
        var currentFrag = fragments[i];
        if (currentFrag && currentFrag.cc === cc) {
            firstFrag = currentFrag;
            break;
        }
    }
    return firstFrag;
}
exports.findFirstFragWithCC = findFirstFragWithCC;
function findFragWithCC(fragments, CC) {
    return binary_search_1.default.search(fragments, function (candidate) {
        if (candidate.cc < CC) {
            return 1;
        }
        else if (candidate.cc > CC) {
            return -1;
        }
        else {
            return 0;
        }
    });
}
exports.findFragWithCC = findFragWithCC;
function shouldAlignOnDiscontinuities(lastFrag, lastLevel, details) {
    var shouldAlign = false;
    if (lastLevel && lastLevel.details && details) {
        if (details.endCC > details.startCC || (lastFrag && lastFrag.cc < details.startCC)) {
            shouldAlign = true;
        }
    }
    return shouldAlign;
}
exports.shouldAlignOnDiscontinuities = shouldAlignOnDiscontinuities;
// Find the first frag in the previous level which matches the CC of the first frag of the new level
function findDiscontinuousReferenceFrag(prevDetails, curDetails) {
    var prevFrags = prevDetails.fragments;
    var curFrags = curDetails.fragments;
    if (!curFrags.length || !prevFrags.length) {
        logger_1.logger.log('No fragments to align');
        return;
    }
    var prevStartFrag = findFirstFragWithCC(prevFrags, curFrags[0].cc);
    if (!prevStartFrag || (prevStartFrag && !prevStartFrag.startPTS)) {
        logger_1.logger.log('No frag in previous level to align on');
        return;
    }
    return prevStartFrag;
}
exports.findDiscontinuousReferenceFrag = findDiscontinuousReferenceFrag;
function adjustPts(sliding, details) {
    details.fragments.forEach(function (frag) {
        if (frag) {
            var start = frag.start + sliding;
            frag.start = frag.startPTS = start;
            frag.endPTS = start + frag.duration;
        }
    });
    details.PTSKnown = true;
}
exports.adjustPts = adjustPts;
/**
 * Using the parameters of the last level, this function computes PTS' of the new fragments so that they form a
 * contiguous stream with the last fragments.
 * The PTS of a fragment lets Hls.js know where it fits into a stream - by knowing every PTS, we know which fragment to
 * download at any given time. PTS is normally computed when the fragment is demuxed, so taking this step saves us time
 * and an extra download.
 * @param lastFrag
 * @param lastLevel
 * @param details
 */
function alignStream(lastFrag, lastLevel, details) {
    alignDiscontinuities(lastFrag, details, lastLevel);
    if (!details.PTSKnown && lastLevel) {
        // If the PTS wasn't figured out via discontinuity sequence that means there was no CC increase within the level.
        // Aligning via Program Date Time should therefore be reliable, since PDT should be the same within the same
        // discontinuity sequence.
        alignPDT(details, lastLevel.details);
    }
}
exports.alignStream = alignStream;
/**
 * Computes the PTS if a new level's fragments using the PTS of a fragment in the last level which shares the same
 * discontinuity sequence.
 * @param lastLevel - The details of the last loaded level
 * @param details - The details of the new level
 */
function alignDiscontinuities(lastFrag, details, lastLevel) {
    if (shouldAlignOnDiscontinuities(lastFrag, lastLevel, details)) {
        var referenceFrag = findDiscontinuousReferenceFrag(lastLevel.details, details);
        if (referenceFrag) {
            logger_1.logger.log('Adjusting PTS using last level due to CC increase within current level');
            adjustPts(referenceFrag.start, details);
        }
    }
}
exports.alignDiscontinuities = alignDiscontinuities;
/**
 * Computes the PTS of a new level's fragments using the difference in Program Date Time from the last level.
 * @param details - The details of the new level
 * @param lastDetails - The details of the last loaded level
 */
function alignPDT(details, lastDetails) {
    if (lastDetails && lastDetails.fragments.length) {
        if (!details.hasProgramDateTime || !lastDetails.hasProgramDateTime) {
            return;
        }
        // if last level sliding is 1000 and its first frag PROGRAM-DATE-TIME is 2017-08-20 1:10:00 AM
        // and if new details first frag PROGRAM DATE-TIME is 2017-08-20 1:10:08 AM
        // then we can deduce that playlist B sliding is 1000+8 = 1008s
        var lastPDT = lastDetails.fragments[0].programDateTime;
        var newPDT = details.fragments[0].programDateTime;
        // date diff is in ms. frag.start is in seconds
        var sliding = (newPDT - lastPDT) / 1000 + lastDetails.fragments[0].start;
        if (Number.isFinite(sliding)) {
            logger_1.logger.log("adjusting PTS using programDateTime delta, sliding:" + sliding.toFixed(3));
            adjustPts(sliding, details);
        }
    }
}
exports.alignPDT = alignPDT;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./src/polyfills/number */ "./src/polyfills/number.js")["Number"]))

/***/ }),

/***/ "./src/utils/ewma-bandwidth-estimator.js":
/*!***********************************************!*\
  !*** ./src/utils/ewma-bandwidth-estimator.js ***!
  \***********************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * EWMA Bandwidth Estimator
 *  - heavily inspired from shaka-player
 * Tracks bandwidth samples and estimates available bandwidth.
 * Based on the minimum of two exponentially-weighted moving averages with
 * different half-lives.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var ewma_1 = __webpack_require__(/*! ../utils/ewma */ "./src/utils/ewma.js");
var EwmaBandWidthEstimator = /** @class */ (function () {
    function EwmaBandWidthEstimator(hls, slow, fast, defaultEstimate) {
        this.hls = hls;
        this.defaultEstimate_ = defaultEstimate;
        this.minWeight_ = 0.001;
        this.minDelayMs_ = 50;
        this.slow_ = new ewma_1.default(slow);
        this.fast_ = new ewma_1.default(fast);
    }
    EwmaBandWidthEstimator.prototype.sample = function (durationMs, numBytes) {
        durationMs = Math.max(durationMs, this.minDelayMs_);
        var bandwidth = 8000 * numBytes / durationMs, 
        // console.log('instant bw:'+ Math.round(bandwidth));
        // we weight sample using loading duration....
        weight = durationMs / 1000;
        this.fast_.sample(weight, bandwidth);
        this.slow_.sample(weight, bandwidth);
    };
    EwmaBandWidthEstimator.prototype.canEstimate = function () {
        var fast = this.fast_;
        return (fast && fast.getTotalWeight() >= this.minWeight_);
    };
    EwmaBandWidthEstimator.prototype.getEstimate = function () {
        if (this.canEstimate()) {
            // console.log('slow estimate:'+ Math.round(this.slow_.getEstimate()));
            // console.log('fast estimate:'+ Math.round(this.fast_.getEstimate()));
            // Take the minimum of these two estimates.  This should have the effect of
            // adapting down quickly, but up more slowly.
            return Math.min(this.fast_.getEstimate(), this.slow_.getEstimate());
        }
        else {
            return this.defaultEstimate_;
        }
    };
    EwmaBandWidthEstimator.prototype.destroy = function () {
    };
    return EwmaBandWidthEstimator;
}());
exports.default = EwmaBandWidthEstimator;


/***/ }),

/***/ "./src/utils/ewma.js":
/*!***************************!*\
  !*** ./src/utils/ewma.js ***!
  \***************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * compute an Exponential Weighted moving average
 * - https://en.wikipedia.org/wiki/Moving_average#Exponential_moving_average
 *  - heavily inspired from shaka-player
 */
Object.defineProperty(exports, "__esModule", { value: true });
var EWMA = /** @class */ (function () {
    //  About half of the estimated value will be from the last |halfLife| samples by weight.
    function EWMA(halfLife) {
        // Larger values of alpha expire historical data more slowly.
        this.alpha_ = halfLife ? Math.exp(Math.log(0.5) / halfLife) : 0;
        this.estimate_ = 0;
        this.totalWeight_ = 0;
    }
    EWMA.prototype.sample = function (weight, value) {
        var adjAlpha = Math.pow(this.alpha_, weight);
        this.estimate_ = value * (1 - adjAlpha) + adjAlpha * this.estimate_;
        this.totalWeight_ += weight;
    };
    EWMA.prototype.getTotalWeight = function () {
        return this.totalWeight_;
    };
    EWMA.prototype.getEstimate = function () {
        if (this.alpha_) {
            var zeroFactor = 1 - Math.pow(this.alpha_, this.totalWeight_);
            return this.estimate_ / zeroFactor;
        }
        else {
            return this.estimate_;
        }
    };
    return EWMA;
}());
exports.default = EWMA;


/***/ }),

/***/ "./src/utils/get-self-scope.js":
/*!*************************************!*\
  !*** ./src/utils/get-self-scope.js ***!
  \*************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function getSelfScope() {
    // see https://stackoverflow.com/a/11237259/589493
    if (typeof window === 'undefined') {
        /* eslint-disable-next-line no-undef */
        return self;
    }
    else {
        return window;
    }
}
exports.getSelfScope = getSelfScope;


/***/ }),

/***/ "./src/utils/logger.js":
/*!*****************************!*\
  !*** ./src/utils/logger.js ***!
  \*****************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var get_self_scope_1 = __webpack_require__(/*! ./get-self-scope */ "./src/utils/get-self-scope.js");
function noop() { }
var fakeLogger = {
    trace: noop,
    debug: noop,
    log: noop,
    warn: noop,
    info: noop,
    error: noop
};
var exportedLogger = fakeLogger;
// let lastCallTime;
// function formatMsgWithTimeInfo(type, msg) {
//   const now = Date.now();
//   const diff = lastCallTime ? '+' + (now - lastCallTime) : '0';
//   lastCallTime = now;
//   msg = (new Date(now)).toISOString() + ' | [' +  type + '] > ' + msg + ' ( ' + diff + ' ms )';
//   return msg;
// }
function formatMsg(type, msg) {
    msg = '[' + type + '] > ' + msg;
    return msg;
}
var global = get_self_scope_1.getSelfScope();
function consolePrintFn(type) {
    var func = global.console[type];
    if (func) {
        return function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            if (args[0]) {
                args[0] = formatMsg(type, args[0]);
            }
            func.apply(global.console, args);
        };
    }
    return noop;
}
function exportLoggerFunctions(debugConfig) {
    var functions = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        functions[_i - 1] = arguments[_i];
    }
    functions.forEach(function (type) {
        exportedLogger[type] = debugConfig[type] ? debugConfig[type].bind(debugConfig) : consolePrintFn(type);
    });
}
exports.enableLogs = function (debugConfig) {
    if (debugConfig === true || typeof debugConfig === 'object') {
        exportLoggerFunctions(debugConfig, 
        // Remove out from list here to hard-disable a log-level
        // 'trace',
        'debug', 'log', 'info', 'warn', 'error');
        // Some browsers don't allow to use bind on console object anyway
        // fallback to default if needed
        try {
            exportedLogger.log();
        }
        catch (e) {
            exportedLogger = fakeLogger;
        }
    }
    else {
        exportedLogger = fakeLogger;
    }
};
exports.logger = exportedLogger;


/***/ }),

/***/ "./src/utils/mediakeys-helper.js":
/*!***************************************!*\
  !*** ./src/utils/mediakeys-helper.js ***!
  \***************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var requestMediaKeySystemAccess = (function () {
    if (typeof window !== 'undefined' && window.navigator && window.navigator.requestMediaKeySystemAccess) {
        return window.navigator.requestMediaKeySystemAccess.bind(window.navigator);
    }
    else {
        return null;
    }
})();
exports.requestMediaKeySystemAccess = requestMediaKeySystemAccess;


/***/ }),

/***/ "./src/utils/mediasource-helper.js":
/*!*****************************************!*\
  !*** ./src/utils/mediasource-helper.js ***!
  \*****************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * MediaSource helper
 */
Object.defineProperty(exports, "__esModule", { value: true });
function getMediaSource() {
    if (typeof window !== 'undefined') {
        return window.MediaSource || window.WebKitMediaSource;
    }
}
exports.getMediaSource = getMediaSource;


/***/ }),

/***/ "./src/utils/output-filter.js":
/*!************************************!*\
  !*** ./src/utils/output-filter.js ***!
  \************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var OutputFilter = /** @class */ (function () {
    function OutputFilter(timelineController, trackName) {
        this.timelineController = timelineController;
        this.trackName = trackName;
        this.startTime = null;
        this.endTime = null;
        this.screen = null;
    }
    OutputFilter.prototype.dispatchCue = function () {
        if (this.startTime === null) {
            return;
        }
        this.timelineController.addCues(this.trackName, this.startTime, this.endTime, this.screen);
        this.startTime = null;
    };
    OutputFilter.prototype.newCue = function (startTime, endTime, screen) {
        if (this.startTime === null || this.startTime > startTime) {
            this.startTime = startTime;
        }
        this.endTime = endTime;
        this.screen = screen;
        this.timelineController.createCaptionsTrack(this.trackName);
    };
    return OutputFilter;
}());
exports.default = OutputFilter;


/***/ }),

/***/ "./src/utils/texttrack-utils.js":
/*!**************************************!*\
  !*** ./src/utils/texttrack-utils.js ***!
  \**************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function sendAddTrackEvent(track, videoEl) {
    var event = null;
    try {
        event = new window.Event('addtrack');
    }
    catch (err) {
        // for IE11
        event = document.createEvent('Event');
        event.initEvent('addtrack', false, false);
    }
    event.track = track;
    videoEl.dispatchEvent(event);
}
exports.sendAddTrackEvent = sendAddTrackEvent;
function clearCurrentCues(track) {
    if (track && track.cues) {
        while (track.cues.length > 0) {
            track.removeCue(track.cues[0]);
        }
    }
}
exports.clearCurrentCues = clearCurrentCues;


/***/ }),

/***/ "./src/utils/time-ranges.js":
/*!**********************************!*\
  !*** ./src/utils/time-ranges.js ***!
  \**********************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 *  TimeRanges to string helper
 */
Object.defineProperty(exports, "__esModule", { value: true });
var TimeRanges = {
    toString: function (r) {
        var log = '', len = r.length;
        for (var i = 0; i < len; i++) {
            log += '[' + r.start(i).toFixed(3) + ',' + r.end(i).toFixed(3) + ']';
        }
        return log;
    }
};
exports.default = TimeRanges;


/***/ }),

/***/ "./src/utils/vttcue.js":
/*!*****************************!*\
  !*** ./src/utils/vttcue.js ***!
  \*****************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2013 vtt.js Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = (function () {
    if (typeof window !== 'undefined' && window.VTTCue) {
        return window.VTTCue;
    }
    var autoKeyword = 'auto';
    var directionSetting = {
        '': true,
        lr: true,
        rl: true
    };
    var alignSetting = {
        start: true,
        middle: true,
        end: true,
        left: true,
        right: true
    };
    function findDirectionSetting(value) {
        if (typeof value !== 'string') {
            return false;
        }
        var dir = directionSetting[value.toLowerCase()];
        return dir ? value.toLowerCase() : false;
    }
    function findAlignSetting(value) {
        if (typeof value !== 'string') {
            return false;
        }
        var align = alignSetting[value.toLowerCase()];
        return align ? value.toLowerCase() : false;
    }
    function extend(obj) {
        var i = 1;
        for (; i < arguments.length; i++) {
            var cobj = arguments[i];
            for (var p in cobj) {
                obj[p] = cobj[p];
            }
        }
        return obj;
    }
    function VTTCue(startTime, endTime, text) {
        var cue = this;
        var isIE8 = (function () {
            if (typeof navigator === 'undefined') {
                return;
            }
            return (/MSIE\s8\.0/).test(navigator.userAgent);
        })();
        var baseObj = {};
        if (isIE8) {
            cue = document.createElement('custom');
        }
        else {
            baseObj.enumerable = true;
        }
        /**
         * Shim implementation specific properties. These properties are not in
         * the spec.
         */
        // Lets us know when the VTTCue's data has changed in such a way that we need
        // to recompute its display state. This lets us compute its display state
        // lazily.
        cue.hasBeenReset = false;
        /**
         * VTTCue and TextTrackCue properties
         * http://dev.w3.org/html5/webvtt/#vttcue-interface
         */
        var _id = '';
        var _pauseOnExit = false;
        var _startTime = startTime;
        var _endTime = endTime;
        var _text = text;
        var _region = null;
        var _vertical = '';
        var _snapToLines = true;
        var _line = 'auto';
        var _lineAlign = 'start';
        var _position = 50;
        var _positionAlign = 'middle';
        var _size = 50;
        var _align = 'middle';
        Object.defineProperty(cue, 'id', extend({}, baseObj, {
            get: function () {
                return _id;
            },
            set: function (value) {
                _id = '' + value;
            }
        }));
        Object.defineProperty(cue, 'pauseOnExit', extend({}, baseObj, {
            get: function () {
                return _pauseOnExit;
            },
            set: function (value) {
                _pauseOnExit = !!value;
            }
        }));
        Object.defineProperty(cue, 'startTime', extend({}, baseObj, {
            get: function () {
                return _startTime;
            },
            set: function (value) {
                if (typeof value !== 'number') {
                    throw new TypeError('Start time must be set to a number.');
                }
                _startTime = value;
                this.hasBeenReset = true;
            }
        }));
        Object.defineProperty(cue, 'endTime', extend({}, baseObj, {
            get: function () {
                return _endTime;
            },
            set: function (value) {
                if (typeof value !== 'number') {
                    throw new TypeError('End time must be set to a number.');
                }
                _endTime = value;
                this.hasBeenReset = true;
            }
        }));
        Object.defineProperty(cue, 'text', extend({}, baseObj, {
            get: function () {
                return _text;
            },
            set: function (value) {
                _text = '' + value;
                this.hasBeenReset = true;
            }
        }));
        Object.defineProperty(cue, 'region', extend({}, baseObj, {
            get: function () {
                return _region;
            },
            set: function (value) {
                _region = value;
                this.hasBeenReset = true;
            }
        }));
        Object.defineProperty(cue, 'vertical', extend({}, baseObj, {
            get: function () {
                return _vertical;
            },
            set: function (value) {
                var setting = findDirectionSetting(value);
                // Have to check for false because the setting an be an empty string.
                if (setting === false) {
                    throw new SyntaxError('An invalid or illegal string was specified.');
                }
                _vertical = setting;
                this.hasBeenReset = true;
            }
        }));
        Object.defineProperty(cue, 'snapToLines', extend({}, baseObj, {
            get: function () {
                return _snapToLines;
            },
            set: function (value) {
                _snapToLines = !!value;
                this.hasBeenReset = true;
            }
        }));
        Object.defineProperty(cue, 'line', extend({}, baseObj, {
            get: function () {
                return _line;
            },
            set: function (value) {
                if (typeof value !== 'number' && value !== autoKeyword) {
                    throw new SyntaxError('An invalid number or illegal string was specified.');
                }
                _line = value;
                this.hasBeenReset = true;
            }
        }));
        Object.defineProperty(cue, 'lineAlign', extend({}, baseObj, {
            get: function () {
                return _lineAlign;
            },
            set: function (value) {
                var setting = findAlignSetting(value);
                if (!setting) {
                    throw new SyntaxError('An invalid or illegal string was specified.');
                }
                _lineAlign = setting;
                this.hasBeenReset = true;
            }
        }));
        Object.defineProperty(cue, 'position', extend({}, baseObj, {
            get: function () {
                return _position;
            },
            set: function (value) {
                if (value < 0 || value > 100) {
                    throw new Error('Position must be between 0 and 100.');
                }
                _position = value;
                this.hasBeenReset = true;
            }
        }));
        Object.defineProperty(cue, 'positionAlign', extend({}, baseObj, {
            get: function () {
                return _positionAlign;
            },
            set: function (value) {
                var setting = findAlignSetting(value);
                if (!setting) {
                    throw new SyntaxError('An invalid or illegal string was specified.');
                }
                _positionAlign = setting;
                this.hasBeenReset = true;
            }
        }));
        Object.defineProperty(cue, 'size', extend({}, baseObj, {
            get: function () {
                return _size;
            },
            set: function (value) {
                if (value < 0 || value > 100) {
                    throw new Error('Size must be between 0 and 100.');
                }
                _size = value;
                this.hasBeenReset = true;
            }
        }));
        Object.defineProperty(cue, 'align', extend({}, baseObj, {
            get: function () {
                return _align;
            },
            set: function (value) {
                var setting = findAlignSetting(value);
                if (!setting) {
                    throw new SyntaxError('An invalid or illegal string was specified.');
                }
                _align = setting;
                this.hasBeenReset = true;
            }
        }));
        /**
         * Other <track> spec defined properties
         */
        // http://www.whatwg.org/specs/web-apps/current-work/multipage/the-video-element.html#text-track-cue-display-state
        cue.displayState = undefined;
        if (isIE8) {
            return cue;
        }
    }
    /**
     * VTTCue methods
     */
    VTTCue.prototype.getCueAsHTML = function () {
        // Assume WebVTT.convertCueToDOMTree is on the global.
        var WebVTT = window.WebVTT;
        return WebVTT.convertCueToDOMTree(window, this.text);
    };
    return VTTCue;
})();


/***/ }),

/***/ "./src/utils/vttparser.js":
/*!********************************!*\
  !*** ./src/utils/vttparser.js ***!
  \********************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Source: https://github.com/mozilla/vtt.js/blob/master/dist/vtt.js#L1716
 */
Object.defineProperty(exports, "__esModule", { value: true });
var vttcue_1 = __webpack_require__(/*! ./vttcue */ "./src/utils/vttcue.js");
var StringDecoder = function StringDecoder() {
    return {
        decode: function (data) {
            if (!data) {
                return '';
            }
            if (typeof data !== 'string') {
                throw new Error('Error - expected string data.');
            }
            return decodeURIComponent(encodeURIComponent(data));
        }
    };
};
function VTTParser() {
    this.window = window;
    this.state = 'INITIAL';
    this.buffer = '';
    this.decoder = new StringDecoder();
    this.regionList = [];
}
// Try to parse input as a time stamp.
function parseTimeStamp(input) {
    function computeSeconds(h, m, s, f) {
        return (h | 0) * 3600 + (m | 0) * 60 + (s | 0) + (f | 0) / 1000;
    }
    var m = input.match(/^(\d+):(\d{2})(:\d{2})?\.(\d{3})/);
    if (!m) {
        return null;
    }
    if (m[3]) {
        // Timestamp takes the form of [hours]:[minutes]:[seconds].[milliseconds]
        return computeSeconds(m[1], m[2], m[3].replace(':', ''), m[4]);
    }
    else if (m[1] > 59) {
        // Timestamp takes the form of [hours]:[minutes].[milliseconds]
        // First position is hours as it's over 59.
        return computeSeconds(m[1], m[2], 0, m[4]);
    }
    else {
        // Timestamp takes the form of [minutes]:[seconds].[milliseconds]
        return computeSeconds(0, m[1], m[2], m[4]);
    }
}
// A settings object holds key/value pairs and will ignore anything but the first
// assignment to a specific key.
function Settings() {
    this.values = Object.create(null);
}
Settings.prototype = {
    // Only accept the first assignment to any key.
    set: function (k, v) {
        if (!this.get(k) && v !== '') {
            this.values[k] = v;
        }
    },
    // Return the value for a key, or a default value.
    // If 'defaultKey' is passed then 'dflt' is assumed to be an object with
    // a number of possible default values as properties where 'defaultKey' is
    // the key of the property that will be chosen; otherwise it's assumed to be
    // a single value.
    get: function (k, dflt, defaultKey) {
        if (defaultKey) {
            return this.has(k) ? this.values[k] : dflt[defaultKey];
        }
        return this.has(k) ? this.values[k] : dflt;
    },
    // Check whether we have a value for a key.
    has: function (k) {
        return k in this.values;
    },
    // Accept a setting if its one of the given alternatives.
    alt: function (k, v, a) {
        for (var n = 0; n < a.length; ++n) {
            if (v === a[n]) {
                this.set(k, v);
                break;
            }
        }
    },
    // Accept a setting if its a valid (signed) integer.
    integer: function (k, v) {
        if (/^-?\d+$/.test(v)) { // integer
            this.set(k, parseInt(v, 10));
        }
    },
    // Accept a setting if its a valid percentage.
    percent: function (k, v) {
        var m;
        if ((m = v.match(/^([\d]{1,3})(\.[\d]*)?%$/))) {
            v = parseFloat(v);
            if (v >= 0 && v <= 100) {
                this.set(k, v);
                return true;
            }
        }
        return false;
    }
};
// Helper function to parse input into groups separated by 'groupDelim', and
// interprete each group as a key/value pair separated by 'keyValueDelim'.
function parseOptions(input, callback, keyValueDelim, groupDelim) {
    var groups = groupDelim ? input.split(groupDelim) : [input];
    for (var i in groups) {
        if (typeof groups[i] !== 'string') {
            continue;
        }
        var kv = groups[i].split(keyValueDelim);
        if (kv.length !== 2) {
            continue;
        }
        var k = kv[0];
        var v = kv[1];
        callback(k, v);
    }
}
var defaults = new vttcue_1.default(0, 0, 0);
// 'middle' was changed to 'center' in the spec: https://github.com/w3c/webvtt/pull/244
//  Safari doesn't yet support this change, but FF and Chrome do.
var center = defaults.align === 'middle' ? 'middle' : 'center';
function parseCue(input, cue, regionList) {
    // Remember the original input if we need to throw an error.
    var oInput = input;
    // 4.1 WebVTT timestamp
    function consumeTimeStamp() {
        var ts = parseTimeStamp(input);
        if (ts === null) {
            throw new Error('Malformed timestamp: ' + oInput);
        }
        // Remove time stamp from input.
        input = input.replace(/^[^\sa-zA-Z-]+/, '');
        return ts;
    }
    // 4.4.2 WebVTT cue settings
    function consumeCueSettings(input, cue) {
        var settings = new Settings();
        parseOptions(input, function (k, v) {
            switch (k) {
                case 'region':
                    // Find the last region we parsed with the same region id.
                    for (var i = regionList.length - 1; i >= 0; i--) {
                        if (regionList[i].id === v) {
                            settings.set(k, regionList[i].region);
                            break;
                        }
                    }
                    break;
                case 'vertical':
                    settings.alt(k, v, ['rl', 'lr']);
                    break;
                case 'line':
                    var vals = v.split(','), vals0 = vals[0];
                    settings.integer(k, vals0);
                    if (settings.percent(k, vals0)) {
                        settings.set('snapToLines', false);
                    }
                    settings.alt(k, vals0, ['auto']);
                    if (vals.length === 2) {
                        settings.alt('lineAlign', vals[1], ['start', center, 'end']);
                    }
                    break;
                case 'position':
                    vals = v.split(',');
                    settings.percent(k, vals[0]);
                    if (vals.length === 2) {
                        settings.alt('positionAlign', vals[1], ['start', center, 'end', 'line-left', 'line-right', 'auto']);
                    }
                    break;
                case 'size':
                    settings.percent(k, v);
                    break;
                case 'align':
                    settings.alt(k, v, ['start', center, 'end', 'left', 'right']);
                    break;
            }
        }, /:/, /\s/);
        // Apply default values for any missing fields.
        cue.region = settings.get('region', null);
        cue.vertical = settings.get('vertical', '');
        var line = settings.get('line', 'auto');
        if (line === 'auto' && defaults.line === -1) {
            // set numeric line number for Safari
            line = -1;
        }
        cue.line = line;
        cue.lineAlign = settings.get('lineAlign', 'start');
        cue.snapToLines = settings.get('snapToLines', true);
        cue.size = settings.get('size', 100);
        cue.align = settings.get('align', center);
        var position = settings.get('position', 'auto');
        if (position === 'auto' && defaults.position === 50) {
            // set numeric position for Safari
            position = cue.align === 'start' || cue.align === 'left' ? 0 : cue.align === 'end' || cue.align === 'right' ? 100 : 50;
        }
        cue.position = position;
    }
    function skipWhitespace() {
        input = input.replace(/^\s+/, '');
    }
    // 4.1 WebVTT cue timings.
    skipWhitespace();
    cue.startTime = consumeTimeStamp(); // (1) collect cue start time
    skipWhitespace();
    if (input.substr(0, 3) !== '-->') { // (3) next characters must match '-->'
        throw new Error('Malformed time stamp (time stamps must be separated by \'-->\'): ' +
            oInput);
    }
    input = input.substr(3);
    skipWhitespace();
    cue.endTime = consumeTimeStamp(); // (5) collect cue end time
    // 4.1 WebVTT cue settings list.
    skipWhitespace();
    consumeCueSettings(input, cue);
}
function fixLineBreaks(input) {
    return input.replace(/<br(?: \/)?>/gi, '\n');
}
exports.fixLineBreaks = fixLineBreaks;
VTTParser.prototype = {
    parse: function (data) {
        var self = this;
        // If there is no data then we won't decode it, but will just try to parse
        // whatever is in buffer already. This may occur in circumstances, for
        // example when flush() is called.
        if (data) {
            // Try to decode the data that we received.
            self.buffer += self.decoder.decode(data, { stream: true });
        }
        function collectNextLine() {
            var buffer = self.buffer;
            var pos = 0;
            buffer = fixLineBreaks(buffer);
            while (pos < buffer.length && buffer[pos] !== '\r' && buffer[pos] !== '\n') {
                ++pos;
            }
            var line = buffer.substr(0, pos);
            // Advance the buffer early in case we fail below.
            if (buffer[pos] === '\r') {
                ++pos;
            }
            if (buffer[pos] === '\n') {
                ++pos;
            }
            self.buffer = buffer.substr(pos);
            return line;
        }
        // 3.2 WebVTT metadata header syntax
        function parseHeader(input) {
            parseOptions(input, function (k, v) {
                switch (k) {
                    case 'Region':
                        // 3.3 WebVTT region metadata header syntax
                        // console.log('parse region', v);
                        // parseRegion(v);
                        break;
                }
            }, /:/);
        }
        // 5.1 WebVTT file parsing.
        try {
            var line = void 0;
            if (self.state === 'INITIAL') {
                // We can't start parsing until we have the first line.
                if (!/\r\n|\n/.test(self.buffer)) {
                    return this;
                }
                line = collectNextLine();
                // strip of UTF-8 BOM if any
                // https://en.wikipedia.org/wiki/Byte_order_mark#UTF-8
                var m = line.match(/^()?WEBVTT([ \t].*)?$/);
                if (!m || !m[0]) {
                    throw new Error('Malformed WebVTT signature.');
                }
                self.state = 'HEADER';
            }
            var alreadyCollectedLine = false;
            while (self.buffer) {
                // We can't parse a line until we have the full line.
                if (!/\r\n|\n/.test(self.buffer)) {
                    return this;
                }
                if (!alreadyCollectedLine) {
                    line = collectNextLine();
                }
                else {
                    alreadyCollectedLine = false;
                }
                switch (self.state) {
                    case 'HEADER':
                        // 13-18 - Allow a header (metadata) under the WEBVTT line.
                        if (/:/.test(line)) {
                            parseHeader(line);
                        }
                        else if (!line) {
                            // An empty line terminates the header and starts the body (cues).
                            self.state = 'ID';
                        }
                        continue;
                    case 'NOTE':
                        // Ignore NOTE blocks.
                        if (!line) {
                            self.state = 'ID';
                        }
                        continue;
                    case 'ID':
                        // Check for the start of NOTE blocks.
                        if (/^NOTE($|[ \t])/.test(line)) {
                            self.state = 'NOTE';
                            break;
                        }
                        // 19-29 - Allow any number of line terminators, then initialize new cue values.
                        if (!line) {
                            continue;
                        }
                        self.cue = new vttcue_1.default(0, 0, '');
                        self.state = 'CUE';
                        // 30-39 - Check if self line contains an optional identifier or timing data.
                        if (line.indexOf('-->') === -1) {
                            self.cue.id = line;
                            continue;
                        }
                    // Process line as start of a cue.
                    /* falls through */
                    case 'CUE':
                        // 40 - Collect cue timings and settings.
                        try {
                            parseCue(line, self.cue, self.regionList);
                        }
                        catch (e) {
                            // In case of an error ignore rest of the cue.
                            self.cue = null;
                            self.state = 'BADCUE';
                            continue;
                        }
                        self.state = 'CUETEXT';
                        continue;
                    case 'CUETEXT':
                        var hasSubstring = line.indexOf('-->') !== -1;
                        // 34 - If we have an empty line then report the cue.
                        // 35 - If we have the special substring '-->' then report the cue,
                        // but do not collect the line as we need to process the current
                        // one as a new cue.
                        if (!line || hasSubstring && (alreadyCollectedLine = true)) {
                            // We are done parsing self cue.
                            if (self.oncue) {
                                self.oncue(self.cue);
                            }
                            self.cue = null;
                            self.state = 'ID';
                            continue;
                        }
                        if (self.cue.text) {
                            self.cue.text += '\n';
                        }
                        self.cue.text += line;
                        continue;
                    case 'BADCUE': // BADCUE
                        // 54-62 - Collect and discard the remaining cue.
                        if (!line) {
                            self.state = 'ID';
                        }
                        continue;
                }
            }
        }
        catch (e) {
            // If we are currently parsing a cue, report what we have.
            if (self.state === 'CUETEXT' && self.cue && self.oncue) {
                self.oncue(self.cue);
            }
            self.cue = null;
            // Enter BADWEBVTT state if header was not parsed correctly otherwise
            // another exception occurred so enter BADCUE state.
            self.state = self.state === 'INITIAL' ? 'BADWEBVTT' : 'BADCUE';
        }
        return this;
    },
    flush: function () {
        var self = this;
        try {
            // Finish decoding the stream.
            self.buffer += self.decoder.decode();
            // Synthesize the end of the current cue or region.
            if (self.cue || self.state === 'HEADER') {
                self.buffer += '\n\n';
                self.parse();
            }
            // If we've flushed, parsed, and we're still on the INITIAL state then
            // that means we don't have enough of the stream to parse the first
            // line.
            if (self.state === 'INITIAL') {
                throw new Error('Malformed WebVTT signature.');
            }
        }
        catch (e) {
            throw e;
        }
        if (self.onflush) {
            self.onflush();
        }
        return this;
    }
};
exports.default = VTTParser;


/***/ }),

/***/ "./src/utils/webvtt-parser.js":
/*!************************************!*\
  !*** ./src/utils/webvtt-parser.js ***!
  \************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Number) {
Object.defineProperty(exports, "__esModule", { value: true });
var vttparser_1 = __webpack_require__(/*! ./vttparser */ "./src/utils/vttparser.js");
var id3_1 = __webpack_require__(/*! ../demux/id3 */ "./src/demux/id3.js");
// String.prototype.startsWith is not supported in IE11
var startsWith = function (inputString, searchString, position) {
    return inputString.substr(position || 0, searchString.length) === searchString;
};
var cueString2millis = function (timeString) {
    var ts = parseInt(timeString.substr(-3));
    var secs = parseInt(timeString.substr(-6, 2));
    var mins = parseInt(timeString.substr(-9, 2));
    var hours = timeString.length > 9 ? parseInt(timeString.substr(0, timeString.indexOf(':'))) : 0;
    if (!Number.isFinite(ts) || !Number.isFinite(secs) || !Number.isFinite(mins) || !Number.isFinite(hours)) {
        return -1;
    }
    ts += 1000 * secs;
    ts += 60 * 1000 * mins;
    ts += 60 * 60 * 1000 * hours;
    return ts;
};
// From https://github.com/darkskyapp/string-hash
var hash = function (text) {
    var hash = 5381;
    var i = text.length;
    while (i) {
        hash = (hash * 33) ^ text.charCodeAt(--i);
    }
    return (hash >>> 0).toString();
};
var calculateOffset = function (vttCCs, cc, presentationTime) {
    var currCC = vttCCs[cc];
    var prevCC = vttCCs[currCC.prevCC];
    // This is the first discontinuity or cues have been processed since the last discontinuity
    // Offset = current discontinuity time
    if (!prevCC || (!prevCC.new && currCC.new)) {
        vttCCs.ccOffset = vttCCs.presentationOffset = currCC.start;
        currCC.new = false;
        return;
    }
    // There have been discontinuities since cues were last parsed.
    // Offset = time elapsed
    while (prevCC && prevCC.new) {
        vttCCs.ccOffset += currCC.start - prevCC.start;
        currCC.new = false;
        currCC = prevCC;
        prevCC = vttCCs[currCC.prevCC];
    }
    vttCCs.presentationOffset = presentationTime;
};
var WebVTTParser = {
    parse: function (vttByteArray, syncPTS, vttCCs, cc, callBack, errorCallBack) {
        // Convert byteArray into string, replacing any somewhat exotic linefeeds with "\n", then split on that character.
        var re = /\r\n|\n\r|\n|\r/g;
        // Uint8Array.prototype.reduce is not implemented in IE11
        var vttLines = id3_1.utf8ArrayToStr(new Uint8Array(vttByteArray)).trim().replace(re, '\n').split('\n');
        var cueTime = '00:00.000';
        var mpegTs = 0;
        var localTime = 0;
        var presentationTime = 0;
        var cues = [];
        var parsingError;
        var inHeader = true;
        // let VTTCue = VTTCue || window.TextTrackCue;
        // Create parser object using VTTCue with TextTrackCue fallback on certain browsers.
        var parser = new vttparser_1.default();
        parser.oncue = function (cue) {
            // Adjust cue timing; clamp cues to start no earlier than - and drop cues that don't end after - 0 on timeline.
            var currCC = vttCCs[cc];
            var cueOffset = vttCCs.ccOffset;
            // Update offsets for new discontinuities
            if (currCC && currCC.new) {
                if (localTime !== undefined) {
                    // When local time is provided, offset = discontinuity start time - local time
                    cueOffset = vttCCs.ccOffset = currCC.start;
                }
                else {
                    calculateOffset(vttCCs, cc, presentationTime);
                }
            }
            if (presentationTime) {
                // If we have MPEGTS, offset = presentation time + discontinuity offset
                cueOffset = presentationTime - vttCCs.presentationOffset;
            }
            cue.startTime += cueOffset - localTime;
            cue.endTime += cueOffset - localTime;
            // Create a unique hash id for a cue based on start/end times and text.
            // This helps timeline-controller to avoid showing repeated captions.
            cue.id = hash(cue.startTime.toString()) + hash(cue.endTime.toString()) + hash(cue.text);
            // Fix encoding of special characters. TODO: Test with all sorts of weird characters.
            cue.text = decodeURIComponent(encodeURIComponent(cue.text));
            if (cue.endTime > 0) {
                cues.push(cue);
            }
        };
        parser.onparsingerror = function (e) {
            parsingError = e;
        };
        parser.onflush = function () {
            if (parsingError && errorCallBack) {
                errorCallBack(parsingError);
                return;
            }
            callBack(cues);
        };
        // Go through contents line by line.
        vttLines.forEach(function (line) {
            if (inHeader) {
                // Look for X-TIMESTAMP-MAP in header.
                if (startsWith(line, 'X-TIMESTAMP-MAP=')) {
                    // Once found, no more are allowed anyway, so stop searching.
                    inHeader = false;
                    // Extract LOCAL and MPEGTS.
                    line.substr(16).split(',').forEach(function (timestamp) {
                        if (startsWith(timestamp, 'LOCAL:')) {
                            cueTime = timestamp.substr(6);
                        }
                        else if (startsWith(timestamp, 'MPEGTS:')) {
                            mpegTs = parseInt(timestamp.substr(7));
                        }
                    });
                    try {
                        // Calculate subtitle offset in milliseconds.
                        if (syncPTS + ((vttCCs[cc].start * 90000) || 0) < 0) {
                            syncPTS += 8589934592;
                        }
                        // Adjust MPEGTS by sync PTS.
                        mpegTs -= syncPTS;
                        // Convert cue time to seconds
                        localTime = cueString2millis(cueTime) / 1000;
                        // Convert MPEGTS to seconds from 90kHz.
                        presentationTime = mpegTs / 90000;
                        if (localTime === -1) {
                            parsingError = new Error("Malformed X-TIMESTAMP-MAP: " + line);
                        }
                    }
                    catch (e) {
                        parsingError = new Error("Malformed X-TIMESTAMP-MAP: " + line);
                    }
                    // Return without parsing X-TIMESTAMP-MAP line.
                    return;
                }
                else if (line === '') {
                    inHeader = false;
                }
            }
            // Parse line by default.
            parser.parse(line + '\n');
        });
        parser.flush();
    }
};
exports.default = WebVTTParser;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./src/polyfills/number */ "./src/polyfills/number.js")["Number"]))

/***/ }),

/***/ "./src/utils/xhr-loader.js":
/*!*********************************!*\
  !*** ./src/utils/xhr-loader.js ***!
  \*********************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * XHR based logger
*/
Object.defineProperty(exports, "__esModule", { value: true });
var logger_1 = __webpack_require__(/*! ../utils/logger */ "./src/utils/logger.js");
var performance = window.performance, XMLHttpRequest = window.XMLHttpRequest;
var XhrLoader = /** @class */ (function () {
    function XhrLoader(config) {
        if (config && config.xhrSetup) {
            this.xhrSetup = config.xhrSetup;
        }
    }
    XhrLoader.prototype.destroy = function () {
        this.abort();
        this.loader = null;
    };
    XhrLoader.prototype.abort = function () {
        var loader = this.loader;
        if (loader && loader.readyState !== 4) {
            this.stats.aborted = true;
            loader.abort();
        }
        window.clearTimeout(this.requestTimeout);
        this.requestTimeout = null;
        window.clearTimeout(this.retryTimeout);
        this.retryTimeout = null;
    };
    XhrLoader.prototype.load = function (context, config, callbacks) {
        this.context = context;
        this.config = config;
        this.callbacks = callbacks;
        this.stats = { trequest: performance.now(), retry: 0 };
        this.retryDelay = config.retryDelay;
        this.loadInternal();
    };
    XhrLoader.prototype.loadInternal = function () {
        var xhr, context = this.context;
        xhr = this.loader = new XMLHttpRequest();
        var stats = this.stats;
        stats.tfirst = 0;
        stats.loaded = 0;
        var xhrSetup = this.xhrSetup;
        try {
            if (xhrSetup) {
                try {
                    xhrSetup(xhr, context.url);
                }
                catch (e) {
                    // fix xhrSetup: (xhr, url) => {xhr.setRequestHeader("Content-Language", "test");}
                    // not working, as xhr.setRequestHeader expects xhr.readyState === OPEN
                    xhr.open('GET', context.url, true);
                    xhrSetup(xhr, context.url);
                }
            }
            if (!xhr.readyState) {
                xhr.open('GET', context.url, true);
            }
        }
        catch (e) {
            // IE11 throws an exception on xhr.open if attempting to access an HTTP resource over HTTPS
            this.callbacks.onError({ code: xhr.status, text: e.message }, context, xhr);
            return;
        }
        if (context.rangeEnd) {
            xhr.setRequestHeader('Range', 'bytes=' + context.rangeStart + '-' + (context.rangeEnd - 1));
        }
        xhr.onreadystatechange = this.readystatechange.bind(this);
        xhr.onprogress = this.loadprogress.bind(this);
        xhr.responseType = context.responseType;
        // setup timeout before we perform request
        this.requestTimeout = window.setTimeout(this.loadtimeout.bind(this), this.config.timeout);
        xhr.send();
    };
    XhrLoader.prototype.readystatechange = function (event) {
        var xhr = event.currentTarget, readyState = xhr.readyState, stats = this.stats, context = this.context, config = this.config;
        // don't proceed if xhr has been aborted
        if (stats.aborted) {
            return;
        }
        // >= HEADERS_RECEIVED
        if (readyState >= 2) {
            // clear xhr timeout and rearm it if readyState less than 4
            window.clearTimeout(this.requestTimeout);
            if (stats.tfirst === 0) {
                stats.tfirst = Math.max(performance.now(), stats.trequest);
            }
            if (readyState === 4) {
                var status_1 = xhr.status;
                // http status between 200 to 299 are all successful
                if (status_1 >= 200 && status_1 < 300) {
                    stats.tload = Math.max(stats.tfirst, performance.now());
                    var data = void 0, len = void 0;
                    if (context.responseType === 'arraybuffer') {
                        data = xhr.response;
                        len = data.byteLength;
                    }
                    else {
                        data = xhr.responseText;
                        len = data.length;
                    }
                    stats.loaded = stats.total = len;
                    var response = { url: xhr.responseURL, data: data };
                    this.callbacks.onSuccess(response, stats, context, xhr);
                }
                else {
                    // if max nb of retries reached or if http status between 400 and 499 (such error cannot be recovered, retrying is useless), return error
                    if (stats.retry >= config.maxRetry || (status_1 >= 400 && status_1 < 499)) {
                        logger_1.logger.error(status_1 + " while loading " + context.url);
                        this.callbacks.onError({ code: status_1, text: xhr.statusText }, context, xhr);
                    }
                    else {
                        // retry
                        logger_1.logger.warn(status_1 + " while loading " + context.url + ", retrying in " + this.retryDelay + "...");
                        // aborts and resets internal state
                        this.destroy();
                        // schedule retry
                        this.retryTimeout = window.setTimeout(this.loadInternal.bind(this), this.retryDelay);
                        // set exponential backoff
                        this.retryDelay = Math.min(2 * this.retryDelay, config.maxRetryDelay);
                        stats.retry++;
                    }
                }
            }
            else {
                // readyState >= 2 AND readyState !==4 (readyState = HEADERS_RECEIVED || LOADING) rearm timeout as xhr not finished yet
                this.requestTimeout = window.setTimeout(this.loadtimeout.bind(this), config.timeout);
            }
        }
    };
    XhrLoader.prototype.loadtimeout = function () {
        logger_1.logger.warn("timeout while loading " + this.context.url);
        this.callbacks.onTimeout(this.stats, this.context, null);
    };
    XhrLoader.prototype.loadprogress = function (event) {
        var xhr = event.currentTarget, stats = this.stats;
        stats.loaded = event.loaded;
        if (event.lengthComputable) {
            stats.total = event.total;
        }
        var onProgress = this.callbacks.onProgress;
        if (onProgress) {
            // third arg is to provide on progress data
            onProgress(stats, this.context, null, xhr);
        }
    };
    return XhrLoader;
}());
exports.default = XhrLoader;


/***/ })

/******/ })["default"];
});
//# sourceMappingURL=hls.js.map

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9yc35obHMuanMuY2h1bmsuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaGxzLmpzL2Rpc3QvaGxzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbInR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiZcbihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFtdLCBmYWN0b3J5KTtcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0ZXhwb3J0c1tcIkhsc1wiXSA9IGZhY3RvcnkoKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJIbHNcIl0gPSBmYWN0b3J5KCk7XG59KSh0aGlzLCBmdW5jdGlvbigpIHtcbnJldHVybiAvKioqKioqLyAoZnVuY3Rpb24obW9kdWxlcykgeyAvLyB3ZWJwYWNrQm9vdHN0cmFwXG4vKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4vKioqKioqLyBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbi8qKioqKiovIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbi8qKioqKiovIFx0XHRcdGk6IG1vZHVsZUlkLFxuLyoqKioqKi8gXHRcdFx0bDogZmFsc2UsXG4vKioqKioqLyBcdFx0XHRleHBvcnRzOiB7fVxuLyoqKioqKi8gXHRcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuLyoqKioqKi8gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4vKioqKioqLyBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuLyoqKioqKi8gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0fVxuLyoqKioqKi9cbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuLyoqKioqKi8gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbi8qKioqKiovIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZ2V0dGVyIH0pO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yID0gZnVuY3Rpb24oZXhwb3J0cykge1xuLyoqKioqKi8gXHRcdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuLyoqKioqKi8gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBjcmVhdGUgYSBmYWtlIG5hbWVzcGFjZSBvYmplY3Rcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDE6IHZhbHVlIGlzIGEgbW9kdWxlIGlkLCByZXF1aXJlIGl0XG4vKioqKioqLyBcdC8vIG1vZGUgJiAyOiBtZXJnZSBhbGwgcHJvcGVydGllcyBvZiB2YWx1ZSBpbnRvIHRoZSBuc1xuLyoqKioqKi8gXHQvLyBtb2RlICYgNDogcmV0dXJuIHZhbHVlIHdoZW4gYWxyZWFkeSBucyBvYmplY3Rcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDh8MTogYmVoYXZlIGxpa2UgcmVxdWlyZVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnQgPSBmdW5jdGlvbih2YWx1ZSwgbW9kZSkge1xuLyoqKioqKi8gXHRcdGlmKG1vZGUgJiAxKSB2YWx1ZSA9IF9fd2VicGFja19yZXF1aXJlX18odmFsdWUpO1xuLyoqKioqKi8gXHRcdGlmKG1vZGUgJiA4KSByZXR1cm4gdmFsdWU7XG4vKioqKioqLyBcdFx0aWYoKG1vZGUgJiA0KSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICYmIHZhbHVlLl9fZXNNb2R1bGUpIHJldHVybiB2YWx1ZTtcbi8qKioqKiovIFx0XHR2YXIgbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18ucihucyk7XG4vKioqKioqLyBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG5zLCAnZGVmYXVsdCcsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHZhbHVlIH0pO1xuLyoqKioqKi8gXHRcdGlmKG1vZGUgJiAyICYmIHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykgZm9yKHZhciBrZXkgaW4gdmFsdWUpIF9fd2VicGFja19yZXF1aXJlX18uZChucywga2V5LCBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIHZhbHVlW2tleV07IH0uYmluZChudWxsLCBrZXkpKTtcbi8qKioqKiovIFx0XHRyZXR1cm4gbnM7XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbi8qKioqKiovIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbi8qKioqKiovIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4vKioqKioqLyBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbi8qKioqKiovIFx0XHRyZXR1cm4gZ2V0dGVyO1xuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiL2Rpc3QvXCI7XG4vKioqKioqL1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4vKioqKioqLyBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IFwiLi9zcmMvaGxzLmpzXCIpO1xuLyoqKioqKi8gfSlcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyAoe1xuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2V2ZW50ZW1pdHRlcjMvaW5kZXguanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9ldmVudGVtaXR0ZXIzL2luZGV4LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qISBNb2R1bGVDb25jYXRlbmF0aW9uIGJhaWxvdXQ6IE1vZHVsZSBpcyBub3QgYW4gRUNNQVNjcmlwdCBtb2R1bGUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIGhhcyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHlcbiAgLCBwcmVmaXggPSAnfic7XG5cbi8qKlxuICogQ29uc3RydWN0b3IgdG8gY3JlYXRlIGEgc3RvcmFnZSBmb3Igb3VyIGBFRWAgb2JqZWN0cy5cbiAqIEFuIGBFdmVudHNgIGluc3RhbmNlIGlzIGEgcGxhaW4gb2JqZWN0IHdob3NlIHByb3BlcnRpZXMgYXJlIGV2ZW50IG5hbWVzLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gRXZlbnRzKCkge31cblxuLy9cbi8vIFdlIHRyeSB0byBub3QgaW5oZXJpdCBmcm9tIGBPYmplY3QucHJvdG90eXBlYC4gSW4gc29tZSBlbmdpbmVzIGNyZWF0aW5nIGFuXG4vLyBpbnN0YW5jZSBpbiB0aGlzIHdheSBpcyBmYXN0ZXIgdGhhbiBjYWxsaW5nIGBPYmplY3QuY3JlYXRlKG51bGwpYCBkaXJlY3RseS5cbi8vIElmIGBPYmplY3QuY3JlYXRlKG51bGwpYCBpcyBub3Qgc3VwcG9ydGVkIHdlIHByZWZpeCB0aGUgZXZlbnQgbmFtZXMgd2l0aCBhXG4vLyBjaGFyYWN0ZXIgdG8gbWFrZSBzdXJlIHRoYXQgdGhlIGJ1aWx0LWluIG9iamVjdCBwcm9wZXJ0aWVzIGFyZSBub3Rcbi8vIG92ZXJyaWRkZW4gb3IgdXNlZCBhcyBhbiBhdHRhY2sgdmVjdG9yLlxuLy9cbmlmIChPYmplY3QuY3JlYXRlKSB7XG4gIEV2ZW50cy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gIC8vXG4gIC8vIFRoaXMgaGFjayBpcyBuZWVkZWQgYmVjYXVzZSB0aGUgYF9fcHJvdG9fX2AgcHJvcGVydHkgaXMgc3RpbGwgaW5oZXJpdGVkIGluXG4gIC8vIHNvbWUgb2xkIGJyb3dzZXJzIGxpa2UgQW5kcm9pZCA0LCBpUGhvbmUgNS4xLCBPcGVyYSAxMSBhbmQgU2FmYXJpIDUuXG4gIC8vXG4gIGlmICghbmV3IEV2ZW50cygpLl9fcHJvdG9fXykgcHJlZml4ID0gZmFsc2U7XG59XG5cbi8qKlxuICogUmVwcmVzZW50YXRpb24gb2YgYSBzaW5nbGUgZXZlbnQgbGlzdGVuZXIuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGxpc3RlbmVyIGZ1bmN0aW9uLlxuICogQHBhcmFtIHsqfSBjb250ZXh0IFRoZSBjb250ZXh0IHRvIGludm9rZSB0aGUgbGlzdGVuZXIgd2l0aC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29uY2U9ZmFsc2VdIFNwZWNpZnkgaWYgdGhlIGxpc3RlbmVyIGlzIGEgb25lLXRpbWUgbGlzdGVuZXIuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIEVFKGZuLCBjb250ZXh0LCBvbmNlKSB7XG4gIHRoaXMuZm4gPSBmbjtcbiAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgdGhpcy5vbmNlID0gb25jZSB8fCBmYWxzZTtcbn1cblxuLyoqXG4gKiBBZGQgYSBsaXN0ZW5lciBmb3IgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0ge0V2ZW50RW1pdHRlcn0gZW1pdHRlciBSZWZlcmVuY2UgdG8gdGhlIGBFdmVudEVtaXR0ZXJgIGluc3RhbmNlLlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGxpc3RlbmVyIGZ1bmN0aW9uLlxuICogQHBhcmFtIHsqfSBjb250ZXh0IFRoZSBjb250ZXh0IHRvIGludm9rZSB0aGUgbGlzdGVuZXIgd2l0aC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gb25jZSBTcGVjaWZ5IGlmIHRoZSBsaXN0ZW5lciBpcyBhIG9uZS10aW1lIGxpc3RlbmVyLlxuICogQHJldHVybnMge0V2ZW50RW1pdHRlcn1cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGFkZExpc3RlbmVyKGVtaXR0ZXIsIGV2ZW50LCBmbiwgY29udGV4dCwgb25jZSkge1xuICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIGxpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICB9XG5cbiAgdmFyIGxpc3RlbmVyID0gbmV3IEVFKGZuLCBjb250ZXh0IHx8IGVtaXR0ZXIsIG9uY2UpXG4gICAgLCBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50O1xuXG4gIGlmICghZW1pdHRlci5fZXZlbnRzW2V2dF0pIGVtaXR0ZXIuX2V2ZW50c1tldnRdID0gbGlzdGVuZXIsIGVtaXR0ZXIuX2V2ZW50c0NvdW50Kys7XG4gIGVsc2UgaWYgKCFlbWl0dGVyLl9ldmVudHNbZXZ0XS5mbikgZW1pdHRlci5fZXZlbnRzW2V2dF0ucHVzaChsaXN0ZW5lcik7XG4gIGVsc2UgZW1pdHRlci5fZXZlbnRzW2V2dF0gPSBbZW1pdHRlci5fZXZlbnRzW2V2dF0sIGxpc3RlbmVyXTtcblxuICByZXR1cm4gZW1pdHRlcjtcbn1cblxuLyoqXG4gKiBDbGVhciBldmVudCBieSBuYW1lLlxuICpcbiAqIEBwYXJhbSB7RXZlbnRFbWl0dGVyfSBlbWl0dGVyIFJlZmVyZW5jZSB0byB0aGUgYEV2ZW50RW1pdHRlcmAgaW5zdGFuY2UuXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZ0IFRoZSBFdmVudCBuYW1lLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY2xlYXJFdmVudChlbWl0dGVyLCBldnQpIHtcbiAgaWYgKC0tZW1pdHRlci5fZXZlbnRzQ291bnQgPT09IDApIGVtaXR0ZXIuX2V2ZW50cyA9IG5ldyBFdmVudHMoKTtcbiAgZWxzZSBkZWxldGUgZW1pdHRlci5fZXZlbnRzW2V2dF07XG59XG5cbi8qKlxuICogTWluaW1hbCBgRXZlbnRFbWl0dGVyYCBpbnRlcmZhY2UgdGhhdCBpcyBtb2xkZWQgYWdhaW5zdCB0aGUgTm9kZS5qc1xuICogYEV2ZW50RW1pdHRlcmAgaW50ZXJmYWNlLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gIHRoaXMuX2V2ZW50cyA9IG5ldyBFdmVudHMoKTtcbiAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xufVxuXG4vKipcbiAqIFJldHVybiBhbiBhcnJheSBsaXN0aW5nIHRoZSBldmVudHMgZm9yIHdoaWNoIHRoZSBlbWl0dGVyIGhhcyByZWdpc3RlcmVkXG4gKiBsaXN0ZW5lcnMuXG4gKlxuICogQHJldHVybnMge0FycmF5fVxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmV2ZW50TmFtZXMgPSBmdW5jdGlvbiBldmVudE5hbWVzKCkge1xuICB2YXIgbmFtZXMgPSBbXVxuICAgICwgZXZlbnRzXG4gICAgLCBuYW1lO1xuXG4gIGlmICh0aGlzLl9ldmVudHNDb3VudCA9PT0gMCkgcmV0dXJuIG5hbWVzO1xuXG4gIGZvciAobmFtZSBpbiAoZXZlbnRzID0gdGhpcy5fZXZlbnRzKSkge1xuICAgIGlmIChoYXMuY2FsbChldmVudHMsIG5hbWUpKSBuYW1lcy5wdXNoKHByZWZpeCA/IG5hbWUuc2xpY2UoMSkgOiBuYW1lKTtcbiAgfVxuXG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgcmV0dXJuIG5hbWVzLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGV2ZW50cykpO1xuICB9XG5cbiAgcmV0dXJuIG5hbWVzO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gdGhlIGxpc3RlbmVycyByZWdpc3RlcmVkIGZvciBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEByZXR1cm5zIHtBcnJheX0gVGhlIHJlZ2lzdGVyZWQgbGlzdGVuZXJzLlxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uIGxpc3RlbmVycyhldmVudCkge1xuICB2YXIgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudFxuICAgICwgaGFuZGxlcnMgPSB0aGlzLl9ldmVudHNbZXZ0XTtcblxuICBpZiAoIWhhbmRsZXJzKSByZXR1cm4gW107XG4gIGlmIChoYW5kbGVycy5mbikgcmV0dXJuIFtoYW5kbGVycy5mbl07XG5cbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBoYW5kbGVycy5sZW5ndGgsIGVlID0gbmV3IEFycmF5KGwpOyBpIDwgbDsgaSsrKSB7XG4gICAgZWVbaV0gPSBoYW5kbGVyc1tpXS5mbjtcbiAgfVxuXG4gIHJldHVybiBlZTtcbn07XG5cbi8qKlxuICogUmV0dXJuIHRoZSBudW1iZXIgb2YgbGlzdGVuZXJzIGxpc3RlbmluZyB0byBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBudW1iZXIgb2YgbGlzdGVuZXJzLlxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbiBsaXN0ZW5lckNvdW50KGV2ZW50KSB7XG4gIHZhciBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50XG4gICAgLCBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbZXZ0XTtcblxuICBpZiAoIWxpc3RlbmVycykgcmV0dXJuIDA7XG4gIGlmIChsaXN0ZW5lcnMuZm4pIHJldHVybiAxO1xuICByZXR1cm4gbGlzdGVuZXJzLmxlbmd0aDtcbn07XG5cbi8qKlxuICogQ2FsbHMgZWFjaCBvZiB0aGUgbGlzdGVuZXJzIHJlZ2lzdGVyZWQgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHJldHVybnMge0Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgZXZlbnQgaGFkIGxpc3RlbmVycywgZWxzZSBgZmFsc2VgLlxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiBlbWl0KGV2ZW50LCBhMSwgYTIsIGEzLCBhNCwgYTUpIHtcbiAgdmFyIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnQ7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHNbZXZ0XSkgcmV0dXJuIGZhbHNlO1xuXG4gIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbZXZ0XVxuICAgICwgbGVuID0gYXJndW1lbnRzLmxlbmd0aFxuICAgICwgYXJnc1xuICAgICwgaTtcblxuICBpZiAobGlzdGVuZXJzLmZuKSB7XG4gICAgaWYgKGxpc3RlbmVycy5vbmNlKSB0aGlzLnJlbW92ZUxpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lcnMuZm4sIHVuZGVmaW5lZCwgdHJ1ZSk7XG5cbiAgICBzd2l0Y2ggKGxlbikge1xuICAgICAgY2FzZSAxOiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQpLCB0cnVlO1xuICAgICAgY2FzZSAyOiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExKSwgdHJ1ZTtcbiAgICAgIGNhc2UgMzogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0LCBhMSwgYTIpLCB0cnVlO1xuICAgICAgY2FzZSA0OiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExLCBhMiwgYTMpLCB0cnVlO1xuICAgICAgY2FzZSA1OiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExLCBhMiwgYTMsIGE0KSwgdHJ1ZTtcbiAgICAgIGNhc2UgNjogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0LCBhMSwgYTIsIGEzLCBhNCwgYTUpLCB0cnVlO1xuICAgIH1cblxuICAgIGZvciAoaSA9IDEsIGFyZ3MgPSBuZXcgQXJyYXkobGVuIC0xKTsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICB9XG5cbiAgICBsaXN0ZW5lcnMuZm4uYXBwbHkobGlzdGVuZXJzLmNvbnRleHQsIGFyZ3MpO1xuICB9IGVsc2Uge1xuICAgIHZhciBsZW5ndGggPSBsaXN0ZW5lcnMubGVuZ3RoXG4gICAgICAsIGo7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChsaXN0ZW5lcnNbaV0ub25jZSkgdGhpcy5yZW1vdmVMaXN0ZW5lcihldmVudCwgbGlzdGVuZXJzW2ldLmZuLCB1bmRlZmluZWQsIHRydWUpO1xuXG4gICAgICBzd2l0Y2ggKGxlbikge1xuICAgICAgICBjYXNlIDE6IGxpc3RlbmVyc1tpXS5mbi5jYWxsKGxpc3RlbmVyc1tpXS5jb250ZXh0KTsgYnJlYWs7XG4gICAgICAgIGNhc2UgMjogbGlzdGVuZXJzW2ldLmZuLmNhbGwobGlzdGVuZXJzW2ldLmNvbnRleHQsIGExKTsgYnJlYWs7XG4gICAgICAgIGNhc2UgMzogbGlzdGVuZXJzW2ldLmZuLmNhbGwobGlzdGVuZXJzW2ldLmNvbnRleHQsIGExLCBhMik7IGJyZWFrO1xuICAgICAgICBjYXNlIDQ6IGxpc3RlbmVyc1tpXS5mbi5jYWxsKGxpc3RlbmVyc1tpXS5jb250ZXh0LCBhMSwgYTIsIGEzKTsgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgaWYgKCFhcmdzKSBmb3IgKGogPSAxLCBhcmdzID0gbmV3IEFycmF5KGxlbiAtMSk7IGogPCBsZW47IGorKykge1xuICAgICAgICAgICAgYXJnc1tqIC0gMV0gPSBhcmd1bWVudHNbal07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbGlzdGVuZXJzW2ldLmZuLmFwcGx5KGxpc3RlbmVyc1tpXS5jb250ZXh0LCBhcmdzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuICogQWRkIGEgbGlzdGVuZXIgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGxpc3RlbmVyIGZ1bmN0aW9uLlxuICogQHBhcmFtIHsqfSBbY29udGV4dD10aGlzXSBUaGUgY29udGV4dCB0byBpbnZva2UgdGhlIGxpc3RlbmVyIHdpdGguXG4gKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfSBgdGhpc2AuXG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBmdW5jdGlvbiBvbihldmVudCwgZm4sIGNvbnRleHQpIHtcbiAgcmV0dXJuIGFkZExpc3RlbmVyKHRoaXMsIGV2ZW50LCBmbiwgY29udGV4dCwgZmFsc2UpO1xufTtcblxuLyoqXG4gKiBBZGQgYSBvbmUtdGltZSBsaXN0ZW5lciBmb3IgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgbGlzdGVuZXIgZnVuY3Rpb24uXG4gKiBAcGFyYW0geyp9IFtjb250ZXh0PXRoaXNdIFRoZSBjb250ZXh0IHRvIGludm9rZSB0aGUgbGlzdGVuZXIgd2l0aC5cbiAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9IGB0aGlzYC5cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24gb25jZShldmVudCwgZm4sIGNvbnRleHQpIHtcbiAgcmV0dXJuIGFkZExpc3RlbmVyKHRoaXMsIGV2ZW50LCBmbiwgY29udGV4dCwgdHJ1ZSk7XG59O1xuXG4vKipcbiAqIFJlbW92ZSB0aGUgbGlzdGVuZXJzIG9mIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gT25seSByZW1vdmUgdGhlIGxpc3RlbmVycyB0aGF0IG1hdGNoIHRoaXMgZnVuY3Rpb24uXG4gKiBAcGFyYW0geyp9IGNvbnRleHQgT25seSByZW1vdmUgdGhlIGxpc3RlbmVycyB0aGF0IGhhdmUgdGhpcyBjb250ZXh0LlxuICogQHBhcmFtIHtCb29sZWFufSBvbmNlIE9ubHkgcmVtb3ZlIG9uZS10aW1lIGxpc3RlbmVycy5cbiAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9IGB0aGlzYC5cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKGV2ZW50LCBmbiwgY29udGV4dCwgb25jZSkge1xuICB2YXIgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudDtcblxuICBpZiAoIXRoaXMuX2V2ZW50c1tldnRdKSByZXR1cm4gdGhpcztcbiAgaWYgKCFmbikge1xuICAgIGNsZWFyRXZlbnQodGhpcywgZXZ0KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbZXZ0XTtcblxuICBpZiAobGlzdGVuZXJzLmZuKSB7XG4gICAgaWYgKFxuICAgICAgbGlzdGVuZXJzLmZuID09PSBmbiAmJlxuICAgICAgKCFvbmNlIHx8IGxpc3RlbmVycy5vbmNlKSAmJlxuICAgICAgKCFjb250ZXh0IHx8IGxpc3RlbmVycy5jb250ZXh0ID09PSBjb250ZXh0KVxuICAgICkge1xuICAgICAgY2xlYXJFdmVudCh0aGlzLCBldnQpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmb3IgKHZhciBpID0gMCwgZXZlbnRzID0gW10sIGxlbmd0aCA9IGxpc3RlbmVycy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgaWYgKFxuICAgICAgICBsaXN0ZW5lcnNbaV0uZm4gIT09IGZuIHx8XG4gICAgICAgIChvbmNlICYmICFsaXN0ZW5lcnNbaV0ub25jZSkgfHxcbiAgICAgICAgKGNvbnRleHQgJiYgbGlzdGVuZXJzW2ldLmNvbnRleHQgIT09IGNvbnRleHQpXG4gICAgICApIHtcbiAgICAgICAgZXZlbnRzLnB1c2gobGlzdGVuZXJzW2ldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvL1xuICAgIC8vIFJlc2V0IHRoZSBhcnJheSwgb3IgcmVtb3ZlIGl0IGNvbXBsZXRlbHkgaWYgd2UgaGF2ZSBubyBtb3JlIGxpc3RlbmVycy5cbiAgICAvL1xuICAgIGlmIChldmVudHMubGVuZ3RoKSB0aGlzLl9ldmVudHNbZXZ0XSA9IGV2ZW50cy5sZW5ndGggPT09IDEgPyBldmVudHNbMF0gOiBldmVudHM7XG4gICAgZWxzZSBjbGVhckV2ZW50KHRoaXMsIGV2dCk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmVtb3ZlIGFsbCBsaXN0ZW5lcnMsIG9yIHRob3NlIG9mIHRoZSBzcGVjaWZpZWQgZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IFtldmVudF0gVGhlIGV2ZW50IG5hbWUuXG4gKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfSBgdGhpc2AuXG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24gcmVtb3ZlQWxsTGlzdGVuZXJzKGV2ZW50KSB7XG4gIHZhciBldnQ7XG5cbiAgaWYgKGV2ZW50KSB7XG4gICAgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudDtcbiAgICBpZiAodGhpcy5fZXZlbnRzW2V2dF0pIGNsZWFyRXZlbnQodGhpcywgZXZ0KTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLl9ldmVudHMgPSBuZXcgRXZlbnRzKCk7XG4gICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vL1xuLy8gQWxpYXMgbWV0aG9kcyBuYW1lcyBiZWNhdXNlIHBlb3BsZSByb2xsIGxpa2UgdGhhdC5cbi8vXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9mZiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXI7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbjtcblxuLy9cbi8vIEV4cG9zZSB0aGUgcHJlZml4LlxuLy9cbkV2ZW50RW1pdHRlci5wcmVmaXhlZCA9IHByZWZpeDtcblxuLy9cbi8vIEFsbG93IGBFdmVudEVtaXR0ZXJgIHRvIGJlIGltcG9ydGVkIGFzIG1vZHVsZSBuYW1lc3BhY2UuXG4vL1xuRXZlbnRFbWl0dGVyLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcblxuLy9cbi8vIEV4cG9zZSB0aGUgbW9kdWxlLlxuLy9cbmlmICh0cnVlKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xufVxuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL25vZGUtbGlicy1icm93c2VyL25vZGVfbW9kdWxlcy9ldmVudHMvZXZlbnRzLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL25vZGUtbGlicy1icm93c2VyL25vZGVfbW9kdWxlcy9ldmVudHMvZXZlbnRzLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gIHRoaXMuX2V2ZW50cyA9IHRoaXMuX2V2ZW50cyB8fCB7fTtcbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gdGhpcy5fbWF4TGlzdGVuZXJzIHx8IHVuZGVmaW5lZDtcbn1cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xuXG4vLyBCYWNrd2FyZHMtY29tcGF0IHdpdGggbm9kZSAwLjEwLnhcbkV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50cyA9IHVuZGVmaW5lZDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX21heExpc3RlbmVycyA9IHVuZGVmaW5lZDtcblxuLy8gQnkgZGVmYXVsdCBFdmVudEVtaXR0ZXJzIHdpbGwgcHJpbnQgYSB3YXJuaW5nIGlmIG1vcmUgdGhhbiAxMCBsaXN0ZW5lcnMgYXJlXG4vLyBhZGRlZCB0byBpdC4gVGhpcyBpcyBhIHVzZWZ1bCBkZWZhdWx0IHdoaWNoIGhlbHBzIGZpbmRpbmcgbWVtb3J5IGxlYWtzLlxuRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnMgPSAxMDtcblxuLy8gT2J2aW91c2x5IG5vdCBhbGwgRW1pdHRlcnMgc2hvdWxkIGJlIGxpbWl0ZWQgdG8gMTAuIFRoaXMgZnVuY3Rpb24gYWxsb3dzXG4vLyB0aGF0IHRvIGJlIGluY3JlYXNlZC4gU2V0IHRvIHplcm8gZm9yIHVubGltaXRlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuc2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24obikge1xuICBpZiAoIWlzTnVtYmVyKG4pIHx8IG4gPCAwIHx8IGlzTmFOKG4pKVxuICAgIHRocm93IFR5cGVFcnJvcignbiBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyJyk7XG4gIHRoaXMuX21heExpc3RlbmVycyA9IG47XG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIgZXIsIGhhbmRsZXIsIGxlbiwgYXJncywgaSwgbGlzdGVuZXJzO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKVxuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuXG4gIC8vIElmIHRoZXJlIGlzIG5vICdlcnJvcicgZXZlbnQgbGlzdGVuZXIgdGhlbiB0aHJvdy5cbiAgaWYgKHR5cGUgPT09ICdlcnJvcicpIHtcbiAgICBpZiAoIXRoaXMuX2V2ZW50cy5lcnJvciB8fFxuICAgICAgICAoaXNPYmplY3QodGhpcy5fZXZlbnRzLmVycm9yKSAmJiAhdGhpcy5fZXZlbnRzLmVycm9yLmxlbmd0aCkpIHtcbiAgICAgIGVyID0gYXJndW1lbnRzWzFdO1xuICAgICAgaWYgKGVyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBBdCBsZWFzdCBnaXZlIHNvbWUga2luZCBvZiBjb250ZXh0IHRvIHRoZSB1c2VyXG4gICAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ1VuY2F1Z2h0LCB1bnNwZWNpZmllZCBcImVycm9yXCIgZXZlbnQuICgnICsgZXIgKyAnKScpO1xuICAgICAgICBlcnIuY29udGV4dCA9IGVyO1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaGFuZGxlciA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICBpZiAoaXNVbmRlZmluZWQoaGFuZGxlcikpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIGlmIChpc0Z1bmN0aW9uKGhhbmRsZXIpKSB7XG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAvLyBmYXN0IGNhc2VzXG4gICAgICBjYXNlIDE6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzLCBhcmd1bWVudHNbMV0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICAvLyBzbG93ZXJcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICBoYW5kbGVyLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc09iamVjdChoYW5kbGVyKSkge1xuICAgIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgIGxpc3RlbmVycyA9IGhhbmRsZXIuc2xpY2UoKTtcbiAgICBsZW4gPSBsaXN0ZW5lcnMubGVuZ3RoO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKylcbiAgICAgIGxpc3RlbmVyc1tpXS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBtO1xuXG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcblxuICAvLyBUbyBhdm9pZCByZWN1cnNpb24gaW4gdGhlIGNhc2UgdGhhdCB0eXBlID09PSBcIm5ld0xpc3RlbmVyXCIhIEJlZm9yZVxuICAvLyBhZGRpbmcgaXQgdG8gdGhlIGxpc3RlbmVycywgZmlyc3QgZW1pdCBcIm5ld0xpc3RlbmVyXCIuXG4gIGlmICh0aGlzLl9ldmVudHMubmV3TGlzdGVuZXIpXG4gICAgdGhpcy5lbWl0KCduZXdMaXN0ZW5lcicsIHR5cGUsXG4gICAgICAgICAgICAgIGlzRnVuY3Rpb24obGlzdGVuZXIubGlzdGVuZXIpID9cbiAgICAgICAgICAgICAgbGlzdGVuZXIubGlzdGVuZXIgOiBsaXN0ZW5lcik7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgLy8gT3B0aW1pemUgdGhlIGNhc2Ugb2Ygb25lIGxpc3RlbmVyLiBEb24ndCBuZWVkIHRoZSBleHRyYSBhcnJheSBvYmplY3QuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gbGlzdGVuZXI7XG4gIGVsc2UgaWYgKGlzT2JqZWN0KHRoaXMuX2V2ZW50c1t0eXBlXSkpXG4gICAgLy8gSWYgd2UndmUgYWxyZWFkeSBnb3QgYW4gYXJyYXksIGp1c3QgYXBwZW5kLlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXS5wdXNoKGxpc3RlbmVyKTtcbiAgZWxzZVxuICAgIC8vIEFkZGluZyB0aGUgc2Vjb25kIGVsZW1lbnQsIG5lZWQgdG8gY2hhbmdlIHRvIGFycmF5LlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IFt0aGlzLl9ldmVudHNbdHlwZV0sIGxpc3RlbmVyXTtcblxuICAvLyBDaGVjayBmb3IgbGlzdGVuZXIgbGVha1xuICBpZiAoaXNPYmplY3QodGhpcy5fZXZlbnRzW3R5cGVdKSAmJiAhdGhpcy5fZXZlbnRzW3R5cGVdLndhcm5lZCkge1xuICAgIGlmICghaXNVbmRlZmluZWQodGhpcy5fbWF4TGlzdGVuZXJzKSkge1xuICAgICAgbSA9IHRoaXMuX21heExpc3RlbmVycztcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IEV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzO1xuICAgIH1cblxuICAgIGlmIChtICYmIG0gPiAwICYmIHRoaXMuX2V2ZW50c1t0eXBlXS5sZW5ndGggPiBtKSB7XG4gICAgICB0aGlzLl9ldmVudHNbdHlwZV0ud2FybmVkID0gdHJ1ZTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJyhub2RlKSB3YXJuaW5nOiBwb3NzaWJsZSBFdmVudEVtaXR0ZXIgbWVtb3J5ICcgK1xuICAgICAgICAgICAgICAgICAgICAnbGVhayBkZXRlY3RlZC4gJWQgbGlzdGVuZXJzIGFkZGVkLiAnICtcbiAgICAgICAgICAgICAgICAgICAgJ1VzZSBlbWl0dGVyLnNldE1heExpc3RlbmVycygpIHRvIGluY3JlYXNlIGxpbWl0LicsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXS5sZW5ndGgpO1xuICAgICAgaWYgKHR5cGVvZiBjb25zb2xlLnRyYWNlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIG5vdCBzdXBwb3J0ZWQgaW4gSUUgMTBcbiAgICAgICAgY29uc29sZS50cmFjZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICB2YXIgZmlyZWQgPSBmYWxzZTtcblxuICBmdW5jdGlvbiBnKCkge1xuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgZyk7XG5cbiAgICBpZiAoIWZpcmVkKSB7XG4gICAgICBmaXJlZCA9IHRydWU7XG4gICAgICBsaXN0ZW5lci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfVxuXG4gIGcubGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgdGhpcy5vbih0eXBlLCBnKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIGVtaXRzIGEgJ3JlbW92ZUxpc3RlbmVyJyBldmVudCBpZmYgdGhlIGxpc3RlbmVyIHdhcyByZW1vdmVkXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIGxpc3QsIHBvc2l0aW9uLCBsZW5ndGgsIGk7XG5cbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzIHx8ICF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgbGlzdCA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgbGVuZ3RoID0gbGlzdC5sZW5ndGg7XG4gIHBvc2l0aW9uID0gLTE7XG5cbiAgaWYgKGxpc3QgPT09IGxpc3RlbmVyIHx8XG4gICAgICAoaXNGdW5jdGlvbihsaXN0Lmxpc3RlbmVyKSAmJiBsaXN0Lmxpc3RlbmVyID09PSBsaXN0ZW5lcikpIHtcbiAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIGlmICh0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdGVuZXIpO1xuXG4gIH0gZWxzZSBpZiAoaXNPYmplY3QobGlzdCkpIHtcbiAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSA+IDA7KSB7XG4gICAgICBpZiAobGlzdFtpXSA9PT0gbGlzdGVuZXIgfHxcbiAgICAgICAgICAobGlzdFtpXS5saXN0ZW5lciAmJiBsaXN0W2ldLmxpc3RlbmVyID09PSBsaXN0ZW5lcikpIHtcbiAgICAgICAgcG9zaXRpb24gPSBpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocG9zaXRpb24gPCAwKVxuICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICBpZiAobGlzdC5sZW5ndGggPT09IDEpIHtcbiAgICAgIGxpc3QubGVuZ3RoID0gMDtcbiAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGxpc3Quc3BsaWNlKHBvc2l0aW9uLCAxKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3RlbmVyKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciBrZXksIGxpc3RlbmVycztcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICByZXR1cm4gdGhpcztcblxuICAvLyBub3QgbGlzdGVuaW5nIGZvciByZW1vdmVMaXN0ZW5lciwgbm8gbmVlZCB0byBlbWl0XG4gIGlmICghdGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApXG4gICAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgICBlbHNlIGlmICh0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gZW1pdCByZW1vdmVMaXN0ZW5lciBmb3IgYWxsIGxpc3RlbmVycyBvbiBhbGwgZXZlbnRzXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgZm9yIChrZXkgaW4gdGhpcy5fZXZlbnRzKSB7XG4gICAgICBpZiAoa2V5ID09PSAncmVtb3ZlTGlzdGVuZXInKSBjb250aW51ZTtcbiAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKGtleSk7XG4gICAgfVxuICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCdyZW1vdmVMaXN0ZW5lcicpO1xuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIGlmIChpc0Z1bmN0aW9uKGxpc3RlbmVycykpIHtcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVycyk7XG4gIH0gZWxzZSBpZiAobGlzdGVuZXJzKSB7XG4gICAgLy8gTElGTyBvcmRlclxuICAgIHdoaWxlIChsaXN0ZW5lcnMubGVuZ3RoKVxuICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnNbbGlzdGVuZXJzLmxlbmd0aCAtIDFdKTtcbiAgfVxuICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciByZXQ7XG4gIGlmICghdGhpcy5fZXZlbnRzIHx8ICF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgcmV0ID0gW107XG4gIGVsc2UgaWYgKGlzRnVuY3Rpb24odGhpcy5fZXZlbnRzW3R5cGVdKSlcbiAgICByZXQgPSBbdGhpcy5fZXZlbnRzW3R5cGVdXTtcbiAgZWxzZVxuICAgIHJldCA9IHRoaXMuX2V2ZW50c1t0eXBlXS5zbGljZSgpO1xuICByZXR1cm4gcmV0O1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24odHlwZSkge1xuICBpZiAodGhpcy5fZXZlbnRzKSB7XG4gICAgdmFyIGV2bGlzdGVuZXIgPSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgICBpZiAoaXNGdW5jdGlvbihldmxpc3RlbmVyKSlcbiAgICAgIHJldHVybiAxO1xuICAgIGVsc2UgaWYgKGV2bGlzdGVuZXIpXG4gICAgICByZXR1cm4gZXZsaXN0ZW5lci5sZW5ndGg7XG4gIH1cbiAgcmV0dXJuIDA7XG59O1xuXG5FdmVudEVtaXR0ZXIubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKGVtaXR0ZXIsIHR5cGUpIHtcbiAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJDb3VudCh0eXBlKTtcbn07XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xufVxuXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xufVxuXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbn1cblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcbn1cblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy91cmwtdG9vbGtpdC9zcmMvdXJsLXRvb2xraXQuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3VybC10b29sa2l0L3NyYy91cmwtdG9vbGtpdC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qISBNb2R1bGVDb25jYXRlbmF0aW9uIGJhaWxvdXQ6IE1vZHVsZSBpcyBub3QgYW4gRUNNQVNjcmlwdCBtb2R1bGUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8gc2VlIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMxODA4XG5cbi8qIGpzaGludCBpZ25vcmU6c3RhcnQgKi9cbihmdW5jdGlvbihyb290KSB7IFxuLyoganNoaW50IGlnbm9yZTplbmQgKi9cblxuICB2YXIgVVJMX1JFR0VYID0gL14oKD86W2EtekEtWjAtOStcXC0uXSs6KT8pKFxcL1xcL1teXFwvPyNdKik/KCg/OlteXFwvXFw/I10qXFwvKSouKj8pPz8oOy4qPyk/KFxcPy4qPyk/KCMuKj8pPyQvO1xuICB2YXIgRklSU1RfU0VHTUVOVF9SRUdFWCA9IC9eKFteXFwvPyNdKikoLiopJC87XG4gIHZhciBTTEFTSF9ET1RfUkVHRVggPSAvKD86XFwvfF4pXFwuKD89XFwvKS9nO1xuICB2YXIgU0xBU0hfRE9UX0RPVF9SRUdFWCA9IC8oPzpcXC98XilcXC5cXC5cXC8oPyFcXC5cXC5cXC8pLio/KD89XFwvKS9nO1xuXG4gIHZhciBVUkxUb29sa2l0ID0geyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcbiAgICAvLyBJZiBvcHRzLmFsd2F5c05vcm1hbGl6ZSBpcyB0cnVlIHRoZW4gdGhlIHBhdGggd2lsbCBhbHdheXMgYmUgbm9ybWFsaXplZCBldmVuIHdoZW4gaXQgc3RhcnRzIHdpdGggLyBvciAvL1xuICAgIC8vIEUuZ1xuICAgIC8vIFdpdGggb3B0cy5hbHdheXNOb3JtYWxpemUgPSBmYWxzZSAoZGVmYXVsdCwgc3BlYyBjb21wbGlhbnQpXG4gICAgLy8gaHR0cDovL2EuY29tL2IvY2QgKyAvZS9mLy4uL2cgPT4gaHR0cDovL2EuY29tL2UvZi8uLi9nXG4gICAgLy8gV2l0aCBvcHRzLmFsd2F5c05vcm1hbGl6ZSA9IHRydWUgKG5vdCBzcGVjIGNvbXBsaWFudClcbiAgICAvLyBodHRwOi8vYS5jb20vYi9jZCArIC9lL2YvLi4vZyA9PiBodHRwOi8vYS5jb20vZS9nXG4gICAgYnVpbGRBYnNvbHV0ZVVSTDogZnVuY3Rpb24oYmFzZVVSTCwgcmVsYXRpdmVVUkwsIG9wdHMpIHtcbiAgICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xuICAgICAgLy8gcmVtb3ZlIGFueSByZW1haW5pbmcgc3BhY2UgYW5kIENSTEZcbiAgICAgIGJhc2VVUkwgPSBiYXNlVVJMLnRyaW0oKTtcbiAgICAgIHJlbGF0aXZlVVJMID0gcmVsYXRpdmVVUkwudHJpbSgpO1xuICAgICAgaWYgKCFyZWxhdGl2ZVVSTCkge1xuICAgICAgICAvLyAyYSkgSWYgdGhlIGVtYmVkZGVkIFVSTCBpcyBlbnRpcmVseSBlbXB0eSwgaXQgaW5oZXJpdHMgdGhlXG4gICAgICAgIC8vIGVudGlyZSBiYXNlIFVSTCAoaS5lLiwgaXMgc2V0IGVxdWFsIHRvIHRoZSBiYXNlIFVSTClcbiAgICAgICAgLy8gYW5kIHdlIGFyZSBkb25lLlxuICAgICAgICBpZiAoIW9wdHMuYWx3YXlzTm9ybWFsaXplKSB7XG4gICAgICAgICAgcmV0dXJuIGJhc2VVUkw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJhc2VQYXJ0c0Zvck5vcm1hbGlzZSA9IFVSTFRvb2xraXQucGFyc2VVUkwoYmFzZVVSTCk7XG4gICAgICAgIGlmICghYmFzZVBhcnRzRm9yTm9ybWFsaXNlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFcnJvciB0cnlpbmcgdG8gcGFyc2UgYmFzZSBVUkwuJyk7XG4gICAgICAgIH1cbiAgICAgICAgYmFzZVBhcnRzRm9yTm9ybWFsaXNlLnBhdGggPSBVUkxUb29sa2l0Lm5vcm1hbGl6ZVBhdGgoYmFzZVBhcnRzRm9yTm9ybWFsaXNlLnBhdGgpO1xuICAgICAgICByZXR1cm4gVVJMVG9vbGtpdC5idWlsZFVSTEZyb21QYXJ0cyhiYXNlUGFydHNGb3JOb3JtYWxpc2UpO1xuICAgICAgfVxuICAgICAgdmFyIHJlbGF0aXZlUGFydHMgPSBVUkxUb29sa2l0LnBhcnNlVVJMKHJlbGF0aXZlVVJMKTtcbiAgICAgIGlmICghcmVsYXRpdmVQYXJ0cykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Vycm9yIHRyeWluZyB0byBwYXJzZSByZWxhdGl2ZSBVUkwuJyk7XG4gICAgICB9XG4gICAgICBpZiAocmVsYXRpdmVQYXJ0cy5zY2hlbWUpIHtcbiAgICAgICAgLy8gMmIpIElmIHRoZSBlbWJlZGRlZCBVUkwgc3RhcnRzIHdpdGggYSBzY2hlbWUgbmFtZSwgaXQgaXNcbiAgICAgICAgLy8gaW50ZXJwcmV0ZWQgYXMgYW4gYWJzb2x1dGUgVVJMIGFuZCB3ZSBhcmUgZG9uZS5cbiAgICAgICAgaWYgKCFvcHRzLmFsd2F5c05vcm1hbGl6ZSkge1xuICAgICAgICAgIHJldHVybiByZWxhdGl2ZVVSTDtcbiAgICAgICAgfVxuICAgICAgICByZWxhdGl2ZVBhcnRzLnBhdGggPSBVUkxUb29sa2l0Lm5vcm1hbGl6ZVBhdGgocmVsYXRpdmVQYXJ0cy5wYXRoKTtcbiAgICAgICAgcmV0dXJuIFVSTFRvb2xraXQuYnVpbGRVUkxGcm9tUGFydHMocmVsYXRpdmVQYXJ0cyk7XG4gICAgICB9XG4gICAgICB2YXIgYmFzZVBhcnRzID0gVVJMVG9vbGtpdC5wYXJzZVVSTChiYXNlVVJMKTtcbiAgICAgIGlmICghYmFzZVBhcnRzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXJyb3IgdHJ5aW5nIHRvIHBhcnNlIGJhc2UgVVJMLicpO1xuICAgICAgfVxuICAgICAgaWYgKCFiYXNlUGFydHMubmV0TG9jICYmIGJhc2VQYXJ0cy5wYXRoICYmIGJhc2VQYXJ0cy5wYXRoWzBdICE9PSAnLycpIHtcbiAgICAgICAgLy8gSWYgbmV0TG9jIG1pc3NpbmcgYW5kIHBhdGggZG9lc24ndCBzdGFydCB3aXRoICcvJywgYXNzdW1lIGV2ZXJ0aGluZyBiZWZvcmUgdGhlIGZpcnN0ICcvJyBpcyB0aGUgbmV0TG9jXG4gICAgICAgIC8vIFRoaXMgY2F1c2VzICdleGFtcGxlLmNvbS9hJyB0byBiZSBoYW5kbGVkIGFzICcvL2V4YW1wbGUuY29tL2EnIGluc3RlYWQgb2YgJy9leGFtcGxlLmNvbS9hJ1xuICAgICAgICB2YXIgcGF0aFBhcnRzID0gRklSU1RfU0VHTUVOVF9SRUdFWC5leGVjKGJhc2VQYXJ0cy5wYXRoKTtcbiAgICAgICAgYmFzZVBhcnRzLm5ldExvYyA9IHBhdGhQYXJ0c1sxXTtcbiAgICAgICAgYmFzZVBhcnRzLnBhdGggPSBwYXRoUGFydHNbMl07XG4gICAgICB9XG4gICAgICBpZiAoYmFzZVBhcnRzLm5ldExvYyAmJiAhYmFzZVBhcnRzLnBhdGgpIHtcbiAgICAgICAgYmFzZVBhcnRzLnBhdGggPSAnLyc7XG4gICAgICB9XG4gICAgICB2YXIgYnVpbHRQYXJ0cyA9IHtcbiAgICAgICAgLy8gMmMpIE90aGVyd2lzZSwgdGhlIGVtYmVkZGVkIFVSTCBpbmhlcml0cyB0aGUgc2NoZW1lIG9mXG4gICAgICAgIC8vIHRoZSBiYXNlIFVSTC5cbiAgICAgICAgc2NoZW1lOiBiYXNlUGFydHMuc2NoZW1lLFxuICAgICAgICBuZXRMb2M6IHJlbGF0aXZlUGFydHMubmV0TG9jLFxuICAgICAgICBwYXRoOiBudWxsLFxuICAgICAgICBwYXJhbXM6IHJlbGF0aXZlUGFydHMucGFyYW1zLFxuICAgICAgICBxdWVyeTogcmVsYXRpdmVQYXJ0cy5xdWVyeSxcbiAgICAgICAgZnJhZ21lbnQ6IHJlbGF0aXZlUGFydHMuZnJhZ21lbnRcbiAgICAgIH07XG4gICAgICBpZiAoIXJlbGF0aXZlUGFydHMubmV0TG9jKSB7XG4gICAgICAgIC8vIDMpIElmIHRoZSBlbWJlZGRlZCBVUkwncyA8bmV0X2xvYz4gaXMgbm9uLWVtcHR5LCB3ZSBza2lwIHRvXG4gICAgICAgIC8vIFN0ZXAgNy4gIE90aGVyd2lzZSwgdGhlIGVtYmVkZGVkIFVSTCBpbmhlcml0cyB0aGUgPG5ldF9sb2M+XG4gICAgICAgIC8vIChpZiBhbnkpIG9mIHRoZSBiYXNlIFVSTC5cbiAgICAgICAgYnVpbHRQYXJ0cy5uZXRMb2MgPSBiYXNlUGFydHMubmV0TG9jO1xuICAgICAgICAvLyA0KSBJZiB0aGUgZW1iZWRkZWQgVVJMIHBhdGggaXMgcHJlY2VkZWQgYnkgYSBzbGFzaCBcIi9cIiwgdGhlXG4gICAgICAgIC8vIHBhdGggaXMgbm90IHJlbGF0aXZlIGFuZCB3ZSBza2lwIHRvIFN0ZXAgNy5cbiAgICAgICAgaWYgKHJlbGF0aXZlUGFydHMucGF0aFswXSAhPT0gJy8nKSB7XG4gICAgICAgICAgaWYgKCFyZWxhdGl2ZVBhcnRzLnBhdGgpIHtcbiAgICAgICAgICAgIC8vIDUpIElmIHRoZSBlbWJlZGRlZCBVUkwgcGF0aCBpcyBlbXB0eSAoYW5kIG5vdCBwcmVjZWRlZCBieSBhXG4gICAgICAgICAgICAvLyBzbGFzaCksIHRoZW4gdGhlIGVtYmVkZGVkIFVSTCBpbmhlcml0cyB0aGUgYmFzZSBVUkwgcGF0aFxuICAgICAgICAgICAgYnVpbHRQYXJ0cy5wYXRoID0gYmFzZVBhcnRzLnBhdGg7XG4gICAgICAgICAgICAvLyA1YSkgaWYgdGhlIGVtYmVkZGVkIFVSTCdzIDxwYXJhbXM+IGlzIG5vbi1lbXB0eSwgd2Ugc2tpcCB0b1xuICAgICAgICAgICAgLy8gc3RlcCA3OyBvdGhlcndpc2UsIGl0IGluaGVyaXRzIHRoZSA8cGFyYW1zPiBvZiB0aGUgYmFzZVxuICAgICAgICAgICAgLy8gVVJMIChpZiBhbnkpIGFuZFxuICAgICAgICAgICAgaWYgKCFyZWxhdGl2ZVBhcnRzLnBhcmFtcykge1xuICAgICAgICAgICAgICBidWlsdFBhcnRzLnBhcmFtcyA9IGJhc2VQYXJ0cy5wYXJhbXM7XG4gICAgICAgICAgICAgIC8vIDViKSBpZiB0aGUgZW1iZWRkZWQgVVJMJ3MgPHF1ZXJ5PiBpcyBub24tZW1wdHksIHdlIHNraXAgdG9cbiAgICAgICAgICAgICAgLy8gc3RlcCA3OyBvdGhlcndpc2UsIGl0IGluaGVyaXRzIHRoZSA8cXVlcnk+IG9mIHRoZSBiYXNlXG4gICAgICAgICAgICAgIC8vIFVSTCAoaWYgYW55KSBhbmQgd2Ugc2tpcCB0byBzdGVwIDcuXG4gICAgICAgICAgICAgIGlmICghcmVsYXRpdmVQYXJ0cy5xdWVyeSkge1xuICAgICAgICAgICAgICAgIGJ1aWx0UGFydHMucXVlcnkgPSBiYXNlUGFydHMucXVlcnk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gNikgVGhlIGxhc3Qgc2VnbWVudCBvZiB0aGUgYmFzZSBVUkwncyBwYXRoIChhbnl0aGluZ1xuICAgICAgICAgICAgLy8gZm9sbG93aW5nIHRoZSByaWdodG1vc3Qgc2xhc2ggXCIvXCIsIG9yIHRoZSBlbnRpcmUgcGF0aCBpZiBub1xuICAgICAgICAgICAgLy8gc2xhc2ggaXMgcHJlc2VudCkgaXMgcmVtb3ZlZCBhbmQgdGhlIGVtYmVkZGVkIFVSTCdzIHBhdGggaXNcbiAgICAgICAgICAgIC8vIGFwcGVuZGVkIGluIGl0cyBwbGFjZS5cbiAgICAgICAgICAgIHZhciBiYXNlVVJMUGF0aCA9IGJhc2VQYXJ0cy5wYXRoO1xuICAgICAgICAgICAgdmFyIG5ld1BhdGggPSBiYXNlVVJMUGF0aC5zdWJzdHJpbmcoMCwgYmFzZVVSTFBhdGgubGFzdEluZGV4T2YoJy8nKSArIDEpICsgcmVsYXRpdmVQYXJ0cy5wYXRoO1xuICAgICAgICAgICAgYnVpbHRQYXJ0cy5wYXRoID0gVVJMVG9vbGtpdC5ub3JtYWxpemVQYXRoKG5ld1BhdGgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGJ1aWx0UGFydHMucGF0aCA9PT0gbnVsbCkge1xuICAgICAgICBidWlsdFBhcnRzLnBhdGggPSBvcHRzLmFsd2F5c05vcm1hbGl6ZSA/IFVSTFRvb2xraXQubm9ybWFsaXplUGF0aChyZWxhdGl2ZVBhcnRzLnBhdGgpIDogcmVsYXRpdmVQYXJ0cy5wYXRoO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFVSTFRvb2xraXQuYnVpbGRVUkxGcm9tUGFydHMoYnVpbHRQYXJ0cyk7XG4gICAgfSxcbiAgICBwYXJzZVVSTDogZnVuY3Rpb24odXJsKSB7XG4gICAgICB2YXIgcGFydHMgPSBVUkxfUkVHRVguZXhlYyh1cmwpO1xuICAgICAgaWYgKCFwYXJ0cykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHNjaGVtZTogcGFydHNbMV0gfHwgJycsXG4gICAgICAgIG5ldExvYzogcGFydHNbMl0gfHwgJycsXG4gICAgICAgIHBhdGg6IHBhcnRzWzNdIHx8ICcnLFxuICAgICAgICBwYXJhbXM6IHBhcnRzWzRdIHx8ICcnLFxuICAgICAgICBxdWVyeTogcGFydHNbNV0gfHwgJycsXG4gICAgICAgIGZyYWdtZW50OiBwYXJ0c1s2XSB8fCAnJ1xuICAgICAgfTtcbiAgICB9LFxuICAgIG5vcm1hbGl6ZVBhdGg6IGZ1bmN0aW9uKHBhdGgpIHtcbiAgICAgIC8vIFRoZSBmb2xsb3dpbmcgb3BlcmF0aW9ucyBhcmVcbiAgICAgIC8vIHRoZW4gYXBwbGllZCwgaW4gb3JkZXIsIHRvIHRoZSBuZXcgcGF0aDpcbiAgICAgIC8vIDZhKSBBbGwgb2NjdXJyZW5jZXMgb2YgXCIuL1wiLCB3aGVyZSBcIi5cIiBpcyBhIGNvbXBsZXRlIHBhdGhcbiAgICAgIC8vIHNlZ21lbnQsIGFyZSByZW1vdmVkLlxuICAgICAgLy8gNmIpIElmIHRoZSBwYXRoIGVuZHMgd2l0aCBcIi5cIiBhcyBhIGNvbXBsZXRlIHBhdGggc2VnbWVudCxcbiAgICAgIC8vIHRoYXQgXCIuXCIgaXMgcmVtb3ZlZC5cbiAgICAgIHBhdGggPSBwYXRoLnNwbGl0KCcnKS5yZXZlcnNlKCkuam9pbignJykucmVwbGFjZShTTEFTSF9ET1RfUkVHRVgsICcnKTtcbiAgICAgIC8vIDZjKSBBbGwgb2NjdXJyZW5jZXMgb2YgXCI8c2VnbWVudD4vLi4vXCIsIHdoZXJlIDxzZWdtZW50PiBpcyBhXG4gICAgICAvLyBjb21wbGV0ZSBwYXRoIHNlZ21lbnQgbm90IGVxdWFsIHRvIFwiLi5cIiwgYXJlIHJlbW92ZWQuXG4gICAgICAvLyBSZW1vdmFsIG9mIHRoZXNlIHBhdGggc2VnbWVudHMgaXMgcGVyZm9ybWVkIGl0ZXJhdGl2ZWx5LFxuICAgICAgLy8gcmVtb3ZpbmcgdGhlIGxlZnRtb3N0IG1hdGNoaW5nIHBhdHRlcm4gb24gZWFjaCBpdGVyYXRpb24sXG4gICAgICAvLyB1bnRpbCBubyBtYXRjaGluZyBwYXR0ZXJuIHJlbWFpbnMuXG4gICAgICAvLyA2ZCkgSWYgdGhlIHBhdGggZW5kcyB3aXRoIFwiPHNlZ21lbnQ+Ly4uXCIsIHdoZXJlIDxzZWdtZW50PiBpcyBhXG4gICAgICAvLyBjb21wbGV0ZSBwYXRoIHNlZ21lbnQgbm90IGVxdWFsIHRvIFwiLi5cIiwgdGhhdFxuICAgICAgLy8gXCI8c2VnbWVudD4vLi5cIiBpcyByZW1vdmVkLlxuICAgICAgd2hpbGUgKHBhdGgubGVuZ3RoICE9PSAocGF0aCA9IHBhdGgucmVwbGFjZShTTEFTSF9ET1RfRE9UX1JFR0VYLCAnJykpLmxlbmd0aCkge30gLy8ganNoaW50IGlnbm9yZTpsaW5lXG4gICAgICByZXR1cm4gcGF0aC5zcGxpdCgnJykucmV2ZXJzZSgpLmpvaW4oJycpO1xuICAgIH0sXG4gICAgYnVpbGRVUkxGcm9tUGFydHM6IGZ1bmN0aW9uKHBhcnRzKSB7XG4gICAgICByZXR1cm4gcGFydHMuc2NoZW1lICsgcGFydHMubmV0TG9jICsgcGFydHMucGF0aCArIHBhcnRzLnBhcmFtcyArIHBhcnRzLnF1ZXJ5ICsgcGFydHMuZnJhZ21lbnQ7XG4gICAgfVxuICB9O1xuXG4vKiBqc2hpbnQgaWdub3JlOnN0YXJ0ICovXG4gIGlmKHRydWUpXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBVUkxUb29sa2l0O1xuICBlbHNlIHt9XG59KSh0aGlzKTtcbi8qIGpzaGludCBpZ25vcmU6ZW5kICovXG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvd2Vid29ya2lmeS13ZWJwYWNrL2luZGV4LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy93ZWJ3b3JraWZ5LXdlYnBhY2svaW5kZXguanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbmZ1bmN0aW9uIHdlYnBhY2tCb290c3RyYXBGdW5jIChtb2R1bGVzKSB7XG4vKioqKioqLyAgLy8gVGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gIHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbi8qKioqKiovICAvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gIGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuLyoqKioqKi8gICAgLy8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyAgICBpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSlcbi8qKioqKiovICAgICAgcmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG5cbi8qKioqKiovICAgIC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyAgICB2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4vKioqKioqLyAgICAgIGk6IG1vZHVsZUlkLFxuLyoqKioqKi8gICAgICBsOiBmYWxzZSxcbi8qKioqKiovICAgICAgZXhwb3J0czoge31cbi8qKioqKiovICAgIH07XG5cbi8qKioqKiovICAgIC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuLyoqKioqKi8gICAgbW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbi8qKioqKiovICAgIC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbi8qKioqKiovICAgIG1vZHVsZS5sID0gdHJ1ZTtcblxuLyoqKioqKi8gICAgLy8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovICAgIHJldHVybiBtb2R1bGUuZXhwb3J0cztcbi8qKioqKiovICB9XG5cbi8qKioqKiovICAvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuLyoqKioqKi8gIF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbi8qKioqKiovICAvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gIF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbi8qKioqKiovICAvLyBpZGVudGl0eSBmdW5jdGlvbiBmb3IgY2FsbGluZyBoYXJtb255IGltcG9ydHMgd2l0aCB0aGUgY29ycmVjdCBjb250ZXh0XG4vKioqKioqLyAgX193ZWJwYWNrX3JlcXVpcmVfXy5pID0gZnVuY3Rpb24odmFsdWUpIHsgcmV0dXJuIHZhbHVlOyB9O1xuXG4vKioqKioqLyAgLy8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4vKioqKioqLyAgX193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4vKioqKioqLyAgICBpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4vKioqKioqLyAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7XG4vKioqKioqLyAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbi8qKioqKiovICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuLyoqKioqKi8gICAgICAgIGdldDogZ2V0dGVyXG4vKioqKioqLyAgICAgIH0pO1xuLyoqKioqKi8gICAgfVxuLyoqKioqKi8gIH07XG5cbi8qKioqKiovICAvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG4vKioqKioqLyAgX193ZWJwYWNrX3JlcXVpcmVfXy5yID0gZnVuY3Rpb24oZXhwb3J0cykge1xuLyoqKioqKi8gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKioqKiovICB9O1xuXG4vKioqKioqLyAgLy8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbi8qKioqKiovICBfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbi8qKioqKiovICAgIHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuLyoqKioqKi8gICAgICBmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuLyoqKioqKi8gICAgICBmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuLyoqKioqKi8gICAgX193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuLyoqKioqKi8gICAgcmV0dXJuIGdldHRlcjtcbi8qKioqKiovICB9O1xuXG4vKioqKioqLyAgLy8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4vKioqKioqLyAgX193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4vKioqKioqLyAgLy8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbi8qKioqKiovICBfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIi9cIjtcblxuLyoqKioqKi8gIC8vIG9uIGVycm9yIGZ1bmN0aW9uIGZvciBhc3luYyBsb2FkaW5nXG4vKioqKioqLyAgX193ZWJwYWNrX3JlcXVpcmVfXy5vZSA9IGZ1bmN0aW9uKGVycikgeyBjb25zb2xlLmVycm9yKGVycik7IHRocm93IGVycjsgfTtcblxuICB2YXIgZiA9IF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gRU5UUllfTU9EVUxFKVxuICByZXR1cm4gZi5kZWZhdWx0IHx8IGYgLy8gdHJ5IHRvIGNhbGwgZGVmYXVsdCBpZiBkZWZpbmVkIHRvIGFsc28gc3VwcG9ydCBiYWJlbCBlc21vZHVsZSBleHBvcnRzXG59XG5cbnZhciBtb2R1bGVOYW1lUmVxRXhwID0gJ1tcXFxcLnxcXFxcLXxcXFxcK3xcXFxcd3xcXC98QF0rJ1xudmFyIGRlcGVuZGVuY3lSZWdFeHAgPSAnXFxcXCgoXFwvXFxcXCouKj9cXFxcKlxcLyk/XFxzPy4qPygnICsgbW9kdWxlTmFtZVJlcUV4cCArICcpLio/XFxcXCknIC8vIGFkZGl0aW9uYWwgY2hhcnMgd2hlbiBvdXRwdXQucGF0aGluZm8gaXMgdHJ1ZVxuXG4vLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yNTkzNjYxLzEzMDQ0MlxuZnVuY3Rpb24gcXVvdGVSZWdFeHAgKHN0cikge1xuICByZXR1cm4gKHN0ciArICcnKS5yZXBsYWNlKC9bLj8qK14kW1xcXVxcXFwoKXt9fC1dL2csICdcXFxcJCYnKVxufVxuXG5mdW5jdGlvbiBpc051bWVyaWMobikge1xuICByZXR1cm4gIWlzTmFOKDEgKiBuKTsgLy8gMSAqIG4gY29udmVydHMgaW50ZWdlcnMsIGludGVnZXJzIGFzIHN0cmluZyAoXCIxMjNcIiksIDFlMyBhbmQgXCIxZTNcIiB0byBpbnRlZ2VycyBhbmQgc3RyaW5ncyB0byBOYU5cbn1cblxuZnVuY3Rpb24gZ2V0TW9kdWxlRGVwZW5kZW5jaWVzIChzb3VyY2VzLCBtb2R1bGUsIHF1ZXVlTmFtZSkge1xuICB2YXIgcmV0dmFsID0ge31cbiAgcmV0dmFsW3F1ZXVlTmFtZV0gPSBbXVxuXG4gIHZhciBmblN0cmluZyA9IG1vZHVsZS50b1N0cmluZygpXG4gIHZhciB3cmFwcGVyU2lnbmF0dXJlID0gZm5TdHJpbmcubWF0Y2goL15mdW5jdGlvblxccz9cXChcXHcrLFxccypcXHcrLFxccyooXFx3KylcXCkvKVxuICBpZiAoIXdyYXBwZXJTaWduYXR1cmUpIHJldHVybiByZXR2YWxcbiAgdmFyIHdlYnBhY2tSZXF1aXJlTmFtZSA9IHdyYXBwZXJTaWduYXR1cmVbMV1cblxuICAvLyBtYWluIGJ1bmRsZSBkZXBzXG4gIHZhciByZSA9IG5ldyBSZWdFeHAoJyhcXFxcXFxcXG58XFxcXFcpJyArIHF1b3RlUmVnRXhwKHdlYnBhY2tSZXF1aXJlTmFtZSkgKyBkZXBlbmRlbmN5UmVnRXhwLCAnZycpXG4gIHZhciBtYXRjaFxuICB3aGlsZSAoKG1hdGNoID0gcmUuZXhlYyhmblN0cmluZykpKSB7XG4gICAgaWYgKG1hdGNoWzNdID09PSAnZGxsLXJlZmVyZW5jZScpIGNvbnRpbnVlXG4gICAgcmV0dmFsW3F1ZXVlTmFtZV0ucHVzaChtYXRjaFszXSlcbiAgfVxuXG4gIC8vIGRsbCBkZXBzXG4gIHJlID0gbmV3IFJlZ0V4cCgnXFxcXCgnICsgcXVvdGVSZWdFeHAod2VicGFja1JlcXVpcmVOYW1lKSArICdcXFxcKFwiKGRsbC1yZWZlcmVuY2VcXFxccygnICsgbW9kdWxlTmFtZVJlcUV4cCArICcpKVwiXFxcXClcXFxcKScgKyBkZXBlbmRlbmN5UmVnRXhwLCAnZycpXG4gIHdoaWxlICgobWF0Y2ggPSByZS5leGVjKGZuU3RyaW5nKSkpIHtcbiAgICBpZiAoIXNvdXJjZXNbbWF0Y2hbMl1dKSB7XG4gICAgICByZXR2YWxbcXVldWVOYW1lXS5wdXNoKG1hdGNoWzFdKVxuICAgICAgc291cmNlc1ttYXRjaFsyXV0gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKG1hdGNoWzFdKS5tXG4gICAgfVxuICAgIHJldHZhbFttYXRjaFsyXV0gPSByZXR2YWxbbWF0Y2hbMl1dIHx8IFtdXG4gICAgcmV0dmFsW21hdGNoWzJdXS5wdXNoKG1hdGNoWzRdKVxuICB9XG5cbiAgLy8gY29udmVydCAxZTMgYmFjayB0byAxMDAwIC0gdGhpcyBjYW4gYmUgaW1wb3J0YW50IGFmdGVyIHVnbGlmeS1qcyBjb252ZXJ0ZWQgMTAwMCB0byAxZTNcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhyZXR2YWwpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IHJldHZhbFtrZXlzW2ldXS5sZW5ndGg7IGorKykge1xuICAgICAgaWYgKGlzTnVtZXJpYyhyZXR2YWxba2V5c1tpXV1bal0pKSB7XG4gICAgICAgIHJldHZhbFtrZXlzW2ldXVtqXSA9IDEgKiByZXR2YWxba2V5c1tpXV1bal07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJldHZhbFxufVxuXG5mdW5jdGlvbiBoYXNWYWx1ZXNJblF1ZXVlcyAocXVldWVzKSB7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMocXVldWVzKVxuICByZXR1cm4ga2V5cy5yZWR1Y2UoZnVuY3Rpb24gKGhhc1ZhbHVlcywga2V5KSB7XG4gICAgcmV0dXJuIGhhc1ZhbHVlcyB8fCBxdWV1ZXNba2V5XS5sZW5ndGggPiAwXG4gIH0sIGZhbHNlKVxufVxuXG5mdW5jdGlvbiBnZXRSZXF1aXJlZE1vZHVsZXMgKHNvdXJjZXMsIG1vZHVsZUlkKSB7XG4gIHZhciBtb2R1bGVzUXVldWUgPSB7XG4gICAgbWFpbjogW21vZHVsZUlkXVxuICB9XG4gIHZhciByZXF1aXJlZE1vZHVsZXMgPSB7XG4gICAgbWFpbjogW11cbiAgfVxuICB2YXIgc2Vlbk1vZHVsZXMgPSB7XG4gICAgbWFpbjoge31cbiAgfVxuXG4gIHdoaWxlIChoYXNWYWx1ZXNJblF1ZXVlcyhtb2R1bGVzUXVldWUpKSB7XG4gICAgdmFyIHF1ZXVlcyA9IE9iamVjdC5rZXlzKG1vZHVsZXNRdWV1ZSlcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHF1ZXVlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHF1ZXVlTmFtZSA9IHF1ZXVlc1tpXVxuICAgICAgdmFyIHF1ZXVlID0gbW9kdWxlc1F1ZXVlW3F1ZXVlTmFtZV1cbiAgICAgIHZhciBtb2R1bGVUb0NoZWNrID0gcXVldWUucG9wKClcbiAgICAgIHNlZW5Nb2R1bGVzW3F1ZXVlTmFtZV0gPSBzZWVuTW9kdWxlc1txdWV1ZU5hbWVdIHx8IHt9XG4gICAgICBpZiAoc2Vlbk1vZHVsZXNbcXVldWVOYW1lXVttb2R1bGVUb0NoZWNrXSB8fCAhc291cmNlc1txdWV1ZU5hbWVdW21vZHVsZVRvQ2hlY2tdKSBjb250aW51ZVxuICAgICAgc2Vlbk1vZHVsZXNbcXVldWVOYW1lXVttb2R1bGVUb0NoZWNrXSA9IHRydWVcbiAgICAgIHJlcXVpcmVkTW9kdWxlc1txdWV1ZU5hbWVdID0gcmVxdWlyZWRNb2R1bGVzW3F1ZXVlTmFtZV0gfHwgW11cbiAgICAgIHJlcXVpcmVkTW9kdWxlc1txdWV1ZU5hbWVdLnB1c2gobW9kdWxlVG9DaGVjaylcbiAgICAgIHZhciBuZXdNb2R1bGVzID0gZ2V0TW9kdWxlRGVwZW5kZW5jaWVzKHNvdXJjZXMsIHNvdXJjZXNbcXVldWVOYW1lXVttb2R1bGVUb0NoZWNrXSwgcXVldWVOYW1lKVxuICAgICAgdmFyIG5ld01vZHVsZXNLZXlzID0gT2JqZWN0LmtleXMobmV3TW9kdWxlcylcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbmV3TW9kdWxlc0tleXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgbW9kdWxlc1F1ZXVlW25ld01vZHVsZXNLZXlzW2pdXSA9IG1vZHVsZXNRdWV1ZVtuZXdNb2R1bGVzS2V5c1tqXV0gfHwgW11cbiAgICAgICAgbW9kdWxlc1F1ZXVlW25ld01vZHVsZXNLZXlzW2pdXSA9IG1vZHVsZXNRdWV1ZVtuZXdNb2R1bGVzS2V5c1tqXV0uY29uY2F0KG5ld01vZHVsZXNbbmV3TW9kdWxlc0tleXNbal1dKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXF1aXJlZE1vZHVsZXNcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobW9kdWxlSWQsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge31cbiAgdmFyIHNvdXJjZXMgPSB7XG4gICAgbWFpbjogX193ZWJwYWNrX3JlcXVpcmVfXy5tXG4gIH1cblxuICB2YXIgcmVxdWlyZWRNb2R1bGVzID0gb3B0aW9ucy5hbGwgPyB7IG1haW46IE9iamVjdC5rZXlzKHNvdXJjZXMubWFpbikgfSA6IGdldFJlcXVpcmVkTW9kdWxlcyhzb3VyY2VzLCBtb2R1bGVJZClcblxuICB2YXIgc3JjID0gJydcblxuICBPYmplY3Qua2V5cyhyZXF1aXJlZE1vZHVsZXMpLmZpbHRlcihmdW5jdGlvbiAobSkgeyByZXR1cm4gbSAhPT0gJ21haW4nIH0pLmZvckVhY2goZnVuY3Rpb24gKG1vZHVsZSkge1xuICAgIHZhciBlbnRyeU1vZHVsZSA9IDBcbiAgICB3aGlsZSAocmVxdWlyZWRNb2R1bGVzW21vZHVsZV1bZW50cnlNb2R1bGVdKSB7XG4gICAgICBlbnRyeU1vZHVsZSsrXG4gICAgfVxuICAgIHJlcXVpcmVkTW9kdWxlc1ttb2R1bGVdLnB1c2goZW50cnlNb2R1bGUpXG4gICAgc291cmNlc1ttb2R1bGVdW2VudHJ5TW9kdWxlXSA9ICcoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7IG1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXzsgfSknXG4gICAgc3JjID0gc3JjICsgJ3ZhciAnICsgbW9kdWxlICsgJyA9ICgnICsgd2VicGFja0Jvb3RzdHJhcEZ1bmMudG9TdHJpbmcoKS5yZXBsYWNlKCdFTlRSWV9NT0RVTEUnLCBKU09OLnN0cmluZ2lmeShlbnRyeU1vZHVsZSkpICsgJykoeycgKyByZXF1aXJlZE1vZHVsZXNbbW9kdWxlXS5tYXAoZnVuY3Rpb24gKGlkKSB7IHJldHVybiAnJyArIEpTT04uc3RyaW5naWZ5KGlkKSArICc6ICcgKyBzb3VyY2VzW21vZHVsZV1baWRdLnRvU3RyaW5nKCkgfSkuam9pbignLCcpICsgJ30pO1xcbidcbiAgfSlcblxuICBzcmMgPSBzcmMgKyAnbmV3ICgoJyArIHdlYnBhY2tCb290c3RyYXBGdW5jLnRvU3RyaW5nKCkucmVwbGFjZSgnRU5UUllfTU9EVUxFJywgSlNPTi5zdHJpbmdpZnkobW9kdWxlSWQpKSArICcpKHsnICsgcmVxdWlyZWRNb2R1bGVzLm1haW4ubWFwKGZ1bmN0aW9uIChpZCkgeyByZXR1cm4gJycgKyBKU09OLnN0cmluZ2lmeShpZCkgKyAnOiAnICsgc291cmNlcy5tYWluW2lkXS50b1N0cmluZygpIH0pLmpvaW4oJywnKSArICd9KSkoc2VsZik7J1xuXG4gIHZhciBibG9iID0gbmV3IHdpbmRvdy5CbG9iKFtzcmNdLCB7IHR5cGU6ICd0ZXh0L2phdmFzY3JpcHQnIH0pXG4gIGlmIChvcHRpb25zLmJhcmUpIHsgcmV0dXJuIGJsb2IgfVxuXG4gIHZhciBVUkwgPSB3aW5kb3cuVVJMIHx8IHdpbmRvdy53ZWJraXRVUkwgfHwgd2luZG93Lm1velVSTCB8fCB3aW5kb3cubXNVUkxcblxuICB2YXIgd29ya2VyVXJsID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKVxuICB2YXIgd29ya2VyID0gbmV3IHdpbmRvdy5Xb3JrZXIod29ya2VyVXJsKVxuICB3b3JrZXIub2JqZWN0VVJMID0gd29ya2VyVXJsXG5cbiAgcmV0dXJuIHdvcmtlclxufVxuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2NvbmZpZy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvY29uZmlnLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyoqXG4gKiBITFMgY29uZmlnXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBhYnJfY29udHJvbGxlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9jb250cm9sbGVyL2Fici1jb250cm9sbGVyICovIFwiLi9zcmMvY29udHJvbGxlci9hYnItY29udHJvbGxlci5qc1wiKTtcbnZhciBidWZmZXJfY29udHJvbGxlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9jb250cm9sbGVyL2J1ZmZlci1jb250cm9sbGVyICovIFwiLi9zcmMvY29udHJvbGxlci9idWZmZXItY29udHJvbGxlci5qc1wiKTtcbnZhciBjYXBfbGV2ZWxfY29udHJvbGxlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9jb250cm9sbGVyL2NhcC1sZXZlbC1jb250cm9sbGVyICovIFwiLi9zcmMvY29udHJvbGxlci9jYXAtbGV2ZWwtY29udHJvbGxlci5qc1wiKTtcbnZhciBmcHNfY29udHJvbGxlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9jb250cm9sbGVyL2Zwcy1jb250cm9sbGVyICovIFwiLi9zcmMvY29udHJvbGxlci9mcHMtY29udHJvbGxlci5qc1wiKTtcbnZhciB4aHJfbG9hZGVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3V0aWxzL3hoci1sb2FkZXIgKi8gXCIuL3NyYy91dGlscy94aHItbG9hZGVyLmpzXCIpO1xuLy8gaW1wb3J0IEZldGNoTG9hZGVyIGZyb20gJy4vdXRpbHMvZmV0Y2gtbG9hZGVyJztcbnZhciBhdWRpb190cmFja19jb250cm9sbGVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2NvbnRyb2xsZXIvYXVkaW8tdHJhY2stY29udHJvbGxlciAqLyBcIi4vc3JjL2NvbnRyb2xsZXIvYXVkaW8tdHJhY2stY29udHJvbGxlci5qc1wiKTtcbnZhciBhdWRpb19zdHJlYW1fY29udHJvbGxlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9jb250cm9sbGVyL2F1ZGlvLXN0cmVhbS1jb250cm9sbGVyICovIFwiLi9zcmMvY29udHJvbGxlci9hdWRpby1zdHJlYW0tY29udHJvbGxlci5qc1wiKTtcbnZhciBDdWVzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi91dGlscy9jdWVzICovIFwiLi9zcmMvdXRpbHMvY3Vlcy5qc1wiKTtcbnZhciB0aW1lbGluZV9jb250cm9sbGVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2NvbnRyb2xsZXIvdGltZWxpbmUtY29udHJvbGxlciAqLyBcIi4vc3JjL2NvbnRyb2xsZXIvdGltZWxpbmUtY29udHJvbGxlci5qc1wiKTtcbnZhciBzdWJ0aXRsZV90cmFja19jb250cm9sbGVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2NvbnRyb2xsZXIvc3VidGl0bGUtdHJhY2stY29udHJvbGxlciAqLyBcIi4vc3JjL2NvbnRyb2xsZXIvc3VidGl0bGUtdHJhY2stY29udHJvbGxlci5qc1wiKTtcbnZhciBzdWJ0aXRsZV9zdHJlYW1fY29udHJvbGxlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9jb250cm9sbGVyL3N1YnRpdGxlLXN0cmVhbS1jb250cm9sbGVyICovIFwiLi9zcmMvY29udHJvbGxlci9zdWJ0aXRsZS1zdHJlYW0tY29udHJvbGxlci5qc1wiKTtcbnZhciBlbWVfY29udHJvbGxlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9jb250cm9sbGVyL2VtZS1jb250cm9sbGVyICovIFwiLi9zcmMvY29udHJvbGxlci9lbWUtY29udHJvbGxlci5qc1wiKTtcbnZhciBtZWRpYWtleXNfaGVscGVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3V0aWxzL21lZGlha2V5cy1oZWxwZXIgKi8gXCIuL3NyYy91dGlscy9tZWRpYWtleXMtaGVscGVyLmpzXCIpO1xuZXhwb3J0cy5obHNEZWZhdWx0Q29uZmlnID0ge1xuICAgIGF1dG9TdGFydExvYWQ6IHRydWUsXG4gICAgc3RhcnRQb3NpdGlvbjogLTEsXG4gICAgZGVmYXVsdEF1ZGlvQ29kZWM6IHVuZGVmaW5lZCxcbiAgICBkZWJ1ZzogZmFsc2UsXG4gICAgY2FwTGV2ZWxPbkZQU0Ryb3A6IGZhbHNlLFxuICAgIGNhcExldmVsVG9QbGF5ZXJTaXplOiBmYWxzZSxcbiAgICBpbml0aWFsTGl2ZU1hbmlmZXN0U2l6ZTogMSxcbiAgICBtYXhCdWZmZXJMZW5ndGg6IDMwLFxuICAgIG1heEJ1ZmZlclNpemU6IDYwICogMTAwMCAqIDEwMDAsXG4gICAgbWF4QnVmZmVySG9sZTogMC41LFxuICAgIGxvd0J1ZmZlcldhdGNoZG9nUGVyaW9kOiAwLjUsXG4gICAgaGlnaEJ1ZmZlcldhdGNoZG9nUGVyaW9kOiAzLFxuICAgIG51ZGdlT2Zmc2V0OiAwLjEsXG4gICAgbnVkZ2VNYXhSZXRyeTogMyxcbiAgICBtYXhGcmFnTG9va1VwVG9sZXJhbmNlOiAwLjI1LFxuICAgIGxpdmVTeW5jRHVyYXRpb25Db3VudDogMyxcbiAgICBsaXZlTWF4TGF0ZW5jeUR1cmF0aW9uQ291bnQ6IEluZmluaXR5LFxuICAgIGxpdmVTeW5jRHVyYXRpb246IHVuZGVmaW5lZCxcbiAgICBsaXZlTWF4TGF0ZW5jeUR1cmF0aW9uOiB1bmRlZmluZWQsXG4gICAgbGl2ZUR1cmF0aW9uSW5maW5pdHk6IGZhbHNlLFxuICAgIGxpdmVCYWNrQnVmZmVyTGVuZ3RoOiBJbmZpbml0eSxcbiAgICBtYXhNYXhCdWZmZXJMZW5ndGg6IDYwMCxcbiAgICBlbmFibGVXb3JrZXI6IHRydWUsXG4gICAgZW5hYmxlU29mdHdhcmVBRVM6IHRydWUsXG4gICAgbWFuaWZlc3RMb2FkaW5nVGltZU91dDogMTAwMDAsXG4gICAgbWFuaWZlc3RMb2FkaW5nTWF4UmV0cnk6IDEsXG4gICAgbWFuaWZlc3RMb2FkaW5nUmV0cnlEZWxheTogMTAwMCxcbiAgICBtYW5pZmVzdExvYWRpbmdNYXhSZXRyeVRpbWVvdXQ6IDY0MDAwLFxuICAgIHN0YXJ0TGV2ZWw6IHVuZGVmaW5lZCxcbiAgICBsZXZlbExvYWRpbmdUaW1lT3V0OiAxMDAwMCxcbiAgICBsZXZlbExvYWRpbmdNYXhSZXRyeTogNCxcbiAgICBsZXZlbExvYWRpbmdSZXRyeURlbGF5OiAxMDAwLFxuICAgIGxldmVsTG9hZGluZ01heFJldHJ5VGltZW91dDogNjQwMDAsXG4gICAgZnJhZ0xvYWRpbmdUaW1lT3V0OiAyMDAwMCxcbiAgICBmcmFnTG9hZGluZ01heFJldHJ5OiA2LFxuICAgIGZyYWdMb2FkaW5nUmV0cnlEZWxheTogMTAwMCxcbiAgICBmcmFnTG9hZGluZ01heFJldHJ5VGltZW91dDogNjQwMDAsXG4gICAgc3RhcnRGcmFnUHJlZmV0Y2g6IGZhbHNlLFxuICAgIGZwc0Ryb3BwZWRNb25pdG9yaW5nUGVyaW9kOiA1MDAwLFxuICAgIGZwc0Ryb3BwZWRNb25pdG9yaW5nVGhyZXNob2xkOiAwLjIsXG4gICAgYXBwZW5kRXJyb3JNYXhSZXRyeTogMyxcbiAgICBsb2FkZXI6IHhocl9sb2FkZXJfMS5kZWZhdWx0LFxuICAgIC8vIGxvYWRlcjogRmV0Y2hMb2FkZXIsXG4gICAgZkxvYWRlcjogdW5kZWZpbmVkLFxuICAgIHBMb2FkZXI6IHVuZGVmaW5lZCxcbiAgICB4aHJTZXR1cDogdW5kZWZpbmVkLFxuICAgIGxpY2Vuc2VYaHJTZXR1cDogdW5kZWZpbmVkLFxuICAgIC8vIGZldGNoU2V0dXA6IHVuZGVmaW5lZCxcbiAgICBhYnJDb250cm9sbGVyOiBhYnJfY29udHJvbGxlcl8xLmRlZmF1bHQsXG4gICAgYnVmZmVyQ29udHJvbGxlcjogYnVmZmVyX2NvbnRyb2xsZXJfMS5kZWZhdWx0LFxuICAgIGNhcExldmVsQ29udHJvbGxlcjogY2FwX2xldmVsX2NvbnRyb2xsZXJfMS5kZWZhdWx0LFxuICAgIGZwc0NvbnRyb2xsZXI6IGZwc19jb250cm9sbGVyXzEuZGVmYXVsdCxcbiAgICBzdHJldGNoU2hvcnRWaWRlb1RyYWNrOiBmYWxzZSxcbiAgICBtYXhBdWRpb0ZyYW1lc0RyaWZ0OiAxLFxuICAgIGZvcmNlS2V5RnJhbWVPbkRpc2NvbnRpbnVpdHk6IHRydWUsXG4gICAgYWJyRXdtYUZhc3RMaXZlOiAzLFxuICAgIGFickV3bWFTbG93TGl2ZTogOSxcbiAgICBhYnJFd21hRmFzdFZvRDogMyxcbiAgICBhYnJFd21hU2xvd1ZvRDogOSxcbiAgICBhYnJFd21hRGVmYXVsdEVzdGltYXRlOiA1ZTUsXG4gICAgYWJyQmFuZFdpZHRoRmFjdG9yOiAwLjk1LFxuICAgIGFickJhbmRXaWR0aFVwRmFjdG9yOiAwLjcsXG4gICAgYWJyTWF4V2l0aFJlYWxCaXRyYXRlOiBmYWxzZSxcbiAgICBtYXhTdGFydmF0aW9uRGVsYXk6IDQsXG4gICAgbWF4TG9hZGluZ0RlbGF5OiA0LFxuICAgIG1pbkF1dG9CaXRyYXRlOiAwLFxuICAgIGVtZUVuYWJsZWQ6IGZhbHNlLFxuICAgIHdpZGV2aW5lTGljZW5zZVVybDogdW5kZWZpbmVkLFxuICAgIHJlcXVlc3RNZWRpYUtleVN5c3RlbUFjY2Vzc0Z1bmM6IG1lZGlha2V5c19oZWxwZXJfMS5yZXF1ZXN0TWVkaWFLZXlTeXN0ZW1BY2Nlc3MgLy8gdXNlZCBieSBlbWUtY29udHJvbGxlclxufTtcbmlmICh0cnVlKSB7XG4gICAgZXhwb3J0cy5obHNEZWZhdWx0Q29uZmlnLnN1YnRpdGxlU3RyZWFtQ29udHJvbGxlciA9IHN1YnRpdGxlX3N0cmVhbV9jb250cm9sbGVyXzEuU3VidGl0bGVTdHJlYW1Db250cm9sbGVyO1xuICAgIGV4cG9ydHMuaGxzRGVmYXVsdENvbmZpZy5zdWJ0aXRsZVRyYWNrQ29udHJvbGxlciA9IHN1YnRpdGxlX3RyYWNrX2NvbnRyb2xsZXJfMS5kZWZhdWx0O1xuICAgIGV4cG9ydHMuaGxzRGVmYXVsdENvbmZpZy50aW1lbGluZUNvbnRyb2xsZXIgPSB0aW1lbGluZV9jb250cm9sbGVyXzEuZGVmYXVsdDtcbiAgICBleHBvcnRzLmhsc0RlZmF1bHRDb25maWcuY3VlSGFuZGxlciA9IEN1ZXM7IC8vIHVzZWQgYnkgdGltZWxpbmUtY29udHJvbGxlclxuICAgIGV4cG9ydHMuaGxzRGVmYXVsdENvbmZpZy5lbmFibGVDRUE3MDhDYXB0aW9ucyA9IHRydWU7IC8vIHVzZWQgYnkgdGltZWxpbmUtY29udHJvbGxlclxuICAgIGV4cG9ydHMuaGxzRGVmYXVsdENvbmZpZy5lbmFibGVXZWJWVFQgPSB0cnVlOyAvLyB1c2VkIGJ5IHRpbWVsaW5lLWNvbnRyb2xsZXJcbiAgICBleHBvcnRzLmhsc0RlZmF1bHRDb25maWcuY2FwdGlvbnNUZXh0VHJhY2sxTGFiZWwgPSAnRW5nbGlzaCc7IC8vIHVzZWQgYnkgdGltZWxpbmUtY29udHJvbGxlclxuICAgIGV4cG9ydHMuaGxzRGVmYXVsdENvbmZpZy5jYXB0aW9uc1RleHRUcmFjazFMYW5ndWFnZUNvZGUgPSAnZW4nOyAvLyB1c2VkIGJ5IHRpbWVsaW5lLWNvbnRyb2xsZXJcbiAgICBleHBvcnRzLmhsc0RlZmF1bHRDb25maWcuY2FwdGlvbnNUZXh0VHJhY2syTGFiZWwgPSAnU3BhbmlzaCc7IC8vIHVzZWQgYnkgdGltZWxpbmUtY29udHJvbGxlclxuICAgIGV4cG9ydHMuaGxzRGVmYXVsdENvbmZpZy5jYXB0aW9uc1RleHRUcmFjazJMYW5ndWFnZUNvZGUgPSAnZXMnOyAvLyB1c2VkIGJ5IHRpbWVsaW5lLWNvbnRyb2xsZXJcbn1cbmlmICh0cnVlKSB7XG4gICAgZXhwb3J0cy5obHNEZWZhdWx0Q29uZmlnLmF1ZGlvU3RyZWFtQ29udHJvbGxlciA9IGF1ZGlvX3N0cmVhbV9jb250cm9sbGVyXzEuZGVmYXVsdDtcbiAgICBleHBvcnRzLmhsc0RlZmF1bHRDb25maWcuYXVkaW9UcmFja0NvbnRyb2xsZXIgPSBhdWRpb190cmFja19jb250cm9sbGVyXzEuZGVmYXVsdDtcbn1cbmlmICh0cnVlKSB7XG4gICAgZXhwb3J0cy5obHNEZWZhdWx0Q29uZmlnLmVtZUNvbnRyb2xsZXIgPSBlbWVfY29udHJvbGxlcl8xLmRlZmF1bHQ7XG59XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvY29udHJvbGxlci9hYnItY29udHJvbGxlci5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2NvbnRyb2xsZXIvYWJyLWNvbnRyb2xsZXIuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihOdW1iZXIpIHtcbi8qXG4gKiBzaW1wbGUgQUJSIENvbnRyb2xsZXJcbiAqICAtIGNvbXB1dGUgbmV4dCBsZXZlbCBiYXNlZCBvbiBsYXN0IGZyYWdtZW50IGJ3IGhldXJpc3RpY3NcbiAqICAtIGltcGxlbWVudCBhbiBhYmFuZG9uIHJ1bGVzIHRyaWdnZXJlZCBpZiB3ZSBoYXZlIGxlc3MgdGhhbiAyIGZyYWcgYnVmZmVyZWQgYW5kIGlmIGNvbXB1dGVkIGJ3IHNob3dzIHRoYXQgd2UgcmlzayBidWZmZXIgc3RhbGxpbmdcbiAqL1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZXZlbnRzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9ldmVudHMgKi8gXCIuL3NyYy9ldmVudHMuanNcIik7XG52YXIgZXZlbnRfaGFuZGxlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZXZlbnQtaGFuZGxlciAqLyBcIi4vc3JjL2V2ZW50LWhhbmRsZXIuanNcIik7XG52YXIgYnVmZmVyX2hlbHBlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvYnVmZmVyLWhlbHBlciAqLyBcIi4vc3JjL3V0aWxzL2J1ZmZlci1oZWxwZXIuanNcIik7XG52YXIgZXJyb3JzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9lcnJvcnMgKi8gXCIuL3NyYy9lcnJvcnMuanNcIik7XG52YXIgbG9nZ2VyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy9sb2dnZXIgKi8gXCIuL3NyYy91dGlscy9sb2dnZXIuanNcIik7XG52YXIgZXdtYV9iYW5kd2lkdGhfZXN0aW1hdG9yXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy9ld21hLWJhbmR3aWR0aC1lc3RpbWF0b3IgKi8gXCIuL3NyYy91dGlscy9ld21hLWJhbmR3aWR0aC1lc3RpbWF0b3IuanNcIik7XG52YXIgcGVyZm9ybWFuY2UgPSB3aW5kb3cucGVyZm9ybWFuY2U7XG52YXIgQWJyQ29udHJvbGxlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQWJyQ29udHJvbGxlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBYnJDb250cm9sbGVyKGhscykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBobHMsIGV2ZW50c18xLmRlZmF1bHQuRlJBR19MT0FESU5HLCBldmVudHNfMS5kZWZhdWx0LkZSQUdfTE9BREVELCBldmVudHNfMS5kZWZhdWx0LkZSQUdfQlVGRkVSRUQsIGV2ZW50c18xLmRlZmF1bHQuRVJST1IpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmxhc3RMb2FkZWRGcmFnTGV2ZWwgPSAwO1xuICAgICAgICBfdGhpcy5fbmV4dEF1dG9MZXZlbCA9IC0xO1xuICAgICAgICBfdGhpcy5obHMgPSBobHM7XG4gICAgICAgIF90aGlzLnRpbWVyID0gbnVsbDtcbiAgICAgICAgX3RoaXMuX2J3RXN0aW1hdG9yID0gbnVsbDtcbiAgICAgICAgX3RoaXMub25DaGVjayA9IF90aGlzLl9hYmFuZG9uUnVsZXNDaGVjay5iaW5kKF90aGlzKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBBYnJDb250cm9sbGVyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmNsZWFyVGltZXIoKTtcbiAgICAgICAgZXZlbnRfaGFuZGxlcl8xLmRlZmF1bHQucHJvdG90eXBlLmRlc3Ryb3kuY2FsbCh0aGlzKTtcbiAgICB9O1xuICAgIEFickNvbnRyb2xsZXIucHJvdG90eXBlLm9uRnJhZ0xvYWRpbmcgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB2YXIgZnJhZyA9IGRhdGEuZnJhZztcbiAgICAgICAgaWYgKGZyYWcudHlwZSA9PT0gJ21haW4nKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMudGltZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZyYWdDdXJyZW50ID0gZnJhZztcbiAgICAgICAgICAgICAgICB0aGlzLnRpbWVyID0gc2V0SW50ZXJ2YWwodGhpcy5vbkNoZWNrLCAxMDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gbGF6eSBpbml0IG9mIEJ3RXN0aW1hdG9yLCByYXRpb25hbGUgaXMgdGhhdCB3ZSB1c2UgZGlmZmVyZW50IHBhcmFtcyBmb3IgTGl2ZS9Wb0RcbiAgICAgICAgICAgIC8vIHNvIHdlIG5lZWQgdG8gd2FpdCBmb3Igc3RyZWFtIG1hbmlmZXN0IC8gcGxheWxpc3QgdHlwZSB0byBpbnN0YW50aWF0ZSBpdC5cbiAgICAgICAgICAgIGlmICghdGhpcy5fYndFc3RpbWF0b3IpIHtcbiAgICAgICAgICAgICAgICB2YXIgaGxzXzEgPSB0aGlzLmhscztcbiAgICAgICAgICAgICAgICB2YXIgY29uZmlnID0gaGxzXzEuY29uZmlnO1xuICAgICAgICAgICAgICAgIHZhciBsZXZlbCA9IGZyYWcubGV2ZWw7XG4gICAgICAgICAgICAgICAgdmFyIGlzTGl2ZSA9IGhsc18xLmxldmVsc1tsZXZlbF0uZGV0YWlscy5saXZlO1xuICAgICAgICAgICAgICAgIHZhciBld21hRmFzdCA9IHZvaWQgMCwgZXdtYVNsb3cgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgaWYgKGlzTGl2ZSkge1xuICAgICAgICAgICAgICAgICAgICBld21hRmFzdCA9IGNvbmZpZy5hYnJFd21hRmFzdExpdmU7XG4gICAgICAgICAgICAgICAgICAgIGV3bWFTbG93ID0gY29uZmlnLmFickV3bWFTbG93TGl2ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGV3bWFGYXN0ID0gY29uZmlnLmFickV3bWFGYXN0Vm9EO1xuICAgICAgICAgICAgICAgICAgICBld21hU2xvdyA9IGNvbmZpZy5hYnJFd21hU2xvd1ZvRDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fYndFc3RpbWF0b3IgPSBuZXcgZXdtYV9iYW5kd2lkdGhfZXN0aW1hdG9yXzEuZGVmYXVsdChobHNfMSwgZXdtYVNsb3csIGV3bWFGYXN0LCBjb25maWcuYWJyRXdtYURlZmF1bHRFc3RpbWF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEFickNvbnRyb2xsZXIucHJvdG90eXBlLl9hYmFuZG9uUnVsZXNDaGVjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLypcbiAgICAgICAgICBtb25pdG9yIGZyYWdtZW50IHJldHJpZXZhbCB0aW1lLi4uXG4gICAgICAgICAgd2UgY29tcHV0ZSBleHBlY3RlZCB0aW1lIG9mIGFycml2YWwgb2YgdGhlIGNvbXBsZXRlIGZyYWdtZW50LlxuICAgICAgICAgIHdlIGNvbXBhcmUgaXQgdG8gZXhwZWN0ZWQgdGltZSBvZiBidWZmZXIgc3RhcnZhdGlvblxuICAgICAgICAqL1xuICAgICAgICB2YXIgaGxzID0gdGhpcy5obHM7XG4gICAgICAgIHZhciB2aWRlbyA9IGhscy5tZWRpYTtcbiAgICAgICAgdmFyIGZyYWcgPSB0aGlzLmZyYWdDdXJyZW50O1xuICAgICAgICBpZiAoIWZyYWcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbG9hZGVyID0gZnJhZy5sb2FkZXI7XG4gICAgICAgIHZhciBtaW5BdXRvTGV2ZWwgPSBobHMubWluQXV0b0xldmVsO1xuICAgICAgICAvLyBpZiBsb2FkZXIgaGFzIGJlZW4gZGVzdHJveWVkIG9yIGxvYWRpbmcgaGFzIGJlZW4gYWJvcnRlZCwgc3RvcCB0aW1lciBhbmQgcmV0dXJuXG4gICAgICAgIGlmICghbG9hZGVyIHx8IChsb2FkZXIuc3RhdHMgJiYgbG9hZGVyLnN0YXRzLmFib3J0ZWQpKSB7XG4gICAgICAgICAgICBsb2dnZXJfMS5sb2dnZXIud2FybignZnJhZyBsb2FkZXIgZGVzdHJveSBvciBhYm9ydGVkLCBkaXNhcm0gYWJhbmRvblJ1bGVzJyk7XG4gICAgICAgICAgICB0aGlzLmNsZWFyVGltZXIoKTtcbiAgICAgICAgICAgIC8vIHJlc2V0IGZvcmNlZCBhdXRvIGxldmVsIHZhbHVlIHNvIHRoYXQgbmV4dCBsZXZlbCB3aWxsIGJlIHNlbGVjdGVkXG4gICAgICAgICAgICB0aGlzLl9uZXh0QXV0b0xldmVsID0gLTE7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN0YXRzID0gbG9hZGVyLnN0YXRzO1xuICAgICAgICAvKiBvbmx5IG1vbml0b3IgZnJhZyByZXRyaWV2YWwgdGltZSBpZlxuICAgICAgICAodmlkZW8gbm90IHBhdXNlZCBPUiBmaXJzdCBmcmFnbWVudCBiZWluZyBsb2FkZWQocmVhZHkgc3RhdGUgPT09IEhBVkVfTk9USElORyA9IDApKSBBTkQgYXV0b3N3aXRjaGluZyBlbmFibGVkIEFORCBub3QgbG93ZXN0IGxldmVsICg9PiBtZWFucyB0aGF0IHdlIGhhdmUgc2V2ZXJhbCBsZXZlbHMpICovXG4gICAgICAgIGlmICh2aWRlbyAmJiBzdGF0cyAmJiAoKCF2aWRlby5wYXVzZWQgJiYgKHZpZGVvLnBsYXliYWNrUmF0ZSAhPT0gMCkpIHx8ICF2aWRlby5yZWFkeVN0YXRlKSAmJiBmcmFnLmF1dG9MZXZlbCAmJiBmcmFnLmxldmVsKSB7XG4gICAgICAgICAgICB2YXIgcmVxdWVzdERlbGF5ID0gcGVyZm9ybWFuY2Uubm93KCkgLSBzdGF0cy50cmVxdWVzdCwgcGxheWJhY2tSYXRlID0gTWF0aC5hYnModmlkZW8ucGxheWJhY2tSYXRlKTtcbiAgICAgICAgICAgIC8vIG1vbml0b3IgZnJhZ21lbnQgbG9hZCBwcm9ncmVzcyBhZnRlciBoYWxmIG9mIGV4cGVjdGVkIGZyYWdtZW50IGR1cmF0aW9uLHRvIHN0YWJpbGl6ZSBiaXRyYXRlXG4gICAgICAgICAgICBpZiAocmVxdWVzdERlbGF5ID4gKDUwMCAqIGZyYWcuZHVyYXRpb24gLyBwbGF5YmFja1JhdGUpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxldmVscyA9IGhscy5sZXZlbHMsIGxvYWRSYXRlID0gTWF0aC5tYXgoMSwgc3RhdHMuYncgPyBzdGF0cy5idyAvIDggOiBzdGF0cy5sb2FkZWQgKiAxMDAwIC8gcmVxdWVzdERlbGF5KSwgLy8gYnl0ZS9zOyBhdCBsZWFzdCAxIGJ5dGUvcyB0byBhdm9pZCBkaXZpc2lvbiBieSB6ZXJvXG4gICAgICAgICAgICAgICAgLy8gY29tcHV0ZSBleHBlY3RlZCBmcmFnbWVudCBsZW5ndGggdXNpbmcgZnJhZyBkdXJhdGlvbiBhbmQgbGV2ZWwgYml0cmF0ZS4gYWxzbyBlbnN1cmUgdGhhdCBleHBlY3RlZCBsZW4gaXMgZ3RlIHRoYW4gYWxyZWFkeSBsb2FkZWQgc2l6ZVxuICAgICAgICAgICAgICAgIGxldmVsID0gbGV2ZWxzW2ZyYWcubGV2ZWxdLCBsZXZlbEJpdHJhdGUgPSBsZXZlbC5yZWFsQml0cmF0ZSA/IE1hdGgubWF4KGxldmVsLnJlYWxCaXRyYXRlLCBsZXZlbC5iaXRyYXRlKSA6IGxldmVsLmJpdHJhdGUsIGV4cGVjdGVkTGVuID0gc3RhdHMudG90YWwgPyBzdGF0cy50b3RhbCA6IE1hdGgubWF4KHN0YXRzLmxvYWRlZCwgTWF0aC5yb3VuZChmcmFnLmR1cmF0aW9uICogbGV2ZWxCaXRyYXRlIC8gOCkpLCBwb3MgPSB2aWRlby5jdXJyZW50VGltZSwgZnJhZ0xvYWRlZERlbGF5ID0gKGV4cGVjdGVkTGVuIC0gc3RhdHMubG9hZGVkKSAvIGxvYWRSYXRlLCBidWZmZXJTdGFydmF0aW9uRGVsYXkgPSAoYnVmZmVyX2hlbHBlcl8xLkJ1ZmZlckhlbHBlci5idWZmZXJJbmZvKHZpZGVvLCBwb3MsIGhscy5jb25maWcubWF4QnVmZmVySG9sZSkuZW5kIC0gcG9zKSAvIHBsYXliYWNrUmF0ZTtcbiAgICAgICAgICAgICAgICAvLyBjb25zaWRlciBlbWVyZ2VuY3kgc3dpdGNoIGRvd24gb25seSBpZiB3ZSBoYXZlIGxlc3MgdGhhbiAyIGZyYWcgYnVmZmVyZWQgQU5EXG4gICAgICAgICAgICAgICAgLy8gdGltZSB0byBmaW5pc2ggbG9hZGluZyBjdXJyZW50IGZyYWdtZW50IGlzIGJpZ2dlciB0aGFuIGJ1ZmZlciBzdGFydmF0aW9uIGRlbGF5XG4gICAgICAgICAgICAgICAgLy8gaWUgaWYgd2UgcmlzayBidWZmZXIgc3RhcnZhdGlvbiBpZiBidyBkb2VzIG5vdCBpbmNyZWFzZSBxdWlja2x5XG4gICAgICAgICAgICAgICAgaWYgKChidWZmZXJTdGFydmF0aW9uRGVsYXkgPCAoMiAqIGZyYWcuZHVyYXRpb24gLyBwbGF5YmFja1JhdGUpKSAmJiAoZnJhZ0xvYWRlZERlbGF5ID4gYnVmZmVyU3RhcnZhdGlvbkRlbGF5KSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZnJhZ0xldmVsTmV4dExvYWRlZERlbGF5ID0gdm9pZCAwLCBuZXh0TG9hZExldmVsID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgICAgICAvLyBsZXRzIGl0ZXJhdGUgdGhyb3VnaCBsb3dlciBsZXZlbCBhbmQgdHJ5IHRvIGZpbmQgdGhlIGJpZ2dlc3Qgb25lIHRoYXQgY291bGQgYXZvaWQgcmVidWZmZXJpbmdcbiAgICAgICAgICAgICAgICAgICAgLy8gd2Ugc3RhcnQgZnJvbSBjdXJyZW50IGxldmVsIC0gMSBhbmQgd2Ugc3RlcCBkb3duICwgdW50aWwgd2UgZmluZCBhIG1hdGNoaW5nIGxldmVsXG4gICAgICAgICAgICAgICAgICAgIGZvciAobmV4dExvYWRMZXZlbCA9IGZyYWcubGV2ZWwgLSAxOyBuZXh0TG9hZExldmVsID4gbWluQXV0b0xldmVsOyBuZXh0TG9hZExldmVsLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbXB1dGUgdGltZSB0byBsb2FkIG5leHQgZnJhZ21lbnQgYXQgbG93ZXIgbGV2ZWxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIDAuOCA6IGNvbnNpZGVyIG9ubHkgODAlIG9mIGN1cnJlbnQgYncgdG8gYmUgY29uc2VydmF0aXZlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyA4ID0gYml0cyBwZXIgYnl0ZSAoYnBzL0JwcylcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsZXZlbE5leHRCaXRyYXRlID0gbGV2ZWxzW25leHRMb2FkTGV2ZWxdLnJlYWxCaXRyYXRlID8gTWF0aC5tYXgobGV2ZWxzW25leHRMb2FkTGV2ZWxdLnJlYWxCaXRyYXRlLCBsZXZlbHNbbmV4dExvYWRMZXZlbF0uYml0cmF0ZSkgOiBsZXZlbHNbbmV4dExvYWRMZXZlbF0uYml0cmF0ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyYWdMZXZlbE5leHRMb2FkZWREZWxheSA9IGZyYWcuZHVyYXRpb24gKiBsZXZlbE5leHRCaXRyYXRlIC8gKDggKiAwLjggKiBsb2FkUmF0ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZnJhZ0xldmVsTmV4dExvYWRlZERlbGF5IDwgYnVmZmVyU3RhcnZhdGlvbkRlbGF5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2UgZm91bmQgYSBsb3dlciBsZXZlbCB0aGF0IGJlIHJlYnVmZmVyaW5nIGZyZWUgd2l0aCBjdXJyZW50IGVzdGltYXRlZCBidyAhXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gb25seSBlbWVyZ2VuY3kgc3dpdGNoIGRvd24gaWYgaXQgdGFrZXMgbGVzcyB0aW1lIHRvIGxvYWQgbmV3IGZyYWdtZW50IGF0IGxvd2VzdCBsZXZlbCBpbnN0ZWFkXG4gICAgICAgICAgICAgICAgICAgIC8vIG9mIGZpbmlzaGluZyBsb2FkaW5nIGN1cnJlbnQgb25lIC4uLlxuICAgICAgICAgICAgICAgICAgICBpZiAoZnJhZ0xldmVsTmV4dExvYWRlZERlbGF5IDwgZnJhZ0xvYWRlZERlbGF5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXJfMS5sb2dnZXIud2FybihcImxvYWRpbmcgdG9vIHNsb3csIGFib3J0IGZyYWdtZW50IGxvYWRpbmcgYW5kIHN3aXRjaCB0byBsZXZlbCBcIiArIG5leHRMb2FkTGV2ZWwgKyBcIjpmcmFnTG9hZGVkRGVsYXlbXCIgKyBuZXh0TG9hZExldmVsICsgXCJdPGZyYWdMb2FkZWREZWxheVtcIiArIChmcmFnLmxldmVsIC0gMSkgKyBcIl07YnVmZmVyU3RhcnZhdGlvbkRlbGF5OlwiICsgZnJhZ0xldmVsTmV4dExvYWRlZERlbGF5LnRvRml4ZWQoMSkgKyBcIjxcIiArIGZyYWdMb2FkZWREZWxheS50b0ZpeGVkKDEpICsgXCI6XCIgKyBidWZmZXJTdGFydmF0aW9uRGVsYXkudG9GaXhlZCgxKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBmb3JjZSBuZXh0IGxvYWQgbGV2ZWwgaW4gYXV0byBtb2RlXG4gICAgICAgICAgICAgICAgICAgICAgICBobHMubmV4dExvYWRMZXZlbCA9IG5leHRMb2FkTGV2ZWw7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB1cGRhdGUgYncgZXN0aW1hdGUgZm9yIHRoaXMgZnJhZ21lbnQgYmVmb3JlIGNhbmNlbGxpbmcgbG9hZCAodGhpcyB3aWxsIGhlbHAgcmVkdWNpbmcgdGhlIGJ3KVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYndFc3RpbWF0b3Iuc2FtcGxlKHJlcXVlc3REZWxheSwgc3RhdHMubG9hZGVkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFib3J0IGZyYWdtZW50IGxvYWRpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvYWRlci5hYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3RvcCBhYmFuZG9uIHJ1bGVzIHRpbWVyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNsZWFyVGltZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhscy50cmlnZ2VyKGV2ZW50c18xLmRlZmF1bHQuRlJBR19MT0FEX0VNRVJHRU5DWV9BQk9SVEVELCB7IGZyYWc6IGZyYWcsIHN0YXRzOiBzdGF0cyB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgQWJyQ29udHJvbGxlci5wcm90b3R5cGUub25GcmFnTG9hZGVkID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdmFyIGZyYWcgPSBkYXRhLmZyYWc7XG4gICAgICAgIGlmIChmcmFnLnR5cGUgPT09ICdtYWluJyAmJiBOdW1iZXIuaXNGaW5pdGUoZnJhZy5zbikpIHtcbiAgICAgICAgICAgIC8vIHN0b3AgbW9uaXRvcmluZyBidyBvbmNlIGZyYWcgbG9hZGVkXG4gICAgICAgICAgICB0aGlzLmNsZWFyVGltZXIoKTtcbiAgICAgICAgICAgIC8vIHN0b3JlIGxldmVsIGlkIGFmdGVyIHN1Y2Nlc3NmdWwgZnJhZ21lbnQgbG9hZFxuICAgICAgICAgICAgdGhpcy5sYXN0TG9hZGVkRnJhZ0xldmVsID0gZnJhZy5sZXZlbDtcbiAgICAgICAgICAgIC8vIHJlc2V0IGZvcmNlZCBhdXRvIGxldmVsIHZhbHVlIHNvIHRoYXQgbmV4dCBsZXZlbCB3aWxsIGJlIHNlbGVjdGVkXG4gICAgICAgICAgICB0aGlzLl9uZXh0QXV0b0xldmVsID0gLTE7XG4gICAgICAgICAgICAvLyBjb21wdXRlIGxldmVsIGF2ZXJhZ2UgYml0cmF0ZVxuICAgICAgICAgICAgaWYgKHRoaXMuaGxzLmNvbmZpZy5hYnJNYXhXaXRoUmVhbEJpdHJhdGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgbGV2ZWwgPSB0aGlzLmhscy5sZXZlbHNbZnJhZy5sZXZlbF07XG4gICAgICAgICAgICAgICAgdmFyIGxvYWRlZEJ5dGVzID0gKGxldmVsLmxvYWRlZCA/IGxldmVsLmxvYWRlZC5ieXRlcyA6IDApICsgZGF0YS5zdGF0cy5sb2FkZWQ7XG4gICAgICAgICAgICAgICAgdmFyIGxvYWRlZER1cmF0aW9uID0gKGxldmVsLmxvYWRlZCA/IGxldmVsLmxvYWRlZC5kdXJhdGlvbiA6IDApICsgZGF0YS5mcmFnLmR1cmF0aW9uO1xuICAgICAgICAgICAgICAgIGxldmVsLmxvYWRlZCA9IHsgYnl0ZXM6IGxvYWRlZEJ5dGVzLCBkdXJhdGlvbjogbG9hZGVkRHVyYXRpb24gfTtcbiAgICAgICAgICAgICAgICBsZXZlbC5yZWFsQml0cmF0ZSA9IE1hdGgucm91bmQoOCAqIGxvYWRlZEJ5dGVzIC8gbG9hZGVkRHVyYXRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaWYgZnJhZ21lbnQgaGFzIGJlZW4gbG9hZGVkIHRvIHBlcmZvcm0gYSBiaXRyYXRlIHRlc3QsXG4gICAgICAgICAgICBpZiAoZGF0YS5mcmFnLmJpdHJhdGVUZXN0KSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0YXRzID0gZGF0YS5zdGF0cztcbiAgICAgICAgICAgICAgICBzdGF0cy50cGFyc2VkID0gc3RhdHMudGJ1ZmZlcmVkID0gc3RhdHMudGxvYWQ7XG4gICAgICAgICAgICAgICAgdGhpcy5vbkZyYWdCdWZmZXJlZChkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgQWJyQ29udHJvbGxlci5wcm90b3R5cGUub25GcmFnQnVmZmVyZWQgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB2YXIgc3RhdHMgPSBkYXRhLnN0YXRzO1xuICAgICAgICB2YXIgZnJhZyA9IGRhdGEuZnJhZztcbiAgICAgICAgLy8gb25seSB1cGRhdGUgc3RhdHMgb24gZmlyc3QgZnJhZyBidWZmZXJpbmdcbiAgICAgICAgLy8gaWYgc2FtZSBmcmFnIGlzIGxvYWRlZCBtdWx0aXBsZSB0aW1lcywgaXQgbWlnaHQgYmUgaW4gYnJvd3NlciBjYWNoZSwgYW5kIGxvYWRlZCBxdWlja2x5XG4gICAgICAgIC8vIGFuZCBsZWFkaW5nIHRvIHdyb25nIGJ3IGVzdGltYXRpb25cbiAgICAgICAgLy8gb24gYml0cmF0ZSB0ZXN0LCBhbHNvIG9ubHkgdXBkYXRlIHN0YXRzIG9uY2UgKGlmIHRsb2FkID0gdGJ1ZmZlcmVkID09IG9uIEZSQUdfTE9BREVEKVxuICAgICAgICBpZiAoc3RhdHMuYWJvcnRlZCAhPT0gdHJ1ZSAmJiBmcmFnLnR5cGUgPT09ICdtYWluJyAmJiBOdW1iZXIuaXNGaW5pdGUoZnJhZy5zbikgJiYgKCghZnJhZy5iaXRyYXRlVGVzdCB8fCBzdGF0cy50bG9hZCA9PT0gc3RhdHMudGJ1ZmZlcmVkKSkpIHtcbiAgICAgICAgICAgIC8vIHVzZSB0cGFyc2VkLXRyZXF1ZXN0IGluc3RlYWQgb2YgdGJ1ZmZlcmVkLXRyZXF1ZXN0IHRvIGNvbXB1dGUgZnJhZ0xvYWRpbmdQcm9jZXNzaW5nOyByYXRpb25hbGUgaXMgdGhhdCAgYnVmZmVyIGFwcGVuZGluZyBvbmx5IGhhcHBlbnMgb25jZSBtZWRpYSBpcyBhdHRhY2hlZFxuICAgICAgICAgICAgLy8gaW4gY2FzZSB3ZSB1c2UgY29uZmlnLnN0YXJ0RnJhZ1ByZWZldGNoIHdoaWxlIG1lZGlhIGlzIG5vdCBhdHRhY2hlZCB5ZXQsIGZyYWdtZW50IG1pZ2h0IGJlIHBhcnNlZCB3aGlsZSBtZWRpYSBub3QgYXR0YWNoZWQgeWV0LCBidXQgaXQgd2lsbCBvbmx5IGJlIGJ1ZmZlcmVkIG9uIG1lZGlhIGF0dGFjaGVkXG4gICAgICAgICAgICAvLyBhcyBhIGNvbnNlcXVlbmNlIGl0IGNvdWxkIGhhcHBlbiByZWFsbHkgbGF0ZSBpbiB0aGUgcHJvY2Vzcy4gbWVhbmluZyB0aGF0IGFwcGVuZGluZyBkdXJhdGlvbiBtaWdodCBhcHBlYXJzIGh1Z2UgLi4uIGxlYWRpbmcgdG8gdW5kZXJlc3RpbWF0ZWQgdGhyb3VnaHB1dCBlc3RpbWF0aW9uXG4gICAgICAgICAgICB2YXIgZnJhZ0xvYWRpbmdQcm9jZXNzaW5nTXMgPSBzdGF0cy50cGFyc2VkIC0gc3RhdHMudHJlcXVlc3Q7XG4gICAgICAgICAgICBsb2dnZXJfMS5sb2dnZXIubG9nKFwibGF0ZW5jeS9sb2FkaW5nL3BhcnNpbmcvYXBwZW5kL2ticHM6XCIgKyBNYXRoLnJvdW5kKHN0YXRzLnRmaXJzdCAtIHN0YXRzLnRyZXF1ZXN0KSArIFwiL1wiICsgTWF0aC5yb3VuZChzdGF0cy50bG9hZCAtIHN0YXRzLnRmaXJzdCkgKyBcIi9cIiArIE1hdGgucm91bmQoc3RhdHMudHBhcnNlZCAtIHN0YXRzLnRsb2FkKSArIFwiL1wiICsgTWF0aC5yb3VuZChzdGF0cy50YnVmZmVyZWQgLSBzdGF0cy50cGFyc2VkKSArIFwiL1wiICsgTWF0aC5yb3VuZCg4ICogc3RhdHMubG9hZGVkIC8gKHN0YXRzLnRidWZmZXJlZCAtIHN0YXRzLnRyZXF1ZXN0KSkpO1xuICAgICAgICAgICAgdGhpcy5fYndFc3RpbWF0b3Iuc2FtcGxlKGZyYWdMb2FkaW5nUHJvY2Vzc2luZ01zLCBzdGF0cy5sb2FkZWQpO1xuICAgICAgICAgICAgc3RhdHMuYndFc3RpbWF0ZSA9IHRoaXMuX2J3RXN0aW1hdG9yLmdldEVzdGltYXRlKCk7XG4gICAgICAgICAgICAvLyBpZiBmcmFnbWVudCBoYXMgYmVlbiBsb2FkZWQgdG8gcGVyZm9ybSBhIGJpdHJhdGUgdGVzdCwgKGhscy5zdGFydExldmVsID0gLTEpLCBzdG9yZSBiaXRyYXRlIHRlc3QgZGVsYXkgZHVyYXRpb25cbiAgICAgICAgICAgIGlmIChmcmFnLmJpdHJhdGVUZXN0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5iaXRyYXRlVGVzdERlbGF5ID0gZnJhZ0xvYWRpbmdQcm9jZXNzaW5nTXMgLyAxMDAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5iaXRyYXRlVGVzdERlbGF5ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgQWJyQ29udHJvbGxlci5wcm90b3R5cGUub25FcnJvciA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIC8vIHN0b3AgdGltZXIgaW4gY2FzZSBvZiBmcmFnIGxvYWRpbmcgZXJyb3JcbiAgICAgICAgc3dpdGNoIChkYXRhLmRldGFpbHMpIHtcbiAgICAgICAgICAgIGNhc2UgZXJyb3JzXzEuRXJyb3JEZXRhaWxzLkZSQUdfTE9BRF9FUlJPUjpcbiAgICAgICAgICAgIGNhc2UgZXJyb3JzXzEuRXJyb3JEZXRhaWxzLkZSQUdfTE9BRF9USU1FT1VUOlxuICAgICAgICAgICAgICAgIHRoaXMuY2xlYXJUaW1lcigpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH07XG4gICAgQWJyQ29udHJvbGxlci5wcm90b3R5cGUuY2xlYXJUaW1lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLnRpbWVyKTtcbiAgICAgICAgdGhpcy50aW1lciA9IG51bGw7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWJyQ29udHJvbGxlci5wcm90b3R5cGUsIFwibmV4dEF1dG9MZXZlbFwiLCB7XG4gICAgICAgIC8vIHJldHVybiBuZXh0IGF1dG8gbGV2ZWxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZm9yY2VkQXV0b0xldmVsID0gdGhpcy5fbmV4dEF1dG9MZXZlbDtcbiAgICAgICAgICAgIHZhciBid0VzdGltYXRvciA9IHRoaXMuX2J3RXN0aW1hdG9yO1xuICAgICAgICAgICAgLy8gaW4gY2FzZSBuZXh0IGF1dG8gbGV2ZWwgaGFzIGJlZW4gZm9yY2VkLCBhbmQgYncgbm90IGF2YWlsYWJsZSBvciBub3QgcmVsaWFibGUsIHJldHVybiBmb3JjZWQgdmFsdWVcbiAgICAgICAgICAgIGlmIChmb3JjZWRBdXRvTGV2ZWwgIT09IC0xICYmICghYndFc3RpbWF0b3IgfHwgIWJ3RXN0aW1hdG9yLmNhbkVzdGltYXRlKCkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZvcmNlZEF1dG9MZXZlbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGNvbXB1dGUgbmV4dCBsZXZlbCB1c2luZyBBQlIgbG9naWNcbiAgICAgICAgICAgIHZhciBuZXh0QUJSQXV0b0xldmVsID0gdGhpcy5fbmV4dEFCUkF1dG9MZXZlbDtcbiAgICAgICAgICAgIC8vIGlmIGZvcmNlZCBhdXRvIGxldmVsIGhhcyBiZWVuIGRlZmluZWQsIHVzZSBpdCB0byBjYXAgQUJSIGNvbXB1dGVkIHF1YWxpdHkgbGV2ZWxcbiAgICAgICAgICAgIGlmIChmb3JjZWRBdXRvTGV2ZWwgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgbmV4dEFCUkF1dG9MZXZlbCA9IE1hdGgubWluKGZvcmNlZEF1dG9MZXZlbCwgbmV4dEFCUkF1dG9MZXZlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV4dEFCUkF1dG9MZXZlbDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAobmV4dExldmVsKSB7XG4gICAgICAgICAgICB0aGlzLl9uZXh0QXV0b0xldmVsID0gbmV4dExldmVsO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWJyQ29udHJvbGxlci5wcm90b3R5cGUsIFwiX25leHRBQlJBdXRvTGV2ZWxcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBobHMgPSB0aGlzLmhscywgbWF4QXV0b0xldmVsID0gaGxzLm1heEF1dG9MZXZlbCwgbGV2ZWxzID0gaGxzLmxldmVscywgY29uZmlnID0gaGxzLmNvbmZpZywgbWluQXV0b0xldmVsID0gaGxzLm1pbkF1dG9MZXZlbDtcbiAgICAgICAgICAgIHZhciB2aWRlbyA9IGhscy5tZWRpYSwgY3VycmVudExldmVsID0gdGhpcy5sYXN0TG9hZGVkRnJhZ0xldmVsLCBjdXJyZW50RnJhZ0R1cmF0aW9uID0gdGhpcy5mcmFnQ3VycmVudCA/IHRoaXMuZnJhZ0N1cnJlbnQuZHVyYXRpb24gOiAwLCBwb3MgPSAodmlkZW8gPyB2aWRlby5jdXJyZW50VGltZSA6IDApLCBcbiAgICAgICAgICAgIC8vIHBsYXliYWNrUmF0ZSBpcyB0aGUgYWJzb2x1dGUgdmFsdWUgb2YgdGhlIHBsYXliYWNrIHJhdGU7IGlmIHZpZGVvLnBsYXliYWNrUmF0ZSBpcyAwLCB3ZSB1c2UgMSB0byBsb2FkIGFzXG4gICAgICAgICAgICAvLyBpZiB3ZSdyZSBwbGF5aW5nIGJhY2sgYXQgdGhlIG5vcm1hbCByYXRlLlxuICAgICAgICAgICAgcGxheWJhY2tSYXRlID0gKCh2aWRlbyAmJiAodmlkZW8ucGxheWJhY2tSYXRlICE9PSAwKSkgPyBNYXRoLmFicyh2aWRlby5wbGF5YmFja1JhdGUpIDogMS4wKSwgYXZnYncgPSB0aGlzLl9id0VzdGltYXRvciA/IHRoaXMuX2J3RXN0aW1hdG9yLmdldEVzdGltYXRlKCkgOiBjb25maWcuYWJyRXdtYURlZmF1bHRFc3RpbWF0ZSwgXG4gICAgICAgICAgICAvLyBidWZmZXJTdGFydmF0aW9uRGVsYXkgaXMgdGhlIHdhbGwtY2xvY2sgdGltZSBsZWZ0IHVudGlsIHRoZSBwbGF5YmFjayBidWZmZXIgaXMgZXhoYXVzdGVkLlxuICAgICAgICAgICAgYnVmZmVyU3RhcnZhdGlvbkRlbGF5ID0gKGJ1ZmZlcl9oZWxwZXJfMS5CdWZmZXJIZWxwZXIuYnVmZmVySW5mbyh2aWRlbywgcG9zLCBjb25maWcubWF4QnVmZmVySG9sZSkuZW5kIC0gcG9zKSAvIHBsYXliYWNrUmF0ZTtcbiAgICAgICAgICAgIC8vIEZpcnN0LCBsb29rIHRvIHNlZSBpZiB3ZSBjYW4gZmluZCBhIGxldmVsIG1hdGNoaW5nIHdpdGggb3VyIGF2ZyBiYW5kd2lkdGggQU5EIHRoYXQgY291bGQgYWxzbyBndWFyYW50ZWUgbm8gcmVidWZmZXJpbmcgYXQgYWxsXG4gICAgICAgICAgICB2YXIgYmVzdExldmVsID0gdGhpcy5fZmluZEJlc3RMZXZlbChjdXJyZW50TGV2ZWwsIGN1cnJlbnRGcmFnRHVyYXRpb24sIGF2Z2J3LCBtaW5BdXRvTGV2ZWwsIG1heEF1dG9MZXZlbCwgYnVmZmVyU3RhcnZhdGlvbkRlbGF5LCBjb25maWcuYWJyQmFuZFdpZHRoRmFjdG9yLCBjb25maWcuYWJyQmFuZFdpZHRoVXBGYWN0b3IsIGxldmVscyk7XG4gICAgICAgICAgICBpZiAoYmVzdExldmVsID49IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYmVzdExldmVsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLnRyYWNlKCdyZWJ1ZmZlcmluZyBleHBlY3RlZCB0byBoYXBwZW4sIGxldHMgdHJ5IHRvIGZpbmQgYSBxdWFsaXR5IGxldmVsIG1pbmltaXppbmcgdGhlIHJlYnVmZmVyaW5nJyk7XG4gICAgICAgICAgICAgICAgLy8gbm90IHBvc3NpYmxlIHRvIGdldCByaWQgb2YgcmVidWZmZXJpbmcgLi4uIGxldCdzIHRyeSB0byBmaW5kIGxldmVsIHRoYXQgd2lsbCBndWFyYW50ZWUgbGVzcyB0aGFuIG1heFN0YXJ2YXRpb25EZWxheSBvZiByZWJ1ZmZlcmluZ1xuICAgICAgICAgICAgICAgIC8vIGlmIG5vIG1hdGNoaW5nIGxldmVsIGZvdW5kLCBsb2dpYyB3aWxsIHJldHVybiAwXG4gICAgICAgICAgICAgICAgdmFyIG1heFN0YXJ2YXRpb25EZWxheSA9IGN1cnJlbnRGcmFnRHVyYXRpb24gPyBNYXRoLm1pbihjdXJyZW50RnJhZ0R1cmF0aW9uLCBjb25maWcubWF4U3RhcnZhdGlvbkRlbGF5KSA6IGNvbmZpZy5tYXhTdGFydmF0aW9uRGVsYXksIGJ3RmFjdG9yID0gY29uZmlnLmFickJhbmRXaWR0aEZhY3RvciwgYndVcEZhY3RvciA9IGNvbmZpZy5hYnJCYW5kV2lkdGhVcEZhY3RvcjtcbiAgICAgICAgICAgICAgICBpZiAoYnVmZmVyU3RhcnZhdGlvbkRlbGF5ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGluIGNhc2UgYnVmZmVyIGlzIGVtcHR5LCBsZXQncyBjaGVjayBpZiBwcmV2aW91cyBmcmFnbWVudCB3YXMgbG9hZGVkIHRvIHBlcmZvcm0gYSBiaXRyYXRlIHRlc3RcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJpdHJhdGVUZXN0RGVsYXkgPSB0aGlzLmJpdHJhdGVUZXN0RGVsYXk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChiaXRyYXRlVGVzdERlbGF5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiBpdCBpcyB0aGUgY2FzZSwgdGhlbiB3ZSBuZWVkIHRvIGFkanVzdCBvdXIgbWF4IHN0YXJ2YXRpb24gZGVsYXkgdXNpbmcgbWF4TG9hZGluZ0RlbGF5IGNvbmZpZyB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWF4IHZpZGVvIGxvYWRpbmcgZGVsYXkgdXNlZCBpbiAgYXV0b21hdGljIHN0YXJ0IGxldmVsIHNlbGVjdGlvbiA6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpbiB0aGF0IG1vZGUgQUJSIGNvbnRyb2xsZXIgd2lsbCBlbnN1cmUgdGhhdCB2aWRlbyBsb2FkaW5nIHRpbWUgKGllIHRoZSB0aW1lIHRvIGZldGNoIHRoZSBmaXJzdCBmcmFnbWVudCBhdCBsb3dlc3QgcXVhbGl0eSBsZXZlbCArXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGUgdGltZSB0byBmZXRjaCB0aGUgZnJhZ21lbnQgYXQgdGhlIGFwcHJvcHJpYXRlIHF1YWxpdHkgbGV2ZWwgaXMgbGVzcyB0aGFuIGBgYG1heExvYWRpbmdEZWxheWBgYCApXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjYXAgbWF4TG9hZGluZ0RlbGF5IGFuZCBlbnN1cmUgaXQgaXMgbm90IGJpZ2dlciAndGhhbiBiaXRyYXRlIHRlc3QnIGZyYWcgZHVyYXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtYXhMb2FkaW5nRGVsYXkgPSBjdXJyZW50RnJhZ0R1cmF0aW9uID8gTWF0aC5taW4oY3VycmVudEZyYWdEdXJhdGlvbiwgY29uZmlnLm1heExvYWRpbmdEZWxheSkgOiBjb25maWcubWF4TG9hZGluZ0RlbGF5O1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF4U3RhcnZhdGlvbkRlbGF5ID0gbWF4TG9hZGluZ0RlbGF5IC0gYml0cmF0ZVRlc3REZWxheTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmxvZ2dlci50cmFjZShcImJpdHJhdGUgdGVzdCB0b29rIFwiICsgTWF0aC5yb3VuZCgxMDAwICogYml0cmF0ZVRlc3REZWxheSkgKyBcIm1zLCBzZXQgZmlyc3QgZnJhZ21lbnQgbWF4IGZldGNoRHVyYXRpb24gdG8gXCIgKyBNYXRoLnJvdW5kKDEwMDAgKiBtYXhTdGFydmF0aW9uRGVsYXkpICsgXCIgbXNcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBkb24ndCB1c2UgY29uc2VydmF0aXZlIGZhY3RvciBvbiBiaXRyYXRlIHRlc3RcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ3RmFjdG9yID0gYndVcEZhY3RvciA9IDE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYmVzdExldmVsID0gdGhpcy5fZmluZEJlc3RMZXZlbChjdXJyZW50TGV2ZWwsIGN1cnJlbnRGcmFnRHVyYXRpb24sIGF2Z2J3LCBtaW5BdXRvTGV2ZWwsIG1heEF1dG9MZXZlbCwgYnVmZmVyU3RhcnZhdGlvbkRlbGF5ICsgbWF4U3RhcnZhdGlvbkRlbGF5LCBid0ZhY3RvciwgYndVcEZhY3RvciwgbGV2ZWxzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5tYXgoYmVzdExldmVsLCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgQWJyQ29udHJvbGxlci5wcm90b3R5cGUuX2ZpbmRCZXN0TGV2ZWwgPSBmdW5jdGlvbiAoY3VycmVudExldmVsLCBjdXJyZW50RnJhZ0R1cmF0aW9uLCBjdXJyZW50QncsIG1pbkF1dG9MZXZlbCwgbWF4QXV0b0xldmVsLCBtYXhGZXRjaER1cmF0aW9uLCBid0ZhY3RvciwgYndVcEZhY3RvciwgbGV2ZWxzKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSBtYXhBdXRvTGV2ZWw7IGkgPj0gbWluQXV0b0xldmVsOyBpLS0pIHtcbiAgICAgICAgICAgIHZhciBsZXZlbEluZm8gPSBsZXZlbHNbaV07XG4gICAgICAgICAgICBpZiAoIWxldmVsSW5mbykge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGxldmVsRGV0YWlscyA9IGxldmVsSW5mby5kZXRhaWxzLCBhdmdEdXJhdGlvbiA9IGxldmVsRGV0YWlscyA/IGxldmVsRGV0YWlscy50b3RhbGR1cmF0aW9uIC8gbGV2ZWxEZXRhaWxzLmZyYWdtZW50cy5sZW5ndGggOiBjdXJyZW50RnJhZ0R1cmF0aW9uLCBsaXZlID0gbGV2ZWxEZXRhaWxzID8gbGV2ZWxEZXRhaWxzLmxpdmUgOiBmYWxzZSwgYWRqdXN0ZWRidyA9IHZvaWQgMDtcbiAgICAgICAgICAgIC8vIGZvbGxvdyBhbGdvcml0aG0gY2FwdHVyZWQgZnJvbSBzdGFnZWZyaWdodCA6XG4gICAgICAgICAgICAvLyBodHRwczovL2FuZHJvaWQuZ29vZ2xlc291cmNlLmNvbS9wbGF0Zm9ybS9mcmFtZXdvcmtzL2F2LysvbWFzdGVyL21lZGlhL2xpYnN0YWdlZnJpZ2h0L2h0dHBsaXZlL0xpdmVTZXNzaW9uLmNwcFxuICAgICAgICAgICAgLy8gUGljayB0aGUgaGlnaGVzdCBiYW5kd2lkdGggc3RyZWFtIGJlbG93IG9yIGVxdWFsIHRvIGVzdGltYXRlZCBiYW5kd2lkdGguXG4gICAgICAgICAgICAvLyBjb25zaWRlciBvbmx5IDgwJSBvZiB0aGUgYXZhaWxhYmxlIGJhbmR3aWR0aCwgYnV0IGlmIHdlIGFyZSBzd2l0Y2hpbmcgdXAsXG4gICAgICAgICAgICAvLyBiZSBldmVuIG1vcmUgY29uc2VydmF0aXZlICg3MCUpIHRvIGF2b2lkIG92ZXJlc3RpbWF0aW5nIGFuZCBpbW1lZGlhdGVseVxuICAgICAgICAgICAgLy8gc3dpdGNoaW5nIGJhY2suXG4gICAgICAgICAgICBpZiAoaSA8PSBjdXJyZW50TGV2ZWwpIHtcbiAgICAgICAgICAgICAgICBhZGp1c3RlZGJ3ID0gYndGYWN0b3IgKiBjdXJyZW50Qnc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhZGp1c3RlZGJ3ID0gYndVcEZhY3RvciAqIGN1cnJlbnRCdztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBiaXRyYXRlID0gbGV2ZWxzW2ldLnJlYWxCaXRyYXRlID8gTWF0aC5tYXgobGV2ZWxzW2ldLnJlYWxCaXRyYXRlLCBsZXZlbHNbaV0uYml0cmF0ZSkgOiBsZXZlbHNbaV0uYml0cmF0ZSwgZmV0Y2hEdXJhdGlvbiA9IGJpdHJhdGUgKiBhdmdEdXJhdGlvbiAvIGFkanVzdGVkYnc7XG4gICAgICAgICAgICBsb2dnZXJfMS5sb2dnZXIudHJhY2UoXCJsZXZlbC9hZGp1c3RlZGJ3L2JpdHJhdGUvYXZnRHVyYXRpb24vbWF4RmV0Y2hEdXJhdGlvbi9mZXRjaER1cmF0aW9uOiBcIiArIGkgKyBcIi9cIiArIE1hdGgucm91bmQoYWRqdXN0ZWRidykgKyBcIi9cIiArIGJpdHJhdGUgKyBcIi9cIiArIGF2Z0R1cmF0aW9uICsgXCIvXCIgKyBtYXhGZXRjaER1cmF0aW9uICsgXCIvXCIgKyBmZXRjaER1cmF0aW9uKTtcbiAgICAgICAgICAgIC8vIGlmIGFkanVzdGVkIGJ3IGlzIGdyZWF0ZXIgdGhhbiBsZXZlbCBiaXRyYXRlIEFORFxuICAgICAgICAgICAgaWYgKGFkanVzdGVkYncgPiBiaXRyYXRlICYmXG4gICAgICAgICAgICAgICAgLy8gZnJhZ21lbnQgZmV0Y2hEdXJhdGlvbiB1bmtub3duIE9SIGxpdmUgc3RyZWFtIE9SIGZyYWdtZW50IGZldGNoRHVyYXRpb24gbGVzcyB0aGFuIG1heCBhbGxvd2VkIGZldGNoIGR1cmF0aW9uLCB0aGVuIHRoaXMgbGV2ZWwgbWF0Y2hlc1xuICAgICAgICAgICAgICAgIC8vIHdlIGRvbid0IGFjY291bnQgZm9yIG1heCBGZXRjaCBEdXJhdGlvbiBmb3IgbGl2ZSBzdHJlYW1zLCB0aGlzIGlzIHRvIGF2b2lkIHN3aXRjaGluZyBkb3duIHdoZW4gbmVhciB0aGUgZWRnZSBvZiBsaXZlIHNsaWRpbmcgd2luZG93IC4uLlxuICAgICAgICAgICAgICAgIC8vIHNwZWNpYWwgY2FzZSB0byBzdXBwb3J0IHN0YXJ0TGV2ZWwgPSAtMSAoYml0cmF0ZVRlc3QpIG9uIGxpdmUgc3RyZWFtcyA6IGluIHRoYXQgY2FzZSB3ZSBzaG91bGQgbm90IGV4aXQgbG9vcCBzbyB0aGF0IF9maW5kQmVzdExldmVsIHdpbGwgcmV0dXJuIC0xXG4gICAgICAgICAgICAgICAgKCFmZXRjaER1cmF0aW9uIHx8IChsaXZlICYmICF0aGlzLmJpdHJhdGVUZXN0RGVsYXkpIHx8IGZldGNoRHVyYXRpb24gPCBtYXhGZXRjaER1cmF0aW9uKSkge1xuICAgICAgICAgICAgICAgIC8vIGFzIHdlIGFyZSBsb29waW5nIGZyb20gaGlnaGVzdCB0byBsb3dlc3QsIHRoaXMgd2lsbCByZXR1cm4gdGhlIGJlc3QgYWNoaWV2YWJsZSBxdWFsaXR5IGxldmVsXG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gbm90IGVub3VnaCB0aW1lIGJ1ZGdldCBldmVuIHdpdGggcXVhbGl0eSBsZXZlbCAwIC4uLiByZWJ1ZmZlcmluZyBtaWdodCBoYXBwZW5cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH07XG4gICAgcmV0dXJuIEFickNvbnRyb2xsZXI7XG59KGV2ZW50X2hhbmRsZXJfMS5kZWZhdWx0KSk7XG5leHBvcnRzLmRlZmF1bHQgPSBBYnJDb250cm9sbGVyO1xuXG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwodGhpcywgX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9zcmMvcG9seWZpbGxzL251bWJlciAqLyBcIi4vc3JjL3BvbHlmaWxscy9udW1iZXIuanNcIilbXCJOdW1iZXJcIl0pKVxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9jb250cm9sbGVyL2F1ZGlvLXN0cmVhbS1jb250cm9sbGVyLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvY29udHJvbGxlci9hdWRpby1zdHJlYW0tY29udHJvbGxlci5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovKGZ1bmN0aW9uKE51bWJlcikge1xuLypcbiAqIEF1ZGlvIFN0cmVhbSBDb250cm9sbGVyXG4qL1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgYmluYXJ5X3NlYXJjaF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvYmluYXJ5LXNlYXJjaCAqLyBcIi4vc3JjL3V0aWxzL2JpbmFyeS1zZWFyY2guanNcIik7XG52YXIgYnVmZmVyX2hlbHBlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvYnVmZmVyLWhlbHBlciAqLyBcIi4vc3JjL3V0aWxzL2J1ZmZlci1oZWxwZXIuanNcIik7XG52YXIgZGVtdXhlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZGVtdXgvZGVtdXhlciAqLyBcIi4vc3JjL2RlbXV4L2RlbXV4ZXIuanNcIik7XG52YXIgZXZlbnRzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9ldmVudHMgKi8gXCIuL3NyYy9ldmVudHMuanNcIik7XG52YXIgTGV2ZWxIZWxwZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2xldmVsLWhlbHBlciAqLyBcIi4vc3JjL2NvbnRyb2xsZXIvbGV2ZWwtaGVscGVyLmpzXCIpO1xudmFyIHRpbWVfcmFuZ2VzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy90aW1lLXJhbmdlcyAqLyBcIi4vc3JjL3V0aWxzL3RpbWUtcmFuZ2VzLmpzXCIpO1xudmFyIGVycm9yc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZXJyb3JzICovIFwiLi9zcmMvZXJyb3JzLmpzXCIpO1xudmFyIGxvZ2dlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvbG9nZ2VyICovIFwiLi9zcmMvdXRpbHMvbG9nZ2VyLmpzXCIpO1xudmFyIGRpc2NvbnRpbnVpdGllc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvZGlzY29udGludWl0aWVzICovIFwiLi9zcmMvdXRpbHMvZGlzY29udGludWl0aWVzLmpzXCIpO1xudmFyIGZyYWdtZW50X3RyYWNrZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZnJhZ21lbnQtdHJhY2tlciAqLyBcIi4vc3JjL2NvbnRyb2xsZXIvZnJhZ21lbnQtdHJhY2tlci5qc1wiKTtcbnZhciBmcmFnbWVudF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vbG9hZGVyL2ZyYWdtZW50ICovIFwiLi9zcmMvbG9hZGVyL2ZyYWdtZW50LmpzXCIpO1xudmFyIGJhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vYmFzZS1zdHJlYW0tY29udHJvbGxlciAqLyBcIi4vc3JjL2NvbnRyb2xsZXIvYmFzZS1zdHJlYW0tY29udHJvbGxlci5qc1wiKTtcbnZhciBwZXJmb3JtYW5jZSA9IHdpbmRvdy5wZXJmb3JtYW5jZTtcbnZhciBUSUNLX0lOVEVSVkFMID0gMTAwOyAvLyBob3cgb2Z0ZW4gdG8gdGljayBpbiBtc1xudmFyIEF1ZGlvU3RyZWFtQ29udHJvbGxlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQXVkaW9TdHJlYW1Db250cm9sbGVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEF1ZGlvU3RyZWFtQ29udHJvbGxlcihobHMsIGZyYWdtZW50VHJhY2tlcikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBobHMsIGV2ZW50c18xLmRlZmF1bHQuTUVESUFfQVRUQUNIRUQsIGV2ZW50c18xLmRlZmF1bHQuTUVESUFfREVUQUNISU5HLCBldmVudHNfMS5kZWZhdWx0LkFVRElPX1RSQUNLU19VUERBVEVELCBldmVudHNfMS5kZWZhdWx0LkFVRElPX1RSQUNLX1NXSVRDSElORywgZXZlbnRzXzEuZGVmYXVsdC5BVURJT19UUkFDS19MT0FERUQsIGV2ZW50c18xLmRlZmF1bHQuS0VZX0xPQURFRCwgZXZlbnRzXzEuZGVmYXVsdC5GUkFHX0xPQURFRCwgZXZlbnRzXzEuZGVmYXVsdC5GUkFHX1BBUlNJTkdfSU5JVF9TRUdNRU5ULCBldmVudHNfMS5kZWZhdWx0LkZSQUdfUEFSU0lOR19EQVRBLCBldmVudHNfMS5kZWZhdWx0LkZSQUdfUEFSU0VELCBldmVudHNfMS5kZWZhdWx0LkVSUk9SLCBldmVudHNfMS5kZWZhdWx0LkJVRkZFUl9SRVNFVCwgZXZlbnRzXzEuZGVmYXVsdC5CVUZGRVJfQ1JFQVRFRCwgZXZlbnRzXzEuZGVmYXVsdC5CVUZGRVJfQVBQRU5ERUQsIGV2ZW50c18xLmRlZmF1bHQuQlVGRkVSX0ZMVVNIRUQsIGV2ZW50c18xLmRlZmF1bHQuSU5JVF9QVFNfRk9VTkQpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmZyYWdtZW50VHJhY2tlciA9IGZyYWdtZW50VHJhY2tlcjtcbiAgICAgICAgX3RoaXMuY29uZmlnID0gaGxzLmNvbmZpZztcbiAgICAgICAgX3RoaXMuYXVkaW9Db2RlY1N3YXAgPSBmYWxzZTtcbiAgICAgICAgX3RoaXMuX3N0YXRlID0gYmFzZV9zdHJlYW1fY29udHJvbGxlcl8xLlN0YXRlLlNUT1BQRUQ7XG4gICAgICAgIF90aGlzLmluaXRQVFMgPSBbXTtcbiAgICAgICAgX3RoaXMud2FpdGluZ0ZyYWdtZW50ID0gbnVsbDtcbiAgICAgICAgX3RoaXMudmlkZW9UcmFja0NDID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvLyBTaWduYWwgdGhhdCB2aWRlbyBQVFMgd2FzIGZvdW5kXG4gICAgQXVkaW9TdHJlYW1Db250cm9sbGVyLnByb3RvdHlwZS5vbkluaXRQdHNGb3VuZCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHZhciBkZW11eGVySWQgPSBkYXRhLmlkLCBjYyA9IGRhdGEuZnJhZy5jYywgaW5pdFBUUyA9IGRhdGEuaW5pdFBUUztcbiAgICAgICAgaWYgKGRlbXV4ZXJJZCA9PT0gJ21haW4nKSB7XG4gICAgICAgICAgICAvLyBBbHdheXMgdXBkYXRlIHRoZSBuZXcgSU5JVCBQVFNcbiAgICAgICAgICAgIC8vIENhbiBjaGFuZ2UgZHVlIGxldmVsIHN3aXRjaFxuICAgICAgICAgICAgdGhpcy5pbml0UFRTW2NjXSA9IGluaXRQVFM7XG4gICAgICAgICAgICB0aGlzLnZpZGVvVHJhY2tDQyA9IGNjO1xuICAgICAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLmxvZyhcIkluaXRQVFMgZm9yIGNjOiBcIiArIGNjICsgXCIgZm91bmQgZnJvbSB2aWRlbyB0cmFjazogXCIgKyBpbml0UFRTKTtcbiAgICAgICAgICAgIC8vIElmIHdlIGFyZSB3YWl0aW5nIHdlIG5lZWQgdG8gZGVtdXgvcmVtdXggdGhlIHdhaXRpbmcgZnJhZ1xuICAgICAgICAgICAgLy8gV2l0aCB0aGUgbmV3IGluaXRQVFNcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlID09PSBiYXNlX3N0cmVhbV9jb250cm9sbGVyXzEuU3RhdGUuV0FJVElOR19JTklUX1BUUykge1xuICAgICAgICAgICAgICAgIHRoaXMudGljaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBBdWRpb1N0cmVhbUNvbnRyb2xsZXIucHJvdG90eXBlLnN0YXJ0TG9hZCA9IGZ1bmN0aW9uIChzdGFydFBvc2l0aW9uKSB7XG4gICAgICAgIGlmICh0aGlzLnRyYWNrcykge1xuICAgICAgICAgICAgdmFyIGxhc3RDdXJyZW50VGltZSA9IHRoaXMubGFzdEN1cnJlbnRUaW1lO1xuICAgICAgICAgICAgdGhpcy5zdG9wTG9hZCgpO1xuICAgICAgICAgICAgdGhpcy5zZXRJbnRlcnZhbChUSUNLX0lOVEVSVkFMKTtcbiAgICAgICAgICAgIHRoaXMuZnJhZ0xvYWRFcnJvciA9IDA7XG4gICAgICAgICAgICBpZiAobGFzdEN1cnJlbnRUaW1lID4gMCAmJiBzdGFydFBvc2l0aW9uID09PSAtMSkge1xuICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmxvZ2dlci5sb2coXCJhdWRpbzpvdmVycmlkZSBzdGFydFBvc2l0aW9uIHdpdGggbGFzdEN1cnJlbnRUaW1lIEBcIiArIGxhc3RDdXJyZW50VGltZS50b0ZpeGVkKDMpKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gYmFzZV9zdHJlYW1fY29udHJvbGxlcl8xLlN0YXRlLklETEU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxhc3RDdXJyZW50VGltZSA9IHRoaXMuc3RhcnRQb3NpdGlvbiA/IHRoaXMuc3RhcnRQb3NpdGlvbiA6IHN0YXJ0UG9zaXRpb247XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IGJhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfMS5TdGF0ZS5TVEFSVElORztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubmV4dExvYWRQb3NpdGlvbiA9IHRoaXMuc3RhcnRQb3NpdGlvbiA9IHRoaXMubGFzdEN1cnJlbnRUaW1lO1xuICAgICAgICAgICAgdGhpcy50aWNrKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0UG9zaXRpb24gPSBzdGFydFBvc2l0aW9uO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IGJhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfMS5TdGF0ZS5TVE9QUEVEO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQXVkaW9TdHJlYW1Db250cm9sbGVyLnByb3RvdHlwZSwgXCJzdGF0ZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N0YXRlO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChuZXh0U3RhdGUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlICE9PSBuZXh0U3RhdGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJldmlvdXNTdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhdGUgPSBuZXh0U3RhdGU7XG4gICAgICAgICAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLmxvZyhcImF1ZGlvIHN0cmVhbTpcIiArIHByZXZpb3VzU3RhdGUgKyBcIi0+XCIgKyBuZXh0U3RhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBBdWRpb1N0cmVhbUNvbnRyb2xsZXIucHJvdG90eXBlLmRvVGljayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHBvcywgdHJhY2ssIHRyYWNrRGV0YWlscywgaGxzID0gdGhpcy5obHMsIGNvbmZpZyA9IGhscy5jb25maWc7XG4gICAgICAgIC8vIGxvZ2dlci5sb2coJ2F1ZGlvU3RyZWFtOicgKyB0aGlzLnN0YXRlKTtcbiAgICAgICAgc3dpdGNoICh0aGlzLnN0YXRlKSB7XG4gICAgICAgICAgICBjYXNlIGJhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfMS5TdGF0ZS5FUlJPUjpcbiAgICAgICAgICAgIC8vIGRvbid0IGRvIGFueXRoaW5nIGluIGVycm9yIHN0YXRlIHRvIGF2b2lkIGJyZWFraW5nIGZ1cnRoZXIgLi4uXG4gICAgICAgICAgICBjYXNlIGJhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfMS5TdGF0ZS5QQVVTRUQ6XG4gICAgICAgICAgICAvLyBkb24ndCBkbyBhbnl0aGluZyBpbiBwYXVzZWQgc3RhdGUgZWl0aGVyIC4uLlxuICAgICAgICAgICAgY2FzZSBiYXNlX3N0cmVhbV9jb250cm9sbGVyXzEuU3RhdGUuQlVGRkVSX0ZMVVNISU5HOlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBiYXNlX3N0cmVhbV9jb250cm9sbGVyXzEuU3RhdGUuU1RBUlRJTkc6XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IGJhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfMS5TdGF0ZS5XQUlUSU5HX1RSQUNLO1xuICAgICAgICAgICAgICAgIHRoaXMubG9hZGVkbWV0YWRhdGEgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgYmFzZV9zdHJlYW1fY29udHJvbGxlcl8xLlN0YXRlLklETEU6XG4gICAgICAgICAgICAgICAgdmFyIHRyYWNrcyA9IHRoaXMudHJhY2tzO1xuICAgICAgICAgICAgICAgIC8vIGF1ZGlvIHRyYWNrcyBub3QgcmVjZWl2ZWQgPT4gZXhpdCBsb29wXG4gICAgICAgICAgICAgICAgaWYgKCF0cmFja3MpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGlmIHZpZGVvIG5vdCBhdHRhY2hlZCBBTkRcbiAgICAgICAgICAgICAgICAvLyBzdGFydCBmcmFnbWVudCBhbHJlYWR5IHJlcXVlc3RlZCBPUiBzdGFydCBmcmFnIHByZWZldGNoIGRpc2FibGVcbiAgICAgICAgICAgICAgICAvLyBleGl0IGxvb3BcbiAgICAgICAgICAgICAgICAvLyA9PiBpZiBtZWRpYSBub3QgYXR0YWNoZWQgYnV0IHN0YXJ0IGZyYWcgcHJlZmV0Y2ggaXMgZW5hYmxlZCBhbmQgc3RhcnQgZnJhZyBub3QgcmVxdWVzdGVkIHlldCwgd2Ugd2lsbCBub3QgZXhpdCBsb29wXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLm1lZGlhICYmXG4gICAgICAgICAgICAgICAgICAgICh0aGlzLnN0YXJ0RnJhZ1JlcXVlc3RlZCB8fCAhY29uZmlnLnN0YXJ0RnJhZ1ByZWZldGNoKSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gZGV0ZXJtaW5lIG5leHQgY2FuZGlkYXRlIGZyYWdtZW50IHRvIGJlIGxvYWRlZCwgYmFzZWQgb24gY3VycmVudCBwb3NpdGlvbiBhbmRcbiAgICAgICAgICAgICAgICAvLyAgZW5kIG9mIGJ1ZmZlciBwb3NpdGlvblxuICAgICAgICAgICAgICAgIC8vIGlmIHdlIGhhdmUgbm90IHlldCBsb2FkZWQgYW55IGZyYWdtZW50LCBzdGFydCBsb2FkaW5nIGZyb20gc3RhcnQgcG9zaXRpb25cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5sb2FkZWRtZXRhZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICBwb3MgPSB0aGlzLm1lZGlhLmN1cnJlbnRUaW1lO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zID0gdGhpcy5uZXh0TG9hZFBvc2l0aW9uO1xuICAgICAgICAgICAgICAgICAgICBpZiAocG9zID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBtZWRpYSA9IHRoaXMubWVkaWFCdWZmZXIgPyB0aGlzLm1lZGlhQnVmZmVyIDogdGhpcy5tZWRpYSwgdmlkZW9CdWZmZXIgPSB0aGlzLnZpZGVvQnVmZmVyID8gdGhpcy52aWRlb0J1ZmZlciA6IHRoaXMubWVkaWEsIGJ1ZmZlckluZm8gPSBidWZmZXJfaGVscGVyXzEuQnVmZmVySGVscGVyLmJ1ZmZlckluZm8obWVkaWEsIHBvcywgY29uZmlnLm1heEJ1ZmZlckhvbGUpLCBtYWluQnVmZmVySW5mbyA9IGJ1ZmZlcl9oZWxwZXJfMS5CdWZmZXJIZWxwZXIuYnVmZmVySW5mbyh2aWRlb0J1ZmZlciwgcG9zLCBjb25maWcubWF4QnVmZmVySG9sZSksIGJ1ZmZlckxlbiA9IGJ1ZmZlckluZm8ubGVuLCBidWZmZXJFbmRfMSA9IGJ1ZmZlckluZm8uZW5kLCBmcmFnUHJldmlvdXMgPSB0aGlzLmZyYWdQcmV2aW91cywgXG4gICAgICAgICAgICAgICAgLy8gZW5zdXJlIHdlIGJ1ZmZlciBhdCBsZWFzdCBjb25maWcubWF4QnVmZmVyTGVuZ3RoIChkZWZhdWx0IDMwcykgb3IgY29uZmlnLm1heE1heEJ1ZmZlckxlbmd0aCAoZGVmYXVsdDogNjAwcylcbiAgICAgICAgICAgICAgICAvLyB3aGljaGV2ZXIgaXMgc21hbGxlci5cbiAgICAgICAgICAgICAgICAvLyBvbmNlIHdlIHJlYWNoIHRoYXQgdGhyZXNob2xkLCBkb24ndCBidWZmZXIgbW9yZSB0aGFuIHZpZGVvIChtYWluQnVmZmVySW5mby5sZW4pXG4gICAgICAgICAgICAgICAgbWF4Q29uZmlnQnVmZmVyID0gTWF0aC5taW4oY29uZmlnLm1heEJ1ZmZlckxlbmd0aCwgY29uZmlnLm1heE1heEJ1ZmZlckxlbmd0aCksIG1heEJ1ZkxlbiA9IE1hdGgubWF4KG1heENvbmZpZ0J1ZmZlciwgbWFpbkJ1ZmZlckluZm8ubGVuKSwgYXVkaW9Td2l0Y2ggPSB0aGlzLmF1ZGlvU3dpdGNoLCB0cmFja0lkID0gdGhpcy50cmFja0lkO1xuICAgICAgICAgICAgICAgIC8vIGlmIGJ1ZmZlciBsZW5ndGggaXMgbGVzcyB0aGFuIG1heEJ1ZkxlbiB0cnkgdG8gbG9hZCBhIG5ldyBmcmFnbWVudFxuICAgICAgICAgICAgICAgIGlmICgoYnVmZmVyTGVuIDwgbWF4QnVmTGVuIHx8IGF1ZGlvU3dpdGNoKSAmJiB0cmFja0lkIDwgdHJhY2tzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB0cmFja0RldGFpbHMgPSB0cmFja3NbdHJhY2tJZF0uZGV0YWlscztcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdHJhY2sgaW5mbyBub3QgcmV0cmlldmVkIHlldCwgc3dpdGNoIHN0YXRlIGFuZCB3YWl0IGZvciB0cmFjayByZXRyaWV2YWxcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0cmFja0RldGFpbHMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gYmFzZV9zdHJlYW1fY29udHJvbGxlcl8xLlN0YXRlLldBSVRJTkdfVFJBQ0s7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIWF1ZGlvU3dpdGNoICYmIHRoaXMuX3N0cmVhbUVuZGVkKGJ1ZmZlckluZm8sIHRyYWNrRGV0YWlscykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoZXZlbnRzXzEuZGVmYXVsdC5CVUZGRVJfRU9TLCB7IHR5cGU6ICdhdWRpbycgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gYmFzZV9zdHJlYW1fY29udHJvbGxlcl8xLlN0YXRlLkVOREVEO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIGZpbmQgZnJhZ21lbnQgaW5kZXgsIGNvbnRpZ3VvdXMgd2l0aCBlbmQgb2YgYnVmZmVyIHBvc2l0aW9uXG4gICAgICAgICAgICAgICAgICAgIHZhciBmcmFnbWVudHMgPSB0cmFja0RldGFpbHMuZnJhZ21lbnRzLCBmcmFnTGVuID0gZnJhZ21lbnRzLmxlbmd0aCwgc3RhcnQgPSBmcmFnbWVudHNbMF0uc3RhcnQsIGVuZCA9IGZyYWdtZW50c1tmcmFnTGVuIC0gMV0uc3RhcnQgKyBmcmFnbWVudHNbZnJhZ0xlbiAtIDFdLmR1cmF0aW9uLCBmcmFnID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgICAgICAvLyBXaGVuIHN3aXRjaGluZyBhdWRpbyB0cmFjaywgcmVsb2FkIGF1ZGlvIGFzIGNsb3NlIGFzIHBvc3NpYmxlIHRvIGN1cnJlbnRUaW1lXG4gICAgICAgICAgICAgICAgICAgIGlmIChhdWRpb1N3aXRjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRyYWNrRGV0YWlscy5saXZlICYmICF0cmFja0RldGFpbHMuUFRTS25vd24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXJfMS5sb2dnZXIubG9nKCdzd2l0Y2hpbmcgYXVkaW90cmFjaywgbGl2ZSBzdHJlYW0sIHVua25vd24gUFRTLGxvYWQgZmlyc3QgZnJhZ21lbnQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBidWZmZXJFbmRfMSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBidWZmZXJFbmRfMSA9IHBvcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiBjdXJyZW50VGltZSAocG9zKSBpcyBsZXNzIHRoYW4gYWx0IGF1ZGlvIHBsYXlsaXN0IHN0YXJ0IHRpbWUsIGl0IG1lYW5zIHRoYXQgYWx0IGF1ZGlvIGlzIGFoZWFkIG9mIGN1cnJlbnRUaW1lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRyYWNrRGV0YWlscy5QVFNLbm93biAmJiBwb3MgPCBzdGFydCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiBldmVyeXRoaW5nIGlzIGJ1ZmZlcmVkIGZyb20gcG9zIHRvIHN0YXJ0IG9yIGlmIGF1ZGlvIGJ1ZmZlciB1cGZyb250LCBsZXQncyBzZWVrIHRvIHN0YXJ0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChidWZmZXJJbmZvLmVuZCA+IHN0YXJ0IHx8IGJ1ZmZlckluZm8ubmV4dFN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXJfMS5sb2dnZXIubG9nKCdhbHQgYXVkaW8gdHJhY2sgYWhlYWQgb2YgbWFpbiB0cmFjaywgc2VlayB0byBzdGFydCBvZiBhbHQgYXVkaW8gdHJhY2snKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWVkaWEuY3VycmVudFRpbWUgPSBzdGFydCArIDAuMDU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRyYWNrRGV0YWlscy5pbml0U2VnbWVudCAmJiAhdHJhY2tEZXRhaWxzLmluaXRTZWdtZW50LmRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyYWcgPSB0cmFja0RldGFpbHMuaW5pdFNlZ21lbnQ7XG4gICAgICAgICAgICAgICAgICAgIH0gLy8gZXNsaW50LWRpc2FibGUtbGluZSBicmFjZS1zdHlsZVxuICAgICAgICAgICAgICAgICAgICAvLyBpZiBidWZmZXJFbmQgYmVmb3JlIHN0YXJ0IG9mIHBsYXlsaXN0LCBsb2FkIGZpcnN0IGZyYWdtZW50XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGJ1ZmZlckVuZF8xIDw9IHN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmcmFnID0gZnJhZ21lbnRzWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMudmlkZW9UcmFja0NDICE9PSBudWxsICYmIGZyYWcuY2MgIT09IHRoaXMudmlkZW9UcmFja0NDKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRW5zdXJlIHdlIGZpbmQgYSBmcmFnbWVudCB3aGljaCBtYXRjaGVzIHRoZSBjb250aW51aXR5IG9mIHRoZSB2aWRlbyB0cmFja1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyYWcgPSBkaXNjb250aW51aXRpZXNfMS5maW5kRnJhZ1dpdGhDQyhmcmFnbWVudHMsIHRoaXMudmlkZW9UcmFja0NDKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0cmFja0RldGFpbHMubGl2ZSAmJiBmcmFnLmxvYWRJZHggJiYgZnJhZy5sb2FkSWR4ID09PSB0aGlzLmZyYWdMb2FkSWR4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2UganVzdCBsb2FkZWQgdGhpcyBmaXJzdCBmcmFnbWVudCwgYW5kIHdlIGFyZSBzdGlsbCBsYWdnaW5nIGJlaGluZCB0aGUgc3RhcnQgb2YgdGhlIGxpdmUgcGxheWxpc3RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBsZXQncyBmb3JjZSBzZWVrIHRvIHN0YXJ0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5leHRCdWZmZXJlZCA9IGJ1ZmZlckluZm8ubmV4dFN0YXJ0ID8gYnVmZmVySW5mby5uZXh0U3RhcnQgOiBzdGFydDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXJfMS5sb2dnZXIubG9nKFwibm8gYWx0IGF1ZGlvIGF2YWlsYWJsZSBAY3VycmVudFRpbWU6XCIgKyB0aGlzLm1lZGlhLmN1cnJlbnRUaW1lICsgXCIsIHNlZWtpbmcgQFwiICsgKG5leHRCdWZmZXJlZCArIDAuMDUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1lZGlhLmN1cnJlbnRUaW1lID0gbmV4dEJ1ZmZlcmVkICsgMC4wNTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZm91bmRGcmFnID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1heEZyYWdMb29rVXBUb2xlcmFuY2VfMSA9IGNvbmZpZy5tYXhGcmFnTG9va1VwVG9sZXJhbmNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZyYWdOZXh0ID0gZnJhZ1ByZXZpb3VzID8gZnJhZ21lbnRzW2ZyYWdQcmV2aW91cy5zbiAtIGZyYWdtZW50c1swXS5zbiArIDFdIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZyYWdtZW50V2l0aGluVG9sZXJhbmNlVGVzdCA9IGZ1bmN0aW9uIChjYW5kaWRhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBvZmZzZXQgc2hvdWxkIGJlIHdpdGhpbiBmcmFnbWVudCBib3VuZGFyeSAtIGNvbmZpZy5tYXhGcmFnTG9va1VwVG9sZXJhbmNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyBpcyB0byBjb3BlIHdpdGggc2l0dWF0aW9ucyBsaWtlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYnVmZmVyRW5kID0gOS45OTFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBmcmFnW8OYXSA6IFswLDEwXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZyYWdbMV0gOiBbMTAsMjBdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYnVmZmVyRW5kIGlzIHdpdGhpbiBmcmFnWzBdIHJhbmdlIC4uLiBhbHRob3VnaCB3aGF0IHdlIGFyZSBleHBlY3RpbmcgaXMgdG8gcmV0dXJuIGZyYWdbMV0gaGVyZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgICBmcmFnIHN0YXJ0ICAgICAgICAgICAgICAgZnJhZyBzdGFydCtkdXJhdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgICAgfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgICA8LS0tPiAgICAgICAgICAgICAgICAgICAgICAgICA8LS0tPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAuLi4tLS0tLS0tLT48LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0+PC0tLS0tLS0tLS4uLi5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBwcmV2aW91cyBmcmFnICAgICAgICAgbWF0Y2hpbmcgZnJhZ21lbnQgICAgICAgICBuZXh0IGZyYWdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgcmV0dXJuIC0xICAgICAgICAgICAgIHJldHVybiAwICAgICAgICAgICAgICAgICByZXR1cm4gMVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGxvZ2dlci5sb2coYGxldmVsL3NuL3N0YXJ0L2VuZC9idWZFbmQ6JHtsZXZlbH0vJHtjYW5kaWRhdGUuc259LyR7Y2FuZGlkYXRlLnN0YXJ0fS8keyhjYW5kaWRhdGUuc3RhcnQrY2FuZGlkYXRlLmR1cmF0aW9uKX0vJHtidWZmZXJFbmR9YCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2V0IHRoZSBsb29rdXAgdG9sZXJhbmNlIHRvIGJlIHNtYWxsIGVub3VnaCB0byBkZXRlY3QgdGhlIGN1cnJlbnQgc2VnbWVudCAtIGVuc3VyZXMgd2UgZG9uJ3Qgc2tpcCBvdmVyIHZlcnkgc21hbGwgc2VnbWVudHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2FuZGlkYXRlTG9va3VwVG9sZXJhbmNlID0gTWF0aC5taW4obWF4RnJhZ0xvb2tVcFRvbGVyYW5jZV8xLCBjYW5kaWRhdGUuZHVyYXRpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoY2FuZGlkYXRlLnN0YXJ0ICsgY2FuZGlkYXRlLmR1cmF0aW9uIC0gY2FuZGlkYXRlTG9va3VwVG9sZXJhbmNlKSA8PSBidWZmZXJFbmRfMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY2FuZGlkYXRlLnN0YXJ0IC0gY2FuZGlkYXRlTG9va3VwVG9sZXJhbmNlID4gYnVmZmVyRW5kXzEgJiYgY2FuZGlkYXRlLnN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIG1heEZyYWdMb29rVXBUb2xlcmFuY2Ugd2lsbCBoYXZlIG5lZ2F0aXZlIHZhbHVlIHRoZW4gZG9uJ3QgcmV0dXJuIC0xIGZvciBmaXJzdCBlbGVtZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJ1ZmZlckVuZF8xIDwgZW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJ1ZmZlckVuZF8xID4gZW5kIC0gbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZV8xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heEZyYWdMb29rVXBUb2xlcmFuY2VfMSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFByZWZlciB0aGUgbmV4dCBmcmFnbWVudCBpZiBpdCdzIHdpdGhpbiB0b2xlcmFuY2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZnJhZ05leHQgJiYgIWZyYWdtZW50V2l0aGluVG9sZXJhbmNlVGVzdChmcmFnTmV4dCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm91bmRGcmFnID0gZnJhZ05leHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3VuZEZyYWcgPSBiaW5hcnlfc2VhcmNoXzEuZGVmYXVsdC5zZWFyY2goZnJhZ21lbnRzLCBmcmFnbWVudFdpdGhpblRvbGVyYW5jZVRlc3QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlYWNoIGVuZCBvZiBwbGF5bGlzdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvdW5kRnJhZyA9IGZyYWdtZW50c1tmcmFnTGVuIC0gMV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZm91bmRGcmFnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJhZyA9IGZvdW5kRnJhZztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydCA9IGZvdW5kRnJhZy5zdGFydDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBsb2dnZXIubG9nKCdmaW5kIFNOIG1hdGNoaW5nIHdpdGggcG9zOicgKyAgYnVmZmVyRW5kICsgJzonICsgZnJhZy5zbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZyYWdQcmV2aW91cyAmJiBmcmFnLmxldmVsID09PSBmcmFnUHJldmlvdXMubGV2ZWwgJiYgZnJhZy5zbiA9PT0gZnJhZ1ByZXZpb3VzLnNuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmcmFnLnNuIDwgdHJhY2tEZXRhaWxzLmVuZFNOKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcmFnID0gZnJhZ21lbnRzW2ZyYWcuc24gKyAxIC0gdHJhY2tEZXRhaWxzLnN0YXJ0U05dO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLmxvZyhcIlNOIGp1c3QgbG9hZGVkLCBsb2FkIG5leHQgb25lOiBcIiArIGZyYWcuc24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJhZyA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGZyYWcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGxvZ2dlci5sb2coJyAgICAgIGxvYWRpbmcgZnJhZyAnICsgaSArJyxwb3MvYnVmRW5kOicgKyBwb3MudG9GaXhlZCgzKSArICcvJyArIGJ1ZmZlckVuZC50b0ZpeGVkKDMpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmcmFnLmVuY3J5cHRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmxvZ2dlci5sb2coXCJMb2FkaW5nIGtleSBmb3IgXCIgKyBmcmFnLnNuICsgXCIgb2YgW1wiICsgdHJhY2tEZXRhaWxzLnN0YXJ0U04gKyBcIiAsXCIgKyB0cmFja0RldGFpbHMuZW5kU04gKyBcIl0sdHJhY2sgXCIgKyB0cmFja0lkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gYmFzZV9zdHJlYW1fY29udHJvbGxlcl8xLlN0YXRlLktFWV9MT0FESU5HO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhscy50cmlnZ2VyKGV2ZW50c18xLmRlZmF1bHQuS0VZX0xPQURJTkcsIHsgZnJhZzogZnJhZyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmxvZ2dlci5sb2coXCJMb2FkaW5nIFwiICsgZnJhZy5zbiArIFwiLCBjYzogXCIgKyBmcmFnLmNjICsgXCIgb2YgW1wiICsgdHJhY2tEZXRhaWxzLnN0YXJ0U04gKyBcIiAsXCIgKyB0cmFja0RldGFpbHMuZW5kU04gKyBcIl0sdHJhY2sgXCIgKyB0cmFja0lkICsgXCIsIGN1cnJlbnRUaW1lOlwiICsgcG9zICsgXCIsYnVmZmVyRW5kOlwiICsgYnVmZmVyRW5kXzEudG9GaXhlZCgzKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gb25seSBsb2FkIGlmIGZyYWdtZW50IGlzIG5vdCBsb2FkZWQgb3IgaWYgaW4gYXVkaW8gc3dpdGNoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2UgZm9yY2UgYSBmcmFnIGxvYWRpbmcgaW4gYXVkaW8gc3dpdGNoIGFzIGZyYWdtZW50IHRyYWNrZXIgbWlnaHQgbm90IGhhdmUgZXZpY3RlZCBwcmV2aW91cyBmcmFncyBpbiBjYXNlIG9mIHF1aWNrIGF1ZGlvIHN3aXRjaFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZnJhZ0N1cnJlbnQgPSBmcmFnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhdWRpb1N3aXRjaCB8fCB0aGlzLmZyYWdtZW50VHJhY2tlci5nZXRTdGF0ZShmcmFnKSA9PT0gZnJhZ21lbnRfdHJhY2tlcl8xLkZyYWdtZW50U3RhdGUuTk9UX0xPQURFRCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0RnJhZ1JlcXVlc3RlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChOdW1iZXIuaXNGaW5pdGUoZnJhZy5zbikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubmV4dExvYWRQb3NpdGlvbiA9IGZyYWcuc3RhcnQgKyBmcmFnLmR1cmF0aW9uO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhscy50cmlnZ2VyKGV2ZW50c18xLmRlZmF1bHQuRlJBR19MT0FESU5HLCB7IGZyYWc6IGZyYWcgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBiYXNlX3N0cmVhbV9jb250cm9sbGVyXzEuU3RhdGUuRlJBR19MT0FESU5HO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgYmFzZV9zdHJlYW1fY29udHJvbGxlcl8xLlN0YXRlLldBSVRJTkdfVFJBQ0s6XG4gICAgICAgICAgICAgICAgdHJhY2sgPSB0aGlzLnRyYWNrc1t0aGlzLnRyYWNrSWRdO1xuICAgICAgICAgICAgICAgIC8vIGNoZWNrIGlmIHBsYXlsaXN0IGlzIGFscmVhZHkgbG9hZGVkXG4gICAgICAgICAgICAgICAgaWYgKHRyYWNrICYmIHRyYWNrLmRldGFpbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IGJhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfMS5TdGF0ZS5JRExFO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgYmFzZV9zdHJlYW1fY29udHJvbGxlcl8xLlN0YXRlLkZSQUdfTE9BRElOR19XQUlUSU5HX1JFVFJZOlxuICAgICAgICAgICAgICAgIHZhciBub3cgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgICAgICAgICB2YXIgcmV0cnlEYXRlID0gdGhpcy5yZXRyeURhdGU7XG4gICAgICAgICAgICAgICAgbWVkaWEgPSB0aGlzLm1lZGlhO1xuICAgICAgICAgICAgICAgIHZhciBpc1NlZWtpbmcgPSBtZWRpYSAmJiBtZWRpYS5zZWVraW5nO1xuICAgICAgICAgICAgICAgIC8vIGlmIGN1cnJlbnQgdGltZSBpcyBndCB0aGFuIHJldHJ5RGF0ZSwgb3IgaWYgbWVkaWEgc2Vla2luZyBsZXQncyBzd2l0Y2ggdG8gSURMRSBzdGF0ZSB0byByZXRyeSBsb2FkaW5nXG4gICAgICAgICAgICAgICAgaWYgKCFyZXRyeURhdGUgfHwgKG5vdyA+PSByZXRyeURhdGUpIHx8IGlzU2Vla2luZykge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXJfMS5sb2dnZXIubG9nKCdhdWRpb1N0cmVhbUNvbnRyb2xsZXI6IHJldHJ5RGF0ZSByZWFjaGVkLCBzd2l0Y2ggYmFjayB0byBJRExFIHN0YXRlJyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBiYXNlX3N0cmVhbV9jb250cm9sbGVyXzEuU3RhdGUuSURMRTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIGJhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfMS5TdGF0ZS5XQUlUSU5HX0lOSVRfUFRTOlxuICAgICAgICAgICAgICAgIHZhciB2aWRlb1RyYWNrQ0MgPSB0aGlzLnZpZGVvVHJhY2tDQztcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pbml0UFRTW3ZpZGVvVHJhY2tDQ10gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gRW5zdXJlIHdlIGRvbid0IGdldCBzdHVjayBpbiB0aGUgV0FJVElOR19JTklUX1BUUyBzdGF0ZSBpZiB0aGUgd2FpdGluZyBmcmFnIENDIGRvZXNuJ3QgbWF0Y2ggYW55IGluaXRQVFNcbiAgICAgICAgICAgICAgICB2YXIgd2FpdGluZ0ZyYWcgPSB0aGlzLndhaXRpbmdGcmFnbWVudDtcbiAgICAgICAgICAgICAgICBpZiAod2FpdGluZ0ZyYWcpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHdhaXRpbmdGcmFnQ0MgPSB3YWl0aW5nRnJhZy5mcmFnLmNjO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmlkZW9UcmFja0NDICE9PSB3YWl0aW5nRnJhZ0NDKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFjayA9IHRoaXMudHJhY2tzW3RoaXMudHJhY2tJZF07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHJhY2suZGV0YWlscyAmJiB0cmFjay5kZXRhaWxzLmxpdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXJfMS5sb2dnZXIud2FybihcIldhaXRpbmcgZnJhZ21lbnQgQ0MgKFwiICsgd2FpdGluZ0ZyYWdDQyArIFwiKSBkb2VzIG5vdCBtYXRjaCB2aWRlbyB0cmFjayBDQyAoXCIgKyB2aWRlb1RyYWNrQ0MgKyBcIilcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy53YWl0aW5nRnJhZ21lbnQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBiYXNlX3N0cmVhbV9jb250cm9sbGVyXzEuU3RhdGUuSURMRTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBiYXNlX3N0cmVhbV9jb250cm9sbGVyXzEuU3RhdGUuRlJBR19MT0FESU5HO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vbkZyYWdMb2FkZWQodGhpcy53YWl0aW5nRnJhZ21lbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy53YWl0aW5nRnJhZ21lbnQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gYmFzZV9zdHJlYW1fY29udHJvbGxlcl8xLlN0YXRlLklETEU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBiYXNlX3N0cmVhbV9jb250cm9sbGVyXzEuU3RhdGUuU1RPUFBFRDpcbiAgICAgICAgICAgIGNhc2UgYmFzZV9zdHJlYW1fY29udHJvbGxlcl8xLlN0YXRlLkZSQUdfTE9BRElORzpcbiAgICAgICAgICAgIGNhc2UgYmFzZV9zdHJlYW1fY29udHJvbGxlcl8xLlN0YXRlLlBBUlNJTkc6XG4gICAgICAgICAgICBjYXNlIGJhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfMS5TdGF0ZS5QQVJTRUQ6XG4gICAgICAgICAgICBjYXNlIGJhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfMS5TdGF0ZS5FTkRFRDpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEF1ZGlvU3RyZWFtQ29udHJvbGxlci5wcm90b3R5cGUub25NZWRpYUF0dGFjaGVkID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdmFyIG1lZGlhID0gdGhpcy5tZWRpYSA9IHRoaXMubWVkaWFCdWZmZXIgPSBkYXRhLm1lZGlhO1xuICAgICAgICB0aGlzLm9udnNlZWtpbmcgPSB0aGlzLm9uTWVkaWFTZWVraW5nLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub252ZW5kZWQgPSB0aGlzLm9uTWVkaWFFbmRlZC5iaW5kKHRoaXMpO1xuICAgICAgICBtZWRpYS5hZGRFdmVudExpc3RlbmVyKCdzZWVraW5nJywgdGhpcy5vbnZzZWVraW5nKTtcbiAgICAgICAgbWVkaWEuYWRkRXZlbnRMaXN0ZW5lcignZW5kZWQnLCB0aGlzLm9udmVuZGVkKTtcbiAgICAgICAgdmFyIGNvbmZpZyA9IHRoaXMuY29uZmlnO1xuICAgICAgICBpZiAodGhpcy50cmFja3MgJiYgY29uZmlnLmF1dG9TdGFydExvYWQpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhcnRMb2FkKGNvbmZpZy5zdGFydFBvc2l0aW9uKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQXVkaW9TdHJlYW1Db250cm9sbGVyLnByb3RvdHlwZS5vbk1lZGlhRGV0YWNoaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbWVkaWEgPSB0aGlzLm1lZGlhO1xuICAgICAgICBpZiAobWVkaWEgJiYgbWVkaWEuZW5kZWQpIHtcbiAgICAgICAgICAgIGxvZ2dlcl8xLmxvZ2dlci5sb2coJ01TRSBkZXRhY2hpbmcgYW5kIHZpZGVvIGVuZGVkLCByZXNldCBzdGFydFBvc2l0aW9uJyk7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0UG9zaXRpb24gPSB0aGlzLmxhc3RDdXJyZW50VGltZSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmVtb3ZlIHZpZGVvIGxpc3RlbmVyc1xuICAgICAgICBpZiAobWVkaWEpIHtcbiAgICAgICAgICAgIG1lZGlhLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3NlZWtpbmcnLCB0aGlzLm9udnNlZWtpbmcpO1xuICAgICAgICAgICAgbWVkaWEucmVtb3ZlRXZlbnRMaXN0ZW5lcignZW5kZWQnLCB0aGlzLm9udmVuZGVkKTtcbiAgICAgICAgICAgIHRoaXMub252c2Vla2luZyA9IHRoaXMub252c2Vla2VkID0gdGhpcy5vbnZlbmRlZCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tZWRpYSA9IHRoaXMubWVkaWFCdWZmZXIgPSB0aGlzLnZpZGVvQnVmZmVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5sb2FkZWRtZXRhZGF0YSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnN0b3BMb2FkKCk7XG4gICAgfTtcbiAgICBBdWRpb1N0cmVhbUNvbnRyb2xsZXIucHJvdG90eXBlLm9uQXVkaW9UcmFja3NVcGRhdGVkID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLmxvZygnYXVkaW8gdHJhY2tzIHVwZGF0ZWQnKTtcbiAgICAgICAgdGhpcy50cmFja3MgPSBkYXRhLmF1ZGlvVHJhY2tzO1xuICAgIH07XG4gICAgQXVkaW9TdHJlYW1Db250cm9sbGVyLnByb3RvdHlwZS5vbkF1ZGlvVHJhY2tTd2l0Y2hpbmcgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAvLyBpZiBhbnkgVVJMIGZvdW5kIG9uIG5ldyBhdWRpbyB0cmFjaywgaXQgaXMgYW4gYWx0ZXJuYXRlIGF1ZGlvIHRyYWNrXG4gICAgICAgIHZhciBhbHRBdWRpbyA9ICEhZGF0YS51cmw7XG4gICAgICAgIHRoaXMudHJhY2tJZCA9IGRhdGEuaWQ7XG4gICAgICAgIHRoaXMuZnJhZ0N1cnJlbnQgPSBudWxsO1xuICAgICAgICB0aGlzLnN0YXRlID0gYmFzZV9zdHJlYW1fY29udHJvbGxlcl8xLlN0YXRlLlBBVVNFRDtcbiAgICAgICAgdGhpcy53YWl0aW5nRnJhZ21lbnQgPSBudWxsO1xuICAgICAgICAvLyBkZXN0cm95IHVzZWxlc3MgZGVtdXhlciB3aGVuIHN3aXRjaGluZyBhdWRpbyB0byBtYWluXG4gICAgICAgIGlmICghYWx0QXVkaW8pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRlbXV4ZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRlbXV4ZXIuZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuZGVtdXhlciA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBzd2l0Y2hpbmcgdG8gYXVkaW8gdHJhY2ssIHN0YXJ0IHRpbWVyIGlmIG5vdCBhbHJlYWR5IHN0YXJ0ZWRcbiAgICAgICAgICAgIHRoaXMuc2V0SW50ZXJ2YWwoVElDS19JTlRFUlZBTCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2hvdWxkIHdlIHN3aXRjaCB0cmFja3MgP1xuICAgICAgICBpZiAoYWx0QXVkaW8pIHtcbiAgICAgICAgICAgIHRoaXMuYXVkaW9Td2l0Y2ggPSB0cnVlO1xuICAgICAgICAgICAgLy8gbWFpbiBhdWRpbyB0cmFjayBhcmUgaGFuZGxlZCBieSBzdHJlYW0tY29udHJvbGxlciwganVzdCBkbyBzb21ldGhpbmcgaWYgc3dpdGNoaW5nIHRvIGFsdCBhdWRpbyB0cmFja1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IGJhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfMS5TdGF0ZS5JRExFO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudGljaygpO1xuICAgIH07XG4gICAgQXVkaW9TdHJlYW1Db250cm9sbGVyLnByb3RvdHlwZS5vbkF1ZGlvVHJhY2tMb2FkZWQgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB2YXIgbmV3RGV0YWlscyA9IGRhdGEuZGV0YWlscywgdHJhY2tJZCA9IGRhdGEuaWQsIHRyYWNrID0gdGhpcy50cmFja3NbdHJhY2tJZF0sIGR1cmF0aW9uID0gbmV3RGV0YWlscy50b3RhbGR1cmF0aW9uLCBzbGlkaW5nID0gMDtcbiAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLmxvZyhcInRyYWNrIFwiICsgdHJhY2tJZCArIFwiIGxvYWRlZCBbXCIgKyBuZXdEZXRhaWxzLnN0YXJ0U04gKyBcIixcIiArIG5ld0RldGFpbHMuZW5kU04gKyBcIl0sZHVyYXRpb246XCIgKyBkdXJhdGlvbik7XG4gICAgICAgIGlmIChuZXdEZXRhaWxzLmxpdmUpIHtcbiAgICAgICAgICAgIHZhciBjdXJEZXRhaWxzID0gdHJhY2suZGV0YWlscztcbiAgICAgICAgICAgIGlmIChjdXJEZXRhaWxzICYmIG5ld0RldGFpbHMuZnJhZ21lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAvLyB3ZSBhbHJlYWR5IGhhdmUgZGV0YWlscyBmb3IgdGhhdCBsZXZlbCwgbWVyZ2UgdGhlbVxuICAgICAgICAgICAgICAgIExldmVsSGVscGVyLm1lcmdlRGV0YWlscyhjdXJEZXRhaWxzLCBuZXdEZXRhaWxzKTtcbiAgICAgICAgICAgICAgICBzbGlkaW5nID0gbmV3RGV0YWlscy5mcmFnbWVudHNbMF0uc3RhcnQ7XG4gICAgICAgICAgICAgICAgLy8gVE9ET1xuICAgICAgICAgICAgICAgIC8vIHRoaXMubGl2ZVN5bmNQb3NpdGlvbiA9IHRoaXMuY29tcHV0ZUxpdmVQb3NpdGlvbihzbGlkaW5nLCBjdXJEZXRhaWxzKTtcbiAgICAgICAgICAgICAgICBpZiAobmV3RGV0YWlscy5QVFNLbm93bikge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXJfMS5sb2dnZXIubG9nKFwibGl2ZSBhdWRpbyBwbGF5bGlzdCBzbGlkaW5nOlwiICsgc2xpZGluZy50b0ZpeGVkKDMpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmxvZ2dlci5sb2coJ2xpdmUgYXVkaW8gcGxheWxpc3QgLSBvdXRkYXRlZCBQVFMsIHVua25vd24gc2xpZGluZycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG5ld0RldGFpbHMuUFRTS25vd24gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBsb2dnZXJfMS5sb2dnZXIubG9nKCdsaXZlIGF1ZGlvIHBsYXlsaXN0IC0gZmlyc3QgbG9hZCwgdW5rbm93biBzbGlkaW5nJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBuZXdEZXRhaWxzLlBUU0tub3duID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdHJhY2suZGV0YWlscyA9IG5ld0RldGFpbHM7XG4gICAgICAgIC8vIGNvbXB1dGUgc3RhcnQgcG9zaXRpb25cbiAgICAgICAgaWYgKCF0aGlzLnN0YXJ0RnJhZ1JlcXVlc3RlZCkge1xuICAgICAgICAgICAgLy8gY29tcHV0ZSBzdGFydCBwb3NpdGlvbiBpZiBzZXQgdG8gLTEuIHVzZSBpdCBzdHJhaWdodCBhd2F5IGlmIHZhbHVlIGlzIGRlZmluZWRcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXJ0UG9zaXRpb24gPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgLy8gZmlyc3QsIGNoZWNrIGlmIHN0YXJ0IHRpbWUgb2Zmc2V0IGhhcyBiZWVuIHNldCBpbiBwbGF5bGlzdCwgaWYgeWVzLCB1c2UgdGhpcyB2YWx1ZVxuICAgICAgICAgICAgICAgIHZhciBzdGFydFRpbWVPZmZzZXQgPSBuZXdEZXRhaWxzLnN0YXJ0VGltZU9mZnNldDtcbiAgICAgICAgICAgICAgICBpZiAoTnVtYmVyLmlzRmluaXRlKHN0YXJ0VGltZU9mZnNldCkpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLmxvZyhcInN0YXJ0IHRpbWUgb2Zmc2V0IGZvdW5kIGluIHBsYXlsaXN0LCBhZGp1c3Qgc3RhcnRQb3NpdGlvbiB0byBcIiArIHN0YXJ0VGltZU9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRQb3NpdGlvbiA9IHN0YXJ0VGltZU9mZnNldDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRQb3NpdGlvbiA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5uZXh0TG9hZFBvc2l0aW9uID0gdGhpcy5zdGFydFBvc2l0aW9uO1xuICAgICAgICB9XG4gICAgICAgIC8vIG9ubHkgc3dpdGNoIGJhdGNrIHRvIElETEUgc3RhdGUgaWYgd2Ugd2VyZSB3YWl0aW5nIGZvciB0cmFjayB0byBzdGFydCBkb3dubG9hZGluZyBhIG5ldyBmcmFnbWVudFxuICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gYmFzZV9zdHJlYW1fY29udHJvbGxlcl8xLlN0YXRlLldBSVRJTkdfVFJBQ0spIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBiYXNlX3N0cmVhbV9jb250cm9sbGVyXzEuU3RhdGUuSURMRTtcbiAgICAgICAgfVxuICAgICAgICAvLyB0cmlnZ2VyIGhhbmRsZXIgcmlnaHQgbm93XG4gICAgICAgIHRoaXMudGljaygpO1xuICAgIH07XG4gICAgQXVkaW9TdHJlYW1Db250cm9sbGVyLnByb3RvdHlwZS5vbktleUxvYWRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IGJhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfMS5TdGF0ZS5LRVlfTE9BRElORykge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IGJhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfMS5TdGF0ZS5JRExFO1xuICAgICAgICAgICAgdGhpcy50aWNrKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEF1ZGlvU3RyZWFtQ29udHJvbGxlci5wcm90b3R5cGUub25GcmFnTG9hZGVkID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdmFyIGZyYWdDdXJyZW50ID0gdGhpcy5mcmFnQ3VycmVudCwgZnJhZ0xvYWRlZCA9IGRhdGEuZnJhZztcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IGJhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfMS5TdGF0ZS5GUkFHX0xPQURJTkcgJiZcbiAgICAgICAgICAgIGZyYWdDdXJyZW50ICYmXG4gICAgICAgICAgICBmcmFnTG9hZGVkLnR5cGUgPT09ICdhdWRpbycgJiZcbiAgICAgICAgICAgIGZyYWdMb2FkZWQubGV2ZWwgPT09IGZyYWdDdXJyZW50LmxldmVsICYmXG4gICAgICAgICAgICBmcmFnTG9hZGVkLnNuID09PSBmcmFnQ3VycmVudC5zbikge1xuICAgICAgICAgICAgdmFyIHRyYWNrID0gdGhpcy50cmFja3NbdGhpcy50cmFja0lkXSwgZGV0YWlscyA9IHRyYWNrLmRldGFpbHMsIGR1cmF0aW9uID0gZGV0YWlscy50b3RhbGR1cmF0aW9uLCB0cmFja0lkID0gZnJhZ0N1cnJlbnQubGV2ZWwsIHNuID0gZnJhZ0N1cnJlbnQuc24sIGNjID0gZnJhZ0N1cnJlbnQuY2MsIGF1ZGlvQ29kZWMgPSB0aGlzLmNvbmZpZy5kZWZhdWx0QXVkaW9Db2RlYyB8fCB0cmFjay5hdWRpb0NvZGVjIHx8ICdtcDRhLjQwLjInLCBzdGF0cyA9IHRoaXMuc3RhdHMgPSBkYXRhLnN0YXRzO1xuICAgICAgICAgICAgaWYgKHNuID09PSAnaW5pdFNlZ21lbnQnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IGJhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfMS5TdGF0ZS5JRExFO1xuICAgICAgICAgICAgICAgIHN0YXRzLnRwYXJzZWQgPSBzdGF0cy50YnVmZmVyZWQgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgICAgICAgICBkZXRhaWxzLmluaXRTZWdtZW50LmRhdGEgPSBkYXRhLnBheWxvYWQ7XG4gICAgICAgICAgICAgICAgdGhpcy5obHMudHJpZ2dlcihldmVudHNfMS5kZWZhdWx0LkZSQUdfQlVGRkVSRUQsIHsgc3RhdHM6IHN0YXRzLCBmcmFnOiBmcmFnQ3VycmVudCwgaWQ6ICdhdWRpbycgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy50aWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gYmFzZV9zdHJlYW1fY29udHJvbGxlcl8xLlN0YXRlLlBBUlNJTkc7XG4gICAgICAgICAgICAgICAgLy8gdHJhbnNtdXggdGhlIE1QRUctVFMgZGF0YSB0byBJU08tQk1GRiBzZWdtZW50c1xuICAgICAgICAgICAgICAgIHRoaXMuYXBwZW5kZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuZGVtdXhlcikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlbXV4ZXIgPSBuZXcgZGVtdXhlcl8xLmRlZmF1bHQodGhpcy5obHMsICdhdWRpbycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiB3ZSBoYXZlIHZpZGVvIGluaXRQVFNcbiAgICAgICAgICAgICAgICAvLyBJZiBub3Qgd2UgbmVlZCB0byB3YWl0IGZvciBpdFxuICAgICAgICAgICAgICAgIHZhciBpbml0UFRTID0gdGhpcy5pbml0UFRTW2NjXTtcbiAgICAgICAgICAgICAgICB2YXIgaW5pdFNlZ21lbnREYXRhID0gZGV0YWlscy5pbml0U2VnbWVudCA/IGRldGFpbHMuaW5pdFNlZ21lbnQuZGF0YSA6IFtdO1xuICAgICAgICAgICAgICAgIGlmIChkZXRhaWxzLmluaXRTZWdtZW50IHx8IGluaXRQVFMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdCdWZmZXJpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXJfMS5sb2dnZXIubG9nKFwiRGVtdXhpbmcgXCIgKyBzbiArIFwiIG9mIFtcIiArIGRldGFpbHMuc3RhcnRTTiArIFwiICxcIiArIGRldGFpbHMuZW5kU04gKyBcIl0sdHJhY2sgXCIgKyB0cmFja0lkKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gdGltZSBPZmZzZXQgaXMgYWNjdXJhdGUgaWYgbGV2ZWwgUFRTIGlzIGtub3duLCBvciBpZiBwbGF5bGlzdCBpcyBub3Qgc2xpZGluZyAobm90IGxpdmUpXG4gICAgICAgICAgICAgICAgICAgIHZhciBhY2N1cmF0ZVRpbWVPZmZzZXQgPSBmYWxzZTsgLy8gZGV0YWlscy5QVFNLbm93biB8fCAhZGV0YWlscy5saXZlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlbXV4ZXIucHVzaChkYXRhLnBheWxvYWQsIGluaXRTZWdtZW50RGF0YSwgYXVkaW9Db2RlYywgbnVsbCwgZnJhZ0N1cnJlbnQsIGR1cmF0aW9uLCBhY2N1cmF0ZVRpbWVPZmZzZXQsIGluaXRQVFMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLmxvZyhcInVua25vd24gdmlkZW8gUFRTIGZvciBjb250aW51aXR5IGNvdW50ZXIgXCIgKyBjYyArIFwiLCB3YWl0aW5nIGZvciB2aWRlbyBQVFMgYmVmb3JlIGRlbXV4aW5nIGF1ZGlvIGZyYWcgXCIgKyBzbiArIFwiIG9mIFtcIiArIGRldGFpbHMuc3RhcnRTTiArIFwiICxcIiArIGRldGFpbHMuZW5kU04gKyBcIl0sdHJhY2sgXCIgKyB0cmFja0lkKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy53YWl0aW5nRnJhZ21lbnQgPSBkYXRhO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gYmFzZV9zdHJlYW1fY29udHJvbGxlcl8xLlN0YXRlLldBSVRJTkdfSU5JVF9QVFM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuZnJhZ0xvYWRFcnJvciA9IDA7XG4gICAgfTtcbiAgICBBdWRpb1N0cmVhbUNvbnRyb2xsZXIucHJvdG90eXBlLm9uRnJhZ1BhcnNpbmdJbml0U2VnbWVudCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHZhciBmcmFnQ3VycmVudCA9IHRoaXMuZnJhZ0N1cnJlbnQ7XG4gICAgICAgIHZhciBmcmFnTmV3ID0gZGF0YS5mcmFnO1xuICAgICAgICBpZiAoZnJhZ0N1cnJlbnQgJiZcbiAgICAgICAgICAgIGRhdGEuaWQgPT09ICdhdWRpbycgJiZcbiAgICAgICAgICAgIGZyYWdOZXcuc24gPT09IGZyYWdDdXJyZW50LnNuICYmXG4gICAgICAgICAgICBmcmFnTmV3LmxldmVsID09PSBmcmFnQ3VycmVudC5sZXZlbCAmJlxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9PT0gYmFzZV9zdHJlYW1fY29udHJvbGxlcl8xLlN0YXRlLlBBUlNJTkcpIHtcbiAgICAgICAgICAgIHZhciB0cmFja3MgPSBkYXRhLnRyYWNrcywgdHJhY2sgPSB2b2lkIDA7XG4gICAgICAgICAgICAvLyBkZWxldGUgYW55IHZpZGVvIHRyYWNrIGZvdW5kIG9uIGF1ZGlvIGRlbXV4ZXJcbiAgICAgICAgICAgIGlmICh0cmFja3MudmlkZW8pIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgdHJhY2tzLnZpZGVvO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaW5jbHVkZSBsZXZlbENvZGVjIGluIGF1ZGlvIGFuZCB2aWRlbyB0cmFja3NcbiAgICAgICAgICAgIHRyYWNrID0gdHJhY2tzLmF1ZGlvO1xuICAgICAgICAgICAgaWYgKHRyYWNrKSB7XG4gICAgICAgICAgICAgICAgdHJhY2subGV2ZWxDb2RlYyA9IHRyYWNrLmNvZGVjO1xuICAgICAgICAgICAgICAgIHRyYWNrLmlkID0gZGF0YS5pZDtcbiAgICAgICAgICAgICAgICB0aGlzLmhscy50cmlnZ2VyKGV2ZW50c18xLmRlZmF1bHQuQlVGRkVSX0NPREVDUywgdHJhY2tzKTtcbiAgICAgICAgICAgICAgICBsb2dnZXJfMS5sb2dnZXIubG9nKFwiYXVkaW8gdHJhY2s6YXVkaW8sY29udGFpbmVyOlwiICsgdHJhY2suY29udGFpbmVyICsgXCIsY29kZWNzW2xldmVsL3BhcnNlZF09W1wiICsgdHJhY2subGV2ZWxDb2RlYyArIFwiL1wiICsgdHJhY2suY29kZWMgKyBcIl1cIik7XG4gICAgICAgICAgICAgICAgdmFyIGluaXRTZWdtZW50ID0gdHJhY2suaW5pdFNlZ21lbnQ7XG4gICAgICAgICAgICAgICAgaWYgKGluaXRTZWdtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhcHBlbmRPYmogPSB7IHR5cGU6ICdhdWRpbycsIGRhdGE6IGluaXRTZWdtZW50LCBwYXJlbnQ6ICdhdWRpbycsIGNvbnRlbnQ6ICdpbml0U2VnbWVudCcgfTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuYXVkaW9Td2l0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ0RhdGEgPSBbYXBwZW5kT2JqXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXBwZW5kZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYXJtIHBlbmRpbmcgQnVmZmVyaW5nIGZsYWcgYmVmb3JlIGFwcGVuZGluZyBhIHNlZ21lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ0J1ZmZlcmluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhscy50cmlnZ2VyKGV2ZW50c18xLmRlZmF1bHQuQlVGRkVSX0FQUEVORElORywgYXBwZW5kT2JqKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyB0cmlnZ2VyIGhhbmRsZXIgcmlnaHQgbm93XG4gICAgICAgICAgICAgICAgdGhpcy50aWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEF1ZGlvU3RyZWFtQ29udHJvbGxlci5wcm90b3R5cGUub25GcmFnUGFyc2luZ0RhdGEgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgZnJhZ0N1cnJlbnQgPSB0aGlzLmZyYWdDdXJyZW50O1xuICAgICAgICB2YXIgZnJhZ05ldyA9IGRhdGEuZnJhZztcbiAgICAgICAgaWYgKGZyYWdDdXJyZW50ICYmXG4gICAgICAgICAgICBkYXRhLmlkID09PSAnYXVkaW8nICYmXG4gICAgICAgICAgICBkYXRhLnR5cGUgPT09ICdhdWRpbycgJiZcbiAgICAgICAgICAgIGZyYWdOZXcuc24gPT09IGZyYWdDdXJyZW50LnNuICYmXG4gICAgICAgICAgICBmcmFnTmV3LmxldmVsID09PSBmcmFnQ3VycmVudC5sZXZlbCAmJlxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9PT0gYmFzZV9zdHJlYW1fY29udHJvbGxlcl8xLlN0YXRlLlBBUlNJTkcpIHtcbiAgICAgICAgICAgIHZhciB0cmFja0lkID0gdGhpcy50cmFja0lkLCB0cmFjayA9IHRoaXMudHJhY2tzW3RyYWNrSWRdLCBobHNfMSA9IHRoaXMuaGxzO1xuICAgICAgICAgICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoZGF0YS5lbmRQVFMpKSB7XG4gICAgICAgICAgICAgICAgZGF0YS5lbmRQVFMgPSBkYXRhLnN0YXJ0UFRTICsgZnJhZ0N1cnJlbnQuZHVyYXRpb247XG4gICAgICAgICAgICAgICAgZGF0YS5lbmREVFMgPSBkYXRhLnN0YXJ0RFRTICsgZnJhZ0N1cnJlbnQuZHVyYXRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmcmFnQ3VycmVudC5hZGRFbGVtZW50YXJ5U3RyZWFtKGZyYWdtZW50XzEuZGVmYXVsdC5FbGVtZW50YXJ5U3RyZWFtVHlwZXMuQVVESU8pO1xuICAgICAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLmxvZyhcInBhcnNlZCBcIiArIGRhdGEudHlwZSArIFwiLFBUUzpbXCIgKyBkYXRhLnN0YXJ0UFRTLnRvRml4ZWQoMykgKyBcIixcIiArIGRhdGEuZW5kUFRTLnRvRml4ZWQoMykgKyBcIl0sRFRTOltcIiArIGRhdGEuc3RhcnREVFMudG9GaXhlZCgzKSArIFwiL1wiICsgZGF0YS5lbmREVFMudG9GaXhlZCgzKSArIFwiXSxuYjpcIiArIGRhdGEubmIpO1xuICAgICAgICAgICAgTGV2ZWxIZWxwZXIudXBkYXRlRnJhZ1BUU0RUUyh0cmFjay5kZXRhaWxzLCBmcmFnQ3VycmVudCwgZGF0YS5zdGFydFBUUywgZGF0YS5lbmRQVFMpO1xuICAgICAgICAgICAgdmFyIGF1ZGlvU3dpdGNoID0gdGhpcy5hdWRpb1N3aXRjaCwgbWVkaWEgPSB0aGlzLm1lZGlhLCBhcHBlbmRPbkJ1ZmZlckZsdXNoID0gZmFsc2U7XG4gICAgICAgICAgICAvLyBPbmx5IGZsdXNoIGF1ZGlvIGZyb20gb2xkIGF1ZGlvIHRyYWNrcyB3aGVuIFBUUyBpcyBrbm93biBvbiBuZXcgYXVkaW8gdHJhY2tcbiAgICAgICAgICAgIGlmIChhdWRpb1N3aXRjaCAmJiBtZWRpYSkge1xuICAgICAgICAgICAgICAgIGlmIChtZWRpYS5yZWFkeVN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjdXJyZW50VGltZSA9IG1lZGlhLmN1cnJlbnRUaW1lO1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXJfMS5sb2dnZXIubG9nKCdzd2l0Y2hpbmcgYXVkaW8gdHJhY2sgOiBjdXJyZW50VGltZTonICsgY3VycmVudFRpbWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudFRpbWUgPj0gZGF0YS5zdGFydFBUUykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLmxvZygnc3dpdGNoaW5nIGF1ZGlvIHRyYWNrIDogZmx1c2hpbmcgYWxsIGF1ZGlvJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gYmFzZV9zdHJlYW1fY29udHJvbGxlcl8xLlN0YXRlLkJVRkZFUl9GTFVTSElORztcbiAgICAgICAgICAgICAgICAgICAgICAgIGhsc18xLnRyaWdnZXIoZXZlbnRzXzEuZGVmYXVsdC5CVUZGRVJfRkxVU0hJTkcsIHsgc3RhcnRPZmZzZXQ6IDAsIGVuZE9mZnNldDogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLCB0eXBlOiAnYXVkaW8nIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXBwZW5kT25CdWZmZXJGbHVzaCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBMZXRzIGFubm91bmNlIHRoYXQgdGhlIGluaXRpYWwgYXVkaW8gdHJhY2sgc3dpdGNoIGZsdXNoIG9jY3VyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmF1ZGlvU3dpdGNoID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBobHNfMS50cmlnZ2VyKGV2ZW50c18xLmRlZmF1bHQuQVVESU9fVFJBQ0tfU1dJVENIRUQsIHsgaWQ6IHRyYWNrSWQgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIExldHMgYW5ub3VuY2UgdGhhdCB0aGUgaW5pdGlhbCBhdWRpbyB0cmFjayBzd2l0Y2ggZmx1c2ggb2NjdXJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hdWRpb1N3aXRjaCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBobHNfMS50cmlnZ2VyKGV2ZW50c18xLmRlZmF1bHQuQVVESU9fVFJBQ0tfU1dJVENIRUQsIHsgaWQ6IHRyYWNrSWQgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHBlbmRpbmdEYXRhXzEgPSB0aGlzLnBlbmRpbmdEYXRhO1xuICAgICAgICAgICAgaWYgKCFwZW5kaW5nRGF0YV8xKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLndhcm4oJ0FwcGFyZW50bHkgYXR0ZW1wdCB0byBlbnF1ZXVlIG1lZGlhIHBheWxvYWQgd2l0aG91dCBjb2RlYyBpbml0aWFsaXphdGlvbiBkYXRhIHVwZnJvbnQnKTtcbiAgICAgICAgICAgICAgICBobHNfMS50cmlnZ2VyKGV2ZW50c18xLmRlZmF1bHQuRVJST1IsIHsgdHlwZTogZXJyb3JzXzEuRXJyb3JUeXBlcy5NRURJQV9FUlJPUiwgZGV0YWlsczogbnVsbCwgZmF0YWw6IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLmF1ZGlvU3dpdGNoKSB7XG4gICAgICAgICAgICAgICAgW2RhdGEuZGF0YTEsIGRhdGEuZGF0YTJdLmZvckVhY2goZnVuY3Rpb24gKGJ1ZmZlcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYnVmZmVyICYmIGJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBlbmRpbmdEYXRhXzEucHVzaCh7IHR5cGU6IGRhdGEudHlwZSwgZGF0YTogYnVmZmVyLCBwYXJlbnQ6ICdhdWRpbycsIGNvbnRlbnQ6ICdkYXRhJyB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmICghYXBwZW5kT25CdWZmZXJGbHVzaCAmJiBwZW5kaW5nRGF0YV8xLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBwZW5kaW5nRGF0YV8xLmZvckVhY2goZnVuY3Rpb24gKGFwcGVuZE9iaikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gb25seSBhcHBlbmQgaW4gUEFSU0lORyBzdGF0ZSAocmF0aW9uYWxlIGlzIHRoYXQgYW4gYXBwZW5kaW5nIGVycm9yIGNvdWxkIGhhcHBlbiBzeW5jaHJvbm91c2x5IG9uIGZpcnN0IHNlZ21lbnQgYXBwZW5kaW5nKVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW4gdGhhdCBjYXNlIGl0IGlzIHVzZWxlc3MgdG8gYXBwZW5kIGZvbGxvd2luZyBzZWdtZW50c1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLnN0YXRlID09PSBiYXNlX3N0cmVhbV9jb250cm9sbGVyXzEuU3RhdGUuUEFSU0lORykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFybSBwZW5kaW5nIEJ1ZmZlcmluZyBmbGFnIGJlZm9yZSBhcHBlbmRpbmcgYSBzZWdtZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMucGVuZGluZ0J1ZmZlcmluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuaGxzLnRyaWdnZXIoZXZlbnRzXzEuZGVmYXVsdC5CVUZGRVJfQVBQRU5ESU5HLCBhcHBlbmRPYmopO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nRGF0YSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFwcGVuZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB0cmlnZ2VyIGhhbmRsZXIgcmlnaHQgbm93XG4gICAgICAgICAgICB0aGlzLnRpY2soKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQXVkaW9TdHJlYW1Db250cm9sbGVyLnByb3RvdHlwZS5vbkZyYWdQYXJzZWQgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB2YXIgZnJhZ0N1cnJlbnQgPSB0aGlzLmZyYWdDdXJyZW50O1xuICAgICAgICB2YXIgZnJhZ05ldyA9IGRhdGEuZnJhZztcbiAgICAgICAgaWYgKGZyYWdDdXJyZW50ICYmXG4gICAgICAgICAgICBkYXRhLmlkID09PSAnYXVkaW8nICYmXG4gICAgICAgICAgICBmcmFnTmV3LnNuID09PSBmcmFnQ3VycmVudC5zbiAmJlxuICAgICAgICAgICAgZnJhZ05ldy5sZXZlbCA9PT0gZnJhZ0N1cnJlbnQubGV2ZWwgJiZcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPT09IGJhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfMS5TdGF0ZS5QQVJTSU5HKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRzLnRwYXJzZWQgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBiYXNlX3N0cmVhbV9jb250cm9sbGVyXzEuU3RhdGUuUEFSU0VEO1xuICAgICAgICAgICAgdGhpcy5fY2hlY2tBcHBlbmRlZFBhcnNlZCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBBdWRpb1N0cmVhbUNvbnRyb2xsZXIucHJvdG90eXBlLm9uQnVmZmVyUmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIHJlc2V0IHJlZmVyZW5jZSB0byBzb3VyY2VidWZmZXJzXG4gICAgICAgIHRoaXMubWVkaWFCdWZmZXIgPSB0aGlzLnZpZGVvQnVmZmVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5sb2FkZWRtZXRhZGF0YSA9IGZhbHNlO1xuICAgIH07XG4gICAgQXVkaW9TdHJlYW1Db250cm9sbGVyLnByb3RvdHlwZS5vbkJ1ZmZlckNyZWF0ZWQgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB2YXIgYXVkaW9UcmFjayA9IGRhdGEudHJhY2tzLmF1ZGlvO1xuICAgICAgICBpZiAoYXVkaW9UcmFjaykge1xuICAgICAgICAgICAgdGhpcy5tZWRpYUJ1ZmZlciA9IGF1ZGlvVHJhY2suYnVmZmVyO1xuICAgICAgICAgICAgdGhpcy5sb2FkZWRtZXRhZGF0YSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEudHJhY2tzLnZpZGVvKSB7XG4gICAgICAgICAgICB0aGlzLnZpZGVvQnVmZmVyID0gZGF0YS50cmFja3MudmlkZW8uYnVmZmVyO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBBdWRpb1N0cmVhbUNvbnRyb2xsZXIucHJvdG90eXBlLm9uQnVmZmVyQXBwZW5kZWQgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICBpZiAoZGF0YS5wYXJlbnQgPT09ICdhdWRpbycpIHtcbiAgICAgICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgICAgICAgICBpZiAoc3RhdGUgPT09IGJhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfMS5TdGF0ZS5QQVJTSU5HIHx8IHN0YXRlID09PSBiYXNlX3N0cmVhbV9jb250cm9sbGVyXzEuU3RhdGUuUEFSU0VEKSB7XG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgaWYgYWxsIGJ1ZmZlcnMgaGF2ZSBiZWVuIGFwcGVuZGVkXG4gICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nQnVmZmVyaW5nID0gKGRhdGEucGVuZGluZyA+IDApO1xuICAgICAgICAgICAgICAgIHRoaXMuX2NoZWNrQXBwZW5kZWRQYXJzZWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgQXVkaW9TdHJlYW1Db250cm9sbGVyLnByb3RvdHlwZS5fY2hlY2tBcHBlbmRlZFBhcnNlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gdHJpZ2dlciBoYW5kbGVyIHJpZ2h0IG5vd1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gYmFzZV9zdHJlYW1fY29udHJvbGxlcl8xLlN0YXRlLlBBUlNFRCAmJiAoIXRoaXMuYXBwZW5kZWQgfHwgIXRoaXMucGVuZGluZ0J1ZmZlcmluZykpIHtcbiAgICAgICAgICAgIHZhciBmcmFnID0gdGhpcy5mcmFnQ3VycmVudCwgc3RhdHMgPSB0aGlzLnN0YXRzLCBobHNfMiA9IHRoaXMuaGxzO1xuICAgICAgICAgICAgaWYgKGZyYWcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZyYWdQcmV2aW91cyA9IGZyYWc7XG4gICAgICAgICAgICAgICAgc3RhdHMudGJ1ZmZlcmVkID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgICAgICAgICAgaGxzXzIudHJpZ2dlcihldmVudHNfMS5kZWZhdWx0LkZSQUdfQlVGRkVSRUQsIHsgc3RhdHM6IHN0YXRzLCBmcmFnOiBmcmFnLCBpZDogJ2F1ZGlvJyB9KTtcbiAgICAgICAgICAgICAgICB2YXIgbWVkaWEgPSB0aGlzLm1lZGlhQnVmZmVyID8gdGhpcy5tZWRpYUJ1ZmZlciA6IHRoaXMubWVkaWE7XG4gICAgICAgICAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLmxvZyhcImF1ZGlvIGJ1ZmZlcmVkIDogXCIgKyB0aW1lX3Jhbmdlc18xLmRlZmF1bHQudG9TdHJpbmcobWVkaWEuYnVmZmVyZWQpKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5hdWRpb1N3aXRjaCAmJiB0aGlzLmFwcGVuZGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXVkaW9Td2l0Y2ggPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgaGxzXzIudHJpZ2dlcihldmVudHNfMS5kZWZhdWx0LkFVRElPX1RSQUNLX1NXSVRDSEVELCB7IGlkOiB0aGlzLnRyYWNrSWQgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBiYXNlX3N0cmVhbV9jb250cm9sbGVyXzEuU3RhdGUuSURMRTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudGljaygpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBBdWRpb1N0cmVhbUNvbnRyb2xsZXIucHJvdG90eXBlLm9uRXJyb3IgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB2YXIgZnJhZyA9IGRhdGEuZnJhZztcbiAgICAgICAgLy8gZG9uJ3QgaGFuZGxlIGZyYWcgZXJyb3Igbm90IHJlbGF0ZWQgdG8gYXVkaW8gZnJhZ21lbnRcbiAgICAgICAgaWYgKGZyYWcgJiYgZnJhZy50eXBlICE9PSAnYXVkaW8nKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChkYXRhLmRldGFpbHMpIHtcbiAgICAgICAgICAgIGNhc2UgZXJyb3JzXzEuRXJyb3JEZXRhaWxzLkZSQUdfTE9BRF9FUlJPUjpcbiAgICAgICAgICAgIGNhc2UgZXJyb3JzXzEuRXJyb3JEZXRhaWxzLkZSQUdfTE9BRF9USU1FT1VUOlxuICAgICAgICAgICAgICAgIHZhciBmcmFnXzEgPSBkYXRhLmZyYWc7XG4gICAgICAgICAgICAgICAgLy8gZG9uJ3QgaGFuZGxlIGZyYWcgZXJyb3Igbm90IHJlbGF0ZWQgdG8gYXVkaW8gZnJhZ21lbnRcbiAgICAgICAgICAgICAgICBpZiAoZnJhZ18xICYmIGZyYWdfMS50eXBlICE9PSAnYXVkaW8nKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWRhdGEuZmF0YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxvYWRFcnJvciA9IHRoaXMuZnJhZ0xvYWRFcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxvYWRFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9hZEVycm9yKys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2FkRXJyb3IgPSAxO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb25maWcgPSB0aGlzLmNvbmZpZztcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxvYWRFcnJvciA8PSBjb25maWcuZnJhZ0xvYWRpbmdNYXhSZXRyeSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5mcmFnTG9hZEVycm9yID0gbG9hZEVycm9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXhwb25lbnRpYWwgYmFja29mZiBjYXBwZWQgdG8gY29uZmlnLmZyYWdMb2FkaW5nTWF4UmV0cnlUaW1lb3V0XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGVsYXkgPSBNYXRoLm1pbihNYXRoLnBvdygyLCBsb2FkRXJyb3IgLSAxKSAqIGNvbmZpZy5mcmFnTG9hZGluZ1JldHJ5RGVsYXksIGNvbmZpZy5mcmFnTG9hZGluZ01heFJldHJ5VGltZW91dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXJfMS5sb2dnZXIud2FybihcIkF1ZGlvU3RyZWFtQ29udHJvbGxlcjogZnJhZyBsb2FkaW5nIGZhaWxlZCwgcmV0cnkgaW4gXCIgKyBkZWxheSArIFwiIG1zXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXRyeURhdGUgPSBwZXJmb3JtYW5jZS5ub3coKSArIGRlbGF5O1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmV0cnkgbG9hZGluZyBzdGF0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IGJhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfMS5TdGF0ZS5GUkFHX0xPQURJTkdfV0FJVElOR19SRVRSWTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmxvZ2dlci5lcnJvcihcIkF1ZGlvU3RyZWFtQ29udHJvbGxlcjogXCIgKyBkYXRhLmRldGFpbHMgKyBcIiByZWFjaGVzIG1heCByZXRyeSwgcmVkaXNwYXRjaCBhcyBmYXRhbCAuLi5cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzd2l0Y2ggZXJyb3IgdG8gZmF0YWxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuZmF0YWwgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IGJhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfMS5TdGF0ZS5FUlJPUjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgZXJyb3JzXzEuRXJyb3JEZXRhaWxzLkFVRElPX1RSQUNLX0xPQURfRVJST1I6XG4gICAgICAgICAgICBjYXNlIGVycm9yc18xLkVycm9yRGV0YWlscy5BVURJT19UUkFDS19MT0FEX1RJTUVPVVQ6XG4gICAgICAgICAgICBjYXNlIGVycm9yc18xLkVycm9yRGV0YWlscy5LRVlfTE9BRF9FUlJPUjpcbiAgICAgICAgICAgIGNhc2UgZXJyb3JzXzEuRXJyb3JEZXRhaWxzLktFWV9MT0FEX1RJTUVPVVQ6XG4gICAgICAgICAgICAgICAgLy8gIHdoZW4gaW4gRVJST1Igc3RhdGUsIGRvbid0IHN3aXRjaCBiYWNrIHRvIElETEUgc3RhdGUgaW4gY2FzZSBhIG5vbi1mYXRhbCBlcnJvciBpcyByZWNlaXZlZFxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlICE9PSBiYXNlX3N0cmVhbV9jb250cm9sbGVyXzEuU3RhdGUuRVJST1IpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgZmF0YWwgZXJyb3IsIHN0b3AgcHJvY2Vzc2luZywgb3RoZXJ3aXNlIG1vdmUgdG8gSURMRSB0byByZXRyeSBsb2FkaW5nXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBkYXRhLmZhdGFsID8gYmFzZV9zdHJlYW1fY29udHJvbGxlcl8xLlN0YXRlLkVSUk9SIDogYmFzZV9zdHJlYW1fY29udHJvbGxlcl8xLlN0YXRlLklETEU7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmxvZ2dlci53YXJuKFwiQXVkaW9TdHJlYW1Db250cm9sbGVyOiBcIiArIGRhdGEuZGV0YWlscyArIFwiIHdoaWxlIGxvYWRpbmcgZnJhZywgbm93IHN3aXRjaGluZyB0byBcIiArIHRoaXMuc3RhdGUgKyBcIiBzdGF0ZSAuLi5cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBlcnJvcnNfMS5FcnJvckRldGFpbHMuQlVGRkVSX0ZVTExfRVJST1I6XG4gICAgICAgICAgICAgICAgLy8gaWYgaW4gYXBwZW5kaW5nIHN0YXRlXG4gICAgICAgICAgICAgICAgaWYgKGRhdGEucGFyZW50ID09PSAnYXVkaW8nICYmICh0aGlzLnN0YXRlID09PSBiYXNlX3N0cmVhbV9jb250cm9sbGVyXzEuU3RhdGUuUEFSU0lORyB8fCB0aGlzLnN0YXRlID09PSBiYXNlX3N0cmVhbV9jb250cm9sbGVyXzEuU3RhdGUuUEFSU0VEKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWVkaWEgPSB0aGlzLm1lZGlhQnVmZmVyLCBjdXJyZW50VGltZSA9IHRoaXMubWVkaWEuY3VycmVudFRpbWUsIG1lZGlhQnVmZmVyZWQgPSBtZWRpYSAmJiBidWZmZXJfaGVscGVyXzEuQnVmZmVySGVscGVyLmlzQnVmZmVyZWQobWVkaWEsIGN1cnJlbnRUaW1lKSAmJiBidWZmZXJfaGVscGVyXzEuQnVmZmVySGVscGVyLmlzQnVmZmVyZWQobWVkaWEsIGN1cnJlbnRUaW1lICsgMC41KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVkdWNlIG1heCBidWYgbGVuIGlmIGN1cnJlbnQgcG9zaXRpb24gaXMgYnVmZmVyZWRcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1lZGlhQnVmZmVyZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb25maWcgPSB0aGlzLmNvbmZpZztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb25maWcubWF4TWF4QnVmZmVyTGVuZ3RoID49IGNvbmZpZy5tYXhCdWZmZXJMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZWR1Y2UgbWF4IGJ1ZmZlciBsZW5ndGggYXMgaXQgbWlnaHQgYmUgdG9vIGhpZ2guIHdlIGRvIHRoaXMgdG8gYXZvaWQgbG9vcCBmbHVzaGluZyAuLi5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maWcubWF4TWF4QnVmZmVyTGVuZ3RoIC89IDI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLndhcm4oXCJBdWRpb1N0cmVhbUNvbnRyb2xsZXI6IHJlZHVjZSBtYXggYnVmZmVyIGxlbmd0aCB0byBcIiArIGNvbmZpZy5tYXhNYXhCdWZmZXJMZW5ndGggKyBcInNcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gYmFzZV9zdHJlYW1fY29udHJvbGxlcl8xLlN0YXRlLklETEU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjdXJyZW50IHBvc2l0aW9uIGlzIG5vdCBidWZmZXJlZCwgYnV0IGJyb3dzZXIgaXMgc3RpbGwgY29tcGxhaW5pbmcgYWJvdXQgYnVmZmVyIGZ1bGwgZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgaGFwcGVucyBvbiBJRS9FZGdlLCByZWZlciB0byBodHRwczovL2dpdGh1Yi5jb20vdmlkZW8tZGV2L2hscy5qcy9wdWxsLzcwOFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW4gdGhhdCBjYXNlIGZsdXNoIHRoZSB3aG9sZSBhdWRpbyBidWZmZXIgdG8gcmVjb3ZlclxuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLndhcm4oJ0F1ZGlvU3RyZWFtQ29udHJvbGxlcjogYnVmZmVyIGZ1bGwgZXJyb3IgYWxzbyBtZWRpYS5jdXJyZW50VGltZSBpcyBub3QgYnVmZmVyZWQsIGZsdXNoIGF1ZGlvIGJ1ZmZlcicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5mcmFnQ3VycmVudCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBmbHVzaCBldmVyeXRoaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gYmFzZV9zdHJlYW1fY29udHJvbGxlcl8xLlN0YXRlLkJVRkZFUl9GTFVTSElORztcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoZXZlbnRzXzEuZGVmYXVsdC5CVUZGRVJfRkxVU0hJTkcsIHsgc3RhcnRPZmZzZXQ6IDAsIGVuZE9mZnNldDogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLCB0eXBlOiAnYXVkaW8nIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH07XG4gICAgQXVkaW9TdHJlYW1Db250cm9sbGVyLnByb3RvdHlwZS5vbkJ1ZmZlckZsdXNoZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBwZW5kaW5nRGF0YSA9IHRoaXMucGVuZGluZ0RhdGE7XG4gICAgICAgIGlmIChwZW5kaW5nRGF0YSAmJiBwZW5kaW5nRGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxvZ2dlcl8xLmxvZ2dlci5sb2coJ0F1ZGlvU3RyZWFtQ29udHJvbGxlcjogYXBwZW5kaW5nIHBlbmRpbmcgYXVkaW8gZGF0YSBhZnRlciBidWZmZXIgZmx1c2hlZCcpO1xuICAgICAgICAgICAgcGVuZGluZ0RhdGEuZm9yRWFjaChmdW5jdGlvbiAoYXBwZW5kT2JqKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuaGxzLnRyaWdnZXIoZXZlbnRzXzEuZGVmYXVsdC5CVUZGRVJfQVBQRU5ESU5HLCBhcHBlbmRPYmopO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmFwcGVuZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ0RhdGEgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBiYXNlX3N0cmVhbV9jb250cm9sbGVyXzEuU3RhdGUuUEFSU0VEO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gbW92ZSB0byBJRExFIG9uY2UgZmx1c2ggY29tcGxldGUuIHRoaXMgc2hvdWxkIHRyaWdnZXIgbmV3IGZyYWdtZW50IGxvYWRpbmdcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBiYXNlX3N0cmVhbV9jb250cm9sbGVyXzEuU3RhdGUuSURMRTtcbiAgICAgICAgICAgIC8vIHJlc2V0IHJlZmVyZW5jZSB0byBmcmFnXG4gICAgICAgICAgICB0aGlzLmZyYWdQcmV2aW91cyA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLnRpY2soKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIEF1ZGlvU3RyZWFtQ29udHJvbGxlcjtcbn0oYmFzZV9zdHJlYW1fY29udHJvbGxlcl8xLmRlZmF1bHQpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IEF1ZGlvU3RyZWFtQ29udHJvbGxlcjtcblxuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovfS5jYWxsKHRoaXMsIF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vc3JjL3BvbHlmaWxscy9udW1iZXIgKi8gXCIuL3NyYy9wb2x5ZmlsbHMvbnVtYmVyLmpzXCIpW1wiTnVtYmVyXCJdKSlcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvY29udHJvbGxlci9hdWRpby10cmFjay1jb250cm9sbGVyLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9jb250cm9sbGVyL2F1ZGlvLXRyYWNrLWNvbnRyb2xsZXIuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBldmVudHNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2V2ZW50cyAqLyBcIi4vc3JjL2V2ZW50cy5qc1wiKTtcbnZhciB0YXNrX2xvb3BfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3Rhc2stbG9vcCAqLyBcIi4vc3JjL3Rhc2stbG9vcC5qc1wiKTtcbnZhciBsb2dnZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL2xvZ2dlciAqLyBcIi4vc3JjL3V0aWxzL2xvZ2dlci5qc1wiKTtcbnZhciBlcnJvcnNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2Vycm9ycyAqLyBcIi4vc3JjL2Vycm9ycy5qc1wiKTtcbi8qKlxuICogQGNsYXNzIEF1ZGlvVHJhY2tDb250cm9sbGVyXG4gKiBAaW1wbGVtZW50cyB7RXZlbnRIYW5kbGVyfVxuICpcbiAqIEhhbmRsZXMgbWFpbiBtYW5pZmVzdCBhbmQgYXVkaW8tdHJhY2sgbWV0YWRhdGEgbG9hZGVkLFxuICogb3ducyBhbmQgZXhwb3NlcyB0aGUgc2VsZWN0YWJsZSBhdWRpby10cmFja3MgZGF0YS1tb2RlbHMuXG4gKlxuICogRXhwb3NlcyBpbnRlcm5hbCBpbnRlcmZhY2UgdG8gc2VsZWN0IGF2YWlsYWJsZSBhdWRpby10cmFja3MuXG4gKlxuICogSGFuZGxlcyBlcnJvcnMgb24gbG9hZGluZyBhdWRpby10cmFjayBwbGF5bGlzdHMuIE1hbmFnZXMgZmFsbGJhY2sgbWVjaGFuaXNtXG4gKiB3aXRoIHJlZHVuZGFudHMgdHJhY2tzIChncm91cC1JRHMpLlxuICpcbiAqIEhhbmRsZXMgbGV2ZWwtbG9hZGluZyBhbmQgZ3JvdXAtSUQgc3dpdGNoZXMgZm9yIHZpZGVvIChmYWxsYmFjayBvbiB2aWRlbyBsZXZlbHMpLFxuICogYW5kIGV2ZW50dWFsbHkgYWRhcHRzIHRoZSBhdWRpby10cmFjayBncm91cC1JRCB0byBtYXRjaC5cbiAqXG4gKiBAZmlyZXMgQVVESU9fVFJBQ0tfTE9BRElOR1xuICogQGZpcmVzIEFVRElPX1RSQUNLX1NXSVRDSElOR1xuICogQGZpcmVzIEFVRElPX1RSQUNLU19VUERBVEVEXG4gKiBAZmlyZXMgRVJST1JcbiAqXG4gKi9cbnZhciBBdWRpb1RyYWNrQ29udHJvbGxlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQXVkaW9UcmFja0NvbnRyb2xsZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQXVkaW9UcmFja0NvbnRyb2xsZXIoaGxzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGhscywgZXZlbnRzXzEuZGVmYXVsdC5NQU5JRkVTVF9MT0FESU5HLCBldmVudHNfMS5kZWZhdWx0Lk1BTklGRVNUX1BBUlNFRCwgZXZlbnRzXzEuZGVmYXVsdC5BVURJT19UUkFDS19MT0FERUQsIGV2ZW50c18xLmRlZmF1bHQuQVVESU9fVFJBQ0tfU1dJVENIRUQsIGV2ZW50c18xLmRlZmF1bHQuTEVWRUxfTE9BREVELCBldmVudHNfMS5kZWZhdWx0LkVSUk9SKSB8fCB0aGlzO1xuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQ3VycmVudGx5IHNlbGVjdGVkIGluZGV4IGluIGB0cmFja3NgXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn0gdHJhY2tJZFxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMuX3RyYWNrSWQgPSAtMTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIElmIHNob3VsZCBzZWxlY3QgdHJhY2tzIGFjY29yZGluZyB0byBkZWZhdWx0IHRyYWNrIGF0dHJpYnV0ZVxuICAgICAgICAgKiBAbWVtYmVyIHtib29sZWFufSBfc2VsZWN0RGVmYXVsdFRyYWNrXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5fc2VsZWN0RGVmYXVsdFRyYWNrID0gdHJ1ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwdWJsaWNcbiAgICAgICAgICogQWxsIHRyYWNrcyBhdmFpbGFibGVcbiAgICAgICAgICogQG1lbWJlciB7QXVkaW9UcmFja1tdfVxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMudHJhY2tzID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHVibGljXG4gICAgICAgICAqIExpc3Qgb2YgYmxhY2tsaXN0ZWQgYXVkaW8gdHJhY2sgSURzICh0aGF0IGhhdmUgY2F1c2VkIGZhaWx1cmUpXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcltdfVxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMudHJhY2tJZEJsYWNrbGlzdCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHVibGljXG4gICAgICAgICAqIFRoZSBjdXJyZW50bHkgcnVubmluZyBncm91cCBJRCBmb3IgYXVkaW9cbiAgICAgICAgICogKHdlIGdyYWIgdGhpcyBvbiBtYW5pZmVzdC1wYXJzZWQgYW5kIG5ldyBsZXZlbC1sb2FkZWQpXG4gICAgICAgICAqIEBtZW1iZXIge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLmF1ZGlvR3JvdXBJZCA9IG51bGw7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVzZXQgYXVkaW8gdHJhY2tzIG9uIG5ldyBtYW5pZmVzdCBsb2FkaW5nLlxuICAgICAqL1xuICAgIEF1ZGlvVHJhY2tDb250cm9sbGVyLnByb3RvdHlwZS5vbk1hbmlmZXN0TG9hZGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy50cmFja3MgPSBbXTtcbiAgICAgICAgdGhpcy5fdHJhY2tJZCA9IC0xO1xuICAgICAgICB0aGlzLl9zZWxlY3REZWZhdWx0VHJhY2sgPSB0cnVlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU3RvcmUgdHJhY2tzIGRhdGEgZnJvbSBtYW5pZmVzdCBwYXJzZWQgZGF0YS5cbiAgICAgKlxuICAgICAqIFRyaWdnZXIgQVVESU9fVFJBQ0tTX1VQREFURUQgZXZlbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyp9IGRhdGFcbiAgICAgKi9cbiAgICBBdWRpb1RyYWNrQ29udHJvbGxlci5wcm90b3R5cGUub25NYW5pZmVzdFBhcnNlZCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHZhciB0cmFja3MgPSB0aGlzLnRyYWNrcyA9IGRhdGEuYXVkaW9UcmFja3MgfHwgW107XG4gICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoZXZlbnRzXzEuZGVmYXVsdC5BVURJT19UUkFDS1NfVVBEQVRFRCwgeyBhdWRpb1RyYWNrczogdHJhY2tzIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU3RvcmUgdHJhY2sgZGV0YWlscyBvZiBsb2FkZWQgdHJhY2sgaW4gb3VyIGRhdGEtbW9kZWwuXG4gICAgICpcbiAgICAgKiBTZXQtdXAgbWV0YWRhdGEgdXBkYXRlIGludGVydmFsIHRhc2sgZm9yIGxpdmUtbW9kZSBzdHJlYW1zLlxuICAgICAqXG4gICAgICogQHBhcmFtIHt9IGRhdGFcbiAgICAgKi9cbiAgICBBdWRpb1RyYWNrQ29udHJvbGxlci5wcm90b3R5cGUub25BdWRpb1RyYWNrTG9hZGVkID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgaWYgKGRhdGEuaWQgPj0gdGhpcy50cmFja3MubGVuZ3RoKSB7XG4gICAgICAgICAgICBsb2dnZXJfMS5sb2dnZXIud2FybignSW52YWxpZCBhdWRpbyB0cmFjayBpZDonLCBkYXRhLmlkKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsb2dnZXJfMS5sb2dnZXIubG9nKFwiYXVkaW9UcmFjayBcIiArIGRhdGEuaWQgKyBcIiBsb2FkZWRcIik7XG4gICAgICAgIHRoaXMudHJhY2tzW2RhdGEuaWRdLmRldGFpbHMgPSBkYXRhLmRldGFpbHM7XG4gICAgICAgIC8vIGNoZWNrIGlmIGN1cnJlbnQgcGxheWxpc3QgaXMgYSBsaXZlIHBsYXlsaXN0XG4gICAgICAgIC8vIGFuZCBpZiB3ZSBoYXZlIGFscmVhZHkgb3VyIHJlbG9hZCBpbnRlcnZhbCBzZXR1cFxuICAgICAgICBpZiAoZGF0YS5kZXRhaWxzLmxpdmUgJiYgIXRoaXMuaGFzSW50ZXJ2YWwoKSkge1xuICAgICAgICAgICAgLy8gaWYgbGl2ZSBwbGF5bGlzdCB3ZSB3aWxsIGhhdmUgdG8gcmVsb2FkIGl0IHBlcmlvZGljYWxseVxuICAgICAgICAgICAgLy8gc2V0IHJlbG9hZCBwZXJpb2QgdG8gcGxheWxpc3QgdGFyZ2V0IGR1cmF0aW9uXG4gICAgICAgICAgICB2YXIgdXBkYXRlUGVyaW9kTXMgPSBkYXRhLmRldGFpbHMudGFyZ2V0ZHVyYXRpb24gKiAxMDAwO1xuICAgICAgICAgICAgdGhpcy5zZXRJbnRlcnZhbCh1cGRhdGVQZXJpb2RNcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkYXRhLmRldGFpbHMubGl2ZSAmJiB0aGlzLmhhc0ludGVydmFsKCkpIHtcbiAgICAgICAgICAgIC8vIHBsYXlsaXN0IGlzIG5vdCBsaXZlIGFuZCB0aW1lciBpcyBzY2hlZHVsZWQ6IGNhbmNlbCBpdFxuICAgICAgICAgICAgdGhpcy5jbGVhckludGVydmFsKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFVwZGF0ZSB0aGUgaW50ZXJuYWwgZ3JvdXAgSUQgdG8gYW55IGF1ZGlvLXRyYWNrIHdlIG1heSBoYXZlIHNldCBtYW51YWxseVxuICAgICAqIG9yIGJlY2F1c2Ugb2YgYSBmYWlsdXJlLWhhbmRsaW5nIGZhbGxiYWNrLlxuICAgICAqXG4gICAgICogUXVhbGl0eS1sZXZlbHMgc2hvdWxkIHVwZGF0ZSB0byB0aGF0IGdyb3VwIElEIGluIHRoaXMgY2FzZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Kn0gZGF0YVxuICAgICAqL1xuICAgIEF1ZGlvVHJhY2tDb250cm9sbGVyLnByb3RvdHlwZS5vbkF1ZGlvVHJhY2tTd2l0Y2hlZCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHZhciBhdWRpb0dyb3VwSWQgPSB0aGlzLnRyYWNrc1tkYXRhLmlkXS5ncm91cElkO1xuICAgICAgICBpZiAoYXVkaW9Hcm91cElkICYmICh0aGlzLmF1ZGlvR3JvdXBJZCAhPT0gYXVkaW9Hcm91cElkKSkge1xuICAgICAgICAgICAgdGhpcy5hdWRpb0dyb3VwSWQgPSBhdWRpb0dyb3VwSWQ7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFdoZW4gYSBsZXZlbCBnZXRzIGxvYWRlZCwgaWYgaXQgaGFzIHJlZHVuZGFudCBhdWRpb0dyb3VwSWRzIChpbiB0aGUgc2FtZSBvcmRpbmFsaXR5IGFzIGl0J3MgcmVkdW5kYW50IFVSTHMpXG4gICAgICogd2UgYXJlIHNldHRpbmcgb3VyIGF1ZGlvLWdyb3VwIElEIGludGVybmFsbHkgdG8gdGhlIG9uZSBzZXQsIGlmIGl0IGlzIGRpZmZlcmVudCBmcm9tIHRoZSBncm91cCBJRCBjdXJyZW50bHkgc2V0LlxuICAgICAqXG4gICAgICogSWYgZ3JvdXAtSUQgZ290IHVwZGF0ZSwgd2UgcmUtc2VsZWN0IHRoZSBhcHByb3ByaWF0ZSBhdWRpby10cmFjayB3aXRoIHRoaXMgZ3JvdXAtSUQgbWF0Y2hpbmcgdGhlIGN1cnJlbnRseVxuICAgICAqIHNlbGVjdGVkIG9uZSAoYmFzZWQgb24gTkFNRSBwcm9wZXJ0eSkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyp9IGRhdGFcbiAgICAgKi9cbiAgICBBdWRpb1RyYWNrQ29udHJvbGxlci5wcm90b3R5cGUub25MZXZlbExvYWRlZCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIC8vIEZJWE1FOiBjcmFzaGVzIGJlY2F1c2UgY3VycmVudExldmVsIGlzIHVuZGVmaW5lZFxuICAgICAgICAvLyBjb25zdCBsZXZlbEluZm8gPSB0aGlzLmhscy5sZXZlbHNbdGhpcy5obHMuY3VycmVudExldmVsXTtcbiAgICAgICAgdmFyIGxldmVsSW5mbyA9IHRoaXMuaGxzLmxldmVsc1tkYXRhLmxldmVsXTtcbiAgICAgICAgaWYgKCFsZXZlbEluZm8uYXVkaW9Hcm91cElkcykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBhdWRpb0dyb3VwSWQgPSBsZXZlbEluZm8uYXVkaW9Hcm91cElkc1tsZXZlbEluZm8udXJsSWRdO1xuICAgICAgICBpZiAodGhpcy5hdWRpb0dyb3VwSWQgIT09IGF1ZGlvR3JvdXBJZCkge1xuICAgICAgICAgICAgdGhpcy5hdWRpb0dyb3VwSWQgPSBhdWRpb0dyb3VwSWQ7XG4gICAgICAgICAgICB0aGlzLl9zZWxlY3RJbml0aWFsQXVkaW9UcmFjaygpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBIYW5kbGUgbmV0d29yayBlcnJvcnMgbG9hZGluZyBhdWRpbyB0cmFjayBtYW5pZmVzdHNcbiAgICAgKiBhbmQgYWxzbyBwYXVzaW5nIG9uIGFueSBuZXR3b2sgZXJyb3JzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtFcnJvckV2ZW50RGF0YX0gZGF0YVxuICAgICAqL1xuICAgIEF1ZGlvVHJhY2tDb250cm9sbGVyLnByb3RvdHlwZS5vbkVycm9yID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgLy8gT25seSBoYW5kbGUgbmV0d29yayBlcnJvcnNcbiAgICAgICAgaWYgKGRhdGEudHlwZSAhPT0gZXJyb3JzXzEuRXJyb3JUeXBlcy5ORVRXT1JLX0VSUk9SKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgZmF0YWwgbmV0d29yayBlcnJvciwgY2FuY2VsIHVwZGF0ZSB0YXNrXG4gICAgICAgIGlmIChkYXRhLmZhdGFsKSB7XG4gICAgICAgICAgICB0aGlzLmNsZWFySW50ZXJ2YWwoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBub3QgYW4gYXVkaW8tdHJhY2sgbG9hZGluZyBlcnJvciBkb24ndCBoYW5kbGUgZnVydGhlclxuICAgICAgICBpZiAoZGF0YS5kZXRhaWxzICE9PSBlcnJvcnNfMS5FcnJvckRldGFpbHMuQVVESU9fVFJBQ0tfTE9BRF9FUlJPUikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxvZ2dlcl8xLmxvZ2dlci53YXJuKCdOZXR3b3JrIGZhaWx1cmUgb24gYXVkaW8tdHJhY2sgaWQ6JywgZGF0YS5jb250ZXh0LmlkKTtcbiAgICAgICAgdGhpcy5faGFuZGxlTG9hZEVycm9yKCk7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQXVkaW9UcmFja0NvbnRyb2xsZXIucHJvdG90eXBlLCBcImF1ZGlvVHJhY2tzXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtBdWRpb1RyYWNrW119IEF1ZGlvLXRyYWNrIGxpc3Qgd2Ugb3duXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRyYWNrcztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEF1ZGlvVHJhY2tDb250cm9sbGVyLnByb3RvdHlwZSwgXCJhdWRpb1RyYWNrXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9IEluZGV4IGludG8gYXVkaW8tdHJhY2tzIGxpc3Qgb2YgY3VycmVudGx5IHNlbGVjdGVkIHRyYWNrLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdHJhY2tJZDtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNlbGVjdCBjdXJyZW50IHRyYWNrIGJ5IGluZGV4XG4gICAgICAgICAqL1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChuZXdJZCkge1xuICAgICAgICAgICAgdGhpcy5fc2V0QXVkaW9UcmFjayhuZXdJZCk7XG4gICAgICAgICAgICAvLyBJZiBhdWRpbyB0cmFjayBpcyBzZWxlY3RlZCBmcm9tIEFQSSB0aGVuIGRvbid0IGNob29zZSBmcm9tIHRoZSBtYW5pZmVzdCBkZWZhdWx0IHRyYWNrXG4gICAgICAgICAgICB0aGlzLl9zZWxlY3REZWZhdWx0VHJhY2sgPSBmYWxzZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbmV3SWRcbiAgICAgKi9cbiAgICBBdWRpb1RyYWNrQ29udHJvbGxlci5wcm90b3R5cGUuX3NldEF1ZGlvVHJhY2sgPSBmdW5jdGlvbiAobmV3SWQpIHtcbiAgICAgICAgLy8gbm9vcCBvbiBzYW1lIGF1ZGlvIHRyYWNrIGlkIGFzIGFscmVhZHkgc2V0XG4gICAgICAgIGlmICh0aGlzLl90cmFja0lkID09PSBuZXdJZCAmJiB0aGlzLnRyYWNrc1t0aGlzLl90cmFja0lkXS5kZXRhaWxzKSB7XG4gICAgICAgICAgICBsb2dnZXJfMS5sb2dnZXIuZGVidWcoJ1NhbWUgaWQgYXMgY3VycmVudCBhdWRpby10cmFjayBwYXNzZWQsIGFuZCB0cmFjayBkZXRhaWxzIGF2YWlsYWJsZSAtPiBuby1vcCcpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNoZWNrIGlmIGxldmVsIGlkeCBpcyB2YWxpZFxuICAgICAgICBpZiAobmV3SWQgPCAwIHx8IG5ld0lkID49IHRoaXMudHJhY2tzLmxlbmd0aCkge1xuICAgICAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLndhcm4oJ0ludmFsaWQgaWQgcGFzc2VkIHRvIGF1ZGlvLXRyYWNrIGNvbnRyb2xsZXInKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYXVkaW9UcmFjayA9IHRoaXMudHJhY2tzW25ld0lkXTtcbiAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLmxvZyhcIk5vdyBzd2l0Y2hpbmcgdG8gYXVkaW8tdHJhY2sgaW5kZXggXCIgKyBuZXdJZCk7XG4gICAgICAgIC8vIHN0b3BwaW5nIGxpdmUgcmVsb2FkaW5nIHRpbWVyIGlmIGFueVxuICAgICAgICB0aGlzLmNsZWFySW50ZXJ2YWwoKTtcbiAgICAgICAgdGhpcy5fdHJhY2tJZCA9IG5ld0lkO1xuICAgICAgICB2YXIgdXJsID0gYXVkaW9UcmFjay51cmwsIHR5cGUgPSBhdWRpb1RyYWNrLnR5cGUsIGlkID0gYXVkaW9UcmFjay5pZDtcbiAgICAgICAgdGhpcy5obHMudHJpZ2dlcihldmVudHNfMS5kZWZhdWx0LkFVRElPX1RSQUNLX1NXSVRDSElORywgeyBpZDogaWQsIHR5cGU6IHR5cGUsIHVybDogdXJsIH0pO1xuICAgICAgICB0aGlzLl9sb2FkVHJhY2tEZXRhaWxzSWZOZWVkZWQoYXVkaW9UcmFjayk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICBBdWRpb1RyYWNrQ29udHJvbGxlci5wcm90b3R5cGUuZG9UaWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl91cGRhdGVUcmFjayh0aGlzLl90cmFja0lkKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNlbGVjdCBpbml0aWFsIHRyYWNrXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBBdWRpb1RyYWNrQ29udHJvbGxlci5wcm90b3R5cGUuX3NlbGVjdEluaXRpYWxBdWRpb1RyYWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgdHJhY2tzID0gdGhpcy50cmFja3M7XG4gICAgICAgIGlmICghdHJhY2tzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjdXJyZW50QXVkaW9UcmFjayA9IHRoaXMudHJhY2tzW3RoaXMuX3RyYWNrSWRdO1xuICAgICAgICB2YXIgbmFtZSA9IG51bGw7XG4gICAgICAgIGlmIChjdXJyZW50QXVkaW9UcmFjaykge1xuICAgICAgICAgICAgbmFtZSA9IGN1cnJlbnRBdWRpb1RyYWNrLm5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUHJlLXNlbGVjdCBkZWZhdWx0IHRyYWNrcyBpZiB0aGVyZSBhcmUgYW55XG4gICAgICAgIGlmICh0aGlzLl9zZWxlY3REZWZhdWx0VHJhY2spIHtcbiAgICAgICAgICAgIHZhciBkZWZhdWx0VHJhY2tzID0gdHJhY2tzLmZpbHRlcihmdW5jdGlvbiAodHJhY2spIHsgcmV0dXJuIHRyYWNrLmRlZmF1bHQ7IH0pO1xuICAgICAgICAgICAgaWYgKGRlZmF1bHRUcmFja3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdHJhY2tzID0gZGVmYXVsdFRyYWNrcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmxvZ2dlci53YXJuKCdObyBkZWZhdWx0IGF1ZGlvIHRyYWNrcyBkZWZpbmVkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRyYWNrRm91bmQgPSBmYWxzZTtcbiAgICAgICAgdmFyIHRyYXZlcnNlVHJhY2tzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gU2VsZWN0IHRyYWNrIHdpdGggcmlnaHQgZ3JvdXAgSURcbiAgICAgICAgICAgIHRyYWNrcy5mb3JFYWNoKGZ1bmN0aW9uICh0cmFjaykge1xuICAgICAgICAgICAgICAgIGlmICh0cmFja0ZvdW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gV2UgbmVlZCB0byBtYXRjaCB0aGUgKHByZS0pc2VsZWN0ZWQgZ3JvdXAgSURcbiAgICAgICAgICAgICAgICAvLyBhbmQgdGhlIE5BTUUgb2YgdGhlIGN1cnJlbnQgdHJhY2suXG4gICAgICAgICAgICAgICAgaWYgKCghX3RoaXMuYXVkaW9Hcm91cElkIHx8IHRyYWNrLmdyb3VwSWQgPT09IF90aGlzLmF1ZGlvR3JvdXBJZCkgJiZcbiAgICAgICAgICAgICAgICAgICAgKCFuYW1lIHx8IG5hbWUgPT09IHRyYWNrLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZXJlIHdhcyBhIHByZXZpb3VzIHRyYWNrIHRyeSB0byBzdGF5IHdpdGggdGhlIHNhbWUgYE5BTUVgLlxuICAgICAgICAgICAgICAgICAgICAvLyBJdCBzaG91bGQgYmUgdW5pcXVlIGFjcm9zcyB0cmFja3Mgb2Ygc2FtZSBncm91cCwgYW5kIGNvbnNpc3RlbnQgdGhyb3VnaCByZWR1bmRhbnQgdHJhY2sgZ3JvdXBzLlxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fc2V0QXVkaW9UcmFjayh0cmFjay5pZCk7XG4gICAgICAgICAgICAgICAgICAgIHRyYWNrRm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICB0cmF2ZXJzZVRyYWNrcygpO1xuICAgICAgICBpZiAoIXRyYWNrRm91bmQpIHtcbiAgICAgICAgICAgIG5hbWUgPSBudWxsO1xuICAgICAgICAgICAgdHJhdmVyc2VUcmFja3MoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRyYWNrRm91bmQpIHtcbiAgICAgICAgICAgIGxvZ2dlcl8xLmxvZ2dlci5lcnJvcihcIk5vIHRyYWNrIGZvdW5kIGZvciBydW5uaW5nIGF1ZGlvIGdyb3VwLUlEOiBcIiArIHRoaXMuYXVkaW9Hcm91cElkKTtcbiAgICAgICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoZXZlbnRzXzEuZGVmYXVsdC5FUlJPUiwge1xuICAgICAgICAgICAgICAgIHR5cGU6IGVycm9yc18xLkVycm9yVHlwZXMuTUVESUFfRVJST1IsXG4gICAgICAgICAgICAgICAgZGV0YWlsczogZXJyb3JzXzEuRXJyb3JEZXRhaWxzLkFVRElPX1RSQUNLX0xPQURfRVJST1IsXG4gICAgICAgICAgICAgICAgZmF0YWw6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXVkaW9UcmFja30gYXVkaW9UcmFja1xuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIEF1ZGlvVHJhY2tDb250cm9sbGVyLnByb3RvdHlwZS5fbmVlZHNUcmFja0xvYWRpbmcgPSBmdW5jdGlvbiAoYXVkaW9UcmFjaykge1xuICAgICAgICB2YXIgZGV0YWlscyA9IGF1ZGlvVHJhY2suZGV0YWlscywgdXJsID0gYXVkaW9UcmFjay51cmw7XG4gICAgICAgIGlmICghZGV0YWlscyB8fCBkZXRhaWxzLmxpdmUpIHtcbiAgICAgICAgICAgIC8vIGNoZWNrIGlmIHdlIGZhY2UgYW4gYXVkaW8gdHJhY2sgZW1iZWRkZWQgaW4gbWFpbiBwbGF5bGlzdCAoYXVkaW8gdHJhY2sgd2l0aG91dCBVUkkgYXR0cmlidXRlKVxuICAgICAgICAgICAgcmV0dXJuICEhdXJsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBdWRpb1RyYWNrfSBhdWRpb1RyYWNrXG4gICAgICovXG4gICAgQXVkaW9UcmFja0NvbnRyb2xsZXIucHJvdG90eXBlLl9sb2FkVHJhY2tEZXRhaWxzSWZOZWVkZWQgPSBmdW5jdGlvbiAoYXVkaW9UcmFjaykge1xuICAgICAgICBpZiAodGhpcy5fbmVlZHNUcmFja0xvYWRpbmcoYXVkaW9UcmFjaykpIHtcbiAgICAgICAgICAgIHZhciB1cmwgPSBhdWRpb1RyYWNrLnVybCwgaWQgPSBhdWRpb1RyYWNrLmlkO1xuICAgICAgICAgICAgLy8gdHJhY2sgbm90IHJldHJpZXZlZCB5ZXQsIG9yIGxpdmUgcGxheWxpc3Qgd2UgbmVlZCB0byAocmUpbG9hZCBpdFxuICAgICAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLmxvZyhcImxvYWRpbmcgYXVkaW8tdHJhY2sgcGxheWxpc3QgZm9yIGlkOiBcIiArIGlkKTtcbiAgICAgICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoZXZlbnRzXzEuZGVmYXVsdC5BVURJT19UUkFDS19MT0FESU5HLCB7IHVybDogdXJsLCBpZDogaWQgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG5ld0lkXG4gICAgICovXG4gICAgQXVkaW9UcmFja0NvbnRyb2xsZXIucHJvdG90eXBlLl91cGRhdGVUcmFjayA9IGZ1bmN0aW9uIChuZXdJZCkge1xuICAgICAgICAvLyBjaGVjayBpZiBsZXZlbCBpZHggaXMgdmFsaWRcbiAgICAgICAgaWYgKG5ld0lkIDwgMCB8fCBuZXdJZCA+PSB0aGlzLnRyYWNrcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBzdG9wcGluZyBsaXZlIHJlbG9hZGluZyB0aW1lciBpZiBhbnlcbiAgICAgICAgdGhpcy5jbGVhckludGVydmFsKCk7XG4gICAgICAgIHRoaXMuX3RyYWNrSWQgPSBuZXdJZDtcbiAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLmxvZyhcInRyeWluZyB0byB1cGRhdGUgYXVkaW8tdHJhY2sgXCIgKyBuZXdJZCk7XG4gICAgICAgIHZhciBhdWRpb1RyYWNrID0gdGhpcy50cmFja3NbbmV3SWRdO1xuICAgICAgICB0aGlzLl9sb2FkVHJhY2tEZXRhaWxzSWZOZWVkZWQoYXVkaW9UcmFjayk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIEF1ZGlvVHJhY2tDb250cm9sbGVyLnByb3RvdHlwZS5faGFuZGxlTG9hZEVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBGaXJzdCwgbGV0J3MgYmxhY2sgbGlzdCBjdXJyZW50IHRyYWNrIGlkXG4gICAgICAgIHRoaXMudHJhY2tJZEJsYWNrbGlzdFt0aGlzLl90cmFja0lkXSA9IHRydWU7XG4gICAgICAgIC8vIExldCdzIHRyeSB0byBmYWxsIGJhY2sgb24gYSBmdW5jdGlvbmFsIGF1ZGlvLXRyYWNrIHdpdGggdGhlIHNhbWUgZ3JvdXAgSURcbiAgICAgICAgdmFyIHByZXZpb3VzSWQgPSB0aGlzLl90cmFja0lkO1xuICAgICAgICB2YXIgX2EgPSB0aGlzLnRyYWNrc1twcmV2aW91c0lkXSwgbmFtZSA9IF9hLm5hbWUsIGxhbmd1YWdlID0gX2EubGFuZ3VhZ2UsIGdyb3VwSWQgPSBfYS5ncm91cElkO1xuICAgICAgICBsb2dnZXJfMS5sb2dnZXIud2FybihcIkxvYWRpbmcgZmFpbGVkIG9uIGF1ZGlvIHRyYWNrIGlkOiBcIiArIHByZXZpb3VzSWQgKyBcIiwgZ3JvdXAtaWQ6IFwiICsgZ3JvdXBJZCArIFwiLCBuYW1lL2xhbmd1YWdlOiBcXFwiXCIgKyBuYW1lICsgXCJcXFwiIC8gXFxcIlwiICsgbGFuZ3VhZ2UgKyBcIlxcXCJcIik7XG4gICAgICAgIC8vIEZpbmQgYSBub24tYmxhY2tsaXN0ZWQgdHJhY2sgSUQgd2l0aCB0aGUgc2FtZSBOQU1FXG4gICAgICAgIC8vIEF0IGxlYXN0IGEgdHJhY2sgdGhhdCBpcyBub3QgYmxhY2tsaXN0ZWQsIHRodXMgb24gYW5vdGhlciBncm91cC1JRC5cbiAgICAgICAgdmFyIG5ld0lkID0gcHJldmlvdXNJZDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnRyYWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMudHJhY2tJZEJsYWNrbGlzdFtpXSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG5ld1RyYWNrID0gdGhpcy50cmFja3NbaV07XG4gICAgICAgICAgICBpZiAobmV3VHJhY2submFtZSA9PT0gbmFtZSkge1xuICAgICAgICAgICAgICAgIG5ld0lkID0gaTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobmV3SWQgPT09IHByZXZpb3VzSWQpIHtcbiAgICAgICAgICAgIGxvZ2dlcl8xLmxvZ2dlci53YXJuKFwiTm8gZmFsbGJhY2sgYXVkaW8tdHJhY2sgZm91bmQgZm9yIG5hbWUvbGFuZ3VhZ2U6IFxcXCJcIiArIG5hbWUgKyBcIlxcXCIgLyBcXFwiXCIgKyBsYW5ndWFnZSArIFwiXFxcIlwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsb2dnZXJfMS5sb2dnZXIubG9nKCdBdHRlbXB0aW5nIGF1ZGlvLXRyYWNrIGZhbGxiYWNrIGlkOicsIG5ld0lkLCAnZ3JvdXAtaWQ6JywgdGhpcy50cmFja3NbbmV3SWRdLmdyb3VwSWQpO1xuICAgICAgICB0aGlzLl9zZXRBdWRpb1RyYWNrKG5ld0lkKTtcbiAgICB9O1xuICAgIHJldHVybiBBdWRpb1RyYWNrQ29udHJvbGxlcjtcbn0odGFza19sb29wXzEuZGVmYXVsdCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gQXVkaW9UcmFja0NvbnRyb2xsZXI7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvY29udHJvbGxlci9iYXNlLXN0cmVhbS1jb250cm9sbGVyLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9jb250cm9sbGVyL2Jhc2Utc3RyZWFtLWNvbnRyb2xsZXIuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovKGZ1bmN0aW9uKE51bWJlcikge1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdGFza19sb29wXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi90YXNrLWxvb3AgKi8gXCIuL3NyYy90YXNrLWxvb3AuanNcIik7XG52YXIgZnJhZ21lbnRfdHJhY2tlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9mcmFnbWVudC10cmFja2VyICovIFwiLi9zcmMvY29udHJvbGxlci9mcmFnbWVudC10cmFja2VyLmpzXCIpO1xudmFyIGJ1ZmZlcl9oZWxwZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL2J1ZmZlci1oZWxwZXIgKi8gXCIuL3NyYy91dGlscy9idWZmZXItaGVscGVyLmpzXCIpO1xudmFyIGxvZ2dlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvbG9nZ2VyICovIFwiLi9zcmMvdXRpbHMvbG9nZ2VyLmpzXCIpO1xuZXhwb3J0cy5TdGF0ZSA9IHtcbiAgICBTVE9QUEVEOiAnU1RPUFBFRCcsXG4gICAgU1RBUlRJTkc6ICdTVEFSVElORycsXG4gICAgSURMRTogJ0lETEUnLFxuICAgIFBBVVNFRDogJ1BBVVNFRCcsXG4gICAgS0VZX0xPQURJTkc6ICdLRVlfTE9BRElORycsXG4gICAgRlJBR19MT0FESU5HOiAnRlJBR19MT0FESU5HJyxcbiAgICBGUkFHX0xPQURJTkdfV0FJVElOR19SRVRSWTogJ0ZSQUdfTE9BRElOR19XQUlUSU5HX1JFVFJZJyxcbiAgICBXQUlUSU5HX1RSQUNLOiAnV0FJVElOR19UUkFDSycsXG4gICAgUEFSU0lORzogJ1BBUlNJTkcnLFxuICAgIFBBUlNFRDogJ1BBUlNFRCcsXG4gICAgQlVGRkVSX0ZMVVNISU5HOiAnQlVGRkVSX0ZMVVNISU5HJyxcbiAgICBFTkRFRDogJ0VOREVEJyxcbiAgICBFUlJPUjogJ0VSUk9SJyxcbiAgICBXQUlUSU5HX0lOSVRfUFRTOiAnV0FJVElOR19JTklUX1BUUycsXG4gICAgV0FJVElOR19MRVZFTDogJ1dBSVRJTkdfTEVWRUwnXG59O1xudmFyIEJhc2VTdHJlYW1Db250cm9sbGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhCYXNlU3RyZWFtQ29udHJvbGxlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBCYXNlU3RyZWFtQ29udHJvbGxlcigpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBCYXNlU3RyZWFtQ29udHJvbGxlci5wcm90b3R5cGUuZG9UaWNrID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgIEJhc2VTdHJlYW1Db250cm9sbGVyLnByb3RvdHlwZS5zdGFydExvYWQgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgQmFzZVN0cmVhbUNvbnRyb2xsZXIucHJvdG90eXBlLnN0b3BMb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZnJhZyA9IHRoaXMuZnJhZ0N1cnJlbnQ7XG4gICAgICAgIGlmIChmcmFnKSB7XG4gICAgICAgICAgICBpZiAoZnJhZy5sb2FkZXIpIHtcbiAgICAgICAgICAgICAgICBmcmFnLmxvYWRlci5hYm9ydCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5mcmFnbWVudFRyYWNrZXIucmVtb3ZlRnJhZ21lbnQoZnJhZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZGVtdXhlcikge1xuICAgICAgICAgICAgdGhpcy5kZW11eGVyLmRlc3Ryb3koKTtcbiAgICAgICAgICAgIHRoaXMuZGVtdXhlciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5mcmFnQ3VycmVudCA9IG51bGw7XG4gICAgICAgIHRoaXMuZnJhZ1ByZXZpb3VzID0gbnVsbDtcbiAgICAgICAgdGhpcy5jbGVhckludGVydmFsKCk7XG4gICAgICAgIHRoaXMuY2xlYXJOZXh0VGljaygpO1xuICAgICAgICB0aGlzLnN0YXRlID0gZXhwb3J0cy5TdGF0ZS5TVE9QUEVEO1xuICAgIH07XG4gICAgQmFzZVN0cmVhbUNvbnRyb2xsZXIucHJvdG90eXBlLl9zdHJlYW1FbmRlZCA9IGZ1bmN0aW9uIChidWZmZXJJbmZvLCBsZXZlbERldGFpbHMpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcywgZnJhZ0N1cnJlbnQgPSBfYS5mcmFnQ3VycmVudCwgZnJhZ21lbnRUcmFja2VyID0gX2EuZnJhZ21lbnRUcmFja2VyO1xuICAgICAgICAvLyB3ZSBqdXN0IGdvdCBkb25lIGxvYWRpbmcgdGhlIGZpbmFsIGZyYWdtZW50IGFuZCB0aGVyZSBpcyBubyBvdGhlciBidWZmZXJlZCByYW5nZSBhZnRlciAuLi5cbiAgICAgICAgLy8gcmF0aW9uYWxlIGlzIHRoYXQgaW4gY2FzZSB0aGVyZSBhcmUgYW55IGJ1ZmZlcmVkIHJhbmdlcyBhZnRlciwgaXQgbWVhbnMgdGhhdCB0aGVyZSBhcmUgdW5idWZmZXJlZCBwb3J0aW9uIGluIGJldHdlZW5cbiAgICAgICAgLy8gc28gd2Ugc2hvdWxkIG5vdCBzd2l0Y2ggdG8gRU5ERUQgaW4gdGhhdCBjYXNlLCB0byBiZSBhYmxlIHRvIGJ1ZmZlciB0aGVtXG4gICAgICAgIC8vIGRvbnQgc3dpdGNoIHRvIEVOREVEIGlmIHdlIG5lZWQgdG8gYmFja3RyYWNrIGxhc3QgZnJhZ21lbnRcbiAgICAgICAgaWYgKCFsZXZlbERldGFpbHMubGl2ZSAmJiBmcmFnQ3VycmVudCAmJiAhZnJhZ0N1cnJlbnQuYmFja3RyYWNrZWQgJiYgZnJhZ0N1cnJlbnQuc24gPT09IGxldmVsRGV0YWlscy5lbmRTTiAmJiAhYnVmZmVySW5mby5uZXh0U3RhcnQpIHtcbiAgICAgICAgICAgIHZhciBmcmFnU3RhdGUgPSBmcmFnbWVudFRyYWNrZXIuZ2V0U3RhdGUoZnJhZ0N1cnJlbnQpO1xuICAgICAgICAgICAgcmV0dXJuIGZyYWdTdGF0ZSA9PT0gZnJhZ21lbnRfdHJhY2tlcl8xLkZyYWdtZW50U3RhdGUuUEFSVElBTCB8fCBmcmFnU3RhdGUgPT09IGZyYWdtZW50X3RyYWNrZXJfMS5GcmFnbWVudFN0YXRlLk9LO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIEJhc2VTdHJlYW1Db250cm9sbGVyLnByb3RvdHlwZS5vbk1lZGlhU2Vla2luZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcywgY29uZmlnID0gX2EuY29uZmlnLCBtZWRpYSA9IF9hLm1lZGlhLCBtZWRpYUJ1ZmZlciA9IF9hLm1lZGlhQnVmZmVyLCBzdGF0ZSA9IF9hLnN0YXRlO1xuICAgICAgICB2YXIgY3VycmVudFRpbWUgPSBtZWRpYSA/IG1lZGlhLmN1cnJlbnRUaW1lIDogbnVsbDtcbiAgICAgICAgdmFyIGJ1ZmZlckluZm8gPSBidWZmZXJfaGVscGVyXzEuQnVmZmVySGVscGVyLmJ1ZmZlckluZm8obWVkaWFCdWZmZXIgfHwgbWVkaWEsIGN1cnJlbnRUaW1lLCB0aGlzLmNvbmZpZy5tYXhCdWZmZXJIb2xlKTtcbiAgICAgICAgaWYgKE51bWJlci5pc0Zpbml0ZShjdXJyZW50VGltZSkpIHtcbiAgICAgICAgICAgIGxvZ2dlcl8xLmxvZ2dlci5sb2coXCJtZWRpYSBzZWVraW5nIHRvIFwiICsgY3VycmVudFRpbWUudG9GaXhlZCgzKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlID09PSBleHBvcnRzLlN0YXRlLkZSQUdfTE9BRElORykge1xuICAgICAgICAgICAgdmFyIGZyYWdDdXJyZW50ID0gdGhpcy5mcmFnQ3VycmVudDtcbiAgICAgICAgICAgIC8vIGNoZWNrIGlmIHdlIGFyZSBzZWVraW5nIHRvIGEgdW5idWZmZXJlZCBhcmVhIEFORCBpZiBmcmFnIGxvYWRpbmcgaXMgaW4gcHJvZ3Jlc3NcbiAgICAgICAgICAgIGlmIChidWZmZXJJbmZvLmxlbiA9PT0gMCAmJiBmcmFnQ3VycmVudCkge1xuICAgICAgICAgICAgICAgIHZhciB0b2xlcmFuY2UgPSBjb25maWcubWF4RnJhZ0xvb2tVcFRvbGVyYW5jZTtcbiAgICAgICAgICAgICAgICB2YXIgZnJhZ1N0YXJ0T2Zmc2V0ID0gZnJhZ0N1cnJlbnQuc3RhcnQgLSB0b2xlcmFuY2U7XG4gICAgICAgICAgICAgICAgdmFyIGZyYWdFbmRPZmZzZXQgPSBmcmFnQ3VycmVudC5zdGFydCArIGZyYWdDdXJyZW50LmR1cmF0aW9uICsgdG9sZXJhbmNlO1xuICAgICAgICAgICAgICAgIC8vIGNoZWNrIGlmIHdlIHNlZWsgcG9zaXRpb24gd2lsbCBiZSBvdXQgb2YgY3VycmVudGx5IGxvYWRlZCBmcmFnIHJhbmdlIDogaWYgb3V0IGNhbmNlbCBmcmFnIGxvYWQsIGlmIGluLCBkb24ndCBkbyBhbnl0aGluZ1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50VGltZSA8IGZyYWdTdGFydE9mZnNldCB8fCBjdXJyZW50VGltZSA+IGZyYWdFbmRPZmZzZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZyYWdDdXJyZW50LmxvYWRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLmxvZygnc2Vla2luZyBvdXRzaWRlIG9mIGJ1ZmZlciB3aGlsZSBmcmFnbWVudCBsb2FkIGluIHByb2dyZXNzLCBjYW5jZWwgZnJhZ21lbnQgbG9hZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZnJhZ0N1cnJlbnQubG9hZGVyLmFib3J0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mcmFnQ3VycmVudCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZnJhZ1ByZXZpb3VzID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgLy8gc3dpdGNoIHRvIElETEUgc3RhdGUgdG8gbG9hZCBuZXcgZnJhZ21lbnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IGV4cG9ydHMuU3RhdGUuSURMRTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmxvZ2dlci5sb2coJ3NlZWtpbmcgb3V0c2lkZSBvZiBidWZmZXIgYnV0IHdpdGhpbiBjdXJyZW50bHkgbG9hZGVkIGZyYWdtZW50IHJhbmdlJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHN0YXRlID09PSBleHBvcnRzLlN0YXRlLkVOREVEKSB7XG4gICAgICAgICAgICAvLyBpZiBzZWVraW5nIHRvIHVuYnVmZmVyZWQgYXJlYSwgY2xlYW4gdXAgZnJhZ1ByZXZpb3VzXG4gICAgICAgICAgICBpZiAoYnVmZmVySW5mby5sZW4gPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZyYWdQcmV2aW91cyA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy5mcmFnQ3VycmVudCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBzd2l0Y2ggdG8gSURMRSBzdGF0ZSB0byBjaGVjayBmb3IgcG90ZW50aWFsIG5ldyBmcmFnbWVudFxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IGV4cG9ydHMuU3RhdGUuSURMRTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVkaWEpIHtcbiAgICAgICAgICAgIHRoaXMubGFzdEN1cnJlbnRUaW1lID0gY3VycmVudFRpbWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaW4gY2FzZSBzZWVraW5nIG9jY3VycyBhbHRob3VnaCBubyBtZWRpYSBidWZmZXJlZCwgYWRqdXN0IHN0YXJ0UG9zaXRpb24gYW5kIG5leHRMb2FkUG9zaXRpb24gdG8gc2VlayB0YXJnZXRcbiAgICAgICAgaWYgKCF0aGlzLmxvYWRlZG1ldGFkYXRhKSB7XG4gICAgICAgICAgICB0aGlzLm5leHRMb2FkUG9zaXRpb24gPSB0aGlzLnN0YXJ0UG9zaXRpb24gPSBjdXJyZW50VGltZTtcbiAgICAgICAgfVxuICAgICAgICAvLyB0aWNrIHRvIHNwZWVkIHVwIHByb2Nlc3NpbmdcbiAgICAgICAgdGhpcy50aWNrKCk7XG4gICAgfTtcbiAgICBCYXNlU3RyZWFtQ29udHJvbGxlci5wcm90b3R5cGUub25NZWRpYUVuZGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyByZXNldCBzdGFydFBvc2l0aW9uIGFuZCBsYXN0Q3VycmVudFRpbWUgdG8gcmVzdGFydCBwbGF5YmFjayBAIHN0cmVhbSBiZWdpbm5pbmdcbiAgICAgICAgdGhpcy5zdGFydFBvc2l0aW9uID0gdGhpcy5sYXN0Q3VycmVudFRpbWUgPSAwO1xuICAgIH07XG4gICAgQmFzZVN0cmVhbUNvbnRyb2xsZXIucHJvdG90eXBlLm9uSGFuZGxlckRlc3Ryb3lpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuc3RvcExvYWQoKTtcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5vbkhhbmRsZXJEZXN0cm95aW5nLmNhbGwodGhpcyk7XG4gICAgfTtcbiAgICBCYXNlU3RyZWFtQ29udHJvbGxlci5wcm90b3R5cGUub25IYW5kbGVyRGVzdHJveWVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnN0YXRlID0gZXhwb3J0cy5TdGF0ZS5TVE9QUEVEO1xuICAgICAgICB0aGlzLmZyYWdtZW50VHJhY2tlciA9IG51bGw7XG4gICAgfTtcbiAgICByZXR1cm4gQmFzZVN0cmVhbUNvbnRyb2xsZXI7XG59KHRhc2tfbG9vcF8xLmRlZmF1bHQpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IEJhc2VTdHJlYW1Db250cm9sbGVyO1xuXG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwodGhpcywgX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9zcmMvcG9seWZpbGxzL251bWJlciAqLyBcIi4vc3JjL3BvbHlmaWxscy9udW1iZXIuanNcIilbXCJOdW1iZXJcIl0pKVxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9jb250cm9sbGVyL2J1ZmZlci1jb250cm9sbGVyLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvY29udHJvbGxlci9idWZmZXItY29udHJvbGxlci5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovKGZ1bmN0aW9uKE51bWJlcikge1xuLypcbiAqIEJ1ZmZlciBDb250cm9sbGVyXG4qL1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZXZlbnRzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9ldmVudHMgKi8gXCIuL3NyYy9ldmVudHMuanNcIik7XG52YXIgZXZlbnRfaGFuZGxlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZXZlbnQtaGFuZGxlciAqLyBcIi4vc3JjL2V2ZW50LWhhbmRsZXIuanNcIik7XG52YXIgbG9nZ2VyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy9sb2dnZXIgKi8gXCIuL3NyYy91dGlscy9sb2dnZXIuanNcIik7XG52YXIgZXJyb3JzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9lcnJvcnMgKi8gXCIuL3NyYy9lcnJvcnMuanNcIik7XG52YXIgbWVkaWFzb3VyY2VfaGVscGVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy9tZWRpYXNvdXJjZS1oZWxwZXIgKi8gXCIuL3NyYy91dGlscy9tZWRpYXNvdXJjZS1oZWxwZXIuanNcIik7XG52YXIgTWVkaWFTb3VyY2UgPSBtZWRpYXNvdXJjZV9oZWxwZXJfMS5nZXRNZWRpYVNvdXJjZSgpO1xudmFyIEJ1ZmZlckNvbnRyb2xsZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEJ1ZmZlckNvbnRyb2xsZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQnVmZmVyQ29udHJvbGxlcihobHMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgaGxzLCBldmVudHNfMS5kZWZhdWx0Lk1FRElBX0FUVEFDSElORywgZXZlbnRzXzEuZGVmYXVsdC5NRURJQV9ERVRBQ0hJTkcsIGV2ZW50c18xLmRlZmF1bHQuTUFOSUZFU1RfUEFSU0VELCBldmVudHNfMS5kZWZhdWx0LkJVRkZFUl9SRVNFVCwgZXZlbnRzXzEuZGVmYXVsdC5CVUZGRVJfQVBQRU5ESU5HLCBldmVudHNfMS5kZWZhdWx0LkJVRkZFUl9DT0RFQ1MsIGV2ZW50c18xLmRlZmF1bHQuQlVGRkVSX0VPUywgZXZlbnRzXzEuZGVmYXVsdC5CVUZGRVJfRkxVU0hJTkcsIGV2ZW50c18xLmRlZmF1bHQuTEVWRUxfUFRTX1VQREFURUQsIGV2ZW50c18xLmRlZmF1bHQuTEVWRUxfVVBEQVRFRCkgfHwgdGhpcztcbiAgICAgICAgLy8gdGhlIHZhbHVlIHRoYXQgd2UgaGF2ZSBzZXQgbWVkaWFzb3VyY2UuZHVyYXRpb24gdG9cbiAgICAgICAgLy8gKHRoZSBhY3R1YWwgZHVyYXRpb24gbWF5IGJlIHR3ZWFrZWQgc2xpZ2hseSBieSB0aGUgYnJvd3NlcilcbiAgICAgICAgX3RoaXMuX21zRHVyYXRpb24gPSBudWxsO1xuICAgICAgICAvLyB0aGUgdmFsdWUgdGhhdCB3ZSB3YW50IHRvIHNldCBtZWRpYVNvdXJjZS5kdXJhdGlvbiB0b1xuICAgICAgICBfdGhpcy5fbGV2ZWxEdXJhdGlvbiA9IG51bGw7XG4gICAgICAgIC8vIHRoZSB0YXJnZXQgZHVyYXRpb24gb2YgdGhlIGN1cnJlbnQgbWVkaWEgcGxheWxpc3RcbiAgICAgICAgX3RoaXMuX2xldmVsVGFyZ2V0RHVyYXRpb24gPSAxMDtcbiAgICAgICAgLy8gY3VycmVudCBzdHJlYW0gc3RhdGU6IHRydWUgLSBmb3IgbGl2ZSBicm9hZGNhc3QsIGZhbHNlIC0gZm9yIFZvRCBjb250ZW50XG4gICAgICAgIF90aGlzLl9saXZlID0gbnVsbDtcbiAgICAgICAgLy8gY2FjaGUgdGhlIHNlbGYgZ2VuZXJhdGVkIG9iamVjdCB1cmwgdG8gZGV0ZWN0IGhpamFjayBvZiB2aWRlbyB0YWdcbiAgICAgICAgX3RoaXMuX29iamVjdFVybCA9IG51bGw7XG4gICAgICAgIC8vIFRoZSBudW1iZXIgb2YgQlVGRkVSX0NPREVDIGV2ZW50cyByZWNlaXZlZCBiZWZvcmUgYW55IHNvdXJjZUJ1ZmZlcnMgYXJlIGNyZWF0ZWRcbiAgICAgICAgX3RoaXMuYnVmZmVyQ29kZWNFdmVudHNFeHBlY3RlZCA9IDA7XG4gICAgICAgIC8vIFNvdXJjZSBCdWZmZXIgbGlzdGVuZXJzXG4gICAgICAgIF90aGlzLm9uc2J1ZSA9IF90aGlzLm9uU0JVcGRhdGVFbmQuYmluZChfdGhpcyk7XG4gICAgICAgIF90aGlzLm9uc2JlID0gX3RoaXMub25TQlVwZGF0ZUVycm9yLmJpbmQoX3RoaXMpO1xuICAgICAgICBfdGhpcy5wZW5kaW5nVHJhY2tzID0ge307XG4gICAgICAgIF90aGlzLnRyYWNrcyA9IHt9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEJ1ZmZlckNvbnRyb2xsZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGV2ZW50X2hhbmRsZXJfMS5kZWZhdWx0LnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcyk7XG4gICAgfTtcbiAgICBCdWZmZXJDb250cm9sbGVyLnByb3RvdHlwZS5vbkxldmVsUHRzVXBkYXRlZCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHZhciB0eXBlID0gZGF0YS50eXBlO1xuICAgICAgICB2YXIgYXVkaW9UcmFjayA9IHRoaXMudHJhY2tzLmF1ZGlvO1xuICAgICAgICAvLyBBZGp1c3RpbmcgYFNvdXJjZUJ1ZmZlci50aW1lc3RhbXBPZmZzZXRgIChkZXNpcmVkIHBvaW50IGluIHRoZSB0aW1lbGluZSB3aGVyZSB0aGUgbmV4dCBmcmFtZXMgc2hvdWxkIGJlIGFwcGVuZGVkKVxuICAgICAgICAvLyBpbiBDaHJvbWUgYnJvd3NlciB3aGVuIHdlIGRldGVjdCBNUEVHIGF1ZGlvIGNvbnRhaW5lciBhbmQgdGltZSBkZWx0YSBiZXR3ZWVuIGxldmVsIFBUUyBhbmQgYFNvdXJjZUJ1ZmZlci50aW1lc3RhbXBPZmZzZXRgXG4gICAgICAgIC8vIGlzIGdyZWF0ZXIgdGhhbiAxMDBtcyAodGhpcyBpcyBlbm91Z2ggdG8gaGFuZGxlIHNlZWsgZm9yIFZPRCBvciBsZXZlbCBjaGFuZ2UgZm9yIExJVkUgdmlkZW9zKS4gQXQgdGhlIHRpbWUgb2YgY2hhbmdlIHdlIGlzc3VlXG4gICAgICAgIC8vIGBTb3VyY2VCdWZmZXIuYWJvcnQoKWAgYW5kIGFkanVzdGluZyBgU291cmNlQnVmZmVyLnRpbWVzdGFtcE9mZnNldGAgaWYgYFNvdXJjZUJ1ZmZlci51cGRhdGluZ2AgaXMgZmFsc2Ugb3IgYXdhaXRpbmcgYHVwZGF0ZWVuZGBcbiAgICAgICAgLy8gZXZlbnQgaWYgU0IgaXMgaW4gdXBkYXRpbmcgc3RhdGUuXG4gICAgICAgIC8vIE1vcmUgaW5mbyBoZXJlOiBodHRwczovL2dpdGh1Yi5jb20vdmlkZW8tZGV2L2hscy5qcy9pc3N1ZXMvMzMyI2lzc3VlY29tbWVudC0yNTc5ODY0ODZcbiAgICAgICAgaWYgKHR5cGUgPT09ICdhdWRpbycgJiYgYXVkaW9UcmFjayAmJiBhdWRpb1RyYWNrLmNvbnRhaW5lciA9PT0gJ2F1ZGlvL21wZWcnKSB7IC8vIENocm9tZSBhdWRpbyBtcDMgdHJhY2tcbiAgICAgICAgICAgIHZhciBhdWRpb0J1ZmZlciA9IHRoaXMuc291cmNlQnVmZmVyLmF1ZGlvO1xuICAgICAgICAgICAgdmFyIGRlbHRhID0gTWF0aC5hYnMoYXVkaW9CdWZmZXIudGltZXN0YW1wT2Zmc2V0IC0gZGF0YS5zdGFydCk7XG4gICAgICAgICAgICAvLyBhZGp1c3QgdGltZXN0YW1wIG9mZnNldCBpZiB0aW1lIGRlbHRhIGlzIGdyZWF0ZXIgdGhhbiAxMDBtc1xuICAgICAgICAgICAgaWYgKGRlbHRhID4gMC4xKSB7XG4gICAgICAgICAgICAgICAgdmFyIHVwZGF0aW5nID0gYXVkaW9CdWZmZXIudXBkYXRpbmc7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgYXVkaW9CdWZmZXIuYWJvcnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXJfMS5sb2dnZXIud2FybignY2FuIG5vdCBhYm9ydCBhdWRpbyBidWZmZXI6ICcgKyBlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIXVwZGF0aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmxvZ2dlci53YXJuKCdjaGFuZ2UgbXBlZyBhdWRpbyB0aW1lc3RhbXAgb2Zmc2V0IGZyb20gJyArIGF1ZGlvQnVmZmVyLnRpbWVzdGFtcE9mZnNldCArICcgdG8gJyArIGRhdGEuc3RhcnQpO1xuICAgICAgICAgICAgICAgICAgICBhdWRpb0J1ZmZlci50aW1lc3RhbXBPZmZzZXQgPSBkYXRhLnN0YXJ0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hdWRpb1RpbWVzdGFtcE9mZnNldCA9IGRhdGEuc3RhcnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBCdWZmZXJDb250cm9sbGVyLnByb3RvdHlwZS5vbk1hbmlmZXN0UGFyc2VkID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgLy8gaW4gY2FzZSBvZiBhbHQgYXVkaW8gMiBCVUZGRVJfQ09ERUNTIGV2ZW50cyB3aWxsIGJlIHRyaWdnZXJlZCwgb25lIHBlciBzdHJlYW0gY29udHJvbGxlclxuICAgICAgICAvLyBzb3VyY2VidWZmZXJzIHdpbGwgYmUgY3JlYXRlZCBhbGwgYXQgb25jZSB3aGVuIHRoZSBleHBlY3RlZCBuYiBvZiB0cmFja3Mgd2lsbCBiZSByZWFjaGVkXG4gICAgICAgIC8vIGluIGNhc2UgYWx0IGF1ZGlvIGlzIG5vdCB1c2VkLCBvbmx5IG9uZSBCVUZGRVJfQ09ERUMgZXZlbnQgd2lsbCBiZSBmaXJlZCBmcm9tIG1haW4gc3RyZWFtIGNvbnRyb2xsZXJcbiAgICAgICAgLy8gaXQgd2lsbCBjb250YWluIHRoZSBleHBlY3RlZCBuYiBvZiBzb3VyY2UgYnVmZmVycywgbm8gbmVlZCB0byBjb21wdXRlIGl0XG4gICAgICAgIHRoaXMuYnVmZmVyQ29kZWNFdmVudHNFeHBlY3RlZCA9IGRhdGEuYWx0QXVkaW8gPyAyIDogMTtcbiAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLmxvZyh0aGlzLmJ1ZmZlckNvZGVjRXZlbnRzRXhwZWN0ZWQgKyBcIiBidWZmZXJDb2RlYyBldmVudChzKSBleHBlY3RlZFwiKTtcbiAgICB9O1xuICAgIEJ1ZmZlckNvbnRyb2xsZXIucHJvdG90eXBlLm9uTWVkaWFBdHRhY2hpbmcgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB2YXIgbWVkaWEgPSB0aGlzLm1lZGlhID0gZGF0YS5tZWRpYTtcbiAgICAgICAgaWYgKG1lZGlhKSB7XG4gICAgICAgICAgICAvLyBzZXR1cCB0aGUgbWVkaWEgc291cmNlXG4gICAgICAgICAgICB2YXIgbXMgPSB0aGlzLm1lZGlhU291cmNlID0gbmV3IE1lZGlhU291cmNlKCk7XG4gICAgICAgICAgICAvLyBNZWRpYSBTb3VyY2UgbGlzdGVuZXJzXG4gICAgICAgICAgICB0aGlzLm9ubXNvID0gdGhpcy5vbk1lZGlhU291cmNlT3Blbi5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5vbm1zZSA9IHRoaXMub25NZWRpYVNvdXJjZUVuZGVkLmJpbmQodGhpcyk7XG4gICAgICAgICAgICB0aGlzLm9ubXNjID0gdGhpcy5vbk1lZGlhU291cmNlQ2xvc2UuYmluZCh0aGlzKTtcbiAgICAgICAgICAgIG1zLmFkZEV2ZW50TGlzdGVuZXIoJ3NvdXJjZW9wZW4nLCB0aGlzLm9ubXNvKTtcbiAgICAgICAgICAgIG1zLmFkZEV2ZW50TGlzdGVuZXIoJ3NvdXJjZWVuZGVkJywgdGhpcy5vbm1zZSk7XG4gICAgICAgICAgICBtcy5hZGRFdmVudExpc3RlbmVyKCdzb3VyY2VjbG9zZScsIHRoaXMub25tc2MpO1xuICAgICAgICAgICAgLy8gbGluayB2aWRlbyBhbmQgbWVkaWEgU291cmNlXG4gICAgICAgICAgICBtZWRpYS5zcmMgPSB3aW5kb3cuVVJMLmNyZWF0ZU9iamVjdFVSTChtcyk7XG4gICAgICAgICAgICAvLyBjYWNoZSB0aGUgbG9jYWxseSBnZW5lcmF0ZWQgb2JqZWN0IHVybFxuICAgICAgICAgICAgdGhpcy5fb2JqZWN0VXJsID0gbWVkaWEuc3JjO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBCdWZmZXJDb250cm9sbGVyLnByb3RvdHlwZS5vbk1lZGlhRGV0YWNoaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBsb2dnZXJfMS5sb2dnZXIubG9nKCdtZWRpYSBzb3VyY2UgZGV0YWNoaW5nJyk7XG4gICAgICAgIHZhciBtcyA9IHRoaXMubWVkaWFTb3VyY2U7XG4gICAgICAgIGlmIChtcykge1xuICAgICAgICAgICAgaWYgKG1zLnJlYWR5U3RhdGUgPT09ICdvcGVuJykge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVuZE9mU3RyZWFtIGNvdWxkIHRyaWdnZXIgZXhjZXB0aW9uIGlmIGFueSBzb3VyY2VidWZmZXIgaXMgaW4gdXBkYXRpbmcgc3RhdGVcbiAgICAgICAgICAgICAgICAgICAgLy8gd2UgZG9uJ3QgcmVhbGx5IGNhcmUgYWJvdXQgY2hlY2tpbmcgc291cmNlYnVmZmVyIHN0YXRlIGhlcmUsXG4gICAgICAgICAgICAgICAgICAgIC8vIGFzIHdlIGFyZSBhbnl3YXkgZGV0YWNoaW5nIHRoZSBNZWRpYVNvdXJjZVxuICAgICAgICAgICAgICAgICAgICAvLyBsZXQncyBqdXN0IGF2b2lkIHRoaXMgZXhjZXB0aW9uIHRvIHByb3BhZ2F0ZVxuICAgICAgICAgICAgICAgICAgICBtcy5lbmRPZlN0cmVhbSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmxvZ2dlci53YXJuKFwib25NZWRpYURldGFjaGluZzpcIiArIGVyci5tZXNzYWdlICsgXCIgd2hpbGUgY2FsbGluZyBlbmRPZlN0cmVhbVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtcy5yZW1vdmVFdmVudExpc3RlbmVyKCdzb3VyY2VvcGVuJywgdGhpcy5vbm1zbyk7XG4gICAgICAgICAgICBtcy5yZW1vdmVFdmVudExpc3RlbmVyKCdzb3VyY2VlbmRlZCcsIHRoaXMub25tc2UpO1xuICAgICAgICAgICAgbXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignc291cmNlY2xvc2UnLCB0aGlzLm9ubXNjKTtcbiAgICAgICAgICAgIC8vIERldGFjaCBwcm9wZXJseSB0aGUgTWVkaWFTb3VyY2UgZnJvbSB0aGUgSFRNTE1lZGlhRWxlbWVudCBhc1xuICAgICAgICAgICAgLy8gc3VnZ2VzdGVkIGluIGh0dHBzOi8vZ2l0aHViLmNvbS93M2MvbWVkaWEtc291cmNlL2lzc3Vlcy81My5cbiAgICAgICAgICAgIGlmICh0aGlzLm1lZGlhKSB7XG4gICAgICAgICAgICAgICAgd2luZG93LlVSTC5yZXZva2VPYmplY3RVUkwodGhpcy5fb2JqZWN0VXJsKTtcbiAgICAgICAgICAgICAgICAvLyBjbGVhbiB1cCB2aWRlbyB0YWcgc3JjIG9ubHkgaWYgaXQncyBvdXIgb3duIHVybC4gc29tZSBleHRlcm5hbCBsaWJyYXJpZXMgbWlnaHRcbiAgICAgICAgICAgICAgICAvLyBoaWphY2sgdGhlIHZpZGVvIHRhZyBhbmQgY2hhbmdlIGl0cyAnc3JjJyB3aXRob3V0IGRlc3Ryb3lpbmcgdGhlIEhscyBpbnN0YW5jZSBmaXJzdFxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm1lZGlhLnNyYyA9PT0gdGhpcy5fb2JqZWN0VXJsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWVkaWEucmVtb3ZlQXR0cmlidXRlKCdzcmMnKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tZWRpYS5sb2FkKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXJfMS5sb2dnZXIud2FybignbWVkaWEuc3JjIHdhcyBjaGFuZ2VkIGJ5IGEgdGhpcmQgcGFydHkgLSBza2lwIGNsZWFudXAnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm1lZGlhU291cmNlID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMubWVkaWEgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5fb2JqZWN0VXJsID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ1RyYWNrcyA9IHt9O1xuICAgICAgICAgICAgdGhpcy50cmFja3MgPSB7fTtcbiAgICAgICAgICAgIHRoaXMuc291cmNlQnVmZmVyID0ge307XG4gICAgICAgICAgICB0aGlzLmZsdXNoUmFuZ2UgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuc2VnbWVudHMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kZWQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub25tc28gPSB0aGlzLm9ubXNlID0gdGhpcy5vbm1zYyA9IG51bGw7XG4gICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoZXZlbnRzXzEuZGVmYXVsdC5NRURJQV9ERVRBQ0hFRCk7XG4gICAgfTtcbiAgICBCdWZmZXJDb250cm9sbGVyLnByb3RvdHlwZS5vbk1lZGlhU291cmNlT3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLmxvZygnbWVkaWEgc291cmNlIG9wZW5lZCcpO1xuICAgICAgICB0aGlzLmhscy50cmlnZ2VyKGV2ZW50c18xLmRlZmF1bHQuTUVESUFfQVRUQUNIRUQsIHsgbWVkaWE6IHRoaXMubWVkaWEgfSk7XG4gICAgICAgIHZhciBtZWRpYVNvdXJjZSA9IHRoaXMubWVkaWFTb3VyY2U7XG4gICAgICAgIGlmIChtZWRpYVNvdXJjZSkge1xuICAgICAgICAgICAgLy8gb25jZSByZWNlaXZlZCwgZG9uJ3QgbGlzdGVuIGFueW1vcmUgdG8gc291cmNlb3BlbiBldmVudFxuICAgICAgICAgICAgbWVkaWFTb3VyY2UucmVtb3ZlRXZlbnRMaXN0ZW5lcignc291cmNlb3BlbicsIHRoaXMub25tc28pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2hlY2tQZW5kaW5nVHJhY2tzKCk7XG4gICAgfTtcbiAgICBCdWZmZXJDb250cm9sbGVyLnByb3RvdHlwZS5jaGVja1BlbmRpbmdUcmFja3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIGJ1ZmZlckNvZGVjRXZlbnRzRXhwZWN0ZWQgPSBfYS5idWZmZXJDb2RlY0V2ZW50c0V4cGVjdGVkLCBwZW5kaW5nVHJhY2tzID0gX2EucGVuZGluZ1RyYWNrcztcbiAgICAgICAgLy8gQ2hlY2sgaWYgd2UndmUgcmVjZWl2ZWQgYWxsIG9mIHRoZSBleHBlY3RlZCBidWZmZXJDb2RlYyBldmVudHMuIFdoZW4gbm9uZSByZW1haW4sIGNyZWF0ZSBhbGwgdGhlIHNvdXJjZUJ1ZmZlcnMgYXQgb25jZS5cbiAgICAgICAgLy8gVGhpcyBpcyBpbXBvcnRhbnQgYmVjYXVzZSB0aGUgTVNFIHNwZWMgYWxsb3dzIGltcGxlbWVudGF0aW9ucyB0byB0aHJvdyBRdW90YUV4Y2VlZGVkRXJyb3JzIGlmIGNyZWF0aW5nIG5ldyBzb3VyY2VCdWZmZXJzIGFmdGVyXG4gICAgICAgIC8vIGRhdGEgaGFzIGJlZW4gYXBwZW5kZWQgdG8gZXhpc3Rpbmcgb25lcy5cbiAgICAgICAgLy8gMiB0cmFja3MgaXMgdGhlIG1heCAob25lIGZvciBhdWRpbywgb25lIGZvciB2aWRlbykuIElmIHdlJ3ZlIHJlYWNoIHRoaXMgbWF4IGdvIGFoZWFkIGFuZCBjcmVhdGUgdGhlIGJ1ZmZlcnMuXG4gICAgICAgIHZhciBwZW5kaW5nVHJhY2tzQ291bnQgPSBPYmplY3Qua2V5cyhwZW5kaW5nVHJhY2tzKS5sZW5ndGg7XG4gICAgICAgIGlmICgocGVuZGluZ1RyYWNrc0NvdW50ICYmICFidWZmZXJDb2RlY0V2ZW50c0V4cGVjdGVkKSB8fCBwZW5kaW5nVHJhY2tzQ291bnQgPT09IDIpIHtcbiAgICAgICAgICAgIC8vIG9rLCBsZXQncyBjcmVhdGUgdGhlbSBub3cgIVxuICAgICAgICAgICAgdGhpcy5jcmVhdGVTb3VyY2VCdWZmZXJzKHBlbmRpbmdUcmFja3MpO1xuICAgICAgICAgICAgdGhpcy5wZW5kaW5nVHJhY2tzID0ge307XG4gICAgICAgICAgICAvLyBhcHBlbmQgYW55IHBlbmRpbmcgc2VnbWVudHMgbm93ICFcbiAgICAgICAgICAgIHRoaXMuZG9BcHBlbmRpbmcoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQnVmZmVyQ29udHJvbGxlci5wcm90b3R5cGUub25NZWRpYVNvdXJjZUNsb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBsb2dnZXJfMS5sb2dnZXIubG9nKCdtZWRpYSBzb3VyY2UgY2xvc2VkJyk7XG4gICAgfTtcbiAgICBCdWZmZXJDb250cm9sbGVyLnByb3RvdHlwZS5vbk1lZGlhU291cmNlRW5kZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGxvZ2dlcl8xLmxvZ2dlci5sb2coJ21lZGlhIHNvdXJjZSBlbmRlZCcpO1xuICAgIH07XG4gICAgQnVmZmVyQ29udHJvbGxlci5wcm90b3R5cGUub25TQlVwZGF0ZUVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gdXBkYXRlIHRpbWVzdGFtcE9mZnNldFxuICAgICAgICBpZiAodGhpcy5hdWRpb1RpbWVzdGFtcE9mZnNldCkge1xuICAgICAgICAgICAgdmFyIGF1ZGlvQnVmZmVyID0gdGhpcy5zb3VyY2VCdWZmZXIuYXVkaW87XG4gICAgICAgICAgICBsb2dnZXJfMS5sb2dnZXIud2FybihcImNoYW5nZSBtcGVnIGF1ZGlvIHRpbWVzdGFtcCBvZmZzZXQgZnJvbSBcIiArIGF1ZGlvQnVmZmVyLnRpbWVzdGFtcE9mZnNldCArIFwiIHRvIFwiICsgdGhpcy5hdWRpb1RpbWVzdGFtcE9mZnNldCk7XG4gICAgICAgICAgICBhdWRpb0J1ZmZlci50aW1lc3RhbXBPZmZzZXQgPSB0aGlzLmF1ZGlvVGltZXN0YW1wT2Zmc2V0O1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuYXVkaW9UaW1lc3RhbXBPZmZzZXQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX25lZWRzRmx1c2gpIHtcbiAgICAgICAgICAgIHRoaXMuZG9GbHVzaCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9uZWVkc0Vvcykge1xuICAgICAgICAgICAgdGhpcy5jaGVja0VvcygpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYXBwZW5kaW5nID0gZmFsc2U7XG4gICAgICAgIHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudDtcbiAgICAgICAgLy8gY291bnQgbmIgb2YgcGVuZGluZyBzZWdtZW50cyB3YWl0aW5nIGZvciBhcHBlbmRpbmcgb24gdGhpcyBzb3VyY2VidWZmZXJcbiAgICAgICAgdmFyIHBlbmRpbmcgPSB0aGlzLnNlZ21lbnRzLnJlZHVjZShmdW5jdGlvbiAoY291bnRlciwgc2VnbWVudCkgeyByZXR1cm4gKHNlZ21lbnQucGFyZW50ID09PSBwYXJlbnQpID8gY291bnRlciArIDEgOiBjb3VudGVyOyB9LCAwKTtcbiAgICAgICAgLy8gdGhpcy5zb3VyY2VCdWZmZXIgaXMgYmV0dGVyIHRvIHVzZSB0aGFuIG1lZGlhLmJ1ZmZlcmVkIGFzIGl0IGlzIGNsb3NlciB0byB0aGUgUFRTIGRhdGEgZnJvbSB0aGUgZnJhZ21lbnRzXG4gICAgICAgIHZhciB0aW1lUmFuZ2VzID0ge307XG4gICAgICAgIHZhciBzb3VyY2VCdWZmZXIgPSB0aGlzLnNvdXJjZUJ1ZmZlcjtcbiAgICAgICAgZm9yICh2YXIgc3RyZWFtVHlwZSBpbiBzb3VyY2VCdWZmZXIpIHtcbiAgICAgICAgICAgIHRpbWVSYW5nZXNbc3RyZWFtVHlwZV0gPSBzb3VyY2VCdWZmZXJbc3RyZWFtVHlwZV0uYnVmZmVyZWQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5obHMudHJpZ2dlcihldmVudHNfMS5kZWZhdWx0LkJVRkZFUl9BUFBFTkRFRCwgeyBwYXJlbnQ6IHBhcmVudCwgcGVuZGluZzogcGVuZGluZywgdGltZVJhbmdlczogdGltZVJhbmdlcyB9KTtcbiAgICAgICAgLy8gZG9uJ3QgYXBwZW5kIGluIGZsdXNoaW5nIG1vZGVcbiAgICAgICAgaWYgKCF0aGlzLl9uZWVkc0ZsdXNoKSB7XG4gICAgICAgICAgICB0aGlzLmRvQXBwZW5kaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51cGRhdGVNZWRpYUVsZW1lbnREdXJhdGlvbigpO1xuICAgICAgICAvLyBhcHBlbmRpbmcgZ29lcyBmaXJzdFxuICAgICAgICBpZiAocGVuZGluZyA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5mbHVzaExpdmVCYWNrQnVmZmVyKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEJ1ZmZlckNvbnRyb2xsZXIucHJvdG90eXBlLm9uU0JVcGRhdGVFcnJvciA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBsb2dnZXJfMS5sb2dnZXIuZXJyb3IoJ3NvdXJjZUJ1ZmZlciBlcnJvcjonLCBldmVudCk7XG4gICAgICAgIC8vIGFjY29yZGluZyB0byBodHRwOi8vd3d3LnczLm9yZy9UUi9tZWRpYS1zb3VyY2UvI3NvdXJjZWJ1ZmZlci1hcHBlbmQtZXJyb3JcbiAgICAgICAgLy8gdGhpcyBlcnJvciBtaWdodCBub3QgYWx3YXlzIGJlIGZhdGFsIChpdCBpcyBmYXRhbCBpZiBkZWNvZGUgZXJyb3IgaXMgc2V0LCBpbiB0aGF0IGNhc2VcbiAgICAgICAgLy8gaXQgd2lsbCBiZSBmb2xsb3dlZCBieSBhIG1lZGlhRWxlbWVudCBlcnJvciAuLi4pXG4gICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoZXZlbnRzXzEuZGVmYXVsdC5FUlJPUiwgeyB0eXBlOiBlcnJvcnNfMS5FcnJvclR5cGVzLk1FRElBX0VSUk9SLCBkZXRhaWxzOiBlcnJvcnNfMS5FcnJvckRldGFpbHMuQlVGRkVSX0FQUEVORElOR19FUlJPUiwgZmF0YWw6IGZhbHNlIH0pO1xuICAgICAgICAvLyB3ZSBkb24ndCBuZWVkIHRvIGRvIG1vcmUgdGhhbiB0aGF0LCBhcyBhY2NvcmRpbiB0byB0aGUgc3BlYywgdXBkYXRlZW5kIHdpbGwgYmUgZmlyZWQganVzdCBhZnRlclxuICAgIH07XG4gICAgQnVmZmVyQ29udHJvbGxlci5wcm90b3R5cGUub25CdWZmZXJSZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHNvdXJjZUJ1ZmZlciA9IHRoaXMuc291cmNlQnVmZmVyO1xuICAgICAgICBmb3IgKHZhciB0eXBlIGluIHNvdXJjZUJ1ZmZlcikge1xuICAgICAgICAgICAgdmFyIHNiID0gc291cmNlQnVmZmVyW3R5cGVdO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0aGlzLm1lZGlhU291cmNlLnJlbW92ZVNvdXJjZUJ1ZmZlcihzYik7XG4gICAgICAgICAgICAgICAgc2IucmVtb3ZlRXZlbnRMaXN0ZW5lcigndXBkYXRlZW5kJywgdGhpcy5vbnNidWUpO1xuICAgICAgICAgICAgICAgIHNiLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgdGhpcy5vbnNiZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zb3VyY2VCdWZmZXIgPSB7fTtcbiAgICAgICAgdGhpcy5mbHVzaFJhbmdlID0gW107XG4gICAgICAgIHRoaXMuc2VnbWVudHMgPSBbXTtcbiAgICAgICAgdGhpcy5hcHBlbmRlZCA9IDA7XG4gICAgfTtcbiAgICBCdWZmZXJDb250cm9sbGVyLnByb3RvdHlwZS5vbkJ1ZmZlckNvZGVjcyA9IGZ1bmN0aW9uICh0cmFja3MpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgLy8gaWYgc291cmNlIGJ1ZmZlcihzKSBub3QgY3JlYXRlZCB5ZXQsIGFwcGVuZGVkIGJ1ZmZlciB0cmFja3MgaW4gdGhpcy5wZW5kaW5nVHJhY2tzXG4gICAgICAgIC8vIGlmIHNvdXJjZWJ1ZmZlcnMgYWxyZWFkeSBjcmVhdGVkLCBkbyBub3RoaW5nIC4uLlxuICAgICAgICBpZiAoT2JqZWN0LmtleXModGhpcy5zb3VyY2VCdWZmZXIpLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5rZXlzKHRyYWNrcykuZm9yRWFjaChmdW5jdGlvbiAodHJhY2tOYW1lKSB7XG4gICAgICAgICAgICBfdGhpcy5wZW5kaW5nVHJhY2tzW3RyYWNrTmFtZV0gPSB0cmFja3NbdHJhY2tOYW1lXTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBtZWRpYVNvdXJjZSA9IHRoaXMubWVkaWFTb3VyY2U7XG4gICAgICAgIHRoaXMuYnVmZmVyQ29kZWNFdmVudHNFeHBlY3RlZCA9IE1hdGgubWF4KHRoaXMuYnVmZmVyQ29kZWNFdmVudHNFeHBlY3RlZCAtIDEsIDApO1xuICAgICAgICBpZiAobWVkaWFTb3VyY2UgJiYgbWVkaWFTb3VyY2UucmVhZHlTdGF0ZSA9PT0gJ29wZW4nKSB7XG4gICAgICAgICAgICB0aGlzLmNoZWNrUGVuZGluZ1RyYWNrcygpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBCdWZmZXJDb250cm9sbGVyLnByb3RvdHlwZS5jcmVhdGVTb3VyY2VCdWZmZXJzID0gZnVuY3Rpb24gKHRyYWNrcykge1xuICAgICAgICB2YXIgc291cmNlQnVmZmVyID0gdGhpcy5zb3VyY2VCdWZmZXIsIG1lZGlhU291cmNlID0gdGhpcy5tZWRpYVNvdXJjZTtcbiAgICAgICAgZm9yICh2YXIgdHJhY2tOYW1lIGluIHRyYWNrcykge1xuICAgICAgICAgICAgaWYgKCFzb3VyY2VCdWZmZXJbdHJhY2tOYW1lXSkge1xuICAgICAgICAgICAgICAgIHZhciB0cmFjayA9IHRyYWNrc1t0cmFja05hbWVdO1xuICAgICAgICAgICAgICAgIC8vIHVzZSBsZXZlbENvZGVjIGFzIGZpcnN0IHByaW9yaXR5XG4gICAgICAgICAgICAgICAgdmFyIGNvZGVjID0gdHJhY2subGV2ZWxDb2RlYyB8fCB0cmFjay5jb2RlYztcbiAgICAgICAgICAgICAgICB2YXIgbWltZVR5cGUgPSB0cmFjay5jb250YWluZXIgKyBcIjtjb2RlY3M9XCIgKyBjb2RlYztcbiAgICAgICAgICAgICAgICBsb2dnZXJfMS5sb2dnZXIubG9nKFwiY3JlYXRpbmcgc291cmNlQnVmZmVyKFwiICsgbWltZVR5cGUgKyBcIilcIik7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNiID0gc291cmNlQnVmZmVyW3RyYWNrTmFtZV0gPSBtZWRpYVNvdXJjZS5hZGRTb3VyY2VCdWZmZXIobWltZVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBzYi5hZGRFdmVudExpc3RlbmVyKCd1cGRhdGVlbmQnLCB0aGlzLm9uc2J1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHNiLmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgdGhpcy5vbnNiZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJhY2tzW3RyYWNrTmFtZV0gPSB7IGNvZGVjOiBjb2RlYywgY29udGFpbmVyOiB0cmFjay5jb250YWluZXIgfTtcbiAgICAgICAgICAgICAgICAgICAgdHJhY2suYnVmZmVyID0gc2I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLmVycm9yKFwiZXJyb3Igd2hpbGUgdHJ5aW5nIHRvIGFkZCBzb3VyY2VCdWZmZXI6XCIgKyBlcnIubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoZXZlbnRzXzEuZGVmYXVsdC5FUlJPUiwgeyB0eXBlOiBlcnJvcnNfMS5FcnJvclR5cGVzLk1FRElBX0VSUk9SLCBkZXRhaWxzOiBlcnJvcnNfMS5FcnJvckRldGFpbHMuQlVGRkVSX0FERF9DT0RFQ19FUlJPUiwgZmF0YWw6IGZhbHNlLCBlcnI6IGVyciwgbWltZVR5cGU6IG1pbWVUeXBlIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmhscy50cmlnZ2VyKGV2ZW50c18xLmRlZmF1bHQuQlVGRkVSX0NSRUFURUQsIHsgdHJhY2tzOiB0cmFja3MgfSk7XG4gICAgfTtcbiAgICBCdWZmZXJDb250cm9sbGVyLnByb3RvdHlwZS5vbkJ1ZmZlckFwcGVuZGluZyA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIGlmICghdGhpcy5fbmVlZHNGbHVzaCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnNlZ21lbnRzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZWdtZW50cyA9IFtkYXRhXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc2VnbWVudHMucHVzaChkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZG9BcHBlbmRpbmcoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQnVmZmVyQ29udHJvbGxlci5wcm90b3R5cGUub25CdWZmZXJBcHBlbmRGYWlsID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLmVycm9yKCdzb3VyY2VCdWZmZXIgZXJyb3I6JywgZGF0YS5ldmVudCk7XG4gICAgICAgIC8vIGFjY29yZGluZyB0byBodHRwOi8vd3d3LnczLm9yZy9UUi9tZWRpYS1zb3VyY2UvI3NvdXJjZWJ1ZmZlci1hcHBlbmQtZXJyb3JcbiAgICAgICAgLy8gdGhpcyBlcnJvciBtaWdodCBub3QgYWx3YXlzIGJlIGZhdGFsIChpdCBpcyBmYXRhbCBpZiBkZWNvZGUgZXJyb3IgaXMgc2V0LCBpbiB0aGF0IGNhc2VcbiAgICAgICAgLy8gaXQgd2lsbCBiZSBmb2xsb3dlZCBieSBhIG1lZGlhRWxlbWVudCBlcnJvciAuLi4pXG4gICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoZXZlbnRzXzEuZGVmYXVsdC5FUlJPUiwgeyB0eXBlOiBlcnJvcnNfMS5FcnJvclR5cGVzLk1FRElBX0VSUk9SLCBkZXRhaWxzOiBlcnJvcnNfMS5FcnJvckRldGFpbHMuQlVGRkVSX0FQUEVORElOR19FUlJPUiwgZmF0YWw6IGZhbHNlIH0pO1xuICAgIH07XG4gICAgLy8gb24gQlVGRkVSX0VPUyBtYXJrIG1hdGNoaW5nIHNvdXJjZWJ1ZmZlcihzKSBhcyBlbmRlZCBhbmQgdHJpZ2dlciBjaGVja0VvcygpXG4gICAgQnVmZmVyQ29udHJvbGxlci5wcm90b3R5cGUub25CdWZmZXJFb3MgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB2YXIgc2IgPSB0aGlzLnNvdXJjZUJ1ZmZlcjtcbiAgICAgICAgdmFyIGRhdGFUeXBlID0gZGF0YS50eXBlO1xuICAgICAgICBmb3IgKHZhciB0eXBlIGluIHNiKSB7XG4gICAgICAgICAgICBpZiAoIWRhdGFUeXBlIHx8IHR5cGUgPT09IGRhdGFUeXBlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFzYlt0eXBlXS5lbmRlZCkge1xuICAgICAgICAgICAgICAgICAgICBzYlt0eXBlXS5lbmRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmxvZ2dlci5sb2codHlwZSArIFwiIHNvdXJjZUJ1ZmZlciBub3cgRU9TXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNoZWNrRW9zKCk7XG4gICAgfTtcbiAgICAvLyBpZiBhbGwgc291cmNlIGJ1ZmZlcnMgYXJlIG1hcmtlZCBhcyBlbmRlZCwgc2lnbmFsIGVuZE9mU3RyZWFtKCkgdG8gTWVkaWFTb3VyY2UuXG4gICAgQnVmZmVyQ29udHJvbGxlci5wcm90b3R5cGUuY2hlY2tFb3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzYiA9IHRoaXMuc291cmNlQnVmZmVyLCBtZWRpYVNvdXJjZSA9IHRoaXMubWVkaWFTb3VyY2U7XG4gICAgICAgIGlmICghbWVkaWFTb3VyY2UgfHwgbWVkaWFTb3VyY2UucmVhZHlTdGF0ZSAhPT0gJ29wZW4nKSB7XG4gICAgICAgICAgICB0aGlzLl9uZWVkc0VvcyA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIHR5cGUgaW4gc2IpIHtcbiAgICAgICAgICAgIHZhciBzYm9iaiA9IHNiW3R5cGVdO1xuICAgICAgICAgICAgaWYgKCFzYm9iai5lbmRlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzYm9iai51cGRhdGluZykge1xuICAgICAgICAgICAgICAgIHRoaXMuX25lZWRzRW9zID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLmxvZygnYWxsIG1lZGlhIGRhdGEgYXJlIGF2YWlsYWJsZSwgc2lnbmFsIGVuZE9mU3RyZWFtKCkgdG8gTWVkaWFTb3VyY2UgYW5kIHN0b3AgbG9hZGluZyBmcmFnbWVudCcpO1xuICAgICAgICAvLyBOb3RpZnkgdGhlIG1lZGlhIGVsZW1lbnQgdGhhdCBpdCBub3cgaGFzIGFsbCBvZiB0aGUgbWVkaWEgZGF0YVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbWVkaWFTb3VyY2UuZW5kT2ZTdHJlYW0oKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLndhcm4oJ2V4Y2VwdGlvbiB3aGlsZSBjYWxsaW5nIG1lZGlhU291cmNlLmVuZE9mU3RyZWFtKCknKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9uZWVkc0VvcyA9IGZhbHNlO1xuICAgIH07XG4gICAgQnVmZmVyQ29udHJvbGxlci5wcm90b3R5cGUub25CdWZmZXJGbHVzaGluZyA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHRoaXMuZmx1c2hSYW5nZS5wdXNoKHsgc3RhcnQ6IGRhdGEuc3RhcnRPZmZzZXQsIGVuZDogZGF0YS5lbmRPZmZzZXQsIHR5cGU6IGRhdGEudHlwZSB9KTtcbiAgICAgICAgLy8gYXR0ZW1wdCBmbHVzaCBpbW1lZGlhdGVseVxuICAgICAgICB0aGlzLmZsdXNoQnVmZmVyQ291bnRlciA9IDA7XG4gICAgICAgIHRoaXMuZG9GbHVzaCgpO1xuICAgIH07XG4gICAgQnVmZmVyQ29udHJvbGxlci5wcm90b3R5cGUuZmx1c2hMaXZlQmFja0J1ZmZlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gY2xlYXIgYmFjayBidWZmZXIgZm9yIGxpdmUgb25seVxuICAgICAgICBpZiAoIXRoaXMuX2xpdmUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGl2ZUJhY2tCdWZmZXJMZW5ndGggPSB0aGlzLmhscy5jb25maWcubGl2ZUJhY2tCdWZmZXJMZW5ndGg7XG4gICAgICAgIGlmICghaXNGaW5pdGUobGl2ZUJhY2tCdWZmZXJMZW5ndGgpIHx8IGxpdmVCYWNrQnVmZmVyTGVuZ3RoIDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjdXJyZW50VGltZSA9IHRoaXMubWVkaWEuY3VycmVudFRpbWU7XG4gICAgICAgIHZhciBzb3VyY2VCdWZmZXIgPSB0aGlzLnNvdXJjZUJ1ZmZlcjtcbiAgICAgICAgdmFyIGJ1ZmZlclR5cGVzID0gT2JqZWN0LmtleXMoc291cmNlQnVmZmVyKTtcbiAgICAgICAgdmFyIHRhcmdldEJhY2tCdWZmZXJQb3NpdGlvbiA9IGN1cnJlbnRUaW1lIC0gTWF0aC5tYXgobGl2ZUJhY2tCdWZmZXJMZW5ndGgsIHRoaXMuX2xldmVsVGFyZ2V0RHVyYXRpb24pO1xuICAgICAgICBmb3IgKHZhciBpbmRleCA9IGJ1ZmZlclR5cGVzLmxlbmd0aCAtIDE7IGluZGV4ID49IDA7IGluZGV4LS0pIHtcbiAgICAgICAgICAgIHZhciBidWZmZXJUeXBlID0gYnVmZmVyVHlwZXNbaW5kZXhdLCBidWZmZXJlZCA9IHNvdXJjZUJ1ZmZlcltidWZmZXJUeXBlXS5idWZmZXJlZDtcbiAgICAgICAgICAgIC8vIHdoZW4gdGFyZ2V0IGJ1ZmZlciBzdGFydCBleGNlZWRzIGFjdHVhbCBidWZmZXIgc3RhcnRcbiAgICAgICAgICAgIGlmIChidWZmZXJlZC5sZW5ndGggPiAwICYmIHRhcmdldEJhY2tCdWZmZXJQb3NpdGlvbiA+IGJ1ZmZlcmVkLnN0YXJ0KDApKSB7XG4gICAgICAgICAgICAgICAgLy8gcmVtb3ZlIGJ1ZmZlciB1cCB1bnRpbCBjdXJyZW50IHRpbWUgbWludXMgbWluaW11bSBiYWNrIGJ1ZmZlciBsZW5ndGggKHJlbW92aW5nIGJ1ZmZlciB0b28gY2xvc2UgdG8gY3VycmVudFxuICAgICAgICAgICAgICAgIC8vIHRpbWUgd2lsbCBsZWFkIHRvIHBsYXliYWNrIGZyZWV6aW5nKVxuICAgICAgICAgICAgICAgIC8vIGNyZWRpdHMgZm9yIGxldmVsIHRhcmdldCBkdXJhdGlvbiAtIGh0dHBzOi8vZ2l0aHViLmNvbS92aWRlb2pzL2h0dHAtc3RyZWFtaW5nL2Jsb2IvMzEzMjkzM2I2YWE5OWRkZWZhYjI5YzEwNDQ3NjI0ZWZkNmZkNmU1Mi9zcmMvc2VnbWVudC1sb2FkZXIuanMjTDkxXG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVCdWZmZXJSYW5nZShidWZmZXJUeXBlLCBzb3VyY2VCdWZmZXJbYnVmZmVyVHlwZV0sIDAsIHRhcmdldEJhY2tCdWZmZXJQb3NpdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEJ1ZmZlckNvbnRyb2xsZXIucHJvdG90eXBlLm9uTGV2ZWxVcGRhdGVkID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBkZXRhaWxzID0gX2EuZGV0YWlscztcbiAgICAgICAgaWYgKGRldGFpbHMuZnJhZ21lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuX2xldmVsRHVyYXRpb24gPSBkZXRhaWxzLnRvdGFsZHVyYXRpb24gKyBkZXRhaWxzLmZyYWdtZW50c1swXS5zdGFydDtcbiAgICAgICAgICAgIHRoaXMuX2xldmVsVGFyZ2V0RHVyYXRpb24gPSBkZXRhaWxzLmF2ZXJhZ2V0YXJnZXRkdXJhdGlvbiB8fCBkZXRhaWxzLnRhcmdldGR1cmF0aW9uIHx8IDEwO1xuICAgICAgICAgICAgdGhpcy5fbGl2ZSA9IGRldGFpbHMubGl2ZTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlTWVkaWFFbGVtZW50RHVyYXRpb24oKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogVXBkYXRlIE1lZGlhIFNvdXJjZSBkdXJhdGlvbiB0byBjdXJyZW50IGxldmVsIGR1cmF0aW9uIG9yIG92ZXJyaWRlIHRvIEluZmluaXR5IGlmIGNvbmZpZ3VyYXRpb24gcGFyYW1ldGVyXG4gICAgICogJ2xpdmVEdXJhdGlvbkluZmluaXR5YCBpcyBzZXQgdG8gYHRydWVgXG4gICAgICogTW9yZSBkZXRhaWxzOiBodHRwczovL2dpdGh1Yi5jb20vdmlkZW8tZGV2L2hscy5qcy9pc3N1ZXMvMzU1XG4gICAgICovXG4gICAgQnVmZmVyQ29udHJvbGxlci5wcm90b3R5cGUudXBkYXRlTWVkaWFFbGVtZW50RHVyYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjb25maWcgPSB0aGlzLmhscy5jb25maWc7XG4gICAgICAgIHZhciBkdXJhdGlvbjtcbiAgICAgICAgaWYgKHRoaXMuX2xldmVsRHVyYXRpb24gPT09IG51bGwgfHxcbiAgICAgICAgICAgICF0aGlzLm1lZGlhIHx8XG4gICAgICAgICAgICAhdGhpcy5tZWRpYVNvdXJjZSB8fFxuICAgICAgICAgICAgIXRoaXMuc291cmNlQnVmZmVyIHx8XG4gICAgICAgICAgICB0aGlzLm1lZGlhLnJlYWR5U3RhdGUgPT09IDAgfHxcbiAgICAgICAgICAgIHRoaXMubWVkaWFTb3VyY2UucmVhZHlTdGF0ZSAhPT0gJ29wZW4nKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgdHlwZSBpbiB0aGlzLnNvdXJjZUJ1ZmZlcikge1xuICAgICAgICAgICAgaWYgKHRoaXMuc291cmNlQnVmZmVyW3R5cGVdLnVwZGF0aW5nID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgLy8gY2FuJ3Qgc2V0IGR1cmF0aW9uIHdoaWxzdCBhIGJ1ZmZlciBpcyB1cGRhdGluZ1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBkdXJhdGlvbiA9IHRoaXMubWVkaWEuZHVyYXRpb247XG4gICAgICAgIC8vIGluaXRpYWxpc2UgdG8gdGhlIHZhbHVlIHRoYXQgdGhlIG1lZGlhIHNvdXJjZSBpcyByZXBvcnRpbmdcbiAgICAgICAgaWYgKHRoaXMuX21zRHVyYXRpb24gPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX21zRHVyYXRpb24gPSB0aGlzLm1lZGlhU291cmNlLmR1cmF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9saXZlID09PSB0cnVlICYmIGNvbmZpZy5saXZlRHVyYXRpb25JbmZpbml0eSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgLy8gT3ZlcnJpZGUgZHVyYXRpb24gdG8gSW5maW5pdHlcbiAgICAgICAgICAgIGxvZ2dlcl8xLmxvZ2dlci5sb2coJ01lZGlhIFNvdXJjZSBkdXJhdGlvbiBpcyBzZXQgdG8gSW5maW5pdHknKTtcbiAgICAgICAgICAgIHRoaXMuX21zRHVyYXRpb24gPSB0aGlzLm1lZGlhU291cmNlLmR1cmF0aW9uID0gSW5maW5pdHk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKHRoaXMuX2xldmVsRHVyYXRpb24gPiB0aGlzLl9tc0R1cmF0aW9uICYmIHRoaXMuX2xldmVsRHVyYXRpb24gPiBkdXJhdGlvbikgfHwgIU51bWJlci5pc0Zpbml0ZShkdXJhdGlvbikpIHtcbiAgICAgICAgICAgIC8vIGxldmVsRHVyYXRpb24gd2FzIHRoZSBsYXN0IHZhbHVlIHdlIHNldC5cbiAgICAgICAgICAgIC8vIG5vdCB1c2luZyBtZWRpYVNvdXJjZS5kdXJhdGlvbiBhcyB0aGUgYnJvd3NlciBtYXkgdHdlYWsgdGhpcyB2YWx1ZVxuICAgICAgICAgICAgLy8gb25seSB1cGRhdGUgTWVkaWEgU291cmNlIGR1cmF0aW9uIGlmIGl0cyB2YWx1ZSBpbmNyZWFzZSwgdGhpcyBpcyB0byBhdm9pZFxuICAgICAgICAgICAgLy8gZmx1c2hpbmcgYWxyZWFkeSBidWZmZXJlZCBwb3J0aW9uIHdoZW4gc3dpdGNoaW5nIGJldHdlZW4gcXVhbGl0eSBsZXZlbFxuICAgICAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLmxvZyhcIlVwZGF0aW5nIE1lZGlhIFNvdXJjZSBkdXJhdGlvbiB0byBcIiArIHRoaXMuX2xldmVsRHVyYXRpb24udG9GaXhlZCgzKSk7XG4gICAgICAgICAgICB0aGlzLl9tc0R1cmF0aW9uID0gdGhpcy5tZWRpYVNvdXJjZS5kdXJhdGlvbiA9IHRoaXMuX2xldmVsRHVyYXRpb247XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEJ1ZmZlckNvbnRyb2xsZXIucHJvdG90eXBlLmRvRmx1c2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIGxvb3AgdGhyb3VnaCBhbGwgYnVmZmVyIHJhbmdlcyB0byBmbHVzaFxuICAgICAgICB3aGlsZSAodGhpcy5mbHVzaFJhbmdlLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIHJhbmdlID0gdGhpcy5mbHVzaFJhbmdlWzBdO1xuICAgICAgICAgICAgLy8gZmx1c2hCdWZmZXIgd2lsbCBhYm9ydCBhbnkgYnVmZmVyIGFwcGVuZCBpbiBwcm9ncmVzcyBhbmQgZmx1c2ggQXVkaW8vVmlkZW8gQnVmZmVyXG4gICAgICAgICAgICBpZiAodGhpcy5mbHVzaEJ1ZmZlcihyYW5nZS5zdGFydCwgcmFuZ2UuZW5kLCByYW5nZS50eXBlKSkge1xuICAgICAgICAgICAgICAgIC8vIHJhbmdlIGZsdXNoZWQsIHJlbW92ZSBmcm9tIGZsdXNoIGFycmF5XG4gICAgICAgICAgICAgICAgdGhpcy5mbHVzaFJhbmdlLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5mbHVzaEJ1ZmZlckNvdW50ZXIgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbmVlZHNGbHVzaCA9IHRydWU7XG4gICAgICAgICAgICAgICAgLy8gYXZvaWQgbG9vcGluZywgd2FpdCBmb3IgU0IgdXBkYXRlIGVuZCB0byByZXRyaWdnZXIgYSBmbHVzaFxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5mbHVzaFJhbmdlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgLy8gZXZlcnl0aGluZyBmbHVzaGVkXG4gICAgICAgICAgICB0aGlzLl9uZWVkc0ZsdXNoID0gZmFsc2U7XG4gICAgICAgICAgICAvLyBsZXQncyByZWNvbXB1dGUgdGhpcy5hcHBlbmRlZCwgd2hpY2ggaXMgdXNlZCB0byBhdm9pZCBmbHVzaCBsb29waW5nXG4gICAgICAgICAgICB2YXIgYXBwZW5kZWQgPSAwO1xuICAgICAgICAgICAgdmFyIHNvdXJjZUJ1ZmZlciA9IHRoaXMuc291cmNlQnVmZmVyO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciB0eXBlIGluIHNvdXJjZUJ1ZmZlcikge1xuICAgICAgICAgICAgICAgICAgICBhcHBlbmRlZCArPSBzb3VyY2VCdWZmZXJbdHlwZV0uYnVmZmVyZWQubGVuZ3RoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIC8vIGVycm9yIGNvdWxkIGJlIHRocm93biB3aGlsZSBhY2Nlc3NpbmcgYnVmZmVyZWQsIGluIGNhc2Ugc291cmNlYnVmZmVyIGhhcyBhbHJlYWR5IGJlZW4gcmVtb3ZlZCBmcm9tIE1lZGlhU291cmNlXG4gICAgICAgICAgICAgICAgLy8gdGhpcyBpcyBoYXJtZXNzIGF0IHRoaXMgc3RhZ2UsIGNhdGNoIHRoaXMgdG8gYXZvaWQgcmVwb3J0aW5nIGFuIGludGVybmFsIGV4Y2VwdGlvblxuICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmxvZ2dlci5lcnJvcignZXJyb3Igd2hpbGUgYWNjZXNzaW5nIHNvdXJjZUJ1ZmZlci5idWZmZXJlZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5hcHBlbmRlZCA9IGFwcGVuZGVkO1xuICAgICAgICAgICAgdGhpcy5obHMudHJpZ2dlcihldmVudHNfMS5kZWZhdWx0LkJVRkZFUl9GTFVTSEVEKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQnVmZmVyQ29udHJvbGxlci5wcm90b3R5cGUuZG9BcHBlbmRpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIGhscyA9IF9hLmhscywgc2VnbWVudHMgPSBfYS5zZWdtZW50cywgc291cmNlQnVmZmVyID0gX2Euc291cmNlQnVmZmVyO1xuICAgICAgICBpZiAoT2JqZWN0LmtleXMoc291cmNlQnVmZmVyKS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm1lZGlhLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZWdtZW50cyA9IFtdO1xuICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmxvZ2dlci5lcnJvcigndHJ5aW5nIHRvIGFwcGVuZCBhbHRob3VnaCBhIG1lZGlhIGVycm9yIG9jY3VyZWQsIGZsdXNoIHNlZ21lbnQgYW5kIGFib3J0Jyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuYXBwZW5kaW5nKSB7XG4gICAgICAgICAgICAgICAgLy8gbG9nZ2VyLmxvZyhgc2IgYXBwZW5kaW5nIGluIHByb2dyZXNzYCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNlZ21lbnRzICYmIHNlZ21lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHZhciBzZWdtZW50ID0gc2VnbWVudHMuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdHlwZSA9IHNlZ21lbnQudHlwZSwgc2IgPSBzb3VyY2VCdWZmZXJbdHlwZV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChzYikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzYi51cGRhdGluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlc2V0IHNvdXJjZUJ1ZmZlciBlbmRlZCBmbGFnIGJlZm9yZSBhcHBlbmRpbmcgc2VnbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNiLmVuZGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbG9nZ2VyLmxvZyhgYXBwZW5kaW5nICR7c2VnbWVudC5jb250ZW50fSAke3R5cGV9IFNCLCBzaXplOiR7c2VnbWVudC5kYXRhLmxlbmd0aH0sICR7c2VnbWVudC5wYXJlbnR9YCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQgPSBzZWdtZW50LnBhcmVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzYi5hcHBlbmRCdWZmZXIoc2VnbWVudC5kYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFwcGVuZEVycm9yID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFwcGVuZGVkKys7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hcHBlbmRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VnbWVudHMudW5zaGlmdChzZWdtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGluIGNhc2Ugd2UgZG9uJ3QgaGF2ZSBhbnkgc291cmNlIGJ1ZmZlciBtYXRjaGluZyB3aXRoIHRoaXMgc2VnbWVudCB0eXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXQgbWVhbnMgdGhhdCBNZWRpYXNvdXJjZSBmYWlscyB0byBjcmVhdGUgc291cmNlYnVmZmVyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBkaXNjYXJkIHRoaXMgc2VnbWVudCwgYW5kIHRyaWdnZXIgdXBkYXRlIGVuZFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vblNCVXBkYXRlRW5kKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAvLyBpbiBjYXNlIGFueSBlcnJvciBvY2N1cmVkIHdoaWxlIGFwcGVuZGluZywgcHV0IGJhY2sgc2VnbWVudCBpbiBzZWdtZW50cyB0YWJsZVxuICAgICAgICAgICAgICAgICAgICBsb2dnZXJfMS5sb2dnZXIuZXJyb3IoXCJlcnJvciB3aGlsZSB0cnlpbmcgdG8gYXBwZW5kIGJ1ZmZlcjpcIiArIGVyci5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgc2VnbWVudHMudW5zaGlmdChzZWdtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGV2ZW50XzEgPSB7IHR5cGU6IGVycm9yc18xLkVycm9yVHlwZXMuTUVESUFfRVJST1IsIHBhcmVudDogc2VnbWVudC5wYXJlbnQgfTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVyci5jb2RlICE9PSAyMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuYXBwZW5kRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFwcGVuZEVycm9yKys7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFwcGVuZEVycm9yID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50XzEuZGV0YWlscyA9IGVycm9yc18xLkVycm9yRGV0YWlscy5CVUZGRVJfQVBQRU5EX0VSUk9SO1xuICAgICAgICAgICAgICAgICAgICAgICAgLyogd2l0aCBVSEQgY29udGVudCwgd2UgY291bGQgZ2V0IGxvb3Agb2YgcXVvdGEgZXhjZWVkZWQgZXJyb3IgdW50aWxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYnJvd3NlciBpcyBhYmxlIHRvIGV2aWN0IHNvbWUgZGF0YSBmcm9tIHNvdXJjZWJ1ZmZlci4gcmV0cnlpbmcgaGVscCByZWNvdmVyaW5nIHRoaXNcbiAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5hcHBlbmRFcnJvciA+IGhscy5jb25maWcuYXBwZW5kRXJyb3JNYXhSZXRyeSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmxvZ2dlci5sb2coXCJmYWlsIFwiICsgaGxzLmNvbmZpZy5hcHBlbmRFcnJvck1heFJldHJ5ICsgXCIgdGltZXMgdG8gYXBwZW5kIHNlZ21lbnQgaW4gc291cmNlQnVmZmVyXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2VnbWVudHMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudF8xLmZhdGFsID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBobHMudHJpZ2dlcihldmVudHNfMS5kZWZhdWx0LkVSUk9SLCBldmVudF8xKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50XzEuZmF0YWwgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBobHMudHJpZ2dlcihldmVudHNfMS5kZWZhdWx0LkVSUk9SLCBldmVudF8xKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFF1b3RhRXhjZWVkZWRFcnJvcjogaHR0cDovL3d3dy53My5vcmcvVFIvaHRtbDUvaW5mcmFzdHJ1Y3R1cmUuaHRtbCNxdW90YWV4Y2VlZGVkZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGxldCdzIHN0b3AgYXBwZW5kaW5nIGFueSBzZWdtZW50cywgYW5kIHJlcG9ydCBCVUZGRVJfRlVMTF9FUlJPUiBlcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWdtZW50cyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRfMS5kZXRhaWxzID0gZXJyb3JzXzEuRXJyb3JEZXRhaWxzLkJVRkZFUl9GVUxMX0VSUk9SO1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRfMS5mYXRhbCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaGxzLnRyaWdnZXIoZXZlbnRzXzEuZGVmYXVsdC5FUlJPUiwgZXZlbnRfMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qXG4gICAgICBmbHVzaCBzcGVjaWZpZWQgYnVmZmVyZWQgcmFuZ2UsXG4gICAgICByZXR1cm4gdHJ1ZSBvbmNlIHJhbmdlIGhhcyBiZWVuIGZsdXNoZWQuXG4gICAgICBhcyBzb3VyY2VCdWZmZXIucmVtb3ZlKCkgaXMgYXN5bmNocm9ub3VzLCBmbHVzaEJ1ZmZlciB3aWxsIGJlIHJldHJpZ2dlcmVkIG9uIHNvdXJjZUJ1ZmZlciB1cGRhdGUgZW5kXG4gICAgKi9cbiAgICBCdWZmZXJDb250cm9sbGVyLnByb3RvdHlwZS5mbHVzaEJ1ZmZlciA9IGZ1bmN0aW9uIChzdGFydE9mZnNldCwgZW5kT2Zmc2V0LCB0eXBlSW4pIHtcbiAgICAgICAgdmFyIHNiO1xuICAgICAgICB2YXIgc291cmNlQnVmZmVyID0gdGhpcy5zb3VyY2VCdWZmZXI7XG4gICAgICAgIGlmIChPYmplY3Qua2V5cyhzb3VyY2VCdWZmZXIpLmxlbmd0aCkge1xuICAgICAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLmxvZyhcImZsdXNoQnVmZmVyLHBvcy9zdGFydC9lbmQ6IFwiICsgdGhpcy5tZWRpYS5jdXJyZW50VGltZS50b0ZpeGVkKDMpICsgXCIvXCIgKyBzdGFydE9mZnNldCArIFwiL1wiICsgZW5kT2Zmc2V0KTtcbiAgICAgICAgICAgIC8vIHNhZmVndWFyZCB0byBhdm9pZCBpbmZpbml0ZSBsb29waW5nIDogZG9uJ3QgdHJ5IHRvIGZsdXNoIG1vcmUgdGhhbiB0aGUgbmIgb2YgYXBwZW5kZWQgc2VnbWVudHNcbiAgICAgICAgICAgIGlmICh0aGlzLmZsdXNoQnVmZmVyQ291bnRlciA8IHRoaXMuYXBwZW5kZWQpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciB0eXBlIGluIHNvdXJjZUJ1ZmZlcikge1xuICAgICAgICAgICAgICAgICAgICAvLyBjaGVjayBpZiBzb3VyY2VidWZmZXIgdHlwZSBpcyBkZWZpbmVkICh0eXBlSW4pOiBpZiB5ZXMsIGxldCdzIG9ubHkgZmx1c2ggdGhpcyBvbmVcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgbm8sIGxldCdzIGZsdXNoIGFsbCBzb3VyY2VidWZmZXJzXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlSW4gJiYgdHlwZSAhPT0gdHlwZUluKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzYiA9IHNvdXJjZUJ1ZmZlclt0eXBlXTtcbiAgICAgICAgICAgICAgICAgICAgLy8gd2UgYXJlIGdvaW5nIHRvIGZsdXNoIGJ1ZmZlciwgbWFyayBzb3VyY2UgYnVmZmVyIGFzICdub3QgZW5kZWQnXG4gICAgICAgICAgICAgICAgICAgIHNiLmVuZGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGlmICghc2IudXBkYXRpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnJlbW92ZUJ1ZmZlclJhbmdlKHR5cGUsIHNiLCBzdGFydE9mZnNldCwgZW5kT2Zmc2V0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZmx1c2hCdWZmZXJDb3VudGVyKys7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLndhcm4oJ2Nhbm5vdCBmbHVzaCwgc2IgdXBkYXRpbmcgaW4gcHJvZ3Jlc3MnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmxvZ2dlci53YXJuKCdhYm9ydCBmbHVzaGluZyB0b28gbWFueSByZXRyaWVzJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsb2dnZXJfMS5sb2dnZXIubG9nKCdidWZmZXIgZmx1c2hlZCcpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGV2ZXJ5dGhpbmcgZmx1c2hlZCAhXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBmaXJzdCBidWZmZXJlZCByYW5nZSBmcm9tIHByb3ZpZGVkIHNvdXJjZSBidWZmZXIgdGhhdCBsaWVzIHdpdGhpbiBnaXZlbiBzdGFydCBhbmQgZW5kIG9mZnNldHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdHlwZSBUeXBlIG9mIHRoZSBzb3VyY2UgYnVmZmVyLCBsb2dnaW5nIHB1cnBvc2VzIG9ubHkuXG4gICAgICogQHBhcmFtIHNiIFRhcmdldCBTb3VyY2VCdWZmZXIgaW5zdGFuY2UuXG4gICAgICogQHBhcmFtIHN0YXJ0T2Zmc2V0XG4gICAgICogQHBhcmFtIGVuZE9mZnNldFxuICAgICAqXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgd2hlbiBzb3VyY2UgYnVmZmVyIHJlbW92ZSByZXF1ZXN0ZWQuXG4gICAgICovXG4gICAgQnVmZmVyQ29udHJvbGxlci5wcm90b3R5cGUucmVtb3ZlQnVmZmVyUmFuZ2UgPSBmdW5jdGlvbiAodHlwZSwgc2IsIHN0YXJ0T2Zmc2V0LCBlbmRPZmZzZXQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2IuYnVmZmVyZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgYnVmU3RhcnQgPSBzYi5idWZmZXJlZC5zdGFydChpKTtcbiAgICAgICAgICAgICAgICB2YXIgYnVmRW5kID0gc2IuYnVmZmVyZWQuZW5kKGkpO1xuICAgICAgICAgICAgICAgIHZhciByZW1vdmVTdGFydCA9IE1hdGgubWF4KGJ1ZlN0YXJ0LCBzdGFydE9mZnNldCk7XG4gICAgICAgICAgICAgICAgdmFyIHJlbW92ZUVuZCA9IE1hdGgubWluKGJ1ZkVuZCwgZW5kT2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAvKiBzb21ldGltZXMgc291cmNlYnVmZmVyLnJlbW92ZSgpIGRvZXMgbm90IGZsdXNoXG4gICAgICAgICAgICAgICAgICB0aGUgZXhhY3QgZXhwZWN0ZWQgdGltZSByYW5nZS5cbiAgICAgICAgICAgICAgICAgIHRvIGF2b2lkIHJvdW5kaW5nIGlzc3Vlcy9pbmZpbml0ZSBsb29wLFxuICAgICAgICAgICAgICAgICAgb25seSBmbHVzaCBidWZmZXIgcmFuZ2Ugb2YgbGVuZ3RoIGdyZWF0ZXIgdGhhbiA1MDBtcy5cbiAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGlmIChNYXRoLm1pbihyZW1vdmVFbmQsIGJ1ZkVuZCkgLSByZW1vdmVTdGFydCA+IDAuNSkge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXJfMS5sb2dnZXIubG9nKFwic2IgcmVtb3ZlIFwiICsgdHlwZSArIFwiIFtcIiArIHJlbW92ZVN0YXJ0ICsgXCIsXCIgKyByZW1vdmVFbmQgKyBcIl0sIG9mIFtcIiArIGJ1ZlN0YXJ0ICsgXCIsXCIgKyBidWZFbmQgKyBcIl0sIHBvczpcIiArIHRoaXMubWVkaWEuY3VycmVudFRpbWUpO1xuICAgICAgICAgICAgICAgICAgICBzYi5yZW1vdmUocmVtb3ZlU3RhcnQsIHJlbW92ZUVuZCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGxvZ2dlcl8xLmxvZ2dlci53YXJuKCdyZW1vdmVCdWZmZXJSYW5nZSBmYWlsZWQnLCBlcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgcmV0dXJuIEJ1ZmZlckNvbnRyb2xsZXI7XG59KGV2ZW50X2hhbmRsZXJfMS5kZWZhdWx0KSk7XG5leHBvcnRzLmRlZmF1bHQgPSBCdWZmZXJDb250cm9sbGVyO1xuXG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwodGhpcywgX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9zcmMvcG9seWZpbGxzL251bWJlciAqLyBcIi4vc3JjL3BvbHlmaWxscy9udW1iZXIuanNcIilbXCJOdW1iZXJcIl0pKVxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9jb250cm9sbGVyL2NhcC1sZXZlbC1jb250cm9sbGVyLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvY29udHJvbGxlci9jYXAtbGV2ZWwtY29udHJvbGxlci5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovKGZ1bmN0aW9uKE51bWJlcikge1xuLypcbiAqIGNhcCBzdHJlYW0gbGV2ZWwgdG8gbWVkaWEgc2l6ZSBkaW1lbnNpb24gY29udHJvbGxlclxuKi9cbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGV2ZW50c18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZXZlbnRzICovIFwiLi9zcmMvZXZlbnRzLmpzXCIpO1xudmFyIGV2ZW50X2hhbmRsZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2V2ZW50LWhhbmRsZXIgKi8gXCIuL3NyYy9ldmVudC1oYW5kbGVyLmpzXCIpO1xudmFyIENhcExldmVsQ29udHJvbGxlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ2FwTGV2ZWxDb250cm9sbGVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENhcExldmVsQ29udHJvbGxlcihobHMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgaGxzLCBldmVudHNfMS5kZWZhdWx0LkZQU19EUk9QX0xFVkVMX0NBUFBJTkcsIGV2ZW50c18xLmRlZmF1bHQuTUVESUFfQVRUQUNISU5HLCBldmVudHNfMS5kZWZhdWx0Lk1BTklGRVNUX1BBUlNFRCwgZXZlbnRzXzEuZGVmYXVsdC5CVUZGRVJfQ09ERUNTLCBldmVudHNfMS5kZWZhdWx0Lk1FRElBX0RFVEFDSElORykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuYXV0b0xldmVsQ2FwcGluZyA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICAgICAgX3RoaXMuZmlyc3RMZXZlbCA9IG51bGw7XG4gICAgICAgIF90aGlzLmxldmVscyA9IFtdO1xuICAgICAgICBfdGhpcy5tZWRpYSA9IG51bGw7XG4gICAgICAgIF90aGlzLnJlc3RyaWN0ZWRMZXZlbHMgPSBbXTtcbiAgICAgICAgX3RoaXMudGltZXIgPSBudWxsO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIENhcExldmVsQ29udHJvbGxlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuaGxzLmNvbmZpZy5jYXBMZXZlbFRvUGxheWVyU2l6ZSkge1xuICAgICAgICAgICAgdGhpcy5tZWRpYSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLl9zdG9wQ2FwcGluZygpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDYXBMZXZlbENvbnRyb2xsZXIucHJvdG90eXBlLm9uRnBzRHJvcExldmVsQ2FwcGluZyA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIC8vIERvbid0IGFkZCBhIHJlc3RyaWN0ZWQgbGV2ZWwgbW9yZSB0aGFuIG9uY2VcbiAgICAgICAgaWYgKENhcExldmVsQ29udHJvbGxlci5pc0xldmVsQWxsb3dlZChkYXRhLmRyb3BwZWRMZXZlbCwgdGhpcy5yZXN0cmljdGVkTGV2ZWxzKSkge1xuICAgICAgICAgICAgdGhpcy5yZXN0cmljdGVkTGV2ZWxzLnB1c2goZGF0YS5kcm9wcGVkTGV2ZWwpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDYXBMZXZlbENvbnRyb2xsZXIucHJvdG90eXBlLm9uTWVkaWFBdHRhY2hpbmcgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB0aGlzLm1lZGlhID0gZGF0YS5tZWRpYSBpbnN0YW5jZW9mIHdpbmRvdy5IVE1MVmlkZW9FbGVtZW50ID8gZGF0YS5tZWRpYSA6IG51bGw7XG4gICAgfTtcbiAgICBDYXBMZXZlbENvbnRyb2xsZXIucHJvdG90eXBlLm9uTWFuaWZlc3RQYXJzZWQgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB2YXIgaGxzID0gdGhpcy5obHM7XG4gICAgICAgIHRoaXMucmVzdHJpY3RlZExldmVscyA9IFtdO1xuICAgICAgICB0aGlzLmxldmVscyA9IGRhdGEubGV2ZWxzO1xuICAgICAgICB0aGlzLmZpcnN0TGV2ZWwgPSBkYXRhLmZpcnN0TGV2ZWw7XG4gICAgICAgIGlmIChobHMuY29uZmlnLmNhcExldmVsVG9QbGF5ZXJTaXplICYmIGRhdGEudmlkZW8pIHtcbiAgICAgICAgICAgIC8vIFN0YXJ0IGNhcHBpbmcgaW1tZWRpYXRlbHkgaWYgdGhlIG1hbmlmZXN0IGhhcyBzaWduYWxlZCB2aWRlbyBjb2RlY3NcbiAgICAgICAgICAgIHRoaXMuX3N0YXJ0Q2FwcGluZygpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBPbmx5IGFjdGl2YXRlIGNhcHBpbmcgd2hlbiBwbGF5aW5nIGEgdmlkZW8gc3RyZWFtOyBvdGhlcndpc2UsIG11bHRpLWJpdHJhdGUgYXVkaW8tb25seSBzdHJlYW1zIHdpbGwgYmUgcmVzdHJpY3RlZFxuICAgIC8vIHRvIHRoZSBmaXJzdCBsZXZlbFxuICAgIENhcExldmVsQ29udHJvbGxlci5wcm90b3R5cGUub25CdWZmZXJDb2RlY3MgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB2YXIgaGxzID0gdGhpcy5obHM7XG4gICAgICAgIGlmIChobHMuY29uZmlnLmNhcExldmVsVG9QbGF5ZXJTaXplICYmIGRhdGEudmlkZW8pIHtcbiAgICAgICAgICAgIC8vIElmIHRoZSBtYW5pZmVzdCBkaWQgbm90IHNpZ25hbCBhIHZpZGVvIGNvZGVjIGNhcHBpbmcgaGFzIGJlZW4gZGVmZXJyZWQgdW50aWwgd2UncmUgY2VydGFpbiB2aWRlbyBpcyBwcmVzZW50XG4gICAgICAgICAgICB0aGlzLl9zdGFydENhcHBpbmcoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ2FwTGV2ZWxDb250cm9sbGVyLnByb3RvdHlwZS5vbkxldmVsc1VwZGF0ZWQgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB0aGlzLmxldmVscyA9IGRhdGEubGV2ZWxzO1xuICAgIH07XG4gICAgQ2FwTGV2ZWxDb250cm9sbGVyLnByb3RvdHlwZS5vbk1lZGlhRGV0YWNoaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9zdG9wQ2FwcGluZygpO1xuICAgIH07XG4gICAgQ2FwTGV2ZWxDb250cm9sbGVyLnByb3RvdHlwZS5kZXRlY3RQbGF5ZXJTaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5tZWRpYSkge1xuICAgICAgICAgICAgdmFyIGxldmVsc0xlbmd0aCA9IHRoaXMubGV2ZWxzID8gdGhpcy5sZXZlbHMubGVuZ3RoIDogMDtcbiAgICAgICAgICAgIGlmIChsZXZlbHNMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB2YXIgaGxzXzEgPSB0aGlzLmhscztcbiAgICAgICAgICAgICAgICBobHNfMS5hdXRvTGV2ZWxDYXBwaW5nID0gdGhpcy5nZXRNYXhMZXZlbChsZXZlbHNMZW5ndGggLSAxKTtcbiAgICAgICAgICAgICAgICBpZiAoaGxzXzEuYXV0b0xldmVsQ2FwcGluZyA+IHRoaXMuYXV0b0xldmVsQ2FwcGluZykge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiBhdXRvIGxldmVsIGNhcHBpbmcgaGFzIGEgaGlnaGVyIHZhbHVlIGZvciB0aGUgcHJldmlvdXMgb25lLCBmbHVzaCB0aGUgYnVmZmVyIHVzaW5nIG5leHRMZXZlbFN3aXRjaFxuICAgICAgICAgICAgICAgICAgICAvLyB1c3VhbGx5IGhhcHBlbiB3aGVuIHRoZSB1c2VyIGdvIHRvIHRoZSBmdWxsc2NyZWVuIG1vZGUuXG4gICAgICAgICAgICAgICAgICAgIGhsc18xLnN0cmVhbUNvbnRyb2xsZXIubmV4dExldmVsU3dpdGNoKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuYXV0b0xldmVsQ2FwcGluZyA9IGhsc18xLmF1dG9MZXZlbENhcHBpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qXG4gICAgKiByZXR1cm5zIGxldmVsIHNob3VsZCBiZSB0aGUgb25lIHdpdGggdGhlIGRpbWVuc2lvbnMgZXF1YWwgb3IgZ3JlYXRlciB0aGFuIHRoZSBtZWRpYSAocGxheWVyKSBkaW1lbnNpb25zIChzbyB0aGUgdmlkZW8gd2lsbCBiZSBkb3duc2NhbGVkKVxuICAgICovXG4gICAgQ2FwTGV2ZWxDb250cm9sbGVyLnByb3RvdHlwZS5nZXRNYXhMZXZlbCA9IGZ1bmN0aW9uIChjYXBMZXZlbEluZGV4KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICghdGhpcy5sZXZlbHMpIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdmFsaWRMZXZlbHMgPSB0aGlzLmxldmVscy5maWx0ZXIoZnVuY3Rpb24gKGxldmVsLCBpbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuIENhcExldmVsQ29udHJvbGxlci5pc0xldmVsQWxsb3dlZChpbmRleCwgX3RoaXMucmVzdHJpY3RlZExldmVscykgJiYgaW5kZXggPD0gY2FwTGV2ZWxJbmRleDtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBDYXBMZXZlbENvbnRyb2xsZXIuZ2V0TWF4TGV2ZWxCeU1lZGlhU2l6ZSh2YWxpZExldmVscywgdGhpcy5tZWRpYVdpZHRoLCB0aGlzLm1lZGlhSGVpZ2h0KTtcbiAgICB9O1xuICAgIENhcExldmVsQ29udHJvbGxlci5wcm90b3R5cGUuX3N0YXJ0Q2FwcGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMudGltZXIpIHtcbiAgICAgICAgICAgIC8vIERvbid0IHJlc2V0IGNhcHBpbmcgaWYgc3RhcnRlZCB0d2ljZTsgdGhpcyBjYW4gaGFwcGVuIGlmIHRoZSBtYW5pZmVzdCBzaWduYWxzIGEgdmlkZW8gY29kZWNcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmF1dG9MZXZlbENhcHBpbmcgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgICAgIHRoaXMuaGxzLmZpcnN0TGV2ZWwgPSB0aGlzLmdldE1heExldmVsKHRoaXMuZmlyc3RMZXZlbCk7XG4gICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy50aW1lcik7XG4gICAgICAgIHRoaXMudGltZXIgPSBzZXRJbnRlcnZhbCh0aGlzLmRldGVjdFBsYXllclNpemUuYmluZCh0aGlzKSwgMTAwMCk7XG4gICAgICAgIHRoaXMuZGV0ZWN0UGxheWVyU2l6ZSgpO1xuICAgIH07XG4gICAgQ2FwTGV2ZWxDb250cm9sbGVyLnByb3RvdHlwZS5fc3RvcENhcHBpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMucmVzdHJpY3RlZExldmVscyA9IFtdO1xuICAgICAgICB0aGlzLmZpcnN0TGV2ZWwgPSBudWxsO1xuICAgICAgICB0aGlzLmF1dG9MZXZlbENhcHBpbmcgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgICAgIGlmICh0aGlzLnRpbWVyKSB7XG4gICAgICAgICAgICB0aGlzLnRpbWVyID0gY2xlYXJJbnRlcnZhbCh0aGlzLnRpbWVyKTtcbiAgICAgICAgICAgIHRoaXMudGltZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ2FwTGV2ZWxDb250cm9sbGVyLnByb3RvdHlwZSwgXCJtZWRpYVdpZHRoXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgd2lkdGg7XG4gICAgICAgICAgICB2YXIgbWVkaWEgPSB0aGlzLm1lZGlhO1xuICAgICAgICAgICAgaWYgKG1lZGlhKSB7XG4gICAgICAgICAgICAgICAgd2lkdGggPSBtZWRpYS53aWR0aCB8fCBtZWRpYS5jbGllbnRXaWR0aCB8fCBtZWRpYS5vZmZzZXRXaWR0aDtcbiAgICAgICAgICAgICAgICB3aWR0aCAqPSBDYXBMZXZlbENvbnRyb2xsZXIuY29udGVudFNjYWxlRmFjdG9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHdpZHRoO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ2FwTGV2ZWxDb250cm9sbGVyLnByb3RvdHlwZSwgXCJtZWRpYUhlaWdodFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGhlaWdodDtcbiAgICAgICAgICAgIHZhciBtZWRpYSA9IHRoaXMubWVkaWE7XG4gICAgICAgICAgICBpZiAobWVkaWEpIHtcbiAgICAgICAgICAgICAgICBoZWlnaHQgPSBtZWRpYS5oZWlnaHQgfHwgbWVkaWEuY2xpZW50SGVpZ2h0IHx8IG1lZGlhLm9mZnNldEhlaWdodDtcbiAgICAgICAgICAgICAgICBoZWlnaHQgKj0gQ2FwTGV2ZWxDb250cm9sbGVyLmNvbnRlbnRTY2FsZUZhY3RvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBoZWlnaHQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDYXBMZXZlbENvbnRyb2xsZXIsIFwiY29udGVudFNjYWxlRmFjdG9yXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcGl4ZWxSYXRpbyA9IDE7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHBpeGVsUmF0aW8gPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7IH1cbiAgICAgICAgICAgIHJldHVybiBwaXhlbFJhdGlvO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBDYXBMZXZlbENvbnRyb2xsZXIuaXNMZXZlbEFsbG93ZWQgPSBmdW5jdGlvbiAobGV2ZWwsIHJlc3RyaWN0ZWRMZXZlbHMpIHtcbiAgICAgICAgaWYgKHJlc3RyaWN0ZWRMZXZlbHMgPT09IHZvaWQgMCkgeyByZXN0cmljdGVkTGV2ZWxzID0gW107IH1cbiAgICAgICAgcmV0dXJuIHJlc3RyaWN0ZWRMZXZlbHMuaW5kZXhPZihsZXZlbCkgPT09IC0xO1xuICAgIH07XG4gICAgQ2FwTGV2ZWxDb250cm9sbGVyLmdldE1heExldmVsQnlNZWRpYVNpemUgPSBmdW5jdGlvbiAobGV2ZWxzLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIGlmICghbGV2ZWxzIHx8IChsZXZlbHMgJiYgIWxldmVscy5sZW5ndGgpKSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTGV2ZWxzIGNhbiBoYXZlIHRoZSBzYW1lIGRpbWVuc2lvbnMgYnV0IGRpZmZlcmluZyBiYW5kd2lkdGhzIC0gc2luY2UgbGV2ZWxzIGFyZSBvcmRlcmVkLCB3ZSBjYW4gbG9vayB0byB0aGUgbmV4dFxuICAgICAgICAvLyB0byBkZXRlcm1pbmUgd2hldGhlciB3ZSd2ZSBjaG9zZW4gdGhlIGdyZWF0ZXN0IGJhbmR3aWR0aCBmb3IgdGhlIG1lZGlhJ3MgZGltZW5zaW9uc1xuICAgICAgICB2YXIgYXRHcmVhdGVzdEJhbmRpd2R0aCA9IGZ1bmN0aW9uIChjdXJMZXZlbCwgbmV4dExldmVsKSB7XG4gICAgICAgICAgICBpZiAoIW5leHRMZXZlbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGN1ckxldmVsLndpZHRoICE9PSBuZXh0TGV2ZWwud2lkdGggfHwgY3VyTGV2ZWwuaGVpZ2h0ICE9PSBuZXh0TGV2ZWwuaGVpZ2h0O1xuICAgICAgICB9O1xuICAgICAgICAvLyBJZiB3ZSBydW4gdGhyb3VnaCB0aGUgbG9vcCB3aXRob3V0IGJyZWFraW5nLCB0aGUgbWVkaWEncyBkaW1lbnNpb25zIGFyZSBncmVhdGVyIHRoYW4gZXZlcnkgbGV2ZWwsIHNvIGRlZmF1bHQgdG9cbiAgICAgICAgLy8gdGhlIG1heCBsZXZlbFxuICAgICAgICB2YXIgbWF4TGV2ZWxJbmRleCA9IGxldmVscy5sZW5ndGggLSAxO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxldmVscy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgdmFyIGxldmVsID0gbGV2ZWxzW2ldO1xuICAgICAgICAgICAgaWYgKChsZXZlbC53aWR0aCA+PSB3aWR0aCB8fCBsZXZlbC5oZWlnaHQgPj0gaGVpZ2h0KSAmJiBhdEdyZWF0ZXN0QmFuZGl3ZHRoKGxldmVsLCBsZXZlbHNbaSArIDFdKSkge1xuICAgICAgICAgICAgICAgIG1heExldmVsSW5kZXggPSBpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXhMZXZlbEluZGV4O1xuICAgIH07XG4gICAgcmV0dXJuIENhcExldmVsQ29udHJvbGxlcjtcbn0oZXZlbnRfaGFuZGxlcl8xLmRlZmF1bHQpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IENhcExldmVsQ29udHJvbGxlcjtcblxuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovfS5jYWxsKHRoaXMsIF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vc3JjL3BvbHlmaWxscy9udW1iZXIgKi8gXCIuL3NyYy9wb2x5ZmlsbHMvbnVtYmVyLmpzXCIpW1wiTnVtYmVyXCJdKSlcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvY29udHJvbGxlci9lbWUtY29udHJvbGxlci5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2NvbnRyb2xsZXIvZW1lLWNvbnRyb2xsZXIuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyoqXG4gKiBAYXV0aG9yIFN0ZXBoYW4gSGVzc2UgPGRpc3BhcmF0QGdtYWlsLmNvbT4gfCA8dGNoYWthYmFtQGdtYWlsLmNvbT5cbiAqXG4gKiBEUk0gc3VwcG9ydCBmb3IgSGxzLmpzXG4gKi9cbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGV2ZW50X2hhbmRsZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2V2ZW50LWhhbmRsZXIgKi8gXCIuL3NyYy9ldmVudC1oYW5kbGVyLmpzXCIpO1xudmFyIGV2ZW50c18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZXZlbnRzICovIFwiLi9zcmMvZXZlbnRzLmpzXCIpO1xudmFyIGVycm9yc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZXJyb3JzICovIFwiLi9zcmMvZXJyb3JzLmpzXCIpO1xudmFyIGxvZ2dlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvbG9nZ2VyICovIFwiLi9zcmMvdXRpbHMvbG9nZ2VyLmpzXCIpO1xudmFyIFhNTEh0dHBSZXF1ZXN0ID0gd2luZG93LlhNTEh0dHBSZXF1ZXN0O1xudmFyIE1BWF9MSUNFTlNFX1JFUVVFU1RfRkFJTFVSRVMgPSAzO1xuLyoqXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9OYXZpZ2F0b3IvcmVxdWVzdE1lZGlhS2V5U3lzdGVtQWNjZXNzXG4gKi9cbnZhciBLZXlTeXN0ZW1zID0ge1xuICAgIFdJREVWSU5FOiAnY29tLndpZGV2aW5lLmFscGhhJyxcbiAgICBQTEFZUkVBRFk6ICdjb20ubWljcm9zb2Z0LnBsYXlyZWFkeSdcbn07XG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL01lZGlhS2V5U3lzdGVtQ29uZmlndXJhdGlvblxuICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSBhdWRpb0NvZGVjcyBMaXN0IG9mIHJlcXVpcmVkIGF1ZGlvIGNvZGVjcyB0byBzdXBwb3J0XG4gKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IHZpZGVvQ29kZWNzIExpc3Qgb2YgcmVxdWlyZWQgdmlkZW8gY29kZWNzIHRvIHN1cHBvcnRcbiAqIEBwYXJhbSB7b2JqZWN0fSBkcm1TeXN0ZW1PcHRpb25zIE9wdGlvbmFsIHBhcmFtZXRlcnMvcmVxdWlyZW1lbnRzIGZvciB0aGUga2V5LXN5c3RlbVxuICogQHJldHVybnMge0FycmF5PE1lZGlhU3lzdGVtQ29uZmlndXJhdGlvbj59IEFuIGFycmF5IG9mIHN1cHBvcnRlZCBjb25maWd1cmF0aW9uc1xuICovXG52YXIgY3JlYXRlV2lkZXZpbmVNZWRpYUtleVN5c3RlbUNvbmZpZ3VyYXRpb25zID0gZnVuY3Rpb24gKGF1ZGlvQ29kZWNzLCB2aWRlb0NvZGVjcywgZHJtU3lzdGVtT3B0aW9ucykge1xuICAgIHZhciBiYXNlQ29uZmlnID0ge1xuICAgICAgICAvLyBpbml0RGF0YVR5cGVzOiBbJ2tleWlkcycsICdtcDQnXSxcbiAgICAgICAgLy8gbGFiZWw6IFwiXCIsXG4gICAgICAgIC8vIHBlcnNpc3RlbnRTdGF0ZTogXCJub3QtYWxsb3dlZFwiLCAvLyBvciBcInJlcXVpcmVkXCIgP1xuICAgICAgICAvLyBkaXN0aW5jdGl2ZUlkZW50aWZpZXI6IFwibm90LWFsbG93ZWRcIiwgLy8gb3IgXCJyZXF1aXJlZFwiID9cbiAgICAgICAgLy8gc2Vzc2lvblR5cGVzOiBbJ3RlbXBvcmFyeSddLFxuICAgICAgICB2aWRlb0NhcGFiaWxpdGllczogW1xuICAgICAgICAvLyB7IGNvbnRlbnRUeXBlOiAndmlkZW8vbXA0OyBjb2RlY3M9XCJhdmMxLjQyRTAxRVwiJyB9XG4gICAgICAgIF1cbiAgICB9O1xuICAgIHZpZGVvQ29kZWNzLmZvckVhY2goZnVuY3Rpb24gKGNvZGVjKSB7XG4gICAgICAgIGJhc2VDb25maWcudmlkZW9DYXBhYmlsaXRpZXMucHVzaCh7XG4gICAgICAgICAgICBjb250ZW50VHlwZTogXCJ2aWRlby9tcDQ7IGNvZGVjcz1cXFwiXCIgKyBjb2RlYyArIFwiXFxcIlwiXG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiBbXG4gICAgICAgIGJhc2VDb25maWdcbiAgICBdO1xufTtcbi8qKlxuICogVGhlIGlkZWEgaGVyZSBpcyB0byBoYW5kbGUga2V5LXN5c3RlbSAoYW5kIHRoZWlyIHJlc3BlY3RpdmUgcGxhdGZvcm1zKSBzcGVjaWZpYyBjb25maWd1cmF0aW9uIGRpZmZlcmVuY2VzXG4gKiBpbiBvcmRlciB0byB3b3JrIHdpdGggdGhlIGxvY2FsIHJlcXVlc3RNZWRpYUtleVN5c3RlbUFjY2VzcyBtZXRob2QuXG4gKlxuICogV2UgY2FuIGFsc28gcnVsZS1vdXQgcGxhdGZvcm0tcmVsYXRlZCBrZXktc3lzdGVtIHN1cHBvcnQgYXQgdGhpcyBwb2ludCBieSB0aHJvd2luZyBhbiBlcnJvciBvciByZXR1cm5pbmcgbnVsbC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5U3lzdGVtIElkZW50aWZpZXIgZm9yIHRoZSBrZXktc3lzdGVtLCBzZWUgYEtleVN5c3RlbXNgIGVudW1cbiAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gYXVkaW9Db2RlY3MgTGlzdCBvZiByZXF1aXJlZCBhdWRpbyBjb2RlY3MgdG8gc3VwcG9ydFxuICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSB2aWRlb0NvZGVjcyBMaXN0IG9mIHJlcXVpcmVkIHZpZGVvIGNvZGVjcyB0byBzdXBwb3J0XG4gKiBAcmV0dXJucyB7QXJyYXk8TWVkaWFTeXN0ZW1Db25maWd1cmF0aW9uPiB8IG51bGx9IEEgbm9uLWVtcHR5IEFycmF5IG9mIE1lZGlhS2V5U3lzdGVtQ29uZmlndXJhdGlvbiBvYmplY3RzIG9yIGBudWxsYFxuICovXG52YXIgZ2V0U3VwcG9ydGVkTWVkaWFLZXlTeXN0ZW1Db25maWd1cmF0aW9ucyA9IGZ1bmN0aW9uIChrZXlTeXN0ZW0sIGF1ZGlvQ29kZWNzLCB2aWRlb0NvZGVjcykge1xuICAgIHN3aXRjaCAoa2V5U3lzdGVtKSB7XG4gICAgICAgIGNhc2UgS2V5U3lzdGVtcy5XSURFVklORTpcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVXaWRldmluZU1lZGlhS2V5U3lzdGVtQ29uZmlndXJhdGlvbnMoYXVkaW9Db2RlY3MsIHZpZGVvQ29kZWNzKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IEVycm9yKCdVbmtub3duIGtleS1zeXN0ZW06ICcgKyBrZXlTeXN0ZW0pO1xuICAgIH1cbn07XG4vKipcbiAqIENvbnRyb2xsZXIgdG8gZGVhbCB3aXRoIGVuY3J5cHRlZCBtZWRpYSBleHRlbnNpb25zIChFTUUpXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9FbmNyeXB0ZWRfTWVkaWFfRXh0ZW5zaW9uc19BUElcbiAqXG4gKiBAY2xhc3NcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgRU1FQ29udHJvbGxlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRU1FQ29udHJvbGxlciwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgICAqIEBjb25zdHJ1Y3RzXG4gICAgICAgKiBAcGFyYW0ge0hsc30gaGxzIE91ciBIbHMuanMgaW5zdGFuY2VcbiAgICAgICAqL1xuICAgIGZ1bmN0aW9uIEVNRUNvbnRyb2xsZXIoaGxzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGhscywgZXZlbnRzXzEuZGVmYXVsdC5NRURJQV9BVFRBQ0hFRCwgZXZlbnRzXzEuZGVmYXVsdC5NQU5JRkVTVF9QQVJTRUQpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLl93aWRldmluZUxpY2Vuc2VVcmwgPSBobHMuY29uZmlnLndpZGV2aW5lTGljZW5zZVVybDtcbiAgICAgICAgX3RoaXMuX2xpY2Vuc2VYaHJTZXR1cCA9IGhscy5jb25maWcubGljZW5zZVhoclNldHVwO1xuICAgICAgICBfdGhpcy5fZW1lRW5hYmxlZCA9IGhscy5jb25maWcuZW1lRW5hYmxlZDtcbiAgICAgICAgX3RoaXMuX3JlcXVlc3RNZWRpYUtleVN5c3RlbUFjY2VzcyA9IGhscy5jb25maWcucmVxdWVzdE1lZGlhS2V5U3lzdGVtQWNjZXNzRnVuYztcbiAgICAgICAgX3RoaXMuX21lZGlhS2V5c0xpc3QgPSBbXTtcbiAgICAgICAgX3RoaXMuX21lZGlhID0gbnVsbDtcbiAgICAgICAgX3RoaXMuX2hhc1NldE1lZGlhS2V5cyA9IGZhbHNlO1xuICAgICAgICBfdGhpcy5faXNNZWRpYUVuY3J5cHRlZCA9IGZhbHNlO1xuICAgICAgICBfdGhpcy5fcmVxdWVzdExpY2Vuc2VGYWlsdXJlQ291bnQgPSAwO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlTeXN0ZW0gSWRlbnRpZmllciBmb3IgdGhlIGtleS1zeXN0ZW0sIHNlZSBgS2V5U3lzdGVtc2AgZW51bVxuICAgICAgICogQHJldHVybnMge3N0cmluZ30gTGljZW5zZSBzZXJ2ZXIgVVJMIGZvciBrZXktc3lzdGVtIChpZiBhbnkgY29uZmlndXJlZCwgb3RoZXJ3aXNlIGNhdXNlcyBlcnJvcilcbiAgICAgICAqL1xuICAgIEVNRUNvbnRyb2xsZXIucHJvdG90eXBlLmdldExpY2Vuc2VTZXJ2ZXJVcmwgPSBmdW5jdGlvbiAoa2V5U3lzdGVtKSB7XG4gICAgICAgIHZhciB1cmw7XG4gICAgICAgIHN3aXRjaCAoa2V5U3lzdGVtKSB7XG4gICAgICAgICAgICBjYXNlIEtleVN5c3RlbXMuV0lERVZJTkU6XG4gICAgICAgICAgICAgICAgdXJsID0gdGhpcy5fd2lkZXZpbmVMaWNlbnNlVXJsO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB1cmwgPSBudWxsO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdXJsKSB7XG4gICAgICAgICAgICBsb2dnZXJfMS5sb2dnZXIuZXJyb3IoXCJObyBsaWNlbnNlIHNlcnZlciBVUkwgY29uZmlndXJlZCBmb3Iga2V5LXN5c3RlbSBcXFwiXCIgKyBrZXlTeXN0ZW0gKyBcIlxcXCJcIik7XG4gICAgICAgICAgICB0aGlzLmhscy50cmlnZ2VyKGV2ZW50c18xLmRlZmF1bHQuRVJST1IsIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBlcnJvcnNfMS5FcnJvclR5cGVzLktFWV9TWVNURU1fRVJST1IsXG4gICAgICAgICAgICAgICAgZGV0YWlsczogZXJyb3JzXzEuRXJyb3JEZXRhaWxzLktFWV9TWVNURU1fTElDRU5TRV9SRVFVRVNUX0ZBSUxFRCxcbiAgICAgICAgICAgICAgICBmYXRhbDogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVybDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAgICogUmVxdWVzdHMgYWNjZXNzIG9iamVjdCBhbmQgYWRkcyBpdCB0byBvdXIgbGlzdCB1cG9uIHN1Y2Nlc3NcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5U3lzdGVtIFN5c3RlbSBJRCAoc2VlIGBLZXlTeXN0ZW1zYClcbiAgICAgICAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gYXVkaW9Db2RlY3MgTGlzdCBvZiByZXF1aXJlZCBhdWRpbyBjb2RlY3MgdG8gc3VwcG9ydFxuICAgICAgICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSB2aWRlb0NvZGVjcyBMaXN0IG9mIHJlcXVpcmVkIHZpZGVvIGNvZGVjcyB0byBzdXBwb3J0XG4gICAgICAgKi9cbiAgICBFTUVDb250cm9sbGVyLnByb3RvdHlwZS5fYXR0ZW1wdEtleVN5c3RlbUFjY2VzcyA9IGZ1bmN0aW9uIChrZXlTeXN0ZW0sIGF1ZGlvQ29kZWNzLCB2aWRlb0NvZGVjcykge1xuICAgICAgICAvLyBUT0RPOiBhZGQgb3RoZXIgRFJNIFwib3B0aW9uc1wiXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBtZWRpYUtleVN5c3RlbUNvbmZpZ3MgPSBnZXRTdXBwb3J0ZWRNZWRpYUtleVN5c3RlbUNvbmZpZ3VyYXRpb25zKGtleVN5c3RlbSwgYXVkaW9Db2RlY3MsIHZpZGVvQ29kZWNzKTtcbiAgICAgICAgaWYgKCFtZWRpYUtleVN5c3RlbUNvbmZpZ3MpIHtcbiAgICAgICAgICAgIGxvZ2dlcl8xLmxvZ2dlci53YXJuKCdDYW4gbm90IGNyZWF0ZSBjb25maWcgZm9yIGtleS1zeXN0ZW0gKG1heWJlIGJlY2F1c2UgcGxhdGZvcm0gaXMgbm90IHN1cHBvcnRlZCk6Jywga2V5U3lzdGVtKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsb2dnZXJfMS5sb2dnZXIubG9nKCdSZXF1ZXN0aW5nIGVuY3J5cHRlZCBtZWRpYSBrZXktc3lzdGVtIGFjY2VzcycpO1xuICAgICAgICAvLyBleHBlY3RpbmcgaW50ZXJmYWNlIGxpa2Ugd2luZG93Lm5hdmlnYXRvci5yZXF1ZXN0TWVkaWFLZXlTeXN0ZW1BY2Nlc3NcbiAgICAgICAgdGhpcy5yZXF1ZXN0TWVkaWFLZXlTeXN0ZW1BY2Nlc3Moa2V5U3lzdGVtLCBtZWRpYUtleVN5c3RlbUNvbmZpZ3MpXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAobWVkaWFLZXlTeXN0ZW1BY2Nlc3MpIHtcbiAgICAgICAgICAgIF90aGlzLl9vbk1lZGlhS2V5U3lzdGVtQWNjZXNzT2J0YWluZWQoa2V5U3lzdGVtLCBtZWRpYUtleVN5c3RlbUFjY2Vzcyk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLmVycm9yKFwiRmFpbGVkIHRvIG9idGFpbiBrZXktc3lzdGVtIFxcXCJcIiArIGtleVN5c3RlbSArIFwiXFxcIiBhY2Nlc3M6XCIsIGVycik7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEVNRUNvbnRyb2xsZXIucHJvdG90eXBlLCBcInJlcXVlc3RNZWRpYUtleVN5c3RlbUFjY2Vzc1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9yZXF1ZXN0TWVkaWFLZXlTeXN0ZW1BY2Nlc3MpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHJlcXVlc3RNZWRpYUtleVN5c3RlbUFjY2VzcyBmdW5jdGlvbiBjb25maWd1cmVkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdE1lZGlhS2V5U3lzdGVtQWNjZXNzO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgICAqIEhhbmRsZXMgb2J0YWluaW5nIGFjY2VzcyB0byBhIGtleS1zeXN0ZW1cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5U3lzdGVtXG4gICAgICAgKiBAcGFyYW0ge01lZGlhS2V5U3lzdGVtQWNjZXNzfSBtZWRpYUtleVN5c3RlbUFjY2VzcyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvTWVkaWFLZXlTeXN0ZW1BY2Nlc3NcbiAgICAgICAqL1xuICAgIEVNRUNvbnRyb2xsZXIucHJvdG90eXBlLl9vbk1lZGlhS2V5U3lzdGVtQWNjZXNzT2J0YWluZWQgPSBmdW5jdGlvbiAoa2V5U3lzdGVtLCBtZWRpYUtleVN5c3RlbUFjY2Vzcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBsb2dnZXJfMS5sb2dnZXIubG9nKFwiQWNjZXNzIGZvciBrZXktc3lzdGVtIFxcXCJcIiArIGtleVN5c3RlbSArIFwiXFxcIiBvYnRhaW5lZFwiKTtcbiAgICAgICAgdmFyIG1lZGlhS2V5c0xpc3RJdGVtID0ge1xuICAgICAgICAgICAgbWVkaWFLZXlzOiBudWxsLFxuICAgICAgICAgICAgbWVkaWFLZXlzU2Vzc2lvbjogbnVsbCxcbiAgICAgICAgICAgIG1lZGlhS2V5c1Nlc3Npb25Jbml0aWFsaXplZDogZmFsc2UsXG4gICAgICAgICAgICBtZWRpYUtleVN5c3RlbUFjY2VzczogbWVkaWFLZXlTeXN0ZW1BY2Nlc3MsXG4gICAgICAgICAgICBtZWRpYUtleVN5c3RlbURvbWFpbjoga2V5U3lzdGVtXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX21lZGlhS2V5c0xpc3QucHVzaChtZWRpYUtleXNMaXN0SXRlbSk7XG4gICAgICAgIG1lZGlhS2V5U3lzdGVtQWNjZXNzLmNyZWF0ZU1lZGlhS2V5cygpXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAobWVkaWFLZXlzKSB7XG4gICAgICAgICAgICBtZWRpYUtleXNMaXN0SXRlbS5tZWRpYUtleXMgPSBtZWRpYUtleXM7XG4gICAgICAgICAgICBsb2dnZXJfMS5sb2dnZXIubG9nKFwiTWVkaWEta2V5cyBjcmVhdGVkIGZvciBrZXktc3lzdGVtIFxcXCJcIiArIGtleVN5c3RlbSArIFwiXFxcIlwiKTtcbiAgICAgICAgICAgIF90aGlzLl9vbk1lZGlhS2V5c0NyZWF0ZWQoKTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5jYXRjaChmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICBsb2dnZXJfMS5sb2dnZXIuZXJyb3IoJ0ZhaWxlZCB0byBjcmVhdGUgbWVkaWEta2V5czonLCBlcnIpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAgICogSGFuZGxlcyBrZXktY3JlYXRpb24gKHJlcHJlc2VudHMgYWNjZXNzIHRvIENETSkuIFdlIGFyZSBnb2luZyB0byBjcmVhdGUga2V5LXNlc3Npb25zIHVwb24gdGhpc1xuICAgICAgICogZm9yIGFsbCBleGlzdGluZyBrZXlzIHdoZXJlIG5vIHNlc3Npb24gZXhpc3RzIHlldC5cbiAgICAgICAqL1xuICAgIEVNRUNvbnRyb2xsZXIucHJvdG90eXBlLl9vbk1lZGlhS2V5c0NyZWF0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIC8vIGNoZWNrIGZvciBhbGwga2V5LWxpc3QgaXRlbXMgaWYgYSBzZXNzaW9uIGV4aXN0cywgb3RoZXJ3aXNlLCBjcmVhdGUgb25lXG4gICAgICAgIHRoaXMuX21lZGlhS2V5c0xpc3QuZm9yRWFjaChmdW5jdGlvbiAobWVkaWFLZXlzTGlzdEl0ZW0pIHtcbiAgICAgICAgICAgIGlmICghbWVkaWFLZXlzTGlzdEl0ZW0ubWVkaWFLZXlzU2Vzc2lvbikge1xuICAgICAgICAgICAgICAgIG1lZGlhS2V5c0xpc3RJdGVtLm1lZGlhS2V5c1Nlc3Npb24gPSBtZWRpYUtleXNMaXN0SXRlbS5tZWRpYUtleXMuY3JlYXRlU2Vzc2lvbigpO1xuICAgICAgICAgICAgICAgIF90aGlzLl9vbk5ld01lZGlhS2V5U2Vzc2lvbihtZWRpYUtleXNMaXN0SXRlbS5tZWRpYUtleXNTZXNzaW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0geyp9IGtleVNlc3Npb25cbiAgICAgICAqL1xuICAgIEVNRUNvbnRyb2xsZXIucHJvdG90eXBlLl9vbk5ld01lZGlhS2V5U2Vzc2lvbiA9IGZ1bmN0aW9uIChrZXlTZXNzaW9uKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGxvZ2dlcl8xLmxvZ2dlci5sb2coXCJOZXcga2V5LXN5c3RlbSBzZXNzaW9uIFwiICsga2V5U2Vzc2lvbi5zZXNzaW9uSWQpO1xuICAgICAgICBrZXlTZXNzaW9uLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIF90aGlzLl9vbktleVNlc3Npb25NZXNzYWdlKGtleVNlc3Npb24sIGV2ZW50Lm1lc3NhZ2UpO1xuICAgICAgICB9LCBmYWxzZSk7XG4gICAgfTtcbiAgICBFTUVDb250cm9sbGVyLnByb3RvdHlwZS5fb25LZXlTZXNzaW9uTWVzc2FnZSA9IGZ1bmN0aW9uIChrZXlTZXNzaW9uLCBtZXNzYWdlKSB7XG4gICAgICAgIGxvZ2dlcl8xLmxvZ2dlci5sb2coJ0dvdCBFTUUgbWVzc2FnZSBldmVudCwgY3JlYXRpbmcgbGljZW5zZSByZXF1ZXN0Jyk7XG4gICAgICAgIHRoaXMuX3JlcXVlc3RMaWNlbnNlKG1lc3NhZ2UsIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICBsb2dnZXJfMS5sb2dnZXIubG9nKCdSZWNlaXZlZCBsaWNlbnNlIGRhdGEsIHVwZGF0aW5nIGtleS1zZXNzaW9uJyk7XG4gICAgICAgICAgICBrZXlTZXNzaW9uLnVwZGF0ZShkYXRhKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBFTUVDb250cm9sbGVyLnByb3RvdHlwZS5fb25NZWRpYUVuY3J5cHRlZCA9IGZ1bmN0aW9uIChpbml0RGF0YVR5cGUsIGluaXREYXRhKSB7XG4gICAgICAgIGxvZ2dlcl8xLmxvZ2dlci5sb2coXCJNZWRpYSBpcyBlbmNyeXB0ZWQgdXNpbmcgXFxcIlwiICsgaW5pdERhdGFUeXBlICsgXCJcXFwiIGluaXQgZGF0YSB0eXBlXCIpO1xuICAgICAgICB0aGlzLl9pc01lZGlhRW5jcnlwdGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fbWVkaWFFbmNyeXB0aW9uSW5pdERhdGFUeXBlID0gaW5pdERhdGFUeXBlO1xuICAgICAgICB0aGlzLl9tZWRpYUVuY3J5cHRpb25Jbml0RGF0YSA9IGluaXREYXRhO1xuICAgICAgICB0aGlzLl9hdHRlbXB0U2V0TWVkaWFLZXlzKCk7XG4gICAgICAgIHRoaXMuX2dlbmVyYXRlUmVxdWVzdFdpdGhQcmVmZXJyZWRLZXlTZXNzaW9uKCk7XG4gICAgfTtcbiAgICBFTUVDb250cm9sbGVyLnByb3RvdHlwZS5fYXR0ZW1wdFNldE1lZGlhS2V5cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9oYXNTZXRNZWRpYUtleXMpIHtcbiAgICAgICAgICAgIC8vIEZJWE1FOiBzZWUgaWYgd2UgY2FuL3dhbnQvbmVlZC10byByZWFsbHkgdG8gZGVhbCB3aXRoIHNldmVyYWwgcG90ZW50aWFsIGtleS1zZXNzaW9ucz9cbiAgICAgICAgICAgIHZhciBrZXlzTGlzdEl0ZW0gPSB0aGlzLl9tZWRpYUtleXNMaXN0WzBdO1xuICAgICAgICAgICAgaWYgKCFrZXlzTGlzdEl0ZW0gfHwgIWtleXNMaXN0SXRlbS5tZWRpYUtleXMpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXJfMS5sb2dnZXIuZXJyb3IoJ0ZhdGFsOiBNZWRpYSBpcyBlbmNyeXB0ZWQgYnV0IG5vIENETSBhY2Nlc3Mgb3Igbm8ga2V5cyBoYXZlIGJlZW4gb2J0YWluZWQgeWV0Jyk7XG4gICAgICAgICAgICAgICAgdGhpcy5obHMudHJpZ2dlcihldmVudHNfMS5kZWZhdWx0LkVSUk9SLCB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IGVycm9yc18xLkVycm9yVHlwZXMuS0VZX1NZU1RFTV9FUlJPUixcbiAgICAgICAgICAgICAgICAgICAgZGV0YWlsczogZXJyb3JzXzEuRXJyb3JEZXRhaWxzLktFWV9TWVNURU1fTk9fS0VZUyxcbiAgICAgICAgICAgICAgICAgICAgZmF0YWw6IHRydWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsb2dnZXJfMS5sb2dnZXIubG9nKCdTZXR0aW5nIGtleXMgZm9yIGVuY3J5cHRlZCBtZWRpYScpO1xuICAgICAgICAgICAgdGhpcy5fbWVkaWEuc2V0TWVkaWFLZXlzKGtleXNMaXN0SXRlbS5tZWRpYUtleXMpO1xuICAgICAgICAgICAgdGhpcy5faGFzU2V0TWVkaWFLZXlzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRU1FQ29udHJvbGxlci5wcm90b3R5cGUuX2dlbmVyYXRlUmVxdWVzdFdpdGhQcmVmZXJyZWRLZXlTZXNzaW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvLyBGSVhNRTogc2VlIGlmIHdlIGNhbi93YW50L25lZWQtdG8gcmVhbGx5IHRvIGRlYWwgd2l0aCBzZXZlcmFsIHBvdGVudGlhbCBrZXktc2Vzc2lvbnM/XG4gICAgICAgIHZhciBrZXlzTGlzdEl0ZW0gPSB0aGlzLl9tZWRpYUtleXNMaXN0WzBdO1xuICAgICAgICBpZiAoIWtleXNMaXN0SXRlbSkge1xuICAgICAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLmVycm9yKCdGYXRhbDogTWVkaWEgaXMgZW5jcnlwdGVkIGJ1dCBub3QgYW55IGtleS1zeXN0ZW0gYWNjZXNzIGhhcyBiZWVuIG9idGFpbmVkIHlldCcpO1xuICAgICAgICAgICAgdGhpcy5obHMudHJpZ2dlcihldmVudHNfMS5kZWZhdWx0LkVSUk9SLCB7XG4gICAgICAgICAgICAgICAgdHlwZTogZXJyb3JzXzEuRXJyb3JUeXBlcy5LRVlfU1lTVEVNX0VSUk9SLFxuICAgICAgICAgICAgICAgIGRldGFpbHM6IGVycm9yc18xLkVycm9yRGV0YWlscy5LRVlfU1lTVEVNX05PX0FDQ0VTUyxcbiAgICAgICAgICAgICAgICBmYXRhbDogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGtleXNMaXN0SXRlbS5tZWRpYUtleXNTZXNzaW9uSW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICAgIGxvZ2dlcl8xLmxvZ2dlci53YXJuKCdLZXktU2Vzc2lvbiBhbHJlYWR5IGluaXRpYWxpemVkIGJ1dCByZXF1ZXN0ZWQgYWdhaW4nKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIga2V5U2Vzc2lvbiA9IGtleXNMaXN0SXRlbS5tZWRpYUtleXNTZXNzaW9uO1xuICAgICAgICBpZiAoIWtleVNlc3Npb24pIHtcbiAgICAgICAgICAgIGxvZ2dlcl8xLmxvZ2dlci5lcnJvcignRmF0YWw6IE1lZGlhIGlzIGVuY3J5cHRlZCBidXQgbm8ga2V5LXNlc3Npb24gZXhpc3RpbmcnKTtcbiAgICAgICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoZXZlbnRzXzEuZGVmYXVsdC5FUlJPUiwge1xuICAgICAgICAgICAgICAgIHR5cGU6IGVycm9yc18xLkVycm9yVHlwZXMuS0VZX1NZU1RFTV9FUlJPUixcbiAgICAgICAgICAgICAgICBkZXRhaWxzOiBlcnJvcnNfMS5FcnJvckRldGFpbHMuS0VZX1NZU1RFTV9OT19TRVNTSU9OLFxuICAgICAgICAgICAgICAgIGZhdGFsOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaW5pdERhdGFUeXBlID0gdGhpcy5fbWVkaWFFbmNyeXB0aW9uSW5pdERhdGFUeXBlO1xuICAgICAgICB2YXIgaW5pdERhdGEgPSB0aGlzLl9tZWRpYUVuY3J5cHRpb25Jbml0RGF0YTtcbiAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLmxvZyhcIkdlbmVyYXRpbmcga2V5LXNlc3Npb24gcmVxdWVzdCBmb3IgXFxcIlwiICsgaW5pdERhdGFUeXBlICsgXCJcXFwiIGluaXQgZGF0YSB0eXBlXCIpO1xuICAgICAgICBrZXlzTGlzdEl0ZW0ubWVkaWFLZXlzU2Vzc2lvbkluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgICAga2V5U2Vzc2lvbi5nZW5lcmF0ZVJlcXVlc3QoaW5pdERhdGFUeXBlLCBpbml0RGF0YSlcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGxvZ2dlcl8xLmxvZ2dlci5kZWJ1ZygnS2V5LXNlc3Npb24gZ2VuZXJhdGlvbiBzdWNjZWVkZWQnKTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5jYXRjaChmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICBsb2dnZXJfMS5sb2dnZXIuZXJyb3IoJ0Vycm9yIGdlbmVyYXRpbmcga2V5LXNlc3Npb24gcmVxdWVzdDonLCBlcnIpO1xuICAgICAgICAgICAgX3RoaXMuaGxzLnRyaWdnZXIoZXZlbnRzXzEuZGVmYXVsdC5FUlJPUiwge1xuICAgICAgICAgICAgICAgIHR5cGU6IGVycm9yc18xLkVycm9yVHlwZXMuS0VZX1NZU1RFTV9FUlJPUixcbiAgICAgICAgICAgICAgICBkZXRhaWxzOiBlcnJvcnNfMS5FcnJvckRldGFpbHMuS0VZX1NZU1RFTV9OT19TRVNTSU9OLFxuICAgICAgICAgICAgICAgIGZhdGFsOiBmYWxzZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsIExpY2Vuc2Ugc2VydmVyIFVSTFxuICAgICAgICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0ga2V5TWVzc2FnZSBNZXNzYWdlIGRhdGEgaXNzdWVkIGJ5IGtleS1zeXN0ZW1cbiAgICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCB3aGVuIFhIUiBoYXMgc3VjY2VlZGVkXG4gICAgICAgKiBAcmV0dXJucyB7WE1MSHR0cFJlcXVlc3R9IFVuc2VudCAoYnV0IG9wZW5lZCBzdGF0ZSkgWEhSIG9iamVjdFxuICAgICAgICovXG4gICAgRU1FQ29udHJvbGxlci5wcm90b3R5cGUuX2NyZWF0ZUxpY2Vuc2VYaHIgPSBmdW5jdGlvbiAodXJsLCBrZXlNZXNzYWdlLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgIHZhciBsaWNlbnNlWGhyU2V0dXAgPSB0aGlzLl9saWNlbnNlWGhyU2V0dXA7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAobGljZW5zZVhoclNldHVwKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgbGljZW5zZVhoclNldHVwKHhociwgdXJsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbGV0J3MgdHJ5IHRvIG9wZW4gYmVmb3JlIHJ1bm5pbmcgc2V0dXBcbiAgICAgICAgICAgICAgICAgICAgeGhyLm9wZW4oJ1BPU1QnLCB1cmwsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICBsaWNlbnNlWGhyU2V0dXAoeGhyLCB1cmwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGlmIGxpY2Vuc2VYaHJTZXR1cCBkaWQgbm90IHlldCBjYWxsIG9wZW4sIGxldCdzIGRvIGl0IG5vd1xuICAgICAgICAgICAgaWYgKCF4aHIucmVhZHlTdGF0ZSkge1xuICAgICAgICAgICAgICAgIHhoci5vcGVuKCdQT1NUJywgdXJsLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLy8gSUUxMSB0aHJvd3MgYW4gZXhjZXB0aW9uIG9uIHhoci5vcGVuIGlmIGF0dGVtcHRpbmcgdG8gYWNjZXNzIGFuIEhUVFAgcmVzb3VyY2Ugb3ZlciBIVFRQU1xuICAgICAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLmVycm9yKCdFcnJvciBzZXR0aW5nIHVwIGtleS1zeXN0ZW0gbGljZW5zZSBYSFInLCBlKTtcbiAgICAgICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoZXZlbnRzXzEuZGVmYXVsdC5FUlJPUiwge1xuICAgICAgICAgICAgICAgIHR5cGU6IGVycm9yc18xLkVycm9yVHlwZXMuS0VZX1NZU1RFTV9FUlJPUixcbiAgICAgICAgICAgICAgICBkZXRhaWxzOiBlcnJvcnNfMS5FcnJvckRldGFpbHMuS0VZX1NZU1RFTV9MSUNFTlNFX1JFUVVFU1RfRkFJTEVELFxuICAgICAgICAgICAgICAgIGZhdGFsOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB4aHIucmVzcG9uc2VUeXBlID0gJ2FycmF5YnVmZmVyJztcbiAgICAgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9XG4gICAgICAgICAgICB0aGlzLl9vbkxpY2Vuc2VSZXF1ZXN0UmVhZHlTdGFnZUNoYW5nZS5iaW5kKHRoaXMsIHhociwgdXJsLCBrZXlNZXNzYWdlLCBjYWxsYmFjayk7XG4gICAgICAgIHJldHVybiB4aHI7XG4gICAgfTtcbiAgICAvKipcbiAgICAgICAqIEBwYXJhbSB7WE1MSHR0cFJlcXVlc3R9IHhoclxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHVybCBMaWNlbnNlIHNlcnZlciBVUkxcbiAgICAgICAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGtleU1lc3NhZ2UgTWVzc2FnZSBkYXRhIGlzc3VlZCBieSBrZXktc3lzdGVtXG4gICAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgd2hlbiBYSFIgaGFzIHN1Y2NlZWRlZFxuICAgICAgICpcbiAgICAgICAqL1xuICAgIEVNRUNvbnRyb2xsZXIucHJvdG90eXBlLl9vbkxpY2Vuc2VSZXF1ZXN0UmVhZHlTdGFnZUNoYW5nZSA9IGZ1bmN0aW9uICh4aHIsIHVybCwga2V5TWVzc2FnZSwgY2FsbGJhY2spIHtcbiAgICAgICAgc3dpdGNoICh4aHIucmVhZHlTdGF0ZSkge1xuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgIGlmICh4aHIuc3RhdHVzID09PSAyMDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVxdWVzdExpY2Vuc2VGYWlsdXJlQ291bnQgPSAwO1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXJfMS5sb2dnZXIubG9nKCdMaWNlbnNlIHJlcXVlc3Qgc3VjY2VlZGVkJyk7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKHhoci5yZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXJfMS5sb2dnZXIuZXJyb3IoXCJMaWNlbnNlIFJlcXVlc3QgWEhSIGZhaWxlZCAoXCIgKyB1cmwgKyBcIikuIFN0YXR1czogXCIgKyB4aHIuc3RhdHVzICsgXCIgKFwiICsgeGhyLnN0YXR1c1RleHQgKyBcIilcIik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlcXVlc3RMaWNlbnNlRmFpbHVyZUNvdW50Kys7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9yZXF1ZXN0TGljZW5zZUZhaWx1cmVDb3VudCA8PSBNQVhfTElDRU5TRV9SRVFVRVNUX0ZBSUxVUkVTKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXR0ZW1wdHNMZWZ0ID0gTUFYX0xJQ0VOU0VfUkVRVUVTVF9GQUlMVVJFUyAtIHRoaXMuX3JlcXVlc3RMaWNlbnNlRmFpbHVyZUNvdW50ICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmxvZ2dlci53YXJuKFwiUmV0cnlpbmcgbGljZW5zZSByZXF1ZXN0LCBcIiArIGF0dGVtcHRzTGVmdCArIFwiIGF0dGVtcHRzIGxlZnRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZXF1ZXN0TGljZW5zZShrZXlNZXNzYWdlLCBjYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5obHMudHJpZ2dlcihldmVudHNfMS5kZWZhdWx0LkVSUk9SLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBlcnJvcnNfMS5FcnJvclR5cGVzLktFWV9TWVNURU1fRVJST1IsXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXRhaWxzOiBlcnJvcnNfMS5FcnJvckRldGFpbHMuS0VZX1NZU1RFTV9MSUNFTlNFX1JFUVVFU1RfRkFJTEVELFxuICAgICAgICAgICAgICAgICAgICAgICAgZmF0YWw6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBrZXlzTGlzdEl0ZW1cbiAgICAgICAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGtleU1lc3NhZ2VcbiAgICAgICAqIEByZXR1cm5zIHtBcnJheUJ1ZmZlcn0gQ2hhbGxlbmdlIGRhdGEgcG9zdGVkIHRvIGxpY2Vuc2Ugc2VydmVyXG4gICAgICAgKi9cbiAgICBFTUVDb250cm9sbGVyLnByb3RvdHlwZS5fZ2VuZXJhdGVMaWNlbnNlUmVxdWVzdENoYWxsZW5nZSA9IGZ1bmN0aW9uIChrZXlzTGlzdEl0ZW0sIGtleU1lc3NhZ2UpIHtcbiAgICAgICAgdmFyIGNoYWxsZW5nZTtcbiAgICAgICAgaWYgKGtleXNMaXN0SXRlbS5tZWRpYUtleVN5c3RlbURvbWFpbiA9PT0gS2V5U3lzdGVtcy5QTEFZUkVBRFkpIHtcbiAgICAgICAgICAgIGxvZ2dlcl8xLmxvZ2dlci5lcnJvcignUGxheVJlYWR5IGlzIG5vdCBzdXBwb3J0ZWQgKHlldCknKTtcbiAgICAgICAgICAgIC8vIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL01pY3Jvc29mdEVkZ2UvRGVtb3MvYmxvYi9tYXN0ZXIvZW1lL3NjcmlwdHMvZGVtby5qc1xuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgaWYgKHRoaXMubGljZW5zZVR5cGUgIT09IHRoaXMuTElDRU5TRV9UWVBFX1dJREVWSU5FKSB7XG4gICAgICAgICAgICAgICAgICAvLyBGb3IgUGxheVJlYWR5IENETXMsIHdlIG5lZWQgdG8gZGlnIHRoZSBDaGFsbGVuZ2Ugb3V0IG9mIHRoZSBYTUwuXG4gICAgICAgICAgICAgICAgICB2YXIga2V5TWVzc2FnZVhtbCA9IG5ldyBET01QYXJzZXIoKS5wYXJzZUZyb21TdHJpbmcoU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBuZXcgVWludDE2QXJyYXkoa2V5TWVzc2FnZSkpLCAnYXBwbGljYXRpb24veG1sJyk7XG4gICAgICAgICAgICAgICAgICBpZiAoa2V5TWVzc2FnZVhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnQ2hhbGxlbmdlJylbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICBjaGFsbGVuZ2UgPSBhdG9iKGtleU1lc3NhZ2VYbWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ0NoYWxsZW5nZScpWzBdLmNoaWxkTm9kZXNbMF0ubm9kZVZhbHVlKTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgdGhyb3cgJ0Nhbm5vdCBmaW5kIDxDaGFsbGVuZ2U+IGluIGtleSBtZXNzYWdlJztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHZhciBoZWFkZXJOYW1lcyA9IGtleU1lc3NhZ2VYbWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ25hbWUnKTtcbiAgICAgICAgICAgICAgICAgIHZhciBoZWFkZXJWYWx1ZXMgPSBrZXlNZXNzYWdlWG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKCd2YWx1ZScpO1xuICAgICAgICAgICAgICAgICAgaWYgKGhlYWRlck5hbWVzLmxlbmd0aCAhPT0gaGVhZGVyVmFsdWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgIHRocm93ICdNaXNtYXRjaGVkIGhlYWRlciA8bmFtZT4vPHZhbHVlPiBwYWlyIGluIGtleSBtZXNzYWdlJztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGVhZGVyTmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihoZWFkZXJOYW1lc1tpXS5jaGlsZE5vZGVzWzBdLm5vZGVWYWx1ZSwgaGVhZGVyVmFsdWVzW2ldLmNoaWxkTm9kZXNbMF0ubm9kZVZhbHVlKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAqL1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGtleXNMaXN0SXRlbS5tZWRpYUtleVN5c3RlbURvbWFpbiA9PT0gS2V5U3lzdGVtcy5XSURFVklORSkge1xuICAgICAgICAgICAgLy8gRm9yIFdpZGV2aW5lIENETXMsIHRoZSBjaGFsbGVuZ2UgaXMgdGhlIGtleU1lc3NhZ2UuXG4gICAgICAgICAgICBjaGFsbGVuZ2UgPSBrZXlNZXNzYWdlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLmVycm9yKCdVbnN1cHBvcnRlZCBrZXktc3lzdGVtOicsIGtleXNMaXN0SXRlbS5tZWRpYUtleVN5c3RlbURvbWFpbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNoYWxsZW5nZTtcbiAgICB9O1xuICAgIEVNRUNvbnRyb2xsZXIucHJvdG90eXBlLl9yZXF1ZXN0TGljZW5zZSA9IGZ1bmN0aW9uIChrZXlNZXNzYWdlLCBjYWxsYmFjaykge1xuICAgICAgICBsb2dnZXJfMS5sb2dnZXIubG9nKCdSZXF1ZXN0aW5nIGNvbnRlbnQgbGljZW5zZSBmb3Iga2V5LXN5c3RlbScpO1xuICAgICAgICB2YXIga2V5c0xpc3RJdGVtID0gdGhpcy5fbWVkaWFLZXlzTGlzdFswXTtcbiAgICAgICAgaWYgKCFrZXlzTGlzdEl0ZW0pIHtcbiAgICAgICAgICAgIGxvZ2dlcl8xLmxvZ2dlci5lcnJvcignRmF0YWwgZXJyb3I6IE1lZGlhIGlzIGVuY3J5cHRlZCBidXQgbm8ga2V5LXN5c3RlbSBhY2Nlc3MgaGFzIGJlZW4gb2J0YWluZWQgeWV0Jyk7XG4gICAgICAgICAgICB0aGlzLmhscy50cmlnZ2VyKGV2ZW50c18xLmRlZmF1bHQuRVJST1IsIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBlcnJvcnNfMS5FcnJvclR5cGVzLktFWV9TWVNURU1fRVJST1IsXG4gICAgICAgICAgICAgICAgZGV0YWlsczogZXJyb3JzXzEuRXJyb3JEZXRhaWxzLktFWV9TWVNURU1fTk9fQUNDRVNTLFxuICAgICAgICAgICAgICAgIGZhdGFsOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdXJsID0gdGhpcy5nZXRMaWNlbnNlU2VydmVyVXJsKGtleXNMaXN0SXRlbS5tZWRpYUtleVN5c3RlbURvbWFpbik7XG4gICAgICAgIHZhciB4aHIgPSB0aGlzLl9jcmVhdGVMaWNlbnNlWGhyKHVybCwga2V5TWVzc2FnZSwgY2FsbGJhY2spO1xuICAgICAgICBsb2dnZXJfMS5sb2dnZXIubG9nKFwiU2VuZGluZyBsaWNlbnNlIHJlcXVlc3QgdG8gVVJMOiBcIiArIHVybCk7XG4gICAgICAgIHhoci5zZW5kKHRoaXMuX2dlbmVyYXRlTGljZW5zZVJlcXVlc3RDaGFsbGVuZ2Uoa2V5c0xpc3RJdGVtLCBrZXlNZXNzYWdlKSk7XG4gICAgfTtcbiAgICBFTUVDb250cm9sbGVyLnByb3RvdHlwZS5vbk1lZGlhQXR0YWNoZWQgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoIXRoaXMuX2VtZUVuYWJsZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbWVkaWEgPSBkYXRhLm1lZGlhO1xuICAgICAgICAvLyBrZWVwIHJlZmVyZW5jZSBvZiBtZWRpYVxuICAgICAgICB0aGlzLl9tZWRpYSA9IG1lZGlhO1xuICAgICAgICAvLyBGSVhNRTogYWxzbyBoYW5kbGUgZGV0YWNoaW5nIG1lZGlhICFcbiAgICAgICAgbWVkaWEuYWRkRXZlbnRMaXN0ZW5lcignZW5jcnlwdGVkJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIF90aGlzLl9vbk1lZGlhRW5jcnlwdGVkKGUuaW5pdERhdGFUeXBlLCBlLmluaXREYXRhKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBFTUVDb250cm9sbGVyLnByb3RvdHlwZS5vbk1hbmlmZXN0UGFyc2VkID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9lbWVFbmFibGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGF1ZGlvQ29kZWNzID0gZGF0YS5sZXZlbHMubWFwKGZ1bmN0aW9uIChsZXZlbCkgeyByZXR1cm4gbGV2ZWwuYXVkaW9Db2RlYzsgfSk7XG4gICAgICAgIHZhciB2aWRlb0NvZGVjcyA9IGRhdGEubGV2ZWxzLm1hcChmdW5jdGlvbiAobGV2ZWwpIHsgcmV0dXJuIGxldmVsLnZpZGVvQ29kZWM7IH0pO1xuICAgICAgICB0aGlzLl9hdHRlbXB0S2V5U3lzdGVtQWNjZXNzKEtleVN5c3RlbXMuV0lERVZJTkUsIGF1ZGlvQ29kZWNzLCB2aWRlb0NvZGVjcyk7XG4gICAgfTtcbiAgICByZXR1cm4gRU1FQ29udHJvbGxlcjtcbn0oZXZlbnRfaGFuZGxlcl8xLmRlZmF1bHQpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IEVNRUNvbnRyb2xsZXI7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvY29udHJvbGxlci9mcHMtY29udHJvbGxlci5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2NvbnRyb2xsZXIvZnBzLWNvbnRyb2xsZXIuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLypcbiAqIEZQUyBDb250cm9sbGVyXG4qL1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZXZlbnRzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9ldmVudHMgKi8gXCIuL3NyYy9ldmVudHMuanNcIik7XG52YXIgZXZlbnRfaGFuZGxlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZXZlbnQtaGFuZGxlciAqLyBcIi4vc3JjL2V2ZW50LWhhbmRsZXIuanNcIik7XG52YXIgbG9nZ2VyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy9sb2dnZXIgKi8gXCIuL3NyYy91dGlscy9sb2dnZXIuanNcIik7XG52YXIgcGVyZm9ybWFuY2UgPSB3aW5kb3cucGVyZm9ybWFuY2U7XG52YXIgRlBTQ29udHJvbGxlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRlBTQ29udHJvbGxlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBGUFNDb250cm9sbGVyKGhscykge1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgaGxzLCBldmVudHNfMS5kZWZhdWx0Lk1FRElBX0FUVEFDSElORykgfHwgdGhpcztcbiAgICB9XG4gICAgRlBTQ29udHJvbGxlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMudGltZXIpIHtcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy50aW1lcik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pc1ZpZGVvUGxheWJhY2tRdWFsaXR5QXZhaWxhYmxlID0gZmFsc2U7XG4gICAgfTtcbiAgICBGUFNDb250cm9sbGVyLnByb3RvdHlwZS5vbk1lZGlhQXR0YWNoaW5nID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdmFyIGNvbmZpZyA9IHRoaXMuaGxzLmNvbmZpZztcbiAgICAgICAgaWYgKGNvbmZpZy5jYXBMZXZlbE9uRlBTRHJvcCkge1xuICAgICAgICAgICAgdmFyIHZpZGVvXzEgPSB0aGlzLnZpZGVvID0gZGF0YS5tZWRpYSBpbnN0YW5jZW9mIHdpbmRvdy5IVE1MVmlkZW9FbGVtZW50ID8gZGF0YS5tZWRpYSA6IG51bGw7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZpZGVvXzEuZ2V0VmlkZW9QbGF5YmFja1F1YWxpdHkgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmlzVmlkZW9QbGF5YmFja1F1YWxpdHlBdmFpbGFibGUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLnRpbWVyKTtcbiAgICAgICAgICAgIHRoaXMudGltZXIgPSBzZXRJbnRlcnZhbCh0aGlzLmNoZWNrRlBTSW50ZXJ2YWwuYmluZCh0aGlzKSwgY29uZmlnLmZwc0Ryb3BwZWRNb25pdG9yaW5nUGVyaW9kKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRlBTQ29udHJvbGxlci5wcm90b3R5cGUuY2hlY2tGUFMgPSBmdW5jdGlvbiAodmlkZW8sIGRlY29kZWRGcmFtZXMsIGRyb3BwZWRGcmFtZXMpIHtcbiAgICAgICAgdmFyIGN1cnJlbnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgIGlmIChkZWNvZGVkRnJhbWVzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5sYXN0VGltZSkge1xuICAgICAgICAgICAgICAgIHZhciBjdXJyZW50UGVyaW9kID0gY3VycmVudFRpbWUgLSB0aGlzLmxhc3RUaW1lLCBjdXJyZW50RHJvcHBlZCA9IGRyb3BwZWRGcmFtZXMgLSB0aGlzLmxhc3REcm9wcGVkRnJhbWVzLCBjdXJyZW50RGVjb2RlZCA9IGRlY29kZWRGcmFtZXMgLSB0aGlzLmxhc3REZWNvZGVkRnJhbWVzLCBkcm9wcGVkRlBTID0gMTAwMCAqIGN1cnJlbnREcm9wcGVkIC8gY3VycmVudFBlcmlvZCwgaGxzXzEgPSB0aGlzLmhscztcbiAgICAgICAgICAgICAgICBobHNfMS50cmlnZ2VyKGV2ZW50c18xLmRlZmF1bHQuRlBTX0RST1AsIHsgY3VycmVudERyb3BwZWQ6IGN1cnJlbnREcm9wcGVkLCBjdXJyZW50RGVjb2RlZDogY3VycmVudERlY29kZWQsIHRvdGFsRHJvcHBlZEZyYW1lczogZHJvcHBlZEZyYW1lcyB9KTtcbiAgICAgICAgICAgICAgICBpZiAoZHJvcHBlZEZQUyA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbG9nZ2VyLmxvZygnY2hlY2tGUFMgOiBkcm9wcGVkRlBTL2RlY29kZWRGUFM6JyArIGRyb3BwZWRGUFMvKDEwMDAgKiBjdXJyZW50RGVjb2RlZCAvIGN1cnJlbnRQZXJpb2QpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnREcm9wcGVkID4gaGxzXzEuY29uZmlnLmZwc0Ryb3BwZWRNb25pdG9yaW5nVGhyZXNob2xkICogY3VycmVudERlY29kZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjdXJyZW50TGV2ZWwgPSBobHNfMS5jdXJyZW50TGV2ZWw7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXJfMS5sb2dnZXIud2FybignZHJvcCBGUFMgcmF0aW8gZ3JlYXRlciB0aGFuIG1heCBhbGxvd2VkIHZhbHVlIGZvciBjdXJyZW50TGV2ZWw6ICcgKyBjdXJyZW50TGV2ZWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRMZXZlbCA+IDAgJiYgKGhsc18xLmF1dG9MZXZlbENhcHBpbmcgPT09IC0xIHx8IGhsc18xLmF1dG9MZXZlbENhcHBpbmcgPj0gY3VycmVudExldmVsKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRMZXZlbCA9IGN1cnJlbnRMZXZlbCAtIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGxzXzEudHJpZ2dlcihldmVudHNfMS5kZWZhdWx0LkZQU19EUk9QX0xFVkVMX0NBUFBJTkcsIHsgbGV2ZWw6IGN1cnJlbnRMZXZlbCwgZHJvcHBlZExldmVsOiBobHNfMS5jdXJyZW50TGV2ZWwgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGxzXzEuYXV0b0xldmVsQ2FwcGluZyA9IGN1cnJlbnRMZXZlbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBobHNfMS5zdHJlYW1Db250cm9sbGVyLm5leHRMZXZlbFN3aXRjaCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5sYXN0VGltZSA9IGN1cnJlbnRUaW1lO1xuICAgICAgICAgICAgdGhpcy5sYXN0RHJvcHBlZEZyYW1lcyA9IGRyb3BwZWRGcmFtZXM7XG4gICAgICAgICAgICB0aGlzLmxhc3REZWNvZGVkRnJhbWVzID0gZGVjb2RlZEZyYW1lcztcbiAgICAgICAgfVxuICAgIH07XG4gICAgRlBTQ29udHJvbGxlci5wcm90b3R5cGUuY2hlY2tGUFNJbnRlcnZhbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHZpZGVvID0gdGhpcy52aWRlbztcbiAgICAgICAgaWYgKHZpZGVvKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pc1ZpZGVvUGxheWJhY2tRdWFsaXR5QXZhaWxhYmxlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHZpZGVvUGxheWJhY2tRdWFsaXR5ID0gdmlkZW8uZ2V0VmlkZW9QbGF5YmFja1F1YWxpdHkoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNoZWNrRlBTKHZpZGVvLCB2aWRlb1BsYXliYWNrUXVhbGl0eS50b3RhbFZpZGVvRnJhbWVzLCB2aWRlb1BsYXliYWNrUXVhbGl0eS5kcm9wcGVkVmlkZW9GcmFtZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGVja0ZQUyh2aWRlbywgdmlkZW8ud2Via2l0RGVjb2RlZEZyYW1lQ291bnQsIHZpZGVvLndlYmtpdERyb3BwZWRGcmFtZUNvdW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIEZQU0NvbnRyb2xsZXI7XG59KGV2ZW50X2hhbmRsZXJfMS5kZWZhdWx0KSk7XG5leHBvcnRzLmRlZmF1bHQgPSBGUFNDb250cm9sbGVyO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2NvbnRyb2xsZXIvZnJhZ21lbnQtZmluZGVycy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvY29udHJvbGxlci9mcmFnbWVudC1maW5kZXJzLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihOdW1iZXIpIHtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBiaW5hcnlfc2VhcmNoXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy9iaW5hcnktc2VhcmNoICovIFwiLi9zcmMvdXRpbHMvYmluYXJ5LXNlYXJjaC5qc1wiKTtcbi8qKlxuICogUmV0dXJucyBmaXJzdCBmcmFnbWVudCB3aG9zZSBlbmRQZHQgdmFsdWUgZXhjZWVkcyB0aGUgZ2l2ZW4gUERULlxuICogQHBhcmFtIHtBcnJheTxGcmFnbWVudD59IGZyYWdtZW50cyAtIFRoZSBhcnJheSBvZiBjYW5kaWRhdGUgZnJhZ21lbnRzXG4gKiBAcGFyYW0ge251bWJlcnxudWxsfSBbUERUVmFsdWUgPSBudWxsXSAtIFRoZSBQRFQgdmFsdWUgd2hpY2ggbXVzdCBiZSBleGNlZWRlZFxuICogQHBhcmFtIHtudW1iZXJ9IFttYXhGcmFnTG9va1VwVG9sZXJhbmNlID0gMF0gLSBUaGUgYW1vdW50IG9mIHRpbWUgdGhhdCBhIGZyYWdtZW50J3Mgc3RhcnQvZW5kIGNhbiBiZSB3aXRoaW4gaW4gb3JkZXIgdG8gYmUgY29uc2lkZXJlZCBjb250aWd1b3VzXG4gKiBAcmV0dXJucyB7KnxudWxsfSBmcmFnbWVudCAtIFRoZSBiZXN0IG1hdGNoaW5nIGZyYWdtZW50XG4gKi9cbmZ1bmN0aW9uIGZpbmRGcmFnbWVudEJ5UERUKGZyYWdtZW50cywgUERUVmFsdWUsIG1heEZyYWdMb29rVXBUb2xlcmFuY2UpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoZnJhZ21lbnRzKSB8fCAhZnJhZ21lbnRzLmxlbmd0aCB8fCAhTnVtYmVyLmlzRmluaXRlKFBEVFZhbHVlKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLy8gaWYgbGVzcyB0aGFuIHN0YXJ0XG4gICAgaWYgKFBEVFZhbHVlIDwgZnJhZ21lbnRzWzBdLnByb2dyYW1EYXRlVGltZSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKFBEVFZhbHVlID49IGZyYWdtZW50c1tmcmFnbWVudHMubGVuZ3RoIC0gMV0uZW5kUHJvZ3JhbURhdGVUaW1lKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBtYXhGcmFnTG9va1VwVG9sZXJhbmNlID0gbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSB8fCAwO1xuICAgIGZvciAodmFyIHNlZyA9IDA7IHNlZyA8IGZyYWdtZW50cy5sZW5ndGg7ICsrc2VnKSB7XG4gICAgICAgIHZhciBmcmFnID0gZnJhZ21lbnRzW3NlZ107XG4gICAgICAgIGlmIChwZHRXaXRoaW5Ub2xlcmFuY2VUZXN0KFBEVFZhbHVlLCBtYXhGcmFnTG9va1VwVG9sZXJhbmNlLCBmcmFnKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZyYWc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5leHBvcnRzLmZpbmRGcmFnbWVudEJ5UERUID0gZmluZEZyYWdtZW50QnlQRFQ7XG4vKipcbiAqIEZpbmRzIGEgZnJhZ21lbnQgYmFzZWQgb24gdGhlIFNOIG9mIHRoZSBwcmV2aW91cyBmcmFnbWVudDsgb3IgYmFzZWQgb24gdGhlIG5lZWRzIG9mIHRoZSBjdXJyZW50IGJ1ZmZlci5cbiAqIFRoaXMgbWV0aG9kIGNvbXBlbnNhdGVzIGZvciBzbWFsbCBidWZmZXIgZ2FwcyBieSBhcHBseWluZyBhIHRvbGVyYW5jZSB0byB0aGUgc3RhcnQgb2YgYW55IGNhbmRpZGF0ZSBmcmFnbWVudCwgdGh1c1xuICogYnJlYWtpbmcgYW55IHRyYXBzIHdoaWNoIHdvdWxkIGNhdXNlIHRoZSBzYW1lIGZyYWdtZW50IHRvIGJlIGNvbnRpbnVvdXNseSBzZWxlY3RlZCB3aXRoaW4gYSBzbWFsbCByYW5nZS5cbiAqIEBwYXJhbSB7Kn0gZnJhZ1ByZXZpb3VzIC0gVGhlIGxhc3QgZnJhZyBzdWNjZXNzZnVsbHkgYXBwZW5kZWRcbiAqIEBwYXJhbSB7QXJyYXk8RnJhZ21lbnQ+fSBmcmFnbWVudHMgLSBUaGUgYXJyYXkgb2YgY2FuZGlkYXRlIGZyYWdtZW50c1xuICogQHBhcmFtIHtudW1iZXJ9IFtidWZmZXJFbmQgPSAwXSAtIFRoZSBlbmQgb2YgdGhlIGNvbnRpZ3VvdXMgYnVmZmVyZWQgcmFuZ2UgdGhlIHBsYXloZWFkIGlzIGN1cnJlbnRseSB3aXRoaW5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXhGcmFnTG9va1VwVG9sZXJhbmNlIC0gVGhlIGFtb3VudCBvZiB0aW1lIHRoYXQgYSBmcmFnbWVudCdzIHN0YXJ0L2VuZCBjYW4gYmUgd2l0aGluIGluIG9yZGVyIHRvIGJlIGNvbnNpZGVyZWQgY29udGlndW91c1xuICogQHJldHVybnMgeyp9IGZvdW5kRnJhZyAtIFRoZSBiZXN0IG1hdGNoaW5nIGZyYWdtZW50XG4gKi9cbmZ1bmN0aW9uIGZpbmRGcmFnbWVudEJ5UFRTKGZyYWdQcmV2aW91cywgZnJhZ21lbnRzLCBidWZmZXJFbmQsIG1heEZyYWdMb29rVXBUb2xlcmFuY2UpIHtcbiAgICBpZiAoYnVmZmVyRW5kID09PSB2b2lkIDApIHsgYnVmZmVyRW5kID0gMDsgfVxuICAgIGlmIChtYXhGcmFnTG9va1VwVG9sZXJhbmNlID09PSB2b2lkIDApIHsgbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSA9IDA7IH1cbiAgICB2YXIgZnJhZ05leHQgPSBmcmFnUHJldmlvdXMgPyBmcmFnbWVudHNbZnJhZ1ByZXZpb3VzLnNuIC0gZnJhZ21lbnRzWzBdLnNuICsgMV0gOiBudWxsO1xuICAgIC8vIFByZWZlciB0aGUgbmV4dCBmcmFnbWVudCBpZiBpdCdzIHdpdGhpbiB0b2xlcmFuY2VcbiAgICBpZiAoZnJhZ05leHQgJiYgIWZyYWdtZW50V2l0aGluVG9sZXJhbmNlVGVzdChidWZmZXJFbmQsIG1heEZyYWdMb29rVXBUb2xlcmFuY2UsIGZyYWdOZXh0KSkge1xuICAgICAgICByZXR1cm4gZnJhZ05leHQ7XG4gICAgfVxuICAgIHJldHVybiBiaW5hcnlfc2VhcmNoXzEuZGVmYXVsdC5zZWFyY2goZnJhZ21lbnRzLCBmcmFnbWVudFdpdGhpblRvbGVyYW5jZVRlc3QuYmluZChudWxsLCBidWZmZXJFbmQsIG1heEZyYWdMb29rVXBUb2xlcmFuY2UpKTtcbn1cbmV4cG9ydHMuZmluZEZyYWdtZW50QnlQVFMgPSBmaW5kRnJhZ21lbnRCeVBUUztcbi8qKlxuICogVGhlIHRlc3QgZnVuY3Rpb24gdXNlZCBieSB0aGUgZmluZEZyYWdtZW50QnlTbidzIEJpbmFyeVNlYXJjaCB0byBsb29rIGZvciB0aGUgYmVzdCBtYXRjaCB0byB0aGUgY3VycmVudCBidWZmZXIgY29uZGl0aW9ucy5cbiAqIEBwYXJhbSB7Kn0gY2FuZGlkYXRlIC0gVGhlIGZyYWdtZW50IHRvIHRlc3RcbiAqIEBwYXJhbSB7bnVtYmVyfSBbYnVmZmVyRW5kID0gMF0gLSBUaGUgZW5kIG9mIHRoZSBjdXJyZW50IGJ1ZmZlcmVkIHJhbmdlIHRoZSBwbGF5aGVhZCBpcyBjdXJyZW50bHkgd2l0aGluXG4gKiBAcGFyYW0ge251bWJlcn0gW21heEZyYWdMb29rVXBUb2xlcmFuY2UgPSAwXSAtIFRoZSBhbW91bnQgb2YgdGltZSB0aGF0IGEgZnJhZ21lbnQncyBzdGFydCBjYW4gYmUgd2l0aGluIGluIG9yZGVyIHRvIGJlIGNvbnNpZGVyZWQgY29udGlndW91c1xuICogQHJldHVybnMge251bWJlcn0gLSAwIGlmIGl0IG1hdGNoZXMsIDEgaWYgdG9vIGxvdywgLTEgaWYgdG9vIGhpZ2hcbiAqL1xuZnVuY3Rpb24gZnJhZ21lbnRXaXRoaW5Ub2xlcmFuY2VUZXN0KGJ1ZmZlckVuZCwgbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSwgY2FuZGlkYXRlKSB7XG4gICAgaWYgKGJ1ZmZlckVuZCA9PT0gdm9pZCAwKSB7IGJ1ZmZlckVuZCA9IDA7IH1cbiAgICBpZiAobWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSA9PT0gdm9pZCAwKSB7IG1heEZyYWdMb29rVXBUb2xlcmFuY2UgPSAwOyB9XG4gICAgLy8gb2Zmc2V0IHNob3VsZCBiZSB3aXRoaW4gZnJhZ21lbnQgYm91bmRhcnkgLSBjb25maWcubWF4RnJhZ0xvb2tVcFRvbGVyYW5jZVxuICAgIC8vIHRoaXMgaXMgdG8gY29wZSB3aXRoIHNpdHVhdGlvbnMgbGlrZVxuICAgIC8vIGJ1ZmZlckVuZCA9IDkuOTkxXG4gICAgLy8gZnJhZ1vDmF0gOiBbMCwxMF1cbiAgICAvLyBmcmFnWzFdIDogWzEwLDIwXVxuICAgIC8vIGJ1ZmZlckVuZCBpcyB3aXRoaW4gZnJhZ1swXSByYW5nZSAuLi4gYWx0aG91Z2ggd2hhdCB3ZSBhcmUgZXhwZWN0aW5nIGlzIHRvIHJldHVybiBmcmFnWzFdIGhlcmVcbiAgICAvLyAgICAgICAgICAgICAgZnJhZyBzdGFydCAgICAgICAgICAgICAgIGZyYWcgc3RhcnQrZHVyYXRpb25cbiAgICAvLyAgICAgICAgICAgICAgICAgIHwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXxcbiAgICAvLyAgICAgICAgICAgICAgPC0tLT4gICAgICAgICAgICAgICAgICAgICAgICAgPC0tLT5cbiAgICAvLyAgLi4uLS0tLS0tLS0+PC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tPjwtLS0tLS0tLS0uLi4uXG4gICAgLy8gcHJldmlvdXMgZnJhZyAgICAgICAgIG1hdGNoaW5nIGZyYWdtZW50ICAgICAgICAgbmV4dCBmcmFnXG4gICAgLy8gIHJldHVybiAtMSAgICAgICAgICAgICByZXR1cm4gMCAgICAgICAgICAgICAgICAgcmV0dXJuIDFcbiAgICAvLyBsb2dnZXIubG9nKGBsZXZlbC9zbi9zdGFydC9lbmQvYnVmRW5kOiR7bGV2ZWx9LyR7Y2FuZGlkYXRlLnNufS8ke2NhbmRpZGF0ZS5zdGFydH0vJHsoY2FuZGlkYXRlLnN0YXJ0K2NhbmRpZGF0ZS5kdXJhdGlvbil9LyR7YnVmZmVyRW5kfWApO1xuICAgIC8vIFNldCB0aGUgbG9va3VwIHRvbGVyYW5jZSB0byBiZSBzbWFsbCBlbm91Z2ggdG8gZGV0ZWN0IHRoZSBjdXJyZW50IHNlZ21lbnQgLSBlbnN1cmVzIHdlIGRvbid0IHNraXAgb3ZlciB2ZXJ5IHNtYWxsIHNlZ21lbnRzXG4gICAgdmFyIGNhbmRpZGF0ZUxvb2t1cFRvbGVyYW5jZSA9IE1hdGgubWluKG1heEZyYWdMb29rVXBUb2xlcmFuY2UsIGNhbmRpZGF0ZS5kdXJhdGlvbiArIChjYW5kaWRhdGUuZGVsdGFQVFMgPyBjYW5kaWRhdGUuZGVsdGFQVFMgOiAwKSk7XG4gICAgaWYgKGNhbmRpZGF0ZS5zdGFydCArIGNhbmRpZGF0ZS5kdXJhdGlvbiAtIGNhbmRpZGF0ZUxvb2t1cFRvbGVyYW5jZSA8PSBidWZmZXJFbmQpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIGVsc2UgaWYgKGNhbmRpZGF0ZS5zdGFydCAtIGNhbmRpZGF0ZUxvb2t1cFRvbGVyYW5jZSA+IGJ1ZmZlckVuZCAmJiBjYW5kaWRhdGUuc3RhcnQpIHtcbiAgICAgICAgLy8gaWYgbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSB3aWxsIGhhdmUgbmVnYXRpdmUgdmFsdWUgdGhlbiBkb24ndCByZXR1cm4gLTEgZm9yIGZpcnN0IGVsZW1lbnRcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbn1cbmV4cG9ydHMuZnJhZ21lbnRXaXRoaW5Ub2xlcmFuY2VUZXN0ID0gZnJhZ21lbnRXaXRoaW5Ub2xlcmFuY2VUZXN0O1xuLyoqXG4gKiBUaGUgdGVzdCBmdW5jdGlvbiB1c2VkIGJ5IHRoZSBmaW5kRnJhZ21lbnRCeVBkdCdzIEJpbmFyeVNlYXJjaCB0byBsb29rIGZvciB0aGUgYmVzdCBtYXRjaCB0byB0aGUgY3VycmVudCBidWZmZXIgY29uZGl0aW9ucy5cbiAqIFRoaXMgZnVuY3Rpb24gdGVzdHMgdGhlIGNhbmRpZGF0ZSdzIHByb2dyYW0gZGF0ZSB0aW1lIHZhbHVlcywgYXMgcmVwcmVzZW50ZWQgaW4gVW5peCB0aW1lXG4gKiBAcGFyYW0geyp9IGNhbmRpZGF0ZSAtIFRoZSBmcmFnbWVudCB0byB0ZXN0XG4gKiBAcGFyYW0ge251bWJlcn0gW3BkdEJ1ZmZlckVuZCA9IDBdIC0gVGhlIFVuaXggdGltZSByZXByZXNlbnRpbmcgdGhlIGVuZCBvZiB0aGUgY3VycmVudCBidWZmZXJlZCByYW5nZVxuICogQHBhcmFtIHtudW1iZXJ9IFttYXhGcmFnTG9va1VwVG9sZXJhbmNlID0gMF0gLSBUaGUgYW1vdW50IG9mIHRpbWUgdGhhdCBhIGZyYWdtZW50J3Mgc3RhcnQgY2FuIGJlIHdpdGhpbiBpbiBvcmRlciB0byBiZSBjb25zaWRlcmVkIGNvbnRpZ3VvdXNcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIGNvbnRpZ3VvdXMsIGZhbHNlIG90aGVyd2lzZVxuICovXG5mdW5jdGlvbiBwZHRXaXRoaW5Ub2xlcmFuY2VUZXN0KHBkdEJ1ZmZlckVuZCwgbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSwgY2FuZGlkYXRlKSB7XG4gICAgdmFyIGNhbmRpZGF0ZUxvb2t1cFRvbGVyYW5jZSA9IE1hdGgubWluKG1heEZyYWdMb29rVXBUb2xlcmFuY2UsIGNhbmRpZGF0ZS5kdXJhdGlvbiArIChjYW5kaWRhdGUuZGVsdGFQVFMgPyBjYW5kaWRhdGUuZGVsdGFQVFMgOiAwKSkgKiAxMDAwO1xuICAgIHJldHVybiBjYW5kaWRhdGUuZW5kUHJvZ3JhbURhdGVUaW1lIC0gY2FuZGlkYXRlTG9va3VwVG9sZXJhbmNlID4gcGR0QnVmZmVyRW5kO1xufVxuZXhwb3J0cy5wZHRXaXRoaW5Ub2xlcmFuY2VUZXN0ID0gcGR0V2l0aGluVG9sZXJhbmNlVGVzdDtcblxuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovfS5jYWxsKHRoaXMsIF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vc3JjL3BvbHlmaWxscy9udW1iZXIgKi8gXCIuL3NyYy9wb2x5ZmlsbHMvbnVtYmVyLmpzXCIpW1wiTnVtYmVyXCJdKSlcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvY29udHJvbGxlci9mcmFnbWVudC10cmFja2VyLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9jb250cm9sbGVyL2ZyYWdtZW50LXRyYWNrZXIuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovKGZ1bmN0aW9uKE51bWJlcikge1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZXZlbnRfaGFuZGxlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZXZlbnQtaGFuZGxlciAqLyBcIi4vc3JjL2V2ZW50LWhhbmRsZXIuanNcIik7XG52YXIgZXZlbnRzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9ldmVudHMgKi8gXCIuL3NyYy9ldmVudHMuanNcIik7XG5leHBvcnRzLkZyYWdtZW50U3RhdGUgPSB7XG4gICAgTk9UX0xPQURFRDogJ05PVF9MT0FERUQnLFxuICAgIEFQUEVORElORzogJ0FQUEVORElORycsXG4gICAgUEFSVElBTDogJ1BBUlRJQUwnLFxuICAgIE9LOiAnT0snXG59O1xudmFyIEZyYWdtZW50VHJhY2tlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRnJhZ21lbnRUcmFja2VyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEZyYWdtZW50VHJhY2tlcihobHMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgaGxzLCBldmVudHNfMS5kZWZhdWx0LkJVRkZFUl9BUFBFTkRFRCwgZXZlbnRzXzEuZGVmYXVsdC5GUkFHX0JVRkZFUkVELCBldmVudHNfMS5kZWZhdWx0LkZSQUdfTE9BREVEKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5idWZmZXJQYWRkaW5nID0gMC4yO1xuICAgICAgICBfdGhpcy5mcmFnbWVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBfdGhpcy50aW1lUmFuZ2VzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgX3RoaXMuY29uZmlnID0gaGxzLmNvbmZpZztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBGcmFnbWVudFRyYWNrZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZnJhZ21lbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgdGhpcy50aW1lUmFuZ2VzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgdGhpcy5jb25maWcgPSBudWxsO1xuICAgICAgICBldmVudF9oYW5kbGVyXzEuZGVmYXVsdC5wcm90b3R5cGUuZGVzdHJveS5jYWxsKHRoaXMpO1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLmRlc3Ryb3kuY2FsbCh0aGlzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybiBhIEZyYWdtZW50IHRoYXQgbWF0Y2ggdGhlIHBvc2l0aW9uIGFuZCBsZXZlbFR5cGUuXG4gICAgICogSWYgbm90IGZvdW5kIGFueSBGcmFnbWVudCwgcmV0dXJuIG51bGxcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcG9zaXRpb25cbiAgICAgKiBAcGFyYW0ge0xldmVsVHlwZX0gbGV2ZWxUeXBlXG4gICAgICogQHJldHVybnMge0ZyYWdtZW50fG51bGx9XG4gICAgICovXG4gICAgRnJhZ21lbnRUcmFja2VyLnByb3RvdHlwZS5nZXRCdWZmZXJlZEZyYWcgPSBmdW5jdGlvbiAocG9zaXRpb24sIGxldmVsVHlwZSkge1xuICAgICAgICB2YXIgZnJhZ21lbnRzID0gdGhpcy5mcmFnbWVudHM7XG4gICAgICAgIHZhciBidWZmZXJlZEZyYWdzID0gT2JqZWN0LmtleXMoZnJhZ21lbnRzKS5maWx0ZXIoZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgdmFyIGZyYWdtZW50RW50aXR5ID0gZnJhZ21lbnRzW2tleV07XG4gICAgICAgICAgICBpZiAoZnJhZ21lbnRFbnRpdHkuYm9keS50eXBlICE9PSBsZXZlbFR5cGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWZyYWdtZW50RW50aXR5LmJ1ZmZlcmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGZyYWcgPSBmcmFnbWVudEVudGl0eS5ib2R5O1xuICAgICAgICAgICAgcmV0dXJuIGZyYWcuc3RhcnRQVFMgPD0gcG9zaXRpb24gJiYgcG9zaXRpb24gPD0gZnJhZy5lbmRQVFM7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoYnVmZmVyZWRGcmFncy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3ZpZGVvLWRldi9obHMuanMvcHVsbC8xNTQ1I2Rpc2N1c3Npb25fcjE2NjIyOTU2NlxuICAgICAgICAgICAgdmFyIGJ1ZmZlcmVkRnJhZ0tleSA9IGJ1ZmZlcmVkRnJhZ3MucG9wKCk7XG4gICAgICAgICAgICByZXR1cm4gZnJhZ21lbnRzW2J1ZmZlcmVkRnJhZ0tleV0uYm9keTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogUGFydGlhbCBmcmFnbWVudHMgZWZmZWN0ZWQgYnkgY29kZWQgZnJhbWUgZXZpY3Rpb24gd2lsbCBiZSByZW1vdmVkXG4gICAgICogVGhlIGJyb3dzZXIgd2lsbCB1bmxvYWQgcGFydHMgb2YgdGhlIGJ1ZmZlciB0byBmcmVlIHVwIG1lbW9yeSBmb3IgbmV3IGJ1ZmZlciBkYXRhXG4gICAgICogRnJhZ21lbnRzIHdpbGwgbmVlZCB0byBiZSByZWxvYWRlZCB3aGVuIHRoZSBidWZmZXIgaXMgZnJlZWQgdXAsIHJlbW92aW5nIHBhcnRpYWwgZnJhZ21lbnRzIHdpbGwgYWxsb3cgdGhlbSB0byByZWxvYWQoc2luY2UgdGhlcmUgbWlnaHQgYmUgcGFydHMgdGhhdCBhcmUgc3RpbGwgcGxheWFibGUpXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGVsZW1lbnRhcnlTdHJlYW0gVGhlIGVsZW1lbnRhcnlTdHJlYW0gb2YgbWVkaWEgdGhpcyBpcyAoZWcuIHZpZGVvL2F1ZGlvKVxuICAgICAqIEBwYXJhbSB7VGltZVJhbmdlc30gdGltZVJhbmdlIFRpbWVSYW5nZSBvYmplY3QgZnJvbSBhIHNvdXJjZUJ1ZmZlclxuICAgICAqL1xuICAgIEZyYWdtZW50VHJhY2tlci5wcm90b3R5cGUuZGV0ZWN0RXZpY3RlZEZyYWdtZW50cyA9IGZ1bmN0aW9uIChlbGVtZW50YXJ5U3RyZWFtLCB0aW1lUmFuZ2UpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGZyYWdtZW50VGltZXMsIHRpbWU7XG4gICAgICAgIC8vIENoZWNrIGlmIGFueSBmbGFnZ2VkIGZyYWdtZW50cyBoYXZlIGJlZW4gdW5sb2FkZWRcbiAgICAgICAgT2JqZWN0LmtleXModGhpcy5mcmFnbWVudHMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgdmFyIGZyYWdtZW50RW50aXR5ID0gX3RoaXMuZnJhZ21lbnRzW2tleV07XG4gICAgICAgICAgICBpZiAoZnJhZ21lbnRFbnRpdHkuYnVmZmVyZWQgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgZXNEYXRhID0gZnJhZ21lbnRFbnRpdHkucmFuZ2VbZWxlbWVudGFyeVN0cmVhbV07XG4gICAgICAgICAgICAgICAgaWYgKGVzRGF0YSkge1xuICAgICAgICAgICAgICAgICAgICBmcmFnbWVudFRpbWVzID0gZXNEYXRhLnRpbWU7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZnJhZ21lbnRUaW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGltZSA9IGZyYWdtZW50VGltZXNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuaXNUaW1lQnVmZmVyZWQodGltZS5zdGFydFBUUywgdGltZS5lbmRQVFMsIHRpbWVSYW5nZSkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVW5yZWdpc3RlciBwYXJ0aWFsIGZyYWdtZW50IGFzIGl0IG5lZWRzIHRvIGxvYWQgYWdhaW4gdG8gYmUgcmV1c2VkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMucmVtb3ZlRnJhZ21lbnQoZnJhZ21lbnRFbnRpdHkuYm9keSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHRoZSBmcmFnbWVudCBwYXNzZWQgaW4gaXMgbG9hZGVkIGluIHRoZSBidWZmZXIgcHJvcGVybHlcbiAgICAgKiBQYXJ0aWFsbHkgbG9hZGVkIGZyYWdtZW50cyB3aWxsIGJlIHJlZ2lzdGVyZWQgYXMgYSBwYXJ0aWFsIGZyYWdtZW50XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGZyYWdtZW50IENoZWNrIHRoZSBmcmFnbWVudCBhZ2FpbnN0IGFsbCBzb3VyY2VCdWZmZXJzIGxvYWRlZFxuICAgICAqL1xuICAgIEZyYWdtZW50VHJhY2tlci5wcm90b3R5cGUuZGV0ZWN0UGFydGlhbEZyYWdtZW50cyA9IGZ1bmN0aW9uIChmcmFnbWVudCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgZnJhZ0tleSA9IHRoaXMuZ2V0RnJhZ21lbnRLZXkoZnJhZ21lbnQpO1xuICAgICAgICB2YXIgZnJhZ21lbnRFbnRpdHkgPSB0aGlzLmZyYWdtZW50c1tmcmFnS2V5XTtcbiAgICAgICAgaWYgKGZyYWdtZW50RW50aXR5KSB7XG4gICAgICAgICAgICBmcmFnbWVudEVudGl0eS5idWZmZXJlZCA9IHRydWU7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyh0aGlzLnRpbWVSYW5nZXMpLmZvckVhY2goZnVuY3Rpb24gKGVsZW1lbnRhcnlTdHJlYW0pIHtcbiAgICAgICAgICAgICAgICBpZiAoZnJhZ21lbnQuaGFzRWxlbWVudGFyeVN0cmVhbShlbGVtZW50YXJ5U3RyZWFtKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGltZVJhbmdlID0gX3RoaXMudGltZVJhbmdlc1tlbGVtZW50YXJ5U3RyZWFtXTtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIG1hbGZvcm1lZCBmcmFnbWVudHNcbiAgICAgICAgICAgICAgICAgICAgLy8gR2FwcyBuZWVkIHRvIGJlIGNhbGN1bGF0ZWQgZm9yIGVhY2ggZWxlbWVudGFyeVN0cmVhbVxuICAgICAgICAgICAgICAgICAgICBmcmFnbWVudEVudGl0eS5yYW5nZVtlbGVtZW50YXJ5U3RyZWFtXSA9IF90aGlzLmdldEJ1ZmZlcmVkVGltZXMoZnJhZ21lbnQuc3RhcnRQVFMsIGZyYWdtZW50LmVuZFBUUywgdGltZVJhbmdlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRnJhZ21lbnRUcmFja2VyLnByb3RvdHlwZS5nZXRCdWZmZXJlZFRpbWVzID0gZnVuY3Rpb24gKHN0YXJ0UFRTLCBlbmRQVFMsIHRpbWVSYW5nZSkge1xuICAgICAgICB2YXIgZnJhZ21lbnRUaW1lcyA9IFtdO1xuICAgICAgICB2YXIgc3RhcnRUaW1lLCBlbmRUaW1lO1xuICAgICAgICB2YXIgZnJhZ21lbnRQYXJ0aWFsID0gZmFsc2U7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGltZVJhbmdlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBzdGFydFRpbWUgPSB0aW1lUmFuZ2Uuc3RhcnQoaSkgLSB0aGlzLmJ1ZmZlclBhZGRpbmc7XG4gICAgICAgICAgICBlbmRUaW1lID0gdGltZVJhbmdlLmVuZChpKSArIHRoaXMuYnVmZmVyUGFkZGluZztcbiAgICAgICAgICAgIGlmIChzdGFydFBUUyA+PSBzdGFydFRpbWUgJiYgZW5kUFRTIDw9IGVuZFRpbWUpIHtcbiAgICAgICAgICAgICAgICAvLyBGcmFnbWVudCBpcyBlbnRpcmVseSBjb250YWluZWQgaW4gYnVmZmVyXG4gICAgICAgICAgICAgICAgLy8gTm8gbmVlZCB0byBjaGVjayB0aGUgb3RoZXIgdGltZVJhbmdlIHRpbWVzIHNpbmNlIGl0J3MgY29tcGxldGVseSBwbGF5YWJsZVxuICAgICAgICAgICAgICAgIGZyYWdtZW50VGltZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0UFRTOiBNYXRoLm1heChzdGFydFBUUywgdGltZVJhbmdlLnN0YXJ0KGkpKSxcbiAgICAgICAgICAgICAgICAgICAgZW5kUFRTOiBNYXRoLm1pbihlbmRQVFMsIHRpbWVSYW5nZS5lbmQoaSkpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzdGFydFBUUyA8IGVuZFRpbWUgJiYgZW5kUFRTID4gc3RhcnRUaW1lKSB7XG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIGludGVyc2VjdGlvbiB3aXRoIGJ1ZmZlclxuICAgICAgICAgICAgICAgIC8vIEdldCBwbGF5YWJsZSBzZWN0aW9ucyBvZiB0aGUgZnJhZ21lbnRcbiAgICAgICAgICAgICAgICBmcmFnbWVudFRpbWVzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBzdGFydFBUUzogTWF0aC5tYXgoc3RhcnRQVFMsIHRpbWVSYW5nZS5zdGFydChpKSksXG4gICAgICAgICAgICAgICAgICAgIGVuZFBUUzogTWF0aC5taW4oZW5kUFRTLCB0aW1lUmFuZ2UuZW5kKGkpKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGZyYWdtZW50UGFydGlhbCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChlbmRQVFMgPD0gc3RhcnRUaW1lKSB7XG4gICAgICAgICAgICAgICAgLy8gTm8gbmVlZCB0byBjaGVjayB0aGUgcmVzdCBvZiB0aGUgdGltZVJhbmdlIGFzIGl0IGlzIGluIG9yZGVyXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRpbWU6IGZyYWdtZW50VGltZXMsXG4gICAgICAgICAgICBwYXJ0aWFsOiBmcmFnbWVudFBhcnRpYWxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIEZyYWdtZW50VHJhY2tlci5wcm90b3R5cGUuZ2V0RnJhZ21lbnRLZXkgPSBmdW5jdGlvbiAoZnJhZ21lbnQpIHtcbiAgICAgICAgcmV0dXJuIGZyYWdtZW50LnR5cGUgKyBcIl9cIiArIGZyYWdtZW50LmxldmVsICsgXCJfXCIgKyBmcmFnbWVudC51cmxJZCArIFwiX1wiICsgZnJhZ21lbnQuc247XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBwYXJ0aWFsIGZyYWdtZW50IGZvciBhIGNlcnRhaW4gdGltZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB0aW1lXG4gICAgICogQHJldHVybnMge09iamVjdH0gZnJhZ21lbnQgUmV0dXJucyBhIHBhcnRpYWwgZnJhZ21lbnQgYXQgYSB0aW1lIG9yIG51bGwgaWYgdGhlcmUgaXMgbm8gcGFydGlhbCBmcmFnbWVudFxuICAgICAqL1xuICAgIEZyYWdtZW50VHJhY2tlci5wcm90b3R5cGUuZ2V0UGFydGlhbEZyYWdtZW50ID0gZnVuY3Rpb24gKHRpbWUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHRpbWVQYWRkaW5nLCBzdGFydFRpbWUsIGVuZFRpbWU7XG4gICAgICAgIHZhciBiZXN0RnJhZ21lbnQgPSBudWxsO1xuICAgICAgICB2YXIgYmVzdE92ZXJsYXAgPSAwO1xuICAgICAgICBPYmplY3Qua2V5cyh0aGlzLmZyYWdtZW50cykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICB2YXIgZnJhZ21lbnRFbnRpdHkgPSBfdGhpcy5mcmFnbWVudHNba2V5XTtcbiAgICAgICAgICAgIGlmIChfdGhpcy5pc1BhcnRpYWwoZnJhZ21lbnRFbnRpdHkpKSB7XG4gICAgICAgICAgICAgICAgc3RhcnRUaW1lID0gZnJhZ21lbnRFbnRpdHkuYm9keS5zdGFydFBUUyAtIF90aGlzLmJ1ZmZlclBhZGRpbmc7XG4gICAgICAgICAgICAgICAgZW5kVGltZSA9IGZyYWdtZW50RW50aXR5LmJvZHkuZW5kUFRTICsgX3RoaXMuYnVmZmVyUGFkZGluZztcbiAgICAgICAgICAgICAgICBpZiAodGltZSA+PSBzdGFydFRpbWUgJiYgdGltZSA8PSBlbmRUaW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFVzZSB0aGUgZnJhZ21lbnQgdGhhdCBoYXMgdGhlIG1vc3QgcGFkZGluZyBmcm9tIHN0YXJ0IGFuZCBlbmQgdGltZVxuICAgICAgICAgICAgICAgICAgICB0aW1lUGFkZGluZyA9IE1hdGgubWluKHRpbWUgLSBzdGFydFRpbWUsIGVuZFRpbWUgLSB0aW1lKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJlc3RPdmVybGFwIDw9IHRpbWVQYWRkaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBiZXN0RnJhZ21lbnQgPSBmcmFnbWVudEVudGl0eS5ib2R5O1xuICAgICAgICAgICAgICAgICAgICAgICAgYmVzdE92ZXJsYXAgPSB0aW1lUGFkZGluZztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBiZXN0RnJhZ21lbnQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZnJhZ21lbnQgVGhlIGZyYWdtZW50IHRvIGNoZWNrXG4gICAgICogQHJldHVybnMge1N0cmluZ30gUmV0dXJucyB0aGUgZnJhZ21lbnQgc3RhdGUgd2hlbiBhIGZyYWdtZW50IG5ldmVyIGxvYWRlZCBvciBpZiBpdCBwYXJ0aWFsbHkgbG9hZGVkXG4gICAgICovXG4gICAgRnJhZ21lbnRUcmFja2VyLnByb3RvdHlwZS5nZXRTdGF0ZSA9IGZ1bmN0aW9uIChmcmFnbWVudCkge1xuICAgICAgICB2YXIgZnJhZ0tleSA9IHRoaXMuZ2V0RnJhZ21lbnRLZXkoZnJhZ21lbnQpO1xuICAgICAgICB2YXIgZnJhZ21lbnRFbnRpdHkgPSB0aGlzLmZyYWdtZW50c1tmcmFnS2V5XTtcbiAgICAgICAgdmFyIHN0YXRlID0gZXhwb3J0cy5GcmFnbWVudFN0YXRlLk5PVF9MT0FERUQ7XG4gICAgICAgIGlmIChmcmFnbWVudEVudGl0eSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAoIWZyYWdtZW50RW50aXR5LmJ1ZmZlcmVkKSB7XG4gICAgICAgICAgICAgICAgc3RhdGUgPSBleHBvcnRzLkZyYWdtZW50U3RhdGUuQVBQRU5ESU5HO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5pc1BhcnRpYWwoZnJhZ21lbnRFbnRpdHkpID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgc3RhdGUgPSBleHBvcnRzLkZyYWdtZW50U3RhdGUuUEFSVElBTDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0YXRlID0gZXhwb3J0cy5GcmFnbWVudFN0YXRlLk9LO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9O1xuICAgIEZyYWdtZW50VHJhY2tlci5wcm90b3R5cGUuaXNQYXJ0aWFsID0gZnVuY3Rpb24gKGZyYWdtZW50RW50aXR5KSB7XG4gICAgICAgIHJldHVybiBmcmFnbWVudEVudGl0eS5idWZmZXJlZCA9PT0gdHJ1ZSAmJlxuICAgICAgICAgICAgKChmcmFnbWVudEVudGl0eS5yYW5nZS52aWRlbyAhPT0gdW5kZWZpbmVkICYmIGZyYWdtZW50RW50aXR5LnJhbmdlLnZpZGVvLnBhcnRpYWwgPT09IHRydWUpIHx8XG4gICAgICAgICAgICAgICAgKGZyYWdtZW50RW50aXR5LnJhbmdlLmF1ZGlvICE9PSB1bmRlZmluZWQgJiYgZnJhZ21lbnRFbnRpdHkucmFuZ2UuYXVkaW8ucGFydGlhbCA9PT0gdHJ1ZSkpO1xuICAgIH07XG4gICAgRnJhZ21lbnRUcmFja2VyLnByb3RvdHlwZS5pc1RpbWVCdWZmZXJlZCA9IGZ1bmN0aW9uIChzdGFydFBUUywgZW5kUFRTLCB0aW1lUmFuZ2UpIHtcbiAgICAgICAgdmFyIHN0YXJ0VGltZSwgZW5kVGltZTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aW1lUmFuZ2UubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHN0YXJ0VGltZSA9IHRpbWVSYW5nZS5zdGFydChpKSAtIHRoaXMuYnVmZmVyUGFkZGluZztcbiAgICAgICAgICAgIGVuZFRpbWUgPSB0aW1lUmFuZ2UuZW5kKGkpICsgdGhpcy5idWZmZXJQYWRkaW5nO1xuICAgICAgICAgICAgaWYgKHN0YXJ0UFRTID49IHN0YXJ0VGltZSAmJiBlbmRQVFMgPD0gZW5kVGltZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVuZFBUUyA8PSBzdGFydFRpbWUpIHtcbiAgICAgICAgICAgICAgICAvLyBObyBuZWVkIHRvIGNoZWNrIHRoZSByZXN0IG9mIHRoZSB0aW1lUmFuZ2UgYXMgaXQgaXMgaW4gb3JkZXJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRmlyZXMgd2hlbiBhIGZyYWdtZW50IGxvYWRpbmcgaXMgY29tcGxldGVkXG4gICAgICovXG4gICAgRnJhZ21lbnRUcmFja2VyLnByb3RvdHlwZS5vbkZyYWdMb2FkZWQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgZnJhZ21lbnQgPSBlLmZyYWc7XG4gICAgICAgIC8vIGRvbid0IHRyYWNrIGluaXRzZWdtZW50IChmb3Igd2hpY2ggc24gaXMgbm90IGEgbnVtYmVyKVxuICAgICAgICAvLyBkb24ndCB0cmFjayBmcmFncyB1c2VkIGZvciBiaXRyYXRlVGVzdCwgdGhleSdyZSBpcnJlbGV2YW50LlxuICAgICAgICBpZiAoIU51bWJlci5pc0Zpbml0ZShmcmFnbWVudC5zbikgfHwgZnJhZ21lbnQuYml0cmF0ZVRlc3QpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZyYWdtZW50c1t0aGlzLmdldEZyYWdtZW50S2V5KGZyYWdtZW50KV0gPSB7XG4gICAgICAgICAgICBib2R5OiBmcmFnbWVudCxcbiAgICAgICAgICAgIHJhbmdlOiBPYmplY3QuY3JlYXRlKG51bGwpLFxuICAgICAgICAgICAgYnVmZmVyZWQ6IGZhbHNlXG4gICAgICAgIH07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBGaXJlcyB3aGVuIHRoZSBidWZmZXIgaXMgdXBkYXRlZFxuICAgICAqL1xuICAgIEZyYWdtZW50VHJhY2tlci5wcm90b3R5cGUub25CdWZmZXJBcHBlbmRlZCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIC8vIFN0b3JlIHRoZSBsYXRlc3QgdGltZVJhbmdlcyBsb2FkZWQgaW4gdGhlIGJ1ZmZlclxuICAgICAgICB0aGlzLnRpbWVSYW5nZXMgPSBlLnRpbWVSYW5nZXM7XG4gICAgICAgIE9iamVjdC5rZXlzKHRoaXMudGltZVJhbmdlcykuZm9yRWFjaChmdW5jdGlvbiAoZWxlbWVudGFyeVN0cmVhbSkge1xuICAgICAgICAgICAgdmFyIHRpbWVSYW5nZSA9IF90aGlzLnRpbWVSYW5nZXNbZWxlbWVudGFyeVN0cmVhbV07XG4gICAgICAgICAgICBfdGhpcy5kZXRlY3RFdmljdGVkRnJhZ21lbnRzKGVsZW1lbnRhcnlTdHJlYW0sIHRpbWVSYW5nZSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRmlyZXMgYWZ0ZXIgYSBmcmFnbWVudCBoYXMgYmVlbiBsb2FkZWQgaW50byB0aGUgc291cmNlIGJ1ZmZlclxuICAgICAqL1xuICAgIEZyYWdtZW50VHJhY2tlci5wcm90b3R5cGUub25GcmFnQnVmZmVyZWQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB0aGlzLmRldGVjdFBhcnRpYWxGcmFnbWVudHMoZS5mcmFnKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybiB0cnVlIGlmIGZyYWdtZW50IHRyYWNrZXIgaGFzIHRoZSBmcmFnbWVudC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZnJhZ21lbnRcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBGcmFnbWVudFRyYWNrZXIucHJvdG90eXBlLmhhc0ZyYWdtZW50ID0gZnVuY3Rpb24gKGZyYWdtZW50KSB7XG4gICAgICAgIHZhciBmcmFnS2V5ID0gdGhpcy5nZXRGcmFnbWVudEtleShmcmFnbWVudCk7XG4gICAgICAgIHJldHVybiB0aGlzLmZyYWdtZW50c1tmcmFnS2V5XSAhPT0gdW5kZWZpbmVkO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGEgZnJhZ21lbnQgZnJvbSBmcmFnbWVudCB0cmFja2VyIHVudGlsIGl0IGlzIGxvYWRlZCBhZ2FpblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBmcmFnbWVudCBUaGUgZnJhZ21lbnQgdG8gcmVtb3ZlXG4gICAgICovXG4gICAgRnJhZ21lbnRUcmFja2VyLnByb3RvdHlwZS5yZW1vdmVGcmFnbWVudCA9IGZ1bmN0aW9uIChmcmFnbWVudCkge1xuICAgICAgICB2YXIgZnJhZ0tleSA9IHRoaXMuZ2V0RnJhZ21lbnRLZXkoZnJhZ21lbnQpO1xuICAgICAgICBkZWxldGUgdGhpcy5mcmFnbWVudHNbZnJhZ0tleV07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYWxsIGZyYWdtZW50cyBmcm9tIGZyYWdtZW50IHRyYWNrZXIuXG4gICAgICovXG4gICAgRnJhZ21lbnRUcmFja2VyLnByb3RvdHlwZS5yZW1vdmVBbGxGcmFnbWVudHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZnJhZ21lbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB9O1xuICAgIHJldHVybiBGcmFnbWVudFRyYWNrZXI7XG59KGV2ZW50X2hhbmRsZXJfMS5kZWZhdWx0KSk7XG5leHBvcnRzLkZyYWdtZW50VHJhY2tlciA9IEZyYWdtZW50VHJhY2tlcjtcblxuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovfS5jYWxsKHRoaXMsIF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vc3JjL3BvbHlmaWxscy9udW1iZXIgKi8gXCIuL3NyYy9wb2x5ZmlsbHMvbnVtYmVyLmpzXCIpW1wiTnVtYmVyXCJdKSlcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvY29udHJvbGxlci9nYXAtY29udHJvbGxlci5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2NvbnRyb2xsZXIvZ2FwLWNvbnRyb2xsZXIuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGJ1ZmZlcl9oZWxwZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL2J1ZmZlci1oZWxwZXIgKi8gXCIuL3NyYy91dGlscy9idWZmZXItaGVscGVyLmpzXCIpO1xudmFyIGVycm9yc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZXJyb3JzICovIFwiLi9zcmMvZXJyb3JzLmpzXCIpO1xudmFyIGV2ZW50c18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZXZlbnRzICovIFwiLi9zcmMvZXZlbnRzLmpzXCIpO1xudmFyIGxvZ2dlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvbG9nZ2VyICovIFwiLi9zcmMvdXRpbHMvbG9nZ2VyLmpzXCIpO1xudmFyIHN0YWxsRGVib3VuY2VJbnRlcnZhbCA9IDEwMDA7XG52YXIganVtcFRocmVzaG9sZCA9IDAuNTsgLy8gdG9sZXJhbmNlIG5lZWRlZCBhcyBzb21lIGJyb3dzZXJzIHN0YWxscyBwbGF5YmFjayBiZWZvcmUgcmVhY2hpbmcgYnVmZmVyZWQgcmFuZ2UgZW5kXG52YXIgR2FwQ29udHJvbGxlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBHYXBDb250cm9sbGVyKGNvbmZpZywgbWVkaWEsIGZyYWdtZW50VHJhY2tlciwgaGxzKSB7XG4gICAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgICAgICB0aGlzLm1lZGlhID0gbWVkaWE7XG4gICAgICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyID0gZnJhZ21lbnRUcmFja2VyO1xuICAgICAgICB0aGlzLmhscyA9IGhscztcbiAgICAgICAgdGhpcy5zdGFsbFJlcG9ydGVkID0gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGUgcGxheWhlYWQgaXMgc3R1Y2sgd2l0aGluIGEgZ2FwLCBhbmQgaWYgc28sIGF0dGVtcHRzIHRvIGZyZWUgaXQuXG4gICAgICogQSBnYXAgaXMgYW4gdW5idWZmZXJlZCByYW5nZSBiZXR3ZWVuIHR3byBidWZmZXJlZCByYW5nZXMgKG9yIHRoZSBzdGFydCBhbmQgdGhlIGZpcnN0IGJ1ZmZlcmVkIHJhbmdlKS5cbiAgICAgKiBAcGFyYW0gbGFzdEN1cnJlbnRUaW1lXG4gICAgICogQHBhcmFtIGJ1ZmZlcmVkXG4gICAgICovXG4gICAgR2FwQ29udHJvbGxlci5wcm90b3R5cGUucG9sbCA9IGZ1bmN0aW9uIChsYXN0Q3VycmVudFRpbWUsIGJ1ZmZlcmVkKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIGNvbmZpZyA9IF9hLmNvbmZpZywgbWVkaWEgPSBfYS5tZWRpYTtcbiAgICAgICAgdmFyIGN1cnJlbnRUaW1lID0gbWVkaWEuY3VycmVudFRpbWU7XG4gICAgICAgIHZhciB0bm93ID0gd2luZG93LnBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICBpZiAoY3VycmVudFRpbWUgIT09IGxhc3RDdXJyZW50VGltZSkge1xuICAgICAgICAgICAgLy8gVGhlIHBsYXloZWFkIGlzIG5vdyBtb3ZpbmcsIGJ1dCB3YXMgcHJldmlvdXNseSBzdGFsbGVkXG4gICAgICAgICAgICBpZiAodGhpcy5zdGFsbFJlcG9ydGVkKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLndhcm4oXCJwbGF5YmFjayBub3Qgc3R1Y2sgYW55bW9yZSBAXCIgKyBjdXJyZW50VGltZSArIFwiLCBhZnRlciBcIiArIE1hdGgucm91bmQodG5vdyAtIHRoaXMuc3RhbGxlZCkgKyBcIm1zXCIpO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhbGxSZXBvcnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zdGFsbGVkID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMubnVkZ2VSZXRyeSA9IDA7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lZGlhLmVuZGVkIHx8ICFtZWRpYS5idWZmZXJlZC5sZW5ndGggfHwgbWVkaWEucmVhZHlTdGF0ZSA+IDIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVkaWEuc2Vla2luZyAmJiBidWZmZXJfaGVscGVyXzEuQnVmZmVySGVscGVyLmlzQnVmZmVyZWQobWVkaWEsIGN1cnJlbnRUaW1lKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRoZSBwbGF5aGVhZCBpc24ndCBtb3ZpbmcgYnV0IGl0IHNob3VsZCBiZVxuICAgICAgICAvLyBBbGxvdyBzb21lIHNsYWNrIHRpbWUgdG8gZm9yIHNtYWxsIHN0YWxscyB0byByZXNvbHZlIHRoZW1zZWx2ZXNcbiAgICAgICAgdmFyIHN0YWxsZWREdXJhdGlvbiA9IHRub3cgLSB0aGlzLnN0YWxsZWQ7XG4gICAgICAgIHZhciBidWZmZXJJbmZvID0gYnVmZmVyX2hlbHBlcl8xLkJ1ZmZlckhlbHBlci5idWZmZXJJbmZvKG1lZGlhLCBjdXJyZW50VGltZSwgY29uZmlnLm1heEJ1ZmZlckhvbGUpO1xuICAgICAgICBpZiAoIXRoaXMuc3RhbGxlZCkge1xuICAgICAgICAgICAgdGhpcy5zdGFsbGVkID0gdG5vdztcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzdGFsbGVkRHVyYXRpb24gPj0gc3RhbGxEZWJvdW5jZUludGVydmFsKSB7XG4gICAgICAgICAgICAvLyBSZXBvcnQgc3RhbGxpbmcgYWZ0ZXIgdHJ5aW5nIHRvIGZpeFxuICAgICAgICAgICAgdGhpcy5fcmVwb3J0U3RhbGwoYnVmZmVySW5mby5sZW4pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3RyeUZpeEJ1ZmZlclN0YWxsKGJ1ZmZlckluZm8sIHN0YWxsZWREdXJhdGlvbik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBEZXRlY3RzIGFuZCBhdHRlbXB0cyB0byBmaXgga25vd24gYnVmZmVyIHN0YWxsaW5nIGlzc3Vlcy5cbiAgICAgKiBAcGFyYW0gYnVmZmVySW5mbyAtIFRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBjdXJyZW50IGJ1ZmZlci5cbiAgICAgKiBAcGFyYW0gc3RhbGxlZER1cmF0aW9uIC0gVGhlIGFtb3VudCBvZiB0aW1lIEhscy5qcyBoYXMgYmVlbiBzdGFsbGluZyBmb3IuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBHYXBDb250cm9sbGVyLnByb3RvdHlwZS5fdHJ5Rml4QnVmZmVyU3RhbGwgPSBmdW5jdGlvbiAoYnVmZmVySW5mbywgc3RhbGxlZER1cmF0aW9uKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIGNvbmZpZyA9IF9hLmNvbmZpZywgZnJhZ21lbnRUcmFja2VyID0gX2EuZnJhZ21lbnRUcmFja2VyLCBtZWRpYSA9IF9hLm1lZGlhO1xuICAgICAgICB2YXIgY3VycmVudFRpbWUgPSBtZWRpYS5jdXJyZW50VGltZTtcbiAgICAgICAgdmFyIHBhcnRpYWwgPSBmcmFnbWVudFRyYWNrZXIuZ2V0UGFydGlhbEZyYWdtZW50KGN1cnJlbnRUaW1lKTtcbiAgICAgICAgaWYgKHBhcnRpYWwpIHtcbiAgICAgICAgICAgIC8vIFRyeSB0byBza2lwIG92ZXIgdGhlIGJ1ZmZlciBob2xlIGNhdXNlZCBieSBhIHBhcnRpYWwgZnJhZ21lbnRcbiAgICAgICAgICAgIC8vIFRoaXMgbWV0aG9kIGlzbid0IGxpbWl0ZWQgYnkgdGhlIHNpemUgb2YgdGhlIGdhcCBiZXR3ZWVuIGJ1ZmZlcmVkIHJhbmdlc1xuICAgICAgICAgICAgdGhpcy5fdHJ5U2tpcEJ1ZmZlckhvbGUocGFydGlhbCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJ1ZmZlckluZm8ubGVuID4ganVtcFRocmVzaG9sZCAmJiBzdGFsbGVkRHVyYXRpb24gPiBjb25maWcuaGlnaEJ1ZmZlcldhdGNoZG9nUGVyaW9kICogMTAwMCkge1xuICAgICAgICAgICAgLy8gVHJ5IHRvIG51ZGdlIGN1cnJlbnRUaW1lIG92ZXIgYSBidWZmZXIgaG9sZSBpZiB3ZSd2ZSBiZWVuIHN0YWxsaW5nIGZvciB0aGUgY29uZmlndXJlZCBhbW91bnQgb2Ygc2Vjb25kc1xuICAgICAgICAgICAgLy8gV2Ugb25seSB0cnkgdG8ganVtcCB0aGUgaG9sZSBpZiBpdCdzIHVuZGVyIHRoZSBjb25maWd1cmVkIHNpemVcbiAgICAgICAgICAgIC8vIFJlc2V0IHN0YWxsZWQgc28gdG8gcmVhcm0gd2F0Y2hkb2cgdGltZXJcbiAgICAgICAgICAgIHRoaXMuc3RhbGxlZCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLl90cnlOdWRnZUJ1ZmZlcigpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUcmlnZ2VycyBhIEJVRkZFUl9TVEFMTEVEX0VSUk9SIGV2ZW50LCBidXQgb25seSBvbmNlIHBlciBzdGFsbCBwZXJpb2QuXG4gICAgICogQHBhcmFtIGJ1ZmZlckxlbiAtIFRoZSBwbGF5aGVhZCBkaXN0YW5jZSBmcm9tIHRoZSBlbmQgb2YgdGhlIGN1cnJlbnQgYnVmZmVyIHNlZ21lbnQuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBHYXBDb250cm9sbGVyLnByb3RvdHlwZS5fcmVwb3J0U3RhbGwgPSBmdW5jdGlvbiAoYnVmZmVyTGVuKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIGhscyA9IF9hLmhscywgbWVkaWEgPSBfYS5tZWRpYSwgc3RhbGxSZXBvcnRlZCA9IF9hLnN0YWxsUmVwb3J0ZWQ7XG4gICAgICAgIGlmICghc3RhbGxSZXBvcnRlZCkge1xuICAgICAgICAgICAgLy8gUmVwb3J0IHN0YWxsZWQgZXJyb3Igb25jZVxuICAgICAgICAgICAgdGhpcy5zdGFsbFJlcG9ydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGxvZ2dlcl8xLmxvZ2dlci53YXJuKFwiUGxheWJhY2sgc3RhbGxpbmcgYXQgQFwiICsgbWVkaWEuY3VycmVudFRpbWUgKyBcIiBkdWUgdG8gbG93IGJ1ZmZlclwiKTtcbiAgICAgICAgICAgIGhscy50cmlnZ2VyKGV2ZW50c18xLmRlZmF1bHQuRVJST1IsIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBlcnJvcnNfMS5FcnJvclR5cGVzLk1FRElBX0VSUk9SLFxuICAgICAgICAgICAgICAgIGRldGFpbHM6IGVycm9yc18xLkVycm9yRGV0YWlscy5CVUZGRVJfU1RBTExFRF9FUlJPUixcbiAgICAgICAgICAgICAgICBmYXRhbDogZmFsc2UsXG4gICAgICAgICAgICAgICAgYnVmZmVyOiBidWZmZXJMZW5cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBdHRlbXB0cyB0byBmaXggYnVmZmVyIHN0YWxscyBieSBqdW1waW5nIG92ZXIga25vd24gZ2FwcyBjYXVzZWQgYnkgcGFydGlhbCBmcmFnbWVudHNcbiAgICAgKiBAcGFyYW0gcGFydGlhbCAtIFRoZSBwYXJ0aWFsIGZyYWdtZW50IGZvdW5kIGF0IHRoZSBjdXJyZW50IHRpbWUgKHdoZXJlIHBsYXliYWNrIGlzIHN0YWxsaW5nKS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIEdhcENvbnRyb2xsZXIucHJvdG90eXBlLl90cnlTa2lwQnVmZmVySG9sZSA9IGZ1bmN0aW9uIChwYXJ0aWFsKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIGhscyA9IF9hLmhscywgbWVkaWEgPSBfYS5tZWRpYTtcbiAgICAgICAgdmFyIGN1cnJlbnRUaW1lID0gbWVkaWEuY3VycmVudFRpbWU7XG4gICAgICAgIHZhciBsYXN0RW5kVGltZSA9IDA7XG4gICAgICAgIC8vIENoZWNrIGlmIGN1cnJlbnRUaW1lIGlzIGJldHdlZW4gdW5idWZmZXJlZCByZWdpb25zIG9mIHBhcnRpYWwgZnJhZ21lbnRzXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVkaWEuYnVmZmVyZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBzdGFydFRpbWUgPSBtZWRpYS5idWZmZXJlZC5zdGFydChpKTtcbiAgICAgICAgICAgIGlmIChjdXJyZW50VGltZSA+PSBsYXN0RW5kVGltZSAmJiBjdXJyZW50VGltZSA8IHN0YXJ0VGltZSkge1xuICAgICAgICAgICAgICAgIG1lZGlhLmN1cnJlbnRUaW1lID0gTWF0aC5tYXgoc3RhcnRUaW1lLCBtZWRpYS5jdXJyZW50VGltZSArIDAuMSk7XG4gICAgICAgICAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLndhcm4oXCJza2lwcGluZyBob2xlLCBhZGp1c3RpbmcgY3VycmVudFRpbWUgZnJvbSBcIiArIGN1cnJlbnRUaW1lICsgXCIgdG8gXCIgKyBtZWRpYS5jdXJyZW50VGltZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGFsbGVkID0gbnVsbDtcbiAgICAgICAgICAgICAgICBobHMudHJpZ2dlcihldmVudHNfMS5kZWZhdWx0LkVSUk9SLCB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IGVycm9yc18xLkVycm9yVHlwZXMuTUVESUFfRVJST1IsXG4gICAgICAgICAgICAgICAgICAgIGRldGFpbHM6IGVycm9yc18xLkVycm9yRGV0YWlscy5CVUZGRVJfU0VFS19PVkVSX0hPTEUsXG4gICAgICAgICAgICAgICAgICAgIGZhdGFsOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgcmVhc29uOiBcImZyYWdtZW50IGxvYWRlZCB3aXRoIGJ1ZmZlciBob2xlcywgc2Vla2luZyBmcm9tIFwiICsgY3VycmVudFRpbWUgKyBcIiB0byBcIiArIG1lZGlhLmN1cnJlbnRUaW1lLFxuICAgICAgICAgICAgICAgICAgICBmcmFnOiBwYXJ0aWFsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGFzdEVuZFRpbWUgPSBtZWRpYS5idWZmZXJlZC5lbmQoaSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEF0dGVtcHRzIHRvIGZpeCBidWZmZXIgc3RhbGxzIGJ5IGFkdmFuY2luZyB0aGUgbWVkaWFFbGVtZW50J3MgY3VycmVudCB0aW1lIGJ5IGEgc21hbGwgYW1vdW50LlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgR2FwQ29udHJvbGxlci5wcm90b3R5cGUuX3RyeU51ZGdlQnVmZmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCBjb25maWcgPSBfYS5jb25maWcsIGhscyA9IF9hLmhscywgbWVkaWEgPSBfYS5tZWRpYTtcbiAgICAgICAgdmFyIGN1cnJlbnRUaW1lID0gbWVkaWEuY3VycmVudFRpbWU7XG4gICAgICAgIHZhciBudWRnZVJldHJ5ID0gKHRoaXMubnVkZ2VSZXRyeSB8fCAwKSArIDE7XG4gICAgICAgIHRoaXMubnVkZ2VSZXRyeSA9IG51ZGdlUmV0cnk7XG4gICAgICAgIGlmIChudWRnZVJldHJ5IDwgY29uZmlnLm51ZGdlTWF4UmV0cnkpIHtcbiAgICAgICAgICAgIHZhciB0YXJnZXRUaW1lID0gY3VycmVudFRpbWUgKyBudWRnZVJldHJ5ICogY29uZmlnLm51ZGdlT2Zmc2V0O1xuICAgICAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLmxvZyhcImFkanVzdCBjdXJyZW50VGltZSBmcm9tIFwiICsgY3VycmVudFRpbWUgKyBcIiB0byBcIiArIHRhcmdldFRpbWUpO1xuICAgICAgICAgICAgLy8gcGxheWJhY2sgc3RhbGxlZCBpbiBidWZmZXJlZCBhcmVhIC4uLiBsZXQncyBudWRnZSBjdXJyZW50VGltZSB0byB0cnkgdG8gb3ZlcmNvbWUgdGhpc1xuICAgICAgICAgICAgbWVkaWEuY3VycmVudFRpbWUgPSB0YXJnZXRUaW1lO1xuICAgICAgICAgICAgaGxzLnRyaWdnZXIoZXZlbnRzXzEuZGVmYXVsdC5FUlJPUiwge1xuICAgICAgICAgICAgICAgIHR5cGU6IGVycm9yc18xLkVycm9yVHlwZXMuTUVESUFfRVJST1IsXG4gICAgICAgICAgICAgICAgZGV0YWlsczogZXJyb3JzXzEuRXJyb3JEZXRhaWxzLkJVRkZFUl9OVURHRV9PTl9TVEFMTCxcbiAgICAgICAgICAgICAgICBmYXRhbDogZmFsc2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLmVycm9yKFwic3RpbGwgc3R1Y2sgaW4gaGlnaCBidWZmZXIgQFwiICsgY3VycmVudFRpbWUgKyBcIiBhZnRlciBcIiArIGNvbmZpZy5udWRnZU1heFJldHJ5ICsgXCIsIHJhaXNlIGZhdGFsIGVycm9yXCIpO1xuICAgICAgICAgICAgaGxzLnRyaWdnZXIoZXZlbnRzXzEuZGVmYXVsdC5FUlJPUiwge1xuICAgICAgICAgICAgICAgIHR5cGU6IGVycm9yc18xLkVycm9yVHlwZXMuTUVESUFfRVJST1IsXG4gICAgICAgICAgICAgICAgZGV0YWlsczogZXJyb3JzXzEuRXJyb3JEZXRhaWxzLkJVRkZFUl9TVEFMTEVEX0VSUk9SLFxuICAgICAgICAgICAgICAgIGZhdGFsOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIEdhcENvbnRyb2xsZXI7XG59KCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gR2FwQ29udHJvbGxlcjtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9jb250cm9sbGVyL2lkMy10cmFjay1jb250cm9sbGVyLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvY29udHJvbGxlci9pZDMtdHJhY2stY29udHJvbGxlci5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKlxuICogaWQzIG1ldGFkYXRhIHRyYWNrIGNvbnRyb2xsZXJcbiovXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBldmVudHNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2V2ZW50cyAqLyBcIi4vc3JjL2V2ZW50cy5qc1wiKTtcbnZhciBldmVudF9oYW5kbGVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9ldmVudC1oYW5kbGVyICovIFwiLi9zcmMvZXZlbnQtaGFuZGxlci5qc1wiKTtcbnZhciBpZDNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2RlbXV4L2lkMyAqLyBcIi4vc3JjL2RlbXV4L2lkMy5qc1wiKTtcbnZhciB0ZXh0dHJhY2tfdXRpbHNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL3RleHR0cmFjay11dGlscyAqLyBcIi4vc3JjL3V0aWxzL3RleHR0cmFjay11dGlscy5qc1wiKTtcbnZhciBJRDNUcmFja0NvbnRyb2xsZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKElEM1RyYWNrQ29udHJvbGxlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBJRDNUcmFja0NvbnRyb2xsZXIoaGxzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGhscywgZXZlbnRzXzEuZGVmYXVsdC5NRURJQV9BVFRBQ0hFRCwgZXZlbnRzXzEuZGVmYXVsdC5NRURJQV9ERVRBQ0hJTkcsIGV2ZW50c18xLmRlZmF1bHQuRlJBR19QQVJTSU5HX01FVEFEQVRBKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5pZDNUcmFjayA9IHVuZGVmaW5lZDtcbiAgICAgICAgX3RoaXMubWVkaWEgPSB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgSUQzVHJhY2tDb250cm9sbGVyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBldmVudF9oYW5kbGVyXzEuZGVmYXVsdC5wcm90b3R5cGUuZGVzdHJveS5jYWxsKHRoaXMpO1xuICAgIH07XG4gICAgLy8gQWRkIElEMyBtZXRhdGFkYXRhIHRleHQgdHJhY2suXG4gICAgSUQzVHJhY2tDb250cm9sbGVyLnByb3RvdHlwZS5vbk1lZGlhQXR0YWNoZWQgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB0aGlzLm1lZGlhID0gZGF0YS5tZWRpYTtcbiAgICAgICAgaWYgKCF0aGlzLm1lZGlhKSB7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIElEM1RyYWNrQ29udHJvbGxlci5wcm90b3R5cGUub25NZWRpYURldGFjaGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGV4dHRyYWNrX3V0aWxzXzEuY2xlYXJDdXJyZW50Q3Vlcyh0aGlzLmlkM1RyYWNrKTtcbiAgICAgICAgdGhpcy5pZDNUcmFjayA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5tZWRpYSA9IHVuZGVmaW5lZDtcbiAgICB9O1xuICAgIElEM1RyYWNrQ29udHJvbGxlci5wcm90b3R5cGUuZ2V0SUQzVHJhY2sgPSBmdW5jdGlvbiAodGV4dFRyYWNrcykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRleHRUcmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciB0ZXh0VHJhY2sgPSB0ZXh0VHJhY2tzW2ldO1xuICAgICAgICAgICAgaWYgKHRleHRUcmFjay5raW5kID09PSAnbWV0YWRhdGEnICYmIHRleHRUcmFjay5sYWJlbCA9PT0gJ2lkMycpIHtcbiAgICAgICAgICAgICAgICAvLyBzZW5kICdhZGR0cmFjaycgd2hlbiByZXVzaW5nIHRoZSB0ZXh0VHJhY2sgZm9yIG1ldGFkYXRhLFxuICAgICAgICAgICAgICAgIC8vIHNhbWUgYXMgd2hhdCB3ZSBkbyBmb3IgY2FwdGlvbnNcbiAgICAgICAgICAgICAgICB0ZXh0dHJhY2tfdXRpbHNfMS5zZW5kQWRkVHJhY2tFdmVudCh0ZXh0VHJhY2ssIHRoaXMubWVkaWEpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0ZXh0VHJhY2s7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubWVkaWEuYWRkVGV4dFRyYWNrKCdtZXRhZGF0YScsICdpZDMnKTtcbiAgICB9O1xuICAgIElEM1RyYWNrQ29udHJvbGxlci5wcm90b3R5cGUub25GcmFnUGFyc2luZ01ldGFkYXRhID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdmFyIGZyYWdtZW50ID0gZGF0YS5mcmFnO1xuICAgICAgICB2YXIgc2FtcGxlcyA9IGRhdGEuc2FtcGxlcztcbiAgICAgICAgLy8gY3JlYXRlIHRyYWNrIGR5bmFtaWNhbGx5XG4gICAgICAgIGlmICghdGhpcy5pZDNUcmFjaykge1xuICAgICAgICAgICAgdGhpcy5pZDNUcmFjayA9IHRoaXMuZ2V0SUQzVHJhY2sodGhpcy5tZWRpYS50ZXh0VHJhY2tzKTtcbiAgICAgICAgICAgIHRoaXMuaWQzVHJhY2subW9kZSA9ICdoaWRkZW4nO1xuICAgICAgICB9XG4gICAgICAgIC8vIEF0dGVtcHQgdG8gcmVjcmVhdGUgU2FmYXJpIGZ1bmN0aW9uYWxpdHkgYnkgY3JlYXRpbmdcbiAgICAgICAgLy8gV2ViS2l0RGF0YUN1ZSBvYmplY3RzIHdoZW4gYXZhaWxhYmxlIGFuZCBzdG9yZSB0aGUgZGVjb2RlZFxuICAgICAgICAvLyBJRDMgZGF0YSBpbiB0aGUgdmFsdWUgcHJvcGVydHkgb2YgdGhlIGN1ZVxuICAgICAgICB2YXIgQ3VlID0gd2luZG93LldlYktpdERhdGFDdWUgfHwgd2luZG93LlZUVEN1ZSB8fCB3aW5kb3cuVGV4dFRyYWNrQ3VlO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNhbXBsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBmcmFtZXNfMSA9IGlkM18xLmRlZmF1bHQuZ2V0SUQzRnJhbWVzKHNhbXBsZXNbaV0uZGF0YSk7XG4gICAgICAgICAgICBpZiAoZnJhbWVzXzEpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnRUaW1lID0gc2FtcGxlc1tpXS5wdHM7XG4gICAgICAgICAgICAgICAgdmFyIGVuZFRpbWUgPSBpIDwgc2FtcGxlcy5sZW5ndGggLSAxID8gc2FtcGxlc1tpICsgMV0ucHRzIDogZnJhZ21lbnQuZW5kUFRTO1xuICAgICAgICAgICAgICAgIC8vIEdpdmUgYSBzbGlnaHQgYnVtcCB0byB0aGUgZW5kVGltZSBpZiBpdCdzIGVxdWFsIHRvIHN0YXJ0VGltZSB0byBhdm9pZCBhIFN5bnRheEVycm9yIGluIElFXG4gICAgICAgICAgICAgICAgaWYgKHN0YXJ0VGltZSA9PT0gZW5kVGltZSkge1xuICAgICAgICAgICAgICAgICAgICBlbmRUaW1lICs9IDAuMDAwMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBmcmFtZXNfMS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZnJhbWUgPSBmcmFtZXNfMVtqXTtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2FmYXJpIGRvZXNuJ3QgcHV0IHRoZSB0aW1lc3RhbXAgZnJhbWUgaW4gdGhlIFRleHRUcmFja1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWlkM18xLmRlZmF1bHQuaXNUaW1lU3RhbXBGcmFtZShmcmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjdWUgPSBuZXcgQ3VlKHN0YXJ0VGltZSwgZW5kVGltZSwgJycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VlLnZhbHVlID0gZnJhbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmlkM1RyYWNrLmFkZEN1ZShjdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gSUQzVHJhY2tDb250cm9sbGVyO1xufShldmVudF9oYW5kbGVyXzEuZGVmYXVsdCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gSUQzVHJhY2tDb250cm9sbGVyO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2NvbnRyb2xsZXIvbGV2ZWwtY29udHJvbGxlci5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvY29udHJvbGxlci9sZXZlbC1jb250cm9sbGVyLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLypcbiAqIExldmVsIENvbnRyb2xsZXJcbiovXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBldmVudHNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2V2ZW50cyAqLyBcIi4vc3JjL2V2ZW50cy5qc1wiKTtcbnZhciBldmVudF9oYW5kbGVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9ldmVudC1oYW5kbGVyICovIFwiLi9zcmMvZXZlbnQtaGFuZGxlci5qc1wiKTtcbnZhciBsb2dnZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL2xvZ2dlciAqLyBcIi4vc3JjL3V0aWxzL2xvZ2dlci5qc1wiKTtcbnZhciBlcnJvcnNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2Vycm9ycyAqLyBcIi4vc3JjL2Vycm9ycy5qc1wiKTtcbnZhciBjb2RlY3NfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL2NvZGVjcyAqLyBcIi4vc3JjL3V0aWxzL2NvZGVjcy5qc1wiKTtcbnZhciBsZXZlbF9oZWxwZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vbGV2ZWwtaGVscGVyICovIFwiLi9zcmMvY29udHJvbGxlci9sZXZlbC1oZWxwZXIuanNcIik7XG52YXIgcGVyZm9ybWFuY2UgPSB3aW5kb3cucGVyZm9ybWFuY2U7XG52YXIgY2hyb21lT3JGaXJlZm94O1xudmFyIExldmVsQ29udHJvbGxlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTGV2ZWxDb250cm9sbGVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIExldmVsQ29udHJvbGxlcihobHMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgaGxzLCBldmVudHNfMS5kZWZhdWx0Lk1BTklGRVNUX0xPQURFRCwgZXZlbnRzXzEuZGVmYXVsdC5MRVZFTF9MT0FERUQsIGV2ZW50c18xLmRlZmF1bHQuQVVESU9fVFJBQ0tfU1dJVENIRUQsIGV2ZW50c18xLmRlZmF1bHQuRlJBR19MT0FERUQsIGV2ZW50c18xLmRlZmF1bHQuRVJST1IpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmNhbmxvYWQgPSBmYWxzZTtcbiAgICAgICAgX3RoaXMuY3VycmVudExldmVsSW5kZXggPSBudWxsO1xuICAgICAgICBfdGhpcy5tYW51YWxMZXZlbEluZGV4ID0gLTE7XG4gICAgICAgIF90aGlzLnRpbWVyID0gbnVsbDtcbiAgICAgICAgY2hyb21lT3JGaXJlZm94ID0gL2Nocm9tZXxmaXJlZm94Ly50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgTGV2ZWxDb250cm9sbGVyLnByb3RvdHlwZS5vbkhhbmRsZXJEZXN0cm95aW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmNsZWFyVGltZXIoKTtcbiAgICAgICAgdGhpcy5tYW51YWxMZXZlbEluZGV4ID0gLTE7XG4gICAgfTtcbiAgICBMZXZlbENvbnRyb2xsZXIucHJvdG90eXBlLmNsZWFyVGltZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnRpbWVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lcik7XG4gICAgICAgICAgICB0aGlzLnRpbWVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTGV2ZWxDb250cm9sbGVyLnByb3RvdHlwZS5zdGFydExvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBsZXZlbHMgPSB0aGlzLl9sZXZlbHM7XG4gICAgICAgIHRoaXMuY2FubG9hZCA9IHRydWU7XG4gICAgICAgIHRoaXMubGV2ZWxSZXRyeUNvdW50ID0gMDtcbiAgICAgICAgLy8gY2xlYW4gdXAgbGl2ZSBsZXZlbCBkZXRhaWxzIHRvIGZvcmNlIHJlbG9hZCB0aGVtLCBhbmQgcmVzZXQgbG9hZCBlcnJvcnNcbiAgICAgICAgaWYgKGxldmVscykge1xuICAgICAgICAgICAgbGV2ZWxzLmZvckVhY2goZnVuY3Rpb24gKGxldmVsKSB7XG4gICAgICAgICAgICAgICAgbGV2ZWwubG9hZEVycm9yID0gMDtcbiAgICAgICAgICAgICAgICB2YXIgbGV2ZWxEZXRhaWxzID0gbGV2ZWwuZGV0YWlscztcbiAgICAgICAgICAgICAgICBpZiAobGV2ZWxEZXRhaWxzICYmIGxldmVsRGV0YWlscy5saXZlKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldmVsLmRldGFpbHMgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc3BlZWQgdXAgbGl2ZSBwbGF5bGlzdCByZWZyZXNoIGlmIHRpbWVyIGV4aXN0c1xuICAgICAgICBpZiAodGhpcy50aW1lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5sb2FkTGV2ZWwoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTGV2ZWxDb250cm9sbGVyLnByb3RvdHlwZS5zdG9wTG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5jYW5sb2FkID0gZmFsc2U7XG4gICAgfTtcbiAgICBMZXZlbENvbnRyb2xsZXIucHJvdG90eXBlLm9uTWFuaWZlc3RMb2FkZWQgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB2YXIgbGV2ZWxzID0gW107XG4gICAgICAgIHZhciBhdWRpb1RyYWNrcyA9IFtdO1xuICAgICAgICB2YXIgYml0cmF0ZVN0YXJ0O1xuICAgICAgICB2YXIgbGV2ZWxTZXQgPSB7fTtcbiAgICAgICAgdmFyIGxldmVsRnJvbVNldCA9IG51bGw7XG4gICAgICAgIHZhciB2aWRlb0NvZGVjRm91bmQgPSBmYWxzZTtcbiAgICAgICAgdmFyIGF1ZGlvQ29kZWNGb3VuZCA9IGZhbHNlO1xuICAgICAgICAvLyByZWdyb3VwIHJlZHVuZGFudCBsZXZlbHMgdG9nZXRoZXJcbiAgICAgICAgZGF0YS5sZXZlbHMuZm9yRWFjaChmdW5jdGlvbiAobGV2ZWwpIHtcbiAgICAgICAgICAgIHZhciBhdHRyaWJ1dGVzID0gbGV2ZWwuYXR0cnM7XG4gICAgICAgICAgICBsZXZlbC5sb2FkRXJyb3IgPSAwO1xuICAgICAgICAgICAgbGV2ZWwuZnJhZ21lbnRFcnJvciA9IGZhbHNlO1xuICAgICAgICAgICAgdmlkZW9Db2RlY0ZvdW5kID0gdmlkZW9Db2RlY0ZvdW5kIHx8ICEhbGV2ZWwudmlkZW9Db2RlYztcbiAgICAgICAgICAgIGF1ZGlvQ29kZWNGb3VuZCA9IGF1ZGlvQ29kZWNGb3VuZCB8fCAhIWxldmVsLmF1ZGlvQ29kZWM7XG4gICAgICAgICAgICAvLyBlcmFzZSBhdWRpbyBjb2RlYyBpbmZvIGlmIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCBtcDRhLjQwLjM0LlxuICAgICAgICAgICAgLy8gZGVtdXhlciB3aWxsIGF1dG9kZXRlY3QgY29kZWMgYW5kIGZhbGxiYWNrIHRvIG1wZWcvYXVkaW9cbiAgICAgICAgICAgIGlmIChjaHJvbWVPckZpcmVmb3ggJiYgbGV2ZWwuYXVkaW9Db2RlYyAmJiBsZXZlbC5hdWRpb0NvZGVjLmluZGV4T2YoJ21wNGEuNDAuMzQnKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBsZXZlbC5hdWRpb0NvZGVjID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV2ZWxGcm9tU2V0ID0gbGV2ZWxTZXRbbGV2ZWwuYml0cmF0ZV07IC8vIEZJWE1FOiB3ZSB3b3VsZCBhbHNvIGhhdmUgdG8gbWF0Y2ggdGhlIHJlc29sdXRpb24gaGVyZVxuICAgICAgICAgICAgaWYgKCFsZXZlbEZyb21TZXQpIHtcbiAgICAgICAgICAgICAgICBsZXZlbC51cmwgPSBbbGV2ZWwudXJsXTtcbiAgICAgICAgICAgICAgICBsZXZlbC51cmxJZCA9IDA7XG4gICAgICAgICAgICAgICAgbGV2ZWxTZXRbbGV2ZWwuYml0cmF0ZV0gPSBsZXZlbDtcbiAgICAgICAgICAgICAgICBsZXZlbHMucHVzaChsZXZlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXZlbEZyb21TZXQudXJsLnB1c2gobGV2ZWwudXJsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGF0dHJpYnV0ZXMuQVVESU8pIHtcbiAgICAgICAgICAgICAgICAgICAgYXVkaW9Db2RlY0ZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgbGV2ZWxfaGVscGVyXzEuYWRkR3JvdXBJZChsZXZlbEZyb21TZXQgfHwgbGV2ZWwsICdhdWRpbycsIGF0dHJpYnV0ZXMuQVVESU8pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYXR0cmlidXRlcy5TVUJUSVRMRVMpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV2ZWxfaGVscGVyXzEuYWRkR3JvdXBJZChsZXZlbEZyb21TZXQgfHwgbGV2ZWwsICd0ZXh0JywgYXR0cmlidXRlcy5TVUJUSVRMRVMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIHJlbW92ZSBhdWRpby1vbmx5IGxldmVsIGlmIHdlIGFsc28gaGF2ZSBsZXZlbHMgd2l0aCBhdWRpbyt2aWRlbyBjb2RlY3Mgc2lnbmFsbGVkXG4gICAgICAgIGlmICh2aWRlb0NvZGVjRm91bmQgJiYgYXVkaW9Db2RlY0ZvdW5kKSB7XG4gICAgICAgICAgICBsZXZlbHMgPSBsZXZlbHMuZmlsdGVyKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHZhciB2aWRlb0NvZGVjID0gX2EudmlkZW9Db2RlYztcbiAgICAgICAgICAgICAgICByZXR1cm4gISF2aWRlb0NvZGVjO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gb25seSBrZWVwIGxldmVscyB3aXRoIHN1cHBvcnRlZCBhdWRpby92aWRlbyBjb2RlY3NcbiAgICAgICAgbGV2ZWxzID0gbGV2ZWxzLmZpbHRlcihmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHZhciBhdWRpb0NvZGVjID0gX2EuYXVkaW9Db2RlYywgdmlkZW9Db2RlYyA9IF9hLnZpZGVvQ29kZWM7XG4gICAgICAgICAgICByZXR1cm4gKCFhdWRpb0NvZGVjIHx8IGNvZGVjc18xLmlzQ29kZWNTdXBwb3J0ZWRJbk1wNChhdWRpb0NvZGVjLCAnYXVkaW8nKSkgJiYgKCF2aWRlb0NvZGVjIHx8IGNvZGVjc18xLmlzQ29kZWNTdXBwb3J0ZWRJbk1wNCh2aWRlb0NvZGVjLCAndmlkZW8nKSk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoZGF0YS5hdWRpb1RyYWNrcykge1xuICAgICAgICAgICAgYXVkaW9UcmFja3MgPSBkYXRhLmF1ZGlvVHJhY2tzLmZpbHRlcihmdW5jdGlvbiAodHJhY2spIHsgcmV0dXJuICF0cmFjay5hdWRpb0NvZGVjIHx8IGNvZGVjc18xLmlzQ29kZWNTdXBwb3J0ZWRJbk1wNCh0cmFjay5hdWRpb0NvZGVjLCAnYXVkaW8nKTsgfSk7XG4gICAgICAgICAgICAvLyBSZWFzc2lnbiBpZCdzIGFmdGVyIGZpbHRlcmluZyBzaW5jZSB0aGV5J3JlIHVzZWQgYXMgYXJyYXkgaW5kaWNlc1xuICAgICAgICAgICAgYXVkaW9UcmFja3MuZm9yRWFjaChmdW5jdGlvbiAodHJhY2ssIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgdHJhY2suaWQgPSBpbmRleDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsZXZlbHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgLy8gc3RhcnQgYml0cmF0ZSBpcyB0aGUgZmlyc3QgYml0cmF0ZSBvZiB0aGUgbWFuaWZlc3RcbiAgICAgICAgICAgIGJpdHJhdGVTdGFydCA9IGxldmVsc1swXS5iaXRyYXRlO1xuICAgICAgICAgICAgLy8gc29ydCBsZXZlbCBvbiBiaXRyYXRlXG4gICAgICAgICAgICBsZXZlbHMuc29ydChmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYS5iaXRyYXRlIC0gYi5iaXRyYXRlOyB9KTtcbiAgICAgICAgICAgIHRoaXMuX2xldmVscyA9IGxldmVscztcbiAgICAgICAgICAgIC8vIGZpbmQgaW5kZXggb2YgZmlyc3QgbGV2ZWwgaW4gc29ydGVkIGxldmVsc1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZXZlbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAobGV2ZWxzW2ldLmJpdHJhdGUgPT09IGJpdHJhdGVTdGFydCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9maXJzdExldmVsID0gaTtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLmxvZyhcIm1hbmlmZXN0IGxvYWRlZCxcIiArIGxldmVscy5sZW5ndGggKyBcIiBsZXZlbChzKSBmb3VuZCwgZmlyc3QgYml0cmF0ZTpcIiArIGJpdHJhdGVTdGFydCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEF1ZGlvIGlzIG9ubHkgYWx0ZXJuYXRlIGlmIG1hbmlmZXN0IGluY2x1ZGUgYSBVUkkgYWxvbmcgd2l0aCB0aGUgYXVkaW8gZ3JvdXAgdGFnXG4gICAgICAgICAgICB0aGlzLmhscy50cmlnZ2VyKGV2ZW50c18xLmRlZmF1bHQuTUFOSUZFU1RfUEFSU0VELCB7XG4gICAgICAgICAgICAgICAgbGV2ZWxzOiBsZXZlbHMsXG4gICAgICAgICAgICAgICAgYXVkaW9UcmFja3M6IGF1ZGlvVHJhY2tzLFxuICAgICAgICAgICAgICAgIGZpcnN0TGV2ZWw6IHRoaXMuX2ZpcnN0TGV2ZWwsXG4gICAgICAgICAgICAgICAgc3RhdHM6IGRhdGEuc3RhdHMsXG4gICAgICAgICAgICAgICAgYXVkaW86IGF1ZGlvQ29kZWNGb3VuZCxcbiAgICAgICAgICAgICAgICB2aWRlbzogdmlkZW9Db2RlY0ZvdW5kLFxuICAgICAgICAgICAgICAgIGFsdEF1ZGlvOiBhdWRpb1RyYWNrcy5zb21lKGZ1bmN0aW9uICh0KSB7IHJldHVybiAhIXQudXJsOyB9KVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmhscy50cmlnZ2VyKGV2ZW50c18xLmRlZmF1bHQuRVJST1IsIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBlcnJvcnNfMS5FcnJvclR5cGVzLk1FRElBX0VSUk9SLFxuICAgICAgICAgICAgICAgIGRldGFpbHM6IGVycm9yc18xLkVycm9yRGV0YWlscy5NQU5JRkVTVF9JTkNPTVBBVElCTEVfQ09ERUNTX0VSUk9SLFxuICAgICAgICAgICAgICAgIGZhdGFsOiB0cnVlLFxuICAgICAgICAgICAgICAgIHVybDogdGhpcy5obHMudXJsLFxuICAgICAgICAgICAgICAgIHJlYXNvbjogJ25vIGxldmVsIHdpdGggY29tcGF0aWJsZSBjb2RlY3MgZm91bmQgaW4gbWFuaWZlc3QnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KExldmVsQ29udHJvbGxlci5wcm90b3R5cGUsIFwibGV2ZWxzXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbGV2ZWxzO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTGV2ZWxDb250cm9sbGVyLnByb3RvdHlwZSwgXCJsZXZlbFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudExldmVsSW5kZXg7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKG5ld0xldmVsKSB7XG4gICAgICAgICAgICB2YXIgbGV2ZWxzID0gdGhpcy5fbGV2ZWxzO1xuICAgICAgICAgICAgaWYgKGxldmVscykge1xuICAgICAgICAgICAgICAgIG5ld0xldmVsID0gTWF0aC5taW4obmV3TGV2ZWwsIGxldmVscy5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50TGV2ZWxJbmRleCAhPT0gbmV3TGV2ZWwgfHwgIWxldmVsc1tuZXdMZXZlbF0uZGV0YWlscykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldExldmVsSW50ZXJuYWwobmV3TGV2ZWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgTGV2ZWxDb250cm9sbGVyLnByb3RvdHlwZS5zZXRMZXZlbEludGVybmFsID0gZnVuY3Rpb24gKG5ld0xldmVsKSB7XG4gICAgICAgIHZhciBsZXZlbHMgPSB0aGlzLl9sZXZlbHM7XG4gICAgICAgIHZhciBobHMgPSB0aGlzLmhscztcbiAgICAgICAgLy8gY2hlY2sgaWYgbGV2ZWwgaWR4IGlzIHZhbGlkXG4gICAgICAgIGlmIChuZXdMZXZlbCA+PSAwICYmIG5ld0xldmVsIDwgbGV2ZWxzLmxlbmd0aCkge1xuICAgICAgICAgICAgLy8gc3RvcHBpbmcgbGl2ZSByZWxvYWRpbmcgdGltZXIgaWYgYW55XG4gICAgICAgICAgICB0aGlzLmNsZWFyVGltZXIoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnRMZXZlbEluZGV4ICE9PSBuZXdMZXZlbCkge1xuICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmxvZ2dlci5sb2coXCJzd2l0Y2hpbmcgdG8gbGV2ZWwgXCIgKyBuZXdMZXZlbCk7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50TGV2ZWxJbmRleCA9IG5ld0xldmVsO1xuICAgICAgICAgICAgICAgIHZhciBsZXZlbFByb3BlcnRpZXMgPSBsZXZlbHNbbmV3TGV2ZWxdO1xuICAgICAgICAgICAgICAgIGxldmVsUHJvcGVydGllcy5sZXZlbCA9IG5ld0xldmVsO1xuICAgICAgICAgICAgICAgIGhscy50cmlnZ2VyKGV2ZW50c18xLmRlZmF1bHQuTEVWRUxfU1dJVENISU5HLCBsZXZlbFByb3BlcnRpZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGxldmVsID0gbGV2ZWxzW25ld0xldmVsXTtcbiAgICAgICAgICAgIHZhciBsZXZlbERldGFpbHMgPSBsZXZlbC5kZXRhaWxzO1xuICAgICAgICAgICAgLy8gY2hlY2sgaWYgd2UgbmVlZCB0byBsb2FkIHBsYXlsaXN0IGZvciB0aGlzIGxldmVsXG4gICAgICAgICAgICBpZiAoIWxldmVsRGV0YWlscyB8fCBsZXZlbERldGFpbHMubGl2ZSkge1xuICAgICAgICAgICAgICAgIC8vIGxldmVsIG5vdCByZXRyaWV2ZWQgeWV0LCBvciBsaXZlIHBsYXlsaXN0IHdlIG5lZWQgdG8gKHJlKWxvYWQgaXRcbiAgICAgICAgICAgICAgICB2YXIgdXJsSWQgPSBsZXZlbC51cmxJZDtcbiAgICAgICAgICAgICAgICBobHMudHJpZ2dlcihldmVudHNfMS5kZWZhdWx0LkxFVkVMX0xPQURJTkcsIHsgdXJsOiBsZXZlbC51cmxbdXJsSWRdLCBsZXZlbDogbmV3TGV2ZWwsIGlkOiB1cmxJZCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGludmFsaWQgbGV2ZWwgaWQgZ2l2ZW4sIHRyaWdnZXIgZXJyb3JcbiAgICAgICAgICAgIGhscy50cmlnZ2VyKGV2ZW50c18xLmRlZmF1bHQuRVJST1IsIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBlcnJvcnNfMS5FcnJvclR5cGVzLk9USEVSX0VSUk9SLFxuICAgICAgICAgICAgICAgIGRldGFpbHM6IGVycm9yc18xLkVycm9yRGV0YWlscy5MRVZFTF9TV0lUQ0hfRVJST1IsXG4gICAgICAgICAgICAgICAgbGV2ZWw6IG5ld0xldmVsLFxuICAgICAgICAgICAgICAgIGZhdGFsOiBmYWxzZSxcbiAgICAgICAgICAgICAgICByZWFzb246ICdpbnZhbGlkIGxldmVsIGlkeCdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTGV2ZWxDb250cm9sbGVyLnByb3RvdHlwZSwgXCJtYW51YWxMZXZlbFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWFudWFsTGV2ZWxJbmRleDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAobmV3TGV2ZWwpIHtcbiAgICAgICAgICAgIHRoaXMubWFudWFsTGV2ZWxJbmRleCA9IG5ld0xldmVsO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3N0YXJ0TGV2ZWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0TGV2ZWwgPSBuZXdMZXZlbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuZXdMZXZlbCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxldmVsID0gbmV3TGV2ZWw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShMZXZlbENvbnRyb2xsZXIucHJvdG90eXBlLCBcImZpcnN0TGV2ZWxcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9maXJzdExldmVsO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChuZXdMZXZlbCkge1xuICAgICAgICAgICAgdGhpcy5fZmlyc3RMZXZlbCA9IG5ld0xldmVsO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTGV2ZWxDb250cm9sbGVyLnByb3RvdHlwZSwgXCJzdGFydExldmVsXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBobHMuc3RhcnRMZXZlbCB0YWtlcyBwcmVjZWRlbmNlIG92ZXIgY29uZmlnLnN0YXJ0TGV2ZWxcbiAgICAgICAgICAgIC8vIGlmIG5vbmUgb2YgdGhlc2UgdmFsdWVzIGFyZSBkZWZpbmVkLCBmYWxsYmFjayBvbiB0aGlzLl9maXJzdExldmVsIChmaXJzdCBxdWFsaXR5IGxldmVsIGFwcGVhcmluZyBpbiB2YXJpYW50IG1hbmlmZXN0KVxuICAgICAgICAgICAgaWYgKHRoaXMuX3N0YXJ0TGV2ZWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHZhciBjb25maWdTdGFydExldmVsID0gdGhpcy5obHMuY29uZmlnLnN0YXJ0TGV2ZWw7XG4gICAgICAgICAgICAgICAgaWYgKGNvbmZpZ1N0YXJ0TGV2ZWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29uZmlnU3RhcnRMZXZlbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9maXJzdExldmVsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdGFydExldmVsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChuZXdMZXZlbCkge1xuICAgICAgICAgICAgdGhpcy5fc3RhcnRMZXZlbCA9IG5ld0xldmVsO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBMZXZlbENvbnRyb2xsZXIucHJvdG90eXBlLm9uRXJyb3IgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICBpZiAoZGF0YS5mYXRhbCkge1xuICAgICAgICAgICAgaWYgKGRhdGEudHlwZSA9PT0gZXJyb3JzXzEuRXJyb3JUeXBlcy5ORVRXT1JLX0VSUk9SKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jbGVhclRpbWVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxldmVsRXJyb3IgPSBmYWxzZSwgZnJhZ21lbnRFcnJvciA9IGZhbHNlO1xuICAgICAgICB2YXIgbGV2ZWxJbmRleDtcbiAgICAgICAgLy8gdHJ5IHRvIHJlY292ZXIgbm90IGZhdGFsIGVycm9yc1xuICAgICAgICBzd2l0Y2ggKGRhdGEuZGV0YWlscykge1xuICAgICAgICAgICAgY2FzZSBlcnJvcnNfMS5FcnJvckRldGFpbHMuRlJBR19MT0FEX0VSUk9SOlxuICAgICAgICAgICAgY2FzZSBlcnJvcnNfMS5FcnJvckRldGFpbHMuRlJBR19MT0FEX1RJTUVPVVQ6XG4gICAgICAgICAgICBjYXNlIGVycm9yc18xLkVycm9yRGV0YWlscy5LRVlfTE9BRF9FUlJPUjpcbiAgICAgICAgICAgIGNhc2UgZXJyb3JzXzEuRXJyb3JEZXRhaWxzLktFWV9MT0FEX1RJTUVPVVQ6XG4gICAgICAgICAgICAgICAgbGV2ZWxJbmRleCA9IGRhdGEuZnJhZy5sZXZlbDtcbiAgICAgICAgICAgICAgICBmcmFnbWVudEVycm9yID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgZXJyb3JzXzEuRXJyb3JEZXRhaWxzLkxFVkVMX0xPQURfRVJST1I6XG4gICAgICAgICAgICBjYXNlIGVycm9yc18xLkVycm9yRGV0YWlscy5MRVZFTF9MT0FEX1RJTUVPVVQ6XG4gICAgICAgICAgICAgICAgbGV2ZWxJbmRleCA9IGRhdGEuY29udGV4dC5sZXZlbDtcbiAgICAgICAgICAgICAgICBsZXZlbEVycm9yID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgZXJyb3JzXzEuRXJyb3JEZXRhaWxzLlJFTVVYX0FMTE9DX0VSUk9SOlxuICAgICAgICAgICAgICAgIGxldmVsSW5kZXggPSBkYXRhLmxldmVsO1xuICAgICAgICAgICAgICAgIGxldmVsRXJyb3IgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsZXZlbEluZGV4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMucmVjb3ZlckxldmVsKGRhdGEsIGxldmVsSW5kZXgsIGxldmVsRXJyb3IsIGZyYWdtZW50RXJyb3IpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTd2l0Y2ggdG8gYSByZWR1bmRhbnQgc3RyZWFtIGlmIGFueSBhdmFpbGFibGUuXG4gICAgICogSWYgcmVkdW5kYW50IHN0cmVhbSBpcyBub3QgYXZhaWxhYmxlLCBlbWVyZ2VuY3kgc3dpdGNoIGRvd24gaWYgQUJSIG1vZGUgaXMgZW5hYmxlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlcnJvckV2ZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxldmVsSW5kZXggY3VycmVudCBsZXZlbCBpbmRleFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gbGV2ZWxFcnJvclxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gZnJhZ21lbnRFcnJvclxuICAgICAqL1xuICAgIC8vIEZJWE1FIEZpbmQgYSBiZXR0ZXIgYWJzdHJhY3Rpb24gd2hlcmUgZnJhZ21lbnQvbGV2ZWwgcmV0cnkgbWFuYWdlbWVudCBpcyB3ZWxsIGRlY291cGxlZFxuICAgIExldmVsQ29udHJvbGxlci5wcm90b3R5cGUucmVjb3ZlckxldmVsID0gZnVuY3Rpb24gKGVycm9yRXZlbnQsIGxldmVsSW5kZXgsIGxldmVsRXJyb3IsIGZyYWdtZW50RXJyb3IpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGNvbmZpZyA9IHRoaXMuaGxzLmNvbmZpZztcbiAgICAgICAgdmFyIGVycm9yRGV0YWlscyA9IGVycm9yRXZlbnQuZGV0YWlscztcbiAgICAgICAgdmFyIGxldmVsID0gdGhpcy5fbGV2ZWxzW2xldmVsSW5kZXhdO1xuICAgICAgICB2YXIgcmVkdW5kYW50TGV2ZWxzLCBkZWxheSwgbmV4dExldmVsO1xuICAgICAgICBsZXZlbC5sb2FkRXJyb3IrKztcbiAgICAgICAgbGV2ZWwuZnJhZ21lbnRFcnJvciA9IGZyYWdtZW50RXJyb3I7XG4gICAgICAgIGlmIChsZXZlbEVycm9yKSB7XG4gICAgICAgICAgICBpZiAoKHRoaXMubGV2ZWxSZXRyeUNvdW50ICsgMSkgPD0gY29uZmlnLmxldmVsTG9hZGluZ01heFJldHJ5KSB7XG4gICAgICAgICAgICAgICAgLy8gZXhwb25lbnRpYWwgYmFja29mZiBjYXBwZWQgdG8gbWF4IHJldHJ5IHRpbWVvdXRcbiAgICAgICAgICAgICAgICBkZWxheSA9IE1hdGgubWluKE1hdGgucG93KDIsIHRoaXMubGV2ZWxSZXRyeUNvdW50KSAqIGNvbmZpZy5sZXZlbExvYWRpbmdSZXRyeURlbGF5LCBjb25maWcubGV2ZWxMb2FkaW5nTWF4UmV0cnlUaW1lb3V0KTtcbiAgICAgICAgICAgICAgICAvLyBTY2hlZHVsZSBsZXZlbCByZWxvYWRcbiAgICAgICAgICAgICAgICB0aGlzLnRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5sb2FkTGV2ZWwoKTsgfSwgZGVsYXkpO1xuICAgICAgICAgICAgICAgIC8vIGJvb2xlYW4gdXNlZCB0byBpbmZvcm0gc3RyZWFtIGNvbnRyb2xsZXIgbm90IHRvIHN3aXRjaCBiYWNrIHRvIElETEUgb24gbm9uIGZhdGFsIGVycm9yXG4gICAgICAgICAgICAgICAgZXJyb3JFdmVudC5sZXZlbFJldHJ5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmxldmVsUmV0cnlDb3VudCsrO1xuICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmxvZ2dlci53YXJuKFwibGV2ZWwgY29udHJvbGxlciwgXCIgKyBlcnJvckRldGFpbHMgKyBcIiwgcmV0cnkgaW4gXCIgKyBkZWxheSArIFwiIG1zLCBjdXJyZW50IHJldHJ5IGNvdW50IGlzIFwiICsgdGhpcy5sZXZlbFJldHJ5Q291bnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLmVycm9yKFwibGV2ZWwgY29udHJvbGxlciwgY2Fubm90IHJlY292ZXIgZnJvbSBcIiArIGVycm9yRGV0YWlscyArIFwiIGVycm9yXCIpO1xuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudExldmVsSW5kZXggPSBudWxsO1xuICAgICAgICAgICAgICAgIC8vIHN0b3BwaW5nIGxpdmUgcmVsb2FkaW5nIHRpbWVyIGlmIGFueVxuICAgICAgICAgICAgICAgIHRoaXMuY2xlYXJUaW1lcigpO1xuICAgICAgICAgICAgICAgIC8vIHN3aXRjaCBlcnJvciB0byBmYXRhbFxuICAgICAgICAgICAgICAgIGVycm9yRXZlbnQuZmF0YWwgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBUcnkgYW55IHJlZHVuZGFudCBzdHJlYW1zIGlmIGF2YWlsYWJsZSBmb3IgYm90aCBlcnJvcnM6IGxldmVsIGFuZCBmcmFnbWVudFxuICAgICAgICAvLyBJZiBsZXZlbC5sb2FkRXJyb3IgcmVhY2hlcyByZWR1bmRhbnRMZXZlbHMgaXQgbWVhbnMgdGhhdCB3ZSB0cmllZCB0aGVtIGFsbCwgbm8gaG9wZSAgPT4gbGV0J3Mgc3dpdGNoIGRvd25cbiAgICAgICAgaWYgKGxldmVsRXJyb3IgfHwgZnJhZ21lbnRFcnJvcikge1xuICAgICAgICAgICAgcmVkdW5kYW50TGV2ZWxzID0gbGV2ZWwudXJsLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChyZWR1bmRhbnRMZXZlbHMgPiAxICYmIGxldmVsLmxvYWRFcnJvciA8IHJlZHVuZGFudExldmVscykge1xuICAgICAgICAgICAgICAgIGxldmVsLnVybElkID0gKGxldmVsLnVybElkICsgMSkgJSByZWR1bmRhbnRMZXZlbHM7XG4gICAgICAgICAgICAgICAgbGV2ZWwuZGV0YWlscyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBsb2dnZXJfMS5sb2dnZXIud2FybihcImxldmVsIGNvbnRyb2xsZXIsIFwiICsgZXJyb3JEZXRhaWxzICsgXCIgZm9yIGxldmVsIFwiICsgbGV2ZWxJbmRleCArIFwiOiBzd2l0Y2hpbmcgdG8gcmVkdW5kYW50IFVSTC1pZCBcIiArIGxldmVsLnVybElkKTtcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnQ3VycmVudCBhdWRpbyB0cmFjayBncm91cCBJRDonLCB0aGlzLmhscy5hdWRpb1RyYWNrc1t0aGlzLmhscy5hdWRpb1RyYWNrXS5ncm91cElkKTtcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnTmV3IHZpZGVvIHF1YWxpdHkgbGV2ZWwgYXVkaW8gZ3JvdXAgaWQ6JywgbGV2ZWwuYXR0cnMuQVVESU8pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gU2VhcmNoIGZvciBhdmFpbGFibGUgbGV2ZWxcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5tYW51YWxMZXZlbEluZGV4ID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBXaGVuIGxvd2VzdCBsZXZlbCBoYXMgYmVlbiByZWFjaGVkLCBsZXQncyBzdGFydCBodW50IGZyb20gdGhlIHRvcFxuICAgICAgICAgICAgICAgICAgICBuZXh0TGV2ZWwgPSAobGV2ZWxJbmRleCA9PT0gMCkgPyB0aGlzLl9sZXZlbHMubGVuZ3RoIC0gMSA6IGxldmVsSW5kZXggLSAxO1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXJfMS5sb2dnZXIud2FybihcImxldmVsIGNvbnRyb2xsZXIsIFwiICsgZXJyb3JEZXRhaWxzICsgXCI6IHN3aXRjaCB0byBcIiArIG5leHRMZXZlbCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGxzLm5leHRBdXRvTGV2ZWwgPSB0aGlzLmN1cnJlbnRMZXZlbEluZGV4ID0gbmV4dExldmVsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChmcmFnbWVudEVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFsbG93IGZyYWdtZW50IHJldHJ5IGFzIGxvbmcgYXMgY29uZmlndXJhdGlvbiBhbGxvd3MuXG4gICAgICAgICAgICAgICAgICAgIC8vIHJlc2V0IHRoaXMuX2xldmVsIHNvIHRoYXQgYW5vdGhlciBjYWxsIHRvIHNldCBsZXZlbCgpIHdpbGwgdHJpZ2dlciBhZ2FpbiBhIGZyYWcgbG9hZFxuICAgICAgICAgICAgICAgICAgICBsb2dnZXJfMS5sb2dnZXIud2FybihcImxldmVsIGNvbnRyb2xsZXIsIFwiICsgZXJyb3JEZXRhaWxzICsgXCI6IHJlbG9hZCBhIGZyYWdtZW50XCIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRMZXZlbEluZGV4ID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIHJlc2V0IGVycm9ycyBvbiB0aGUgc3VjY2Vzc2Z1bCBsb2FkIG9mIGEgZnJhZ21lbnRcbiAgICBMZXZlbENvbnRyb2xsZXIucHJvdG90eXBlLm9uRnJhZ0xvYWRlZCA9IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgZnJhZyA9IF9hLmZyYWc7XG4gICAgICAgIGlmIChmcmFnICE9PSB1bmRlZmluZWQgJiYgZnJhZy50eXBlID09PSAnbWFpbicpIHtcbiAgICAgICAgICAgIHZhciBsZXZlbCA9IHRoaXMuX2xldmVsc1tmcmFnLmxldmVsXTtcbiAgICAgICAgICAgIGlmIChsZXZlbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbGV2ZWwuZnJhZ21lbnRFcnJvciA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGxldmVsLmxvYWRFcnJvciA9IDA7XG4gICAgICAgICAgICAgICAgdGhpcy5sZXZlbFJldHJ5Q291bnQgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBMZXZlbENvbnRyb2xsZXIucHJvdG90eXBlLm9uTGV2ZWxMb2FkZWQgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgbGV2ZWwgPSBkYXRhLmxldmVsLCBkZXRhaWxzID0gZGF0YS5kZXRhaWxzO1xuICAgICAgICAvLyBvbmx5IHByb2Nlc3MgbGV2ZWwgbG9hZGVkIGV2ZW50cyBtYXRjaGluZyB3aXRoIGV4cGVjdGVkIGxldmVsXG4gICAgICAgIGlmIChsZXZlbCAhPT0gdGhpcy5jdXJyZW50TGV2ZWxJbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjdXJMZXZlbCA9IHRoaXMuX2xldmVsc1tsZXZlbF07XG4gICAgICAgIC8vIHJlc2V0IGxldmVsIGxvYWQgZXJyb3IgY291bnRlciBvbiBzdWNjZXNzZnVsIGxldmVsIGxvYWRlZCBvbmx5IGlmIHRoZXJlIGlzIG5vIGlzc3VlcyB3aXRoIGZyYWdtZW50c1xuICAgICAgICBpZiAoIWN1ckxldmVsLmZyYWdtZW50RXJyb3IpIHtcbiAgICAgICAgICAgIGN1ckxldmVsLmxvYWRFcnJvciA9IDA7XG4gICAgICAgICAgICB0aGlzLmxldmVsUmV0cnlDb3VudCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgY3VycmVudCBwbGF5bGlzdCBpcyBhIGxpdmUgcGxheWxpc3QsIGFybSBhIHRpbWVyIHRvIHJlbG9hZCBpdFxuICAgICAgICBpZiAoZGV0YWlscy5saXZlKSB7XG4gICAgICAgICAgICB2YXIgcmVsb2FkSW50ZXJ2YWwgPSBsZXZlbF9oZWxwZXJfMS5jb21wdXRlUmVsb2FkSW50ZXJ2YWwoY3VyTGV2ZWwuZGV0YWlscywgZGV0YWlscywgZGF0YS5zdGF0cy50cmVxdWVzdCk7XG4gICAgICAgICAgICBsb2dnZXJfMS5sb2dnZXIubG9nKFwibGl2ZSBwbGF5bGlzdCwgcmVsb2FkIGluIFwiICsgTWF0aC5yb3VuZChyZWxvYWRJbnRlcnZhbCkgKyBcIiBtc1wiKTtcbiAgICAgICAgICAgIHRoaXMudGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLmxvYWRMZXZlbCgpOyB9LCByZWxvYWRJbnRlcnZhbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNsZWFyVGltZXIoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTGV2ZWxDb250cm9sbGVyLnByb3RvdHlwZS5vbkF1ZGlvVHJhY2tTd2l0Y2hlZCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHZhciBhdWRpb0dyb3VwSWQgPSB0aGlzLmhscy5hdWRpb1RyYWNrc1tkYXRhLmlkXS5ncm91cElkO1xuICAgICAgICB2YXIgY3VycmVudExldmVsID0gdGhpcy5obHMubGV2ZWxzW3RoaXMuY3VycmVudExldmVsSW5kZXhdO1xuICAgICAgICBpZiAoIWN1cnJlbnRMZXZlbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjdXJyZW50TGV2ZWwuYXVkaW9Hcm91cElkcykge1xuICAgICAgICAgICAgdmFyIHVybElkID0gLTE7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGN1cnJlbnRMZXZlbC5hdWRpb0dyb3VwSWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRMZXZlbC5hdWRpb0dyb3VwSWRzW2ldID09PSBhdWRpb0dyb3VwSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdXJsSWQgPSBpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodXJsSWQgIT09IGN1cnJlbnRMZXZlbC51cmxJZCkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRMZXZlbC51cmxJZCA9IHVybElkO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRMb2FkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIExldmVsQ29udHJvbGxlci5wcm90b3R5cGUubG9hZExldmVsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBsb2dnZXJfMS5sb2dnZXIuZGVidWcoJ2NhbGwgdG8gbG9hZExldmVsJyk7XG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRMZXZlbEluZGV4ICE9PSBudWxsICYmIHRoaXMuY2FubG9hZCkge1xuICAgICAgICAgICAgdmFyIGxldmVsT2JqZWN0ID0gdGhpcy5fbGV2ZWxzW3RoaXMuY3VycmVudExldmVsSW5kZXhdO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBsZXZlbE9iamVjdCA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgICAgICBsZXZlbE9iamVjdC51cmwubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHZhciBsZXZlbCA9IHRoaXMuY3VycmVudExldmVsSW5kZXg7XG4gICAgICAgICAgICAgICAgdmFyIGlkID0gbGV2ZWxPYmplY3QudXJsSWQ7XG4gICAgICAgICAgICAgICAgdmFyIHVybCA9IGxldmVsT2JqZWN0LnVybFtpZF07XG4gICAgICAgICAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLmxvZyhcIkF0dGVtcHQgbG9hZGluZyBsZXZlbCBpbmRleCBcIiArIGxldmVsICsgXCIgd2l0aCBVUkwtaWQgXCIgKyBpZCk7XG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ0N1cnJlbnQgYXVkaW8gdHJhY2sgZ3JvdXAgSUQ6JywgdGhpcy5obHMuYXVkaW9UcmFja3NbdGhpcy5obHMuYXVkaW9UcmFja10uZ3JvdXBJZCk7XG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ05ldyB2aWRlbyBxdWFsaXR5IGxldmVsIGF1ZGlvIGdyb3VwIGlkOicsIGxldmVsT2JqZWN0LmF0dHJzLkFVRElPLCBsZXZlbCk7XG4gICAgICAgICAgICAgICAgdGhpcy5obHMudHJpZ2dlcihldmVudHNfMS5kZWZhdWx0LkxFVkVMX0xPQURJTkcsIHsgdXJsOiB1cmwsIGxldmVsOiBsZXZlbCwgaWQ6IGlkIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTGV2ZWxDb250cm9sbGVyLnByb3RvdHlwZSwgXCJuZXh0TG9hZExldmVsXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5tYW51YWxMZXZlbEluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm1hbnVhbExldmVsSW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5obHMubmV4dEF1dG9MZXZlbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAobmV4dExldmVsKSB7XG4gICAgICAgICAgICB0aGlzLmxldmVsID0gbmV4dExldmVsO1xuICAgICAgICAgICAgaWYgKHRoaXMubWFudWFsTGV2ZWxJbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhscy5uZXh0QXV0b0xldmVsID0gbmV4dExldmVsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gTGV2ZWxDb250cm9sbGVyO1xufShldmVudF9oYW5kbGVyXzEuZGVmYXVsdCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gTGV2ZWxDb250cm9sbGVyO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2NvbnRyb2xsZXIvbGV2ZWwtaGVscGVyLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2NvbnRyb2xsZXIvbGV2ZWwtaGVscGVyLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovKGZ1bmN0aW9uKE51bWJlcikge1xuLyoqXG4gKiBAbW9kdWxlIExldmVsSGVscGVyXG4gKlxuICogUHJvdmlkaW5nIG1ldGhvZHMgZGVhbGluZyB3aXRoIHBsYXlsaXN0IHNsaWRpbmcgYW5kIGRyaWZ0XG4gKlxuICogVE9ETzogQ3JlYXRlIGFuIGFjdHVhbCBgTGV2ZWxgIGNsYXNzL21vZGVsIHRoYXQgZGVhbHMgd2l0aCBhbGwgdGhpcyBsb2dpYyBpbiBhbiBvYmplY3Qtb3JpZW50ZWQtbWFubmVyLlxuICpcbiAqICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgbG9nZ2VyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy9sb2dnZXIgKi8gXCIuL3NyYy91dGlscy9sb2dnZXIuanNcIik7XG5mdW5jdGlvbiBhZGRHcm91cElkKGxldmVsLCB0eXBlLCBpZCkge1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlICdhdWRpbyc6XG4gICAgICAgICAgICBpZiAoIWxldmVsLmF1ZGlvR3JvdXBJZHMpIHtcbiAgICAgICAgICAgICAgICBsZXZlbC5hdWRpb0dyb3VwSWRzID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXZlbC5hdWRpb0dyb3VwSWRzLnB1c2goaWQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3RleHQnOlxuICAgICAgICAgICAgaWYgKCFsZXZlbC50ZXh0R3JvdXBJZHMpIHtcbiAgICAgICAgICAgICAgICBsZXZlbC50ZXh0R3JvdXBJZHMgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldmVsLnRleHRHcm91cElkcy5wdXNoKGlkKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbn1cbmV4cG9ydHMuYWRkR3JvdXBJZCA9IGFkZEdyb3VwSWQ7XG5mdW5jdGlvbiB1cGRhdGVQVFMoZnJhZ21lbnRzLCBmcm9tSWR4LCB0b0lkeCkge1xuICAgIHZhciBmcmFnRnJvbSA9IGZyYWdtZW50c1tmcm9tSWR4XSwgZnJhZ1RvID0gZnJhZ21lbnRzW3RvSWR4XSwgZnJhZ1RvUFRTID0gZnJhZ1RvLnN0YXJ0UFRTO1xuICAgIC8vIGlmIHdlIGtub3cgc3RhcnRQVFNbdG9JZHhdXG4gICAgaWYgKE51bWJlci5pc0Zpbml0ZShmcmFnVG9QVFMpKSB7XG4gICAgICAgIC8vIHVwZGF0ZSBmcmFnbWVudCBkdXJhdGlvbi5cbiAgICAgICAgLy8gaXQgaGVscHMgdG8gZml4IGRyaWZ0cyBiZXR3ZWVuIHBsYXlsaXN0IHJlcG9ydGVkIGR1cmF0aW9uIGFuZCBmcmFnbWVudCByZWFsIGR1cmF0aW9uXG4gICAgICAgIGlmICh0b0lkeCA+IGZyb21JZHgpIHtcbiAgICAgICAgICAgIGZyYWdGcm9tLmR1cmF0aW9uID0gZnJhZ1RvUFRTIC0gZnJhZ0Zyb20uc3RhcnQ7XG4gICAgICAgICAgICBpZiAoZnJhZ0Zyb20uZHVyYXRpb24gPCAwKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLndhcm4oXCJuZWdhdGl2ZSBkdXJhdGlvbiBjb21wdXRlZCBmb3IgZnJhZyBcIiArIGZyYWdGcm9tLnNuICsgXCIsbGV2ZWwgXCIgKyBmcmFnRnJvbS5sZXZlbCArIFwiLCB0aGVyZSBzaG91bGQgYmUgc29tZSBkdXJhdGlvbiBkcmlmdCBiZXR3ZWVuIHBsYXlsaXN0IGFuZCBmcmFnbWVudCFcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmcmFnVG8uZHVyYXRpb24gPSBmcmFnRnJvbS5zdGFydCAtIGZyYWdUb1BUUztcbiAgICAgICAgICAgIGlmIChmcmFnVG8uZHVyYXRpb24gPCAwKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLndhcm4oXCJuZWdhdGl2ZSBkdXJhdGlvbiBjb21wdXRlZCBmb3IgZnJhZyBcIiArIGZyYWdUby5zbiArIFwiLGxldmVsIFwiICsgZnJhZ1RvLmxldmVsICsgXCIsIHRoZXJlIHNob3VsZCBiZSBzb21lIGR1cmF0aW9uIGRyaWZ0IGJldHdlZW4gcGxheWxpc3QgYW5kIGZyYWdtZW50IVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gd2UgZG9udCBrbm93IHN0YXJ0UFRTW3RvSWR4XVxuICAgICAgICBpZiAodG9JZHggPiBmcm9tSWR4KSB7XG4gICAgICAgICAgICBmcmFnVG8uc3RhcnQgPSBmcmFnRnJvbS5zdGFydCArIGZyYWdGcm9tLmR1cmF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZnJhZ1RvLnN0YXJ0ID0gTWF0aC5tYXgoZnJhZ0Zyb20uc3RhcnQgLSBmcmFnVG8uZHVyYXRpb24sIDApO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy51cGRhdGVQVFMgPSB1cGRhdGVQVFM7XG5mdW5jdGlvbiB1cGRhdGVGcmFnUFRTRFRTKGRldGFpbHMsIGZyYWcsIHN0YXJ0UFRTLCBlbmRQVFMsIHN0YXJ0RFRTLCBlbmREVFMpIHtcbiAgICAvLyB1cGRhdGUgZnJhZyBQVFMvRFRTXG4gICAgdmFyIG1heFN0YXJ0UFRTID0gc3RhcnRQVFM7XG4gICAgaWYgKE51bWJlci5pc0Zpbml0ZShmcmFnLnN0YXJ0UFRTKSkge1xuICAgICAgICAvLyBkZWx0YSBQVFMgYmV0d2VlbiBhdWRpbyBhbmQgdmlkZW9cbiAgICAgICAgdmFyIGRlbHRhUFRTID0gTWF0aC5hYnMoZnJhZy5zdGFydFBUUyAtIHN0YXJ0UFRTKTtcbiAgICAgICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoZnJhZy5kZWx0YVBUUykpIHtcbiAgICAgICAgICAgIGZyYWcuZGVsdGFQVFMgPSBkZWx0YVBUUztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZyYWcuZGVsdGFQVFMgPSBNYXRoLm1heChkZWx0YVBUUywgZnJhZy5kZWx0YVBUUyk7XG4gICAgICAgIH1cbiAgICAgICAgbWF4U3RhcnRQVFMgPSBNYXRoLm1heChzdGFydFBUUywgZnJhZy5zdGFydFBUUyk7XG4gICAgICAgIHN0YXJ0UFRTID0gTWF0aC5taW4oc3RhcnRQVFMsIGZyYWcuc3RhcnRQVFMpO1xuICAgICAgICBlbmRQVFMgPSBNYXRoLm1heChlbmRQVFMsIGZyYWcuZW5kUFRTKTtcbiAgICAgICAgc3RhcnREVFMgPSBNYXRoLm1pbihzdGFydERUUywgZnJhZy5zdGFydERUUyk7XG4gICAgICAgIGVuZERUUyA9IE1hdGgubWF4KGVuZERUUywgZnJhZy5lbmREVFMpO1xuICAgIH1cbiAgICB2YXIgZHJpZnQgPSBzdGFydFBUUyAtIGZyYWcuc3RhcnQ7XG4gICAgZnJhZy5zdGFydCA9IGZyYWcuc3RhcnRQVFMgPSBzdGFydFBUUztcbiAgICBmcmFnLm1heFN0YXJ0UFRTID0gbWF4U3RhcnRQVFM7XG4gICAgZnJhZy5lbmRQVFMgPSBlbmRQVFM7XG4gICAgZnJhZy5zdGFydERUUyA9IHN0YXJ0RFRTO1xuICAgIGZyYWcuZW5kRFRTID0gZW5kRFRTO1xuICAgIGZyYWcuZHVyYXRpb24gPSBlbmRQVFMgLSBzdGFydFBUUztcbiAgICB2YXIgc24gPSBmcmFnLnNuO1xuICAgIC8vIGV4aXQgaWYgc24gb3V0IG9mIHJhbmdlXG4gICAgaWYgKCFkZXRhaWxzIHx8IHNuIDwgZGV0YWlscy5zdGFydFNOIHx8IHNuID4gZGV0YWlscy5lbmRTTikge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgdmFyIGZyYWdJZHgsIGZyYWdtZW50cywgaTtcbiAgICBmcmFnSWR4ID0gc24gLSBkZXRhaWxzLnN0YXJ0U047XG4gICAgZnJhZ21lbnRzID0gZGV0YWlscy5mcmFnbWVudHM7XG4gICAgLy8gdXBkYXRlIGZyYWcgcmVmZXJlbmNlIGluIGZyYWdtZW50cyBhcnJheVxuICAgIC8vIHJhdGlvbmFsZSBpcyB0aGF0IGZyYWdtZW50cyBhcnJheSBtaWdodCBub3QgY29udGFpbiB0aGlzIGZyYWcgb2JqZWN0LlxuICAgIC8vIHRoaXMgd2lsbCBoYXBwZW4gaWYgcGxheWxpc3QgaGFzIGJlZW4gcmVmcmVzaGVkIGJldHdlZW4gZnJhZyBsb2FkaW5nIGFuZCBjYWxsIHRvIHVwZGF0ZUZyYWdQVFNEVFMoKVxuICAgIC8vIGlmIHdlIGRvbid0IHVwZGF0ZSBmcmFnLCB3ZSB3b24ndCBiZSBhYmxlIHRvIHByb3BhZ2F0ZSBQVFMgaW5mbyBvbiB0aGUgcGxheWxpc3RcbiAgICAvLyByZXN1bHRpbmcgaW4gaW52YWxpZCBzbGlkaW5nIGNvbXB1dGF0aW9uXG4gICAgZnJhZ21lbnRzW2ZyYWdJZHhdID0gZnJhZztcbiAgICAvLyBhZGp1c3QgZnJhZ21lbnQgUFRTL2R1cmF0aW9uIGZyb20gc2VxbnVtLTEgdG8gZnJhZyAwXG4gICAgZm9yIChpID0gZnJhZ0lkeDsgaSA+IDA7IGktLSkge1xuICAgICAgICB1cGRhdGVQVFMoZnJhZ21lbnRzLCBpLCBpIC0gMSk7XG4gICAgfVxuICAgIC8vIGFkanVzdCBmcmFnbWVudCBQVFMvZHVyYXRpb24gZnJvbSBzZXFudW0gdG8gbGFzdCBmcmFnXG4gICAgZm9yIChpID0gZnJhZ0lkeDsgaSA8IGZyYWdtZW50cy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgdXBkYXRlUFRTKGZyYWdtZW50cywgaSwgaSArIDEpO1xuICAgIH1cbiAgICBkZXRhaWxzLlBUU0tub3duID0gdHJ1ZTtcbiAgICByZXR1cm4gZHJpZnQ7XG59XG5leHBvcnRzLnVwZGF0ZUZyYWdQVFNEVFMgPSB1cGRhdGVGcmFnUFRTRFRTO1xuZnVuY3Rpb24gbWVyZ2VEZXRhaWxzKG9sZERldGFpbHMsIG5ld0RldGFpbHMpIHtcbiAgICAvLyBwb3RlbnRpYWxseSByZXRyaWV2ZSBjYWNoZWQgaW5pdHNlZ21lbnRcbiAgICBpZiAobmV3RGV0YWlscy5pbml0U2VnbWVudCAmJiBvbGREZXRhaWxzLmluaXRTZWdtZW50KSB7XG4gICAgICAgIG5ld0RldGFpbHMuaW5pdFNlZ21lbnQgPSBvbGREZXRhaWxzLmluaXRTZWdtZW50O1xuICAgIH1cbiAgICAvLyBjaGVjayBpZiBvbGQvbmV3IHBsYXlsaXN0cyBoYXZlIGZyYWdtZW50cyBpbiBjb21tb25cbiAgICAvLyBsb29wIHRocm91Z2ggb3ZlcmxhcHBpbmcgU04gYW5kIHVwZGF0ZSBzdGFydFBUUyAsIGNjLCBhbmQgZHVyYXRpb24gaWYgYW55IGZvdW5kXG4gICAgdmFyIGNjT2Zmc2V0ID0gMDtcbiAgICB2YXIgUFRTRnJhZztcbiAgICBtYXBGcmFnbWVudEludGVyc2VjdGlvbihvbGREZXRhaWxzLCBuZXdEZXRhaWxzLCBmdW5jdGlvbiAob2xkRnJhZywgbmV3RnJhZykge1xuICAgICAgICBjY09mZnNldCA9IG9sZEZyYWcuY2MgLSBuZXdGcmFnLmNjO1xuICAgICAgICBpZiAoTnVtYmVyLmlzRmluaXRlKG9sZEZyYWcuc3RhcnRQVFMpKSB7XG4gICAgICAgICAgICBuZXdGcmFnLnN0YXJ0ID0gbmV3RnJhZy5zdGFydFBUUyA9IG9sZEZyYWcuc3RhcnRQVFM7XG4gICAgICAgICAgICBuZXdGcmFnLmVuZFBUUyA9IG9sZEZyYWcuZW5kUFRTO1xuICAgICAgICAgICAgbmV3RnJhZy5kdXJhdGlvbiA9IG9sZEZyYWcuZHVyYXRpb247XG4gICAgICAgICAgICBuZXdGcmFnLmJhY2t0cmFja2VkID0gb2xkRnJhZy5iYWNrdHJhY2tlZDtcbiAgICAgICAgICAgIG5ld0ZyYWcuZHJvcHBlZCA9IG9sZEZyYWcuZHJvcHBlZDtcbiAgICAgICAgICAgIFBUU0ZyYWcgPSBuZXdGcmFnO1xuICAgICAgICB9XG4gICAgICAgIC8vIFBUUyBpcyBrbm93biB3aGVuIHRoZXJlIGFyZSBvdmVybGFwcGluZyBzZWdtZW50c1xuICAgICAgICBuZXdEZXRhaWxzLlBUU0tub3duID0gdHJ1ZTtcbiAgICB9KTtcbiAgICBpZiAoIW5ld0RldGFpbHMuUFRTS25vd24pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoY2NPZmZzZXQpIHtcbiAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLmxvZygnZGlzY29udGludWl0eSBzbGlkaW5nIGZyb20gcGxheWxpc3QsIHRha2UgZHJpZnQgaW50byBhY2NvdW50Jyk7XG4gICAgICAgIHZhciBuZXdGcmFnbWVudHMgPSBuZXdEZXRhaWxzLmZyYWdtZW50cztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZXdGcmFnbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIG5ld0ZyYWdtZW50c1tpXS5jYyArPSBjY09mZnNldDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBpZiBhdCBsZWFzdCBvbmUgZnJhZ21lbnQgY29udGFpbnMgUFRTIGluZm8sIHJlY29tcHV0ZSBQVFMgaW5mb3JtYXRpb24gZm9yIGFsbCBmcmFnbWVudHNcbiAgICBpZiAoUFRTRnJhZykge1xuICAgICAgICB1cGRhdGVGcmFnUFRTRFRTKG5ld0RldGFpbHMsIFBUU0ZyYWcsIFBUU0ZyYWcuc3RhcnRQVFMsIFBUU0ZyYWcuZW5kUFRTLCBQVFNGcmFnLnN0YXJ0RFRTLCBQVFNGcmFnLmVuZERUUyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBlbnN1cmUgdGhhdCBkZWx0YSBpcyB3aXRoaW4gb2xkRnJhZ21lbnRzIHJhbmdlXG4gICAgICAgIC8vIGFsc28gYWRqdXN0IHNsaWRpbmcgaW4gY2FzZSBkZWx0YSBpcyAwICh3ZSBjb3VsZCBoYXZlIG9sZD1bNTAtNjBdIGFuZCBuZXc9b2xkPVs1MC02MV0pXG4gICAgICAgIC8vIGluIHRoYXQgY2FzZSB3ZSBhbHNvIG5lZWQgdG8gYWRqdXN0IHN0YXJ0IG9mZnNldCBvZiBhbGwgZnJhZ21lbnRzXG4gICAgICAgIGFkanVzdFNsaWRpbmcob2xkRGV0YWlscywgbmV3RGV0YWlscyk7XG4gICAgfVxuICAgIC8vIGlmIHdlIGFyZSBoZXJlLCBpdCBtZWFucyB3ZSBoYXZlIGZyYWdtZW50cyBvdmVybGFwcGluZyBiZXR3ZWVuXG4gICAgLy8gb2xkIGFuZCBuZXcgbGV2ZWwuIHJlbGlhYmxlIFBUUyBpbmZvIGlzIHRodXMgcmVseWluZyBvbiBvbGQgbGV2ZWxcbiAgICBuZXdEZXRhaWxzLlBUU0tub3duID0gb2xkRGV0YWlscy5QVFNLbm93bjtcbn1cbmV4cG9ydHMubWVyZ2VEZXRhaWxzID0gbWVyZ2VEZXRhaWxzO1xuZnVuY3Rpb24gbWVyZ2VTdWJ0aXRsZVBsYXlsaXN0cyhvbGRQbGF5bGlzdCwgbmV3UGxheWxpc3QsIHJlZmVyZW5jZVN0YXJ0KSB7XG4gICAgaWYgKHJlZmVyZW5jZVN0YXJ0ID09PSB2b2lkIDApIHsgcmVmZXJlbmNlU3RhcnQgPSAwOyB9XG4gICAgdmFyIGxhc3RJbmRleCA9IC0xO1xuICAgIG1hcEZyYWdtZW50SW50ZXJzZWN0aW9uKG9sZFBsYXlsaXN0LCBuZXdQbGF5bGlzdCwgZnVuY3Rpb24gKG9sZEZyYWcsIG5ld0ZyYWcsIGluZGV4KSB7XG4gICAgICAgIG5ld0ZyYWcuc3RhcnQgPSBvbGRGcmFnLnN0YXJ0O1xuICAgICAgICBsYXN0SW5kZXggPSBpbmRleDtcbiAgICB9KTtcbiAgICB2YXIgZnJhZ3MgPSBuZXdQbGF5bGlzdC5mcmFnbWVudHM7XG4gICAgaWYgKGxhc3RJbmRleCA8IDApIHtcbiAgICAgICAgZnJhZ3MuZm9yRWFjaChmdW5jdGlvbiAoZnJhZykge1xuICAgICAgICAgICAgZnJhZy5zdGFydCArPSByZWZlcmVuY2VTdGFydDtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IGxhc3RJbmRleCArIDE7IGkgPCBmcmFncy5sZW5ndGg7IGkrKykge1xuICAgICAgICBmcmFnc1tpXS5zdGFydCA9IChmcmFnc1tpIC0gMV0uc3RhcnQgKyBmcmFnc1tpIC0gMV0uZHVyYXRpb24pO1xuICAgIH1cbn1cbmV4cG9ydHMubWVyZ2VTdWJ0aXRsZVBsYXlsaXN0cyA9IG1lcmdlU3VidGl0bGVQbGF5bGlzdHM7XG5mdW5jdGlvbiBtYXBGcmFnbWVudEludGVyc2VjdGlvbihvbGRQbGF5bGlzdCwgbmV3UGxheWxpc3QsIGludGVyc2VjdGlvbkZuKSB7XG4gICAgaWYgKCFvbGRQbGF5bGlzdCB8fCAhbmV3UGxheWxpc3QpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgc3RhcnQgPSBNYXRoLm1heChvbGRQbGF5bGlzdC5zdGFydFNOLCBuZXdQbGF5bGlzdC5zdGFydFNOKSAtIG5ld1BsYXlsaXN0LnN0YXJ0U047XG4gICAgdmFyIGVuZCA9IE1hdGgubWluKG9sZFBsYXlsaXN0LmVuZFNOLCBuZXdQbGF5bGlzdC5lbmRTTikgLSBuZXdQbGF5bGlzdC5zdGFydFNOO1xuICAgIHZhciBkZWx0YSA9IG5ld1BsYXlsaXN0LnN0YXJ0U04gLSBvbGRQbGF5bGlzdC5zdGFydFNOO1xuICAgIGZvciAodmFyIGkgPSBzdGFydDsgaSA8PSBlbmQ7IGkrKykge1xuICAgICAgICB2YXIgb2xkRnJhZyA9IG9sZFBsYXlsaXN0LmZyYWdtZW50c1tkZWx0YSArIGldO1xuICAgICAgICB2YXIgbmV3RnJhZyA9IG5ld1BsYXlsaXN0LmZyYWdtZW50c1tpXTtcbiAgICAgICAgaWYgKCFvbGRGcmFnIHx8ICFuZXdGcmFnKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpbnRlcnNlY3Rpb25GbihvbGRGcmFnLCBuZXdGcmFnLCBpKTtcbiAgICB9XG59XG5leHBvcnRzLm1hcEZyYWdtZW50SW50ZXJzZWN0aW9uID0gbWFwRnJhZ21lbnRJbnRlcnNlY3Rpb247XG5mdW5jdGlvbiBhZGp1c3RTbGlkaW5nKG9sZFBsYXlsaXN0LCBuZXdQbGF5bGlzdCkge1xuICAgIHZhciBkZWx0YSA9IG5ld1BsYXlsaXN0LnN0YXJ0U04gLSBvbGRQbGF5bGlzdC5zdGFydFNOO1xuICAgIHZhciBvbGRGcmFnbWVudHMgPSBvbGRQbGF5bGlzdC5mcmFnbWVudHM7XG4gICAgdmFyIG5ld0ZyYWdtZW50cyA9IG5ld1BsYXlsaXN0LmZyYWdtZW50cztcbiAgICBpZiAoZGVsdGEgPCAwIHx8IGRlbHRhID4gb2xkRnJhZ21lbnRzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmV3RnJhZ21lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG5ld0ZyYWdtZW50c1tpXS5zdGFydCArPSBvbGRGcmFnbWVudHNbZGVsdGFdLnN0YXJ0O1xuICAgIH1cbn1cbmV4cG9ydHMuYWRqdXN0U2xpZGluZyA9IGFkanVzdFNsaWRpbmc7XG5mdW5jdGlvbiBjb21wdXRlUmVsb2FkSW50ZXJ2YWwoY3VycmVudFBsYXlsaXN0LCBuZXdQbGF5bGlzdCwgbGFzdFJlcXVlc3RUaW1lKSB7XG4gICAgdmFyIHJlbG9hZEludGVydmFsID0gMTAwMCAqIChuZXdQbGF5bGlzdC5hdmVyYWdldGFyZ2V0ZHVyYXRpb24gPyBuZXdQbGF5bGlzdC5hdmVyYWdldGFyZ2V0ZHVyYXRpb24gOiBuZXdQbGF5bGlzdC50YXJnZXRkdXJhdGlvbik7XG4gICAgdmFyIG1pblJlbG9hZEludGVydmFsID0gcmVsb2FkSW50ZXJ2YWwgLyAyO1xuICAgIGlmIChjdXJyZW50UGxheWxpc3QgJiYgbmV3UGxheWxpc3QuZW5kU04gPT09IGN1cnJlbnRQbGF5bGlzdC5lbmRTTikge1xuICAgICAgICAvLyBmb2xsb3cgSExTIFNwZWMsIElmIHRoZSBjbGllbnQgcmVsb2FkcyBhIFBsYXlsaXN0IGZpbGUgYW5kIGZpbmRzIHRoYXQgaXQgaGFzIG5vdFxuICAgICAgICAvLyBjaGFuZ2VkIHRoZW4gaXQgTVVTVCB3YWl0IGZvciBhIHBlcmlvZCBvZiBvbmUtaGFsZiB0aGUgdGFyZ2V0XG4gICAgICAgIC8vIGR1cmF0aW9uIGJlZm9yZSByZXRyeWluZy5cbiAgICAgICAgcmVsb2FkSW50ZXJ2YWwgPSBtaW5SZWxvYWRJbnRlcnZhbDtcbiAgICB9XG4gICAgaWYgKGxhc3RSZXF1ZXN0VGltZSkge1xuICAgICAgICByZWxvYWRJbnRlcnZhbCA9IE1hdGgubWF4KG1pblJlbG9hZEludGVydmFsLCByZWxvYWRJbnRlcnZhbCAtICh3aW5kb3cucGVyZm9ybWFuY2Uubm93KCkgLSBsYXN0UmVxdWVzdFRpbWUpKTtcbiAgICB9XG4gICAgLy8gaW4gYW55IGNhc2UsIGRvbid0IHJlbG9hZCBtb3JlIHRoYW4gaGFsZiBvZiB0YXJnZXQgZHVyYXRpb25cbiAgICByZXR1cm4gTWF0aC5yb3VuZChyZWxvYWRJbnRlcnZhbCk7XG59XG5leHBvcnRzLmNvbXB1dGVSZWxvYWRJbnRlcnZhbCA9IGNvbXB1dGVSZWxvYWRJbnRlcnZhbDtcblxuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovfS5jYWxsKHRoaXMsIF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vc3JjL3BvbHlmaWxscy9udW1iZXIgKi8gXCIuL3NyYy9wb2x5ZmlsbHMvbnVtYmVyLmpzXCIpW1wiTnVtYmVyXCJdKSlcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvY29udHJvbGxlci9zdHJlYW0tY29udHJvbGxlci5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2NvbnRyb2xsZXIvc3RyZWFtLWNvbnRyb2xsZXIuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihOdW1iZXIpIHtcbi8qXG4gKiBTdHJlYW0gQ29udHJvbGxlclxuKi9cbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGJpbmFyeV9zZWFyY2hfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL2JpbmFyeS1zZWFyY2ggKi8gXCIuL3NyYy91dGlscy9iaW5hcnktc2VhcmNoLmpzXCIpO1xudmFyIGJ1ZmZlcl9oZWxwZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL2J1ZmZlci1oZWxwZXIgKi8gXCIuL3NyYy91dGlscy9idWZmZXItaGVscGVyLmpzXCIpO1xudmFyIGRlbXV4ZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2RlbXV4L2RlbXV4ZXIgKi8gXCIuL3NyYy9kZW11eC9kZW11eGVyLmpzXCIpO1xudmFyIGV2ZW50c18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZXZlbnRzICovIFwiLi9zcmMvZXZlbnRzLmpzXCIpO1xudmFyIGZyYWdtZW50X3RyYWNrZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZnJhZ21lbnQtdHJhY2tlciAqLyBcIi4vc3JjL2NvbnRyb2xsZXIvZnJhZ21lbnQtdHJhY2tlci5qc1wiKTtcbnZhciBmcmFnbWVudF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vbG9hZGVyL2ZyYWdtZW50ICovIFwiLi9zcmMvbG9hZGVyL2ZyYWdtZW50LmpzXCIpO1xudmFyIHBsYXlsaXN0X2xvYWRlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vbG9hZGVyL3BsYXlsaXN0LWxvYWRlciAqLyBcIi4vc3JjL2xvYWRlci9wbGF5bGlzdC1sb2FkZXIuanNcIik7XG52YXIgTGV2ZWxIZWxwZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2xldmVsLWhlbHBlciAqLyBcIi4vc3JjL2NvbnRyb2xsZXIvbGV2ZWwtaGVscGVyLmpzXCIpO1xudmFyIHRpbWVfcmFuZ2VzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy90aW1lLXJhbmdlcyAqLyBcIi4vc3JjL3V0aWxzL3RpbWUtcmFuZ2VzLmpzXCIpO1xudmFyIGVycm9yc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZXJyb3JzICovIFwiLi9zcmMvZXJyb3JzLmpzXCIpO1xudmFyIGxvZ2dlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvbG9nZ2VyICovIFwiLi9zcmMvdXRpbHMvbG9nZ2VyLmpzXCIpO1xudmFyIGRpc2NvbnRpbnVpdGllc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvZGlzY29udGludWl0aWVzICovIFwiLi9zcmMvdXRpbHMvZGlzY29udGludWl0aWVzLmpzXCIpO1xudmFyIGZyYWdtZW50X2ZpbmRlcnNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZnJhZ21lbnQtZmluZGVycyAqLyBcIi4vc3JjL2NvbnRyb2xsZXIvZnJhZ21lbnQtZmluZGVycy5qc1wiKTtcbnZhciBnYXBfY29udHJvbGxlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9nYXAtY29udHJvbGxlciAqLyBcIi4vc3JjL2NvbnRyb2xsZXIvZ2FwLWNvbnRyb2xsZXIuanNcIik7XG52YXIgYmFzZV9zdHJlYW1fY29udHJvbGxlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9iYXNlLXN0cmVhbS1jb250cm9sbGVyICovIFwiLi9zcmMvY29udHJvbGxlci9iYXNlLXN0cmVhbS1jb250cm9sbGVyLmpzXCIpO1xudmFyIFRJQ0tfSU5URVJWQUwgPSAxMDA7IC8vIGhvdyBvZnRlbiB0byB0aWNrIGluIG1zXG52YXIgU3RyZWFtQ29udHJvbGxlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU3RyZWFtQ29udHJvbGxlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTdHJlYW1Db250cm9sbGVyKGhscywgZnJhZ21lbnRUcmFja2VyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGhscywgZXZlbnRzXzEuZGVmYXVsdC5NRURJQV9BVFRBQ0hFRCwgZXZlbnRzXzEuZGVmYXVsdC5NRURJQV9ERVRBQ0hJTkcsIGV2ZW50c18xLmRlZmF1bHQuTUFOSUZFU1RfTE9BRElORywgZXZlbnRzXzEuZGVmYXVsdC5NQU5JRkVTVF9QQVJTRUQsIGV2ZW50c18xLmRlZmF1bHQuTEVWRUxfTE9BREVELCBldmVudHNfMS5kZWZhdWx0LktFWV9MT0FERUQsIGV2ZW50c18xLmRlZmF1bHQuRlJBR19MT0FERUQsIGV2ZW50c18xLmRlZmF1bHQuRlJBR19MT0FEX0VNRVJHRU5DWV9BQk9SVEVELCBldmVudHNfMS5kZWZhdWx0LkZSQUdfUEFSU0lOR19JTklUX1NFR01FTlQsIGV2ZW50c18xLmRlZmF1bHQuRlJBR19QQVJTSU5HX0RBVEEsIGV2ZW50c18xLmRlZmF1bHQuRlJBR19QQVJTRUQsIGV2ZW50c18xLmRlZmF1bHQuRVJST1IsIGV2ZW50c18xLmRlZmF1bHQuQVVESU9fVFJBQ0tfU1dJVENISU5HLCBldmVudHNfMS5kZWZhdWx0LkFVRElPX1RSQUNLX1NXSVRDSEVELCBldmVudHNfMS5kZWZhdWx0LkJVRkZFUl9DUkVBVEVELCBldmVudHNfMS5kZWZhdWx0LkJVRkZFUl9BUFBFTkRFRCwgZXZlbnRzXzEuZGVmYXVsdC5CVUZGRVJfRkxVU0hFRCkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuZnJhZ21lbnRUcmFja2VyID0gZnJhZ21lbnRUcmFja2VyO1xuICAgICAgICBfdGhpcy5jb25maWcgPSBobHMuY29uZmlnO1xuICAgICAgICBfdGhpcy5hdWRpb0NvZGVjU3dhcCA9IGZhbHNlO1xuICAgICAgICBfdGhpcy5fc3RhdGUgPSBiYXNlX3N0cmVhbV9jb250cm9sbGVyXzEuU3RhdGUuU1RPUFBFRDtcbiAgICAgICAgX3RoaXMuc3RhbGxSZXBvcnRlZCA9IGZhbHNlO1xuICAgICAgICBfdGhpcy5nYXBDb250cm9sbGVyID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBTdHJlYW1Db250cm9sbGVyLnByb3RvdHlwZS5zdGFydExvYWQgPSBmdW5jdGlvbiAoc3RhcnRQb3NpdGlvbikge1xuICAgICAgICBpZiAodGhpcy5sZXZlbHMpIHtcbiAgICAgICAgICAgIHZhciBsYXN0Q3VycmVudFRpbWUgPSB0aGlzLmxhc3RDdXJyZW50VGltZSwgaGxzXzEgPSB0aGlzLmhscztcbiAgICAgICAgICAgIHRoaXMuc3RvcExvYWQoKTtcbiAgICAgICAgICAgIHRoaXMuc2V0SW50ZXJ2YWwoVElDS19JTlRFUlZBTCk7XG4gICAgICAgICAgICB0aGlzLmxldmVsID0gLTE7XG4gICAgICAgICAgICB0aGlzLmZyYWdMb2FkRXJyb3IgPSAwO1xuICAgICAgICAgICAgaWYgKCF0aGlzLnN0YXJ0RnJhZ1JlcXVlc3RlZCkge1xuICAgICAgICAgICAgICAgIC8vIGRldGVybWluZSBsb2FkIGxldmVsXG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0TGV2ZWwgPSBobHNfMS5zdGFydExldmVsO1xuICAgICAgICAgICAgICAgIGlmIChzdGFydExldmVsID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAvLyAtMSA6IGd1ZXNzIHN0YXJ0IExldmVsIGJ5IGRvaW5nIGEgYml0cmF0ZSB0ZXN0IGJ5IGxvYWRpbmcgZmlyc3QgZnJhZ21lbnQgb2YgbG93ZXN0IHF1YWxpdHkgbGV2ZWxcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRMZXZlbCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYml0cmF0ZVRlc3QgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBzZXQgbmV3IGxldmVsIHRvIHBsYXlsaXN0IGxvYWRlciA6IHRoaXMgd2lsbCB0cmlnZ2VyIHN0YXJ0IGxldmVsIGxvYWRcbiAgICAgICAgICAgICAgICAvLyBobHMubmV4dExvYWRMZXZlbCByZW1haW5zIHVudGlsIGl0IGlzIHNldCB0byBhIG5ldyB2YWx1ZSBvciB1bnRpbCBhIG5ldyBmcmFnIGlzIHN1Y2Nlc3NmdWxseSBsb2FkZWRcbiAgICAgICAgICAgICAgICB0aGlzLmxldmVsID0gaGxzXzEubmV4dExvYWRMZXZlbCA9IHN0YXJ0TGV2ZWw7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2FkZWRtZXRhZGF0YSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaWYgc3RhcnRQb3NpdGlvbiB1bmRlZmluZWQgYnV0IGxhc3RDdXJyZW50VGltZSBzZXQsIHNldCBzdGFydFBvc2l0aW9uIHRvIGxhc3QgY3VycmVudFRpbWVcbiAgICAgICAgICAgIGlmIChsYXN0Q3VycmVudFRpbWUgPiAwICYmIHN0YXJ0UG9zaXRpb24gPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLmxvZyhcIm92ZXJyaWRlIHN0YXJ0UG9zaXRpb24gd2l0aCBsYXN0Q3VycmVudFRpbWUgQFwiICsgbGFzdEN1cnJlbnRUaW1lLnRvRml4ZWQoMykpO1xuICAgICAgICAgICAgICAgIHN0YXJ0UG9zaXRpb24gPSBsYXN0Q3VycmVudFRpbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gYmFzZV9zdHJlYW1fY29udHJvbGxlcl8xLlN0YXRlLklETEU7XG4gICAgICAgICAgICB0aGlzLm5leHRMb2FkUG9zaXRpb24gPSB0aGlzLnN0YXJ0UG9zaXRpb24gPSB0aGlzLmxhc3RDdXJyZW50VGltZSA9IHN0YXJ0UG9zaXRpb247XG4gICAgICAgICAgICB0aGlzLnRpY2soKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZm9yY2VTdGFydExvYWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IGJhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfMS5TdGF0ZS5TVE9QUEVEO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTdHJlYW1Db250cm9sbGVyLnByb3RvdHlwZS5zdG9wTG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5mb3JjZVN0YXJ0TG9hZCA9IGZhbHNlO1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLnN0b3BMb2FkLmNhbGwodGhpcyk7XG4gICAgfTtcbiAgICBTdHJlYW1Db250cm9sbGVyLnByb3RvdHlwZS5kb1RpY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy5zdGF0ZSkge1xuICAgICAgICAgICAgY2FzZSBiYXNlX3N0cmVhbV9jb250cm9sbGVyXzEuU3RhdGUuQlVGRkVSX0ZMVVNISU5HOlxuICAgICAgICAgICAgICAgIC8vIGluIGJ1ZmZlciBmbHVzaGluZyBzdGF0ZSwgcmVzZXQgZnJhZ0xvYWRFcnJvciBjb3VudGVyXG4gICAgICAgICAgICAgICAgdGhpcy5mcmFnTG9hZEVycm9yID0gMDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgYmFzZV9zdHJlYW1fY29udHJvbGxlcl8xLlN0YXRlLklETEU6XG4gICAgICAgICAgICAgICAgdGhpcy5fZG9UaWNrSWRsZSgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBiYXNlX3N0cmVhbV9jb250cm9sbGVyXzEuU3RhdGUuV0FJVElOR19MRVZFTDpcbiAgICAgICAgICAgICAgICB2YXIgbGV2ZWwgPSB0aGlzLmxldmVsc1t0aGlzLmxldmVsXTtcbiAgICAgICAgICAgICAgICAvLyBjaGVjayBpZiBwbGF5bGlzdCBpcyBhbHJlYWR5IGxvYWRlZFxuICAgICAgICAgICAgICAgIGlmIChsZXZlbCAmJiBsZXZlbC5kZXRhaWxzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBiYXNlX3N0cmVhbV9jb250cm9sbGVyXzEuU3RhdGUuSURMRTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIGJhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfMS5TdGF0ZS5GUkFHX0xPQURJTkdfV0FJVElOR19SRVRSWTpcbiAgICAgICAgICAgICAgICB2YXIgbm93ID0gd2luZG93LnBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICAgICAgICAgIHZhciByZXRyeURhdGUgPSB0aGlzLnJldHJ5RGF0ZTtcbiAgICAgICAgICAgICAgICAvLyBpZiBjdXJyZW50IHRpbWUgaXMgZ3QgdGhhbiByZXRyeURhdGUsIG9yIGlmIG1lZGlhIHNlZWtpbmcgbGV0J3Mgc3dpdGNoIHRvIElETEUgc3RhdGUgdG8gcmV0cnkgbG9hZGluZ1xuICAgICAgICAgICAgICAgIGlmICghcmV0cnlEYXRlIHx8IChub3cgPj0gcmV0cnlEYXRlKSB8fCAodGhpcy5tZWRpYSAmJiB0aGlzLm1lZGlhLnNlZWtpbmcpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmxvZ2dlci5sb2coJ21lZGlhQ29udHJvbGxlcjogcmV0cnlEYXRlIHJlYWNoZWQsIHN3aXRjaCBiYWNrIHRvIElETEUgc3RhdGUnKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IGJhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfMS5TdGF0ZS5JRExFO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgYmFzZV9zdHJlYW1fY29udHJvbGxlcl8xLlN0YXRlLkVSUk9SOlxuICAgICAgICAgICAgY2FzZSBiYXNlX3N0cmVhbV9jb250cm9sbGVyXzEuU3RhdGUuU1RPUFBFRDpcbiAgICAgICAgICAgIGNhc2UgYmFzZV9zdHJlYW1fY29udHJvbGxlcl8xLlN0YXRlLkZSQUdfTE9BRElORzpcbiAgICAgICAgICAgIGNhc2UgYmFzZV9zdHJlYW1fY29udHJvbGxlcl8xLlN0YXRlLlBBUlNJTkc6XG4gICAgICAgICAgICBjYXNlIGJhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfMS5TdGF0ZS5QQVJTRUQ6XG4gICAgICAgICAgICBjYXNlIGJhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfMS5TdGF0ZS5FTkRFRDpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY2hlY2sgYnVmZmVyXG4gICAgICAgIHRoaXMuX2NoZWNrQnVmZmVyKCk7XG4gICAgICAgIC8vIGNoZWNrL3VwZGF0ZSBjdXJyZW50IGZyYWdtZW50XG4gICAgICAgIHRoaXMuX2NoZWNrRnJhZ21lbnRDaGFuZ2VkKCk7XG4gICAgfTtcbiAgICAvLyBJcm9uaWNhbGx5IHRoZSBcImlkbGVcIiBzdGF0ZSBpcyB0aGUgb24gd2UgZG8gdGhlIG1vc3QgbG9naWMgaW4gaXQgc2VlbXMgLi4uLlxuICAgIC8vIE5PVEU6IE1heWJlIHdlIGNvdWxkIHJhdGhlciBzY2hlZHVsZSBhIGNoZWNrIGZvciBidWZmZXIgbGVuZ3RoIGFmdGVyIGhhbGYgb2YgdGhlIGN1cnJlbnRseVxuICAgIC8vICAgICAgIHBsYXllZCBzZWdtZW50LCBvciBvbiBwYXVzZS9wbGF5L3NlZWsgaW5zdGVhZCBvZiBuYWl2ZWx5IGNoZWNraW5nIGV2ZXJ5IDEwMG1zP1xuICAgIFN0cmVhbUNvbnRyb2xsZXIucHJvdG90eXBlLl9kb1RpY2tJZGxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaGxzID0gdGhpcy5obHMsIGNvbmZpZyA9IGhscy5jb25maWcsIG1lZGlhID0gdGhpcy5tZWRpYTtcbiAgICAgICAgLy8gaWYgc3RhcnQgbGV2ZWwgbm90IHBhcnNlZCB5ZXQgT1JcbiAgICAgICAgLy8gaWYgdmlkZW8gbm90IGF0dGFjaGVkIEFORCBzdGFydCBmcmFnbWVudCBhbHJlYWR5IHJlcXVlc3RlZCBPUiBzdGFydCBmcmFnIHByZWZldGNoIGRpc2FibGVcbiAgICAgICAgLy8gZXhpdCBsb29wLCBhcyB3ZSBlaXRoZXIgbmVlZCBtb3JlIGluZm8gKGxldmVsIG5vdCBwYXJzZWQpIG9yIHdlIG5lZWQgbWVkaWEgdG8gYmUgYXR0YWNoZWQgdG8gbG9hZCBuZXcgZnJhZ21lbnRcbiAgICAgICAgaWYgKHRoaXMubGV2ZWxMYXN0TG9hZGVkID09PSB1bmRlZmluZWQgfHwgKCFtZWRpYSAmJiAodGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQgfHwgIWNvbmZpZy5zdGFydEZyYWdQcmVmZXRjaCkpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgd2UgaGF2ZSBub3QgeWV0IGxvYWRlZCBhbnkgZnJhZ21lbnQsIHN0YXJ0IGxvYWRpbmcgZnJvbSBzdGFydCBwb3NpdGlvblxuICAgICAgICB2YXIgcG9zO1xuICAgICAgICBpZiAodGhpcy5sb2FkZWRtZXRhZGF0YSkge1xuICAgICAgICAgICAgcG9zID0gbWVkaWEuY3VycmVudFRpbWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwb3MgPSB0aGlzLm5leHRMb2FkUG9zaXRpb247XG4gICAgICAgIH1cbiAgICAgICAgLy8gZGV0ZXJtaW5lIG5leHQgbG9hZCBsZXZlbFxuICAgICAgICB2YXIgbGV2ZWwgPSBobHMubmV4dExvYWRMZXZlbCwgbGV2ZWxJbmZvID0gdGhpcy5sZXZlbHNbbGV2ZWxdO1xuICAgICAgICBpZiAoIWxldmVsSW5mbykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsZXZlbEJpdHJhdGUgPSBsZXZlbEluZm8uYml0cmF0ZSwgbWF4QnVmTGVuO1xuICAgICAgICAvLyBjb21wdXRlIG1heCBCdWZmZXIgTGVuZ3RoIHRoYXQgd2UgY291bGQgZ2V0IGZyb20gdGhpcyBsb2FkIGxldmVsLCBiYXNlZCBvbiBsZXZlbCBiaXRyYXRlLiBkb24ndCBidWZmZXIgbW9yZSB0aGFuIDYwIE1CIGFuZCBtb3JlIHRoYW4gMzBzXG4gICAgICAgIGlmIChsZXZlbEJpdHJhdGUpIHtcbiAgICAgICAgICAgIG1heEJ1ZkxlbiA9IE1hdGgubWF4KDggKiBjb25maWcubWF4QnVmZmVyU2l6ZSAvIGxldmVsQml0cmF0ZSwgY29uZmlnLm1heEJ1ZmZlckxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtYXhCdWZMZW4gPSBjb25maWcubWF4QnVmZmVyTGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIG1heEJ1ZkxlbiA9IE1hdGgubWluKG1heEJ1ZkxlbiwgY29uZmlnLm1heE1heEJ1ZmZlckxlbmd0aCk7XG4gICAgICAgIC8vIGRldGVybWluZSBuZXh0IGNhbmRpZGF0ZSBmcmFnbWVudCB0byBiZSBsb2FkZWQsIGJhc2VkIG9uIGN1cnJlbnQgcG9zaXRpb24gYW5kIGVuZCBvZiBidWZmZXIgcG9zaXRpb25cbiAgICAgICAgLy8gZW5zdXJlIHVwIHRvIGBjb25maWcubWF4TWF4QnVmZmVyTGVuZ3RoYCBvZiBidWZmZXIgdXBmcm9udFxuICAgICAgICB2YXIgYnVmZmVySW5mbyA9IGJ1ZmZlcl9oZWxwZXJfMS5CdWZmZXJIZWxwZXIuYnVmZmVySW5mbyh0aGlzLm1lZGlhQnVmZmVyID8gdGhpcy5tZWRpYUJ1ZmZlciA6IG1lZGlhLCBwb3MsIGNvbmZpZy5tYXhCdWZmZXJIb2xlKSwgYnVmZmVyTGVuID0gYnVmZmVySW5mby5sZW47XG4gICAgICAgIC8vIFN0YXkgaWRsZSBpZiB3ZSBhcmUgc3RpbGwgd2l0aCBidWZmZXIgbWFyZ2luc1xuICAgICAgICBpZiAoYnVmZmVyTGVuID49IG1heEJ1Zkxlbikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIGlmIGJ1ZmZlciBsZW5ndGggaXMgbGVzcyB0aGFuIG1heEJ1ZkxlbiB0cnkgdG8gbG9hZCBhIG5ldyBmcmFnbWVudCAuLi5cbiAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLnRyYWNlKFwiYnVmZmVyIGxlbmd0aCBvZiBcIiArIGJ1ZmZlckxlbi50b0ZpeGVkKDMpICsgXCIgaXMgYmVsb3cgbWF4IG9mIFwiICsgbWF4QnVmTGVuLnRvRml4ZWQoMykgKyBcIi4gY2hlY2tpbmcgZm9yIG1vcmUgcGF5bG9hZCAuLi5cIik7XG4gICAgICAgIC8vIHNldCBuZXh0IGxvYWQgbGV2ZWwgOiB0aGlzIHdpbGwgdHJpZ2dlciBhIHBsYXlsaXN0IGxvYWQgaWYgbmVlZGVkXG4gICAgICAgIHRoaXMubGV2ZWwgPSBobHMubmV4dExvYWRMZXZlbCA9IGxldmVsO1xuICAgICAgICB2YXIgbGV2ZWxEZXRhaWxzID0gbGV2ZWxJbmZvLmRldGFpbHM7XG4gICAgICAgIC8vIGlmIGxldmVsIGluZm8gbm90IHJldHJpZXZlZCB5ZXQsIHN3aXRjaCBzdGF0ZSBhbmQgd2FpdCBmb3IgbGV2ZWwgcmV0cmlldmFsXG4gICAgICAgIC8vIGlmIGxpdmUgcGxheWxpc3QsIGVuc3VyZSB0aGF0IG5ldyBwbGF5bGlzdCBoYXMgYmVlbiByZWZyZXNoZWQgdG8gYXZvaWQgbG9hZGluZy90cnkgdG8gbG9hZFxuICAgICAgICAvLyBhIHVzZWxlc3MgYW5kIG91dGRhdGVkIGZyYWdtZW50ICh0aGF0IG1pZ2h0IGV2ZW4gaW50cm9kdWNlIGxvYWQgZXJyb3IgaWYgaXQgaXMgYWxyZWFkeSBvdXQgb2YgdGhlIGxpdmUgcGxheWxpc3QpXG4gICAgICAgIGlmICghbGV2ZWxEZXRhaWxzIHx8IChsZXZlbERldGFpbHMubGl2ZSAmJiB0aGlzLmxldmVsTGFzdExvYWRlZCAhPT0gbGV2ZWwpKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gYmFzZV9zdHJlYW1fY29udHJvbGxlcl8xLlN0YXRlLldBSVRJTkdfTEVWRUw7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3N0cmVhbUVuZGVkKGJ1ZmZlckluZm8sIGxldmVsRGV0YWlscykpIHtcbiAgICAgICAgICAgIHZhciBkYXRhID0ge307XG4gICAgICAgICAgICBpZiAodGhpcy5hbHRBdWRpbykge1xuICAgICAgICAgICAgICAgIGRhdGEudHlwZSA9ICd2aWRlbyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmhscy50cmlnZ2VyKGV2ZW50c18xLmRlZmF1bHQuQlVGRkVSX0VPUywgZGF0YSk7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gYmFzZV9zdHJlYW1fY29udHJvbGxlcl8xLlN0YXRlLkVOREVEO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIGlmIHdlIGhhdmUgdGhlIGxldmVsRGV0YWlscyBmb3IgdGhlIHNlbGVjdGVkIHZhcmlhbnQsIGxldHMgY29udGludWUgZW5yaWNoZW4gb3VyIHN0cmVhbSAobG9hZCBrZXlzL2ZyYWdtZW50cyBvciB0cmlnZ2VyIEVPUywgZXRjLi4pXG4gICAgICAgIHRoaXMuX2ZldGNoUGF5bG9hZE9yRW9zKHBvcywgYnVmZmVySW5mbywgbGV2ZWxEZXRhaWxzKTtcbiAgICB9O1xuICAgIFN0cmVhbUNvbnRyb2xsZXIucHJvdG90eXBlLl9mZXRjaFBheWxvYWRPckVvcyA9IGZ1bmN0aW9uIChwb3MsIGJ1ZmZlckluZm8sIGxldmVsRGV0YWlscykge1xuICAgICAgICB2YXIgZnJhZ1ByZXZpb3VzID0gdGhpcy5mcmFnUHJldmlvdXMsIGxldmVsID0gdGhpcy5sZXZlbCwgZnJhZ21lbnRzID0gbGV2ZWxEZXRhaWxzLmZyYWdtZW50cywgZnJhZ0xlbiA9IGZyYWdtZW50cy5sZW5ndGg7XG4gICAgICAgIC8vIGVtcHR5IHBsYXlsaXN0XG4gICAgICAgIGlmIChmcmFnTGVuID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gZmluZCBmcmFnbWVudCBpbmRleCwgY29udGlndW91cyB3aXRoIGVuZCBvZiBidWZmZXIgcG9zaXRpb25cbiAgICAgICAgdmFyIHN0YXJ0ID0gZnJhZ21lbnRzWzBdLnN0YXJ0LCBlbmQgPSBmcmFnbWVudHNbZnJhZ0xlbiAtIDFdLnN0YXJ0ICsgZnJhZ21lbnRzW2ZyYWdMZW4gLSAxXS5kdXJhdGlvbiwgYnVmZmVyRW5kID0gYnVmZmVySW5mby5lbmQsIGZyYWc7XG4gICAgICAgIGlmIChsZXZlbERldGFpbHMuaW5pdFNlZ21lbnQgJiYgIWxldmVsRGV0YWlscy5pbml0U2VnbWVudC5kYXRhKSB7XG4gICAgICAgICAgICBmcmFnID0gbGV2ZWxEZXRhaWxzLmluaXRTZWdtZW50O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gaW4gY2FzZSBvZiBsaXZlIHBsYXlsaXN0IHdlIG5lZWQgdG8gZW5zdXJlIHRoYXQgcmVxdWVzdGVkIHBvc2l0aW9uIGlzIG5vdCBsb2NhdGVkIGJlZm9yZSBwbGF5bGlzdCBzdGFydFxuICAgICAgICAgICAgaWYgKGxldmVsRGV0YWlscy5saXZlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGluaXRpYWxMaXZlTWFuaWZlc3RTaXplID0gdGhpcy5jb25maWcuaW5pdGlhbExpdmVNYW5pZmVzdFNpemU7XG4gICAgICAgICAgICAgICAgaWYgKGZyYWdMZW4gPCBpbml0aWFsTGl2ZU1hbmlmZXN0U2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXJfMS5sb2dnZXIud2FybihcIkNhbiBub3Qgc3RhcnQgcGxheWJhY2sgb2YgYSBsZXZlbCwgcmVhc29uOiBub3QgZW5vdWdoIGZyYWdtZW50cyBcIiArIGZyYWdMZW4gKyBcIiA8IFwiICsgaW5pdGlhbExpdmVNYW5pZmVzdFNpemUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZyYWcgPSB0aGlzLl9lbnN1cmVGcmFnbWVudEF0TGl2ZVBvaW50KGxldmVsRGV0YWlscywgYnVmZmVyRW5kLCBzdGFydCwgZW5kLCBmcmFnUHJldmlvdXMsIGZyYWdtZW50cywgZnJhZ0xlbik7XG4gICAgICAgICAgICAgICAgLy8gaWYgaXQgZXhwbGljaXRlbHkgcmV0dXJucyBudWxsIGRvbid0IGxvYWQgYW55IGZyYWdtZW50IGFuZCBleGl0IGZ1bmN0aW9uIG5vd1xuICAgICAgICAgICAgICAgIGlmIChmcmFnID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBWb0QgcGxheWxpc3Q6IGlmIGJ1ZmZlckVuZCBiZWZvcmUgc3RhcnQgb2YgcGxheWxpc3QsIGxvYWQgZmlyc3QgZnJhZ21lbnRcbiAgICAgICAgICAgICAgICBpZiAoYnVmZmVyRW5kIDwgc3RhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgZnJhZyA9IGZyYWdtZW50c1swXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFmcmFnKSB7XG4gICAgICAgICAgICBmcmFnID0gdGhpcy5fZmluZEZyYWdtZW50KHN0YXJ0LCBmcmFnUHJldmlvdXMsIGZyYWdMZW4sIGZyYWdtZW50cywgYnVmZmVyRW5kLCBlbmQsIGxldmVsRGV0YWlscyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZyYWcpIHtcbiAgICAgICAgICAgIGlmIChmcmFnLmVuY3J5cHRlZCkge1xuICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmxvZ2dlci5sb2coXCJMb2FkaW5nIGtleSBmb3IgXCIgKyBmcmFnLnNuICsgXCIgb2YgW1wiICsgbGV2ZWxEZXRhaWxzLnN0YXJ0U04gKyBcIiAsXCIgKyBsZXZlbERldGFpbHMuZW5kU04gKyBcIl0sbGV2ZWwgXCIgKyBsZXZlbCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fbG9hZEtleShmcmFnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmxvZ2dlci5sb2coXCJMb2FkaW5nIFwiICsgZnJhZy5zbiArIFwiIG9mIFtcIiArIGxldmVsRGV0YWlscy5zdGFydFNOICsgXCIgLFwiICsgbGV2ZWxEZXRhaWxzLmVuZFNOICsgXCJdLGxldmVsIFwiICsgbGV2ZWwgKyBcIiwgY3VycmVudFRpbWU6XCIgKyBwb3MudG9GaXhlZCgzKSArIFwiLGJ1ZmZlckVuZDpcIiArIGJ1ZmZlckVuZC50b0ZpeGVkKDMpKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2FkRnJhZ21lbnQoZnJhZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN0cmVhbUNvbnRyb2xsZXIucHJvdG90eXBlLl9lbnN1cmVGcmFnbWVudEF0TGl2ZVBvaW50ID0gZnVuY3Rpb24gKGxldmVsRGV0YWlscywgYnVmZmVyRW5kLCBzdGFydCwgZW5kLCBmcmFnUHJldmlvdXMsIGZyYWdtZW50cywgZnJhZ0xlbikge1xuICAgICAgICB2YXIgY29uZmlnID0gdGhpcy5obHMuY29uZmlnLCBtZWRpYSA9IHRoaXMubWVkaWE7XG4gICAgICAgIHZhciBmcmFnO1xuICAgICAgICAvLyBjaGVjayBpZiByZXF1ZXN0ZWQgcG9zaXRpb24gaXMgd2l0aGluIHNlZWthYmxlIGJvdW5kYXJpZXMgOlxuICAgICAgICAvLyBsb2dnZXIubG9nKGBzdGFydC9wb3MvYnVmRW5kL3NlZWtpbmc6JHtzdGFydC50b0ZpeGVkKDMpfS8ke3Bvcy50b0ZpeGVkKDMpfS8ke2J1ZmZlckVuZC50b0ZpeGVkKDMpfS8ke3RoaXMubWVkaWEuc2Vla2luZ31gKTtcbiAgICAgICAgdmFyIG1heExhdGVuY3kgPSBjb25maWcubGl2ZU1heExhdGVuY3lEdXJhdGlvbiAhPT0gdW5kZWZpbmVkID8gY29uZmlnLmxpdmVNYXhMYXRlbmN5RHVyYXRpb24gOiBjb25maWcubGl2ZU1heExhdGVuY3lEdXJhdGlvbkNvdW50ICogbGV2ZWxEZXRhaWxzLnRhcmdldGR1cmF0aW9uO1xuICAgICAgICBpZiAoYnVmZmVyRW5kIDwgTWF0aC5tYXgoc3RhcnQgLSBjb25maWcubWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSwgZW5kIC0gbWF4TGF0ZW5jeSkpIHtcbiAgICAgICAgICAgIHZhciBsaXZlU3luY1Bvc2l0aW9uID0gdGhpcy5saXZlU3luY1Bvc2l0aW9uID0gdGhpcy5jb21wdXRlTGl2ZVBvc2l0aW9uKHN0YXJ0LCBsZXZlbERldGFpbHMpO1xuICAgICAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLmxvZyhcImJ1ZmZlciBlbmQ6IFwiICsgYnVmZmVyRW5kLnRvRml4ZWQoMykgKyBcIiBpcyBsb2NhdGVkIHRvbyBmYXIgZnJvbSB0aGUgZW5kIG9mIGxpdmUgc2xpZGluZyBwbGF5bGlzdCwgcmVzZXQgY3VycmVudFRpbWUgdG8gOiBcIiArIGxpdmVTeW5jUG9zaXRpb24udG9GaXhlZCgzKSk7XG4gICAgICAgICAgICBidWZmZXJFbmQgPSBsaXZlU3luY1Bvc2l0aW9uO1xuICAgICAgICAgICAgaWYgKG1lZGlhICYmIG1lZGlhLnJlYWR5U3RhdGUgJiYgbWVkaWEuZHVyYXRpb24gPiBsaXZlU3luY1Bvc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgbWVkaWEuY3VycmVudFRpbWUgPSBsaXZlU3luY1Bvc2l0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5uZXh0TG9hZFBvc2l0aW9uID0gbGl2ZVN5bmNQb3NpdGlvbjtcbiAgICAgICAgfVxuICAgICAgICAvLyBpZiBlbmQgb2YgYnVmZmVyIGdyZWF0ZXIgdGhhbiBsaXZlIGVkZ2UsIGRvbid0IGxvYWQgYW55IGZyYWdtZW50XG4gICAgICAgIC8vIHRoaXMgY291bGQgaGFwcGVuIGlmIGxpdmUgcGxheWxpc3QgaW50ZXJtaXR0ZW50bHkgc2xpZGVzIGluIHRoZSBwYXN0LlxuICAgICAgICAvLyBsZXZlbCAxIGxvYWRlZCBbMTgyNTgwMTYxLDE4MjU4MDE2N11cbiAgICAgICAgLy8gbGV2ZWwgMSBsb2FkZWQgWzE4MjU4MDE2MiwxODI1ODAxNjldXG4gICAgICAgIC8vIExvYWRpbmcgMTgyNTgwMTY4IG9mIFsxODI1ODAxNjIgLDE4MjU4MDE2OV0sbGV2ZWwgMSAuLlxuICAgICAgICAvLyBMb2FkaW5nIDE4MjU4MDE2OSBvZiBbMTgyNTgwMTYyICwxODI1ODAxNjldLGxldmVsIDEgLi5cbiAgICAgICAgLy8gbGV2ZWwgMSBsb2FkZWQgWzE4MjU4MDE2MiwxODI1ODAxNjhdIDw9PT09PT09PT09PT09IGhlcmUgd2Ugc2hvdWxkIGhhdmUgYnVmZmVyRW5kID4gZW5kLiBpbiB0aGF0IGNhc2UgYnJlYWsgdG8gYXZvaWQgcmVsb2FkaW5nIDE4MjU4MDE2OFxuICAgICAgICAvLyBsZXZlbCAxIGxvYWRlZCBbMTgyNTgwMTY0LDE4MjU4MDE3MV1cbiAgICAgICAgLy9cbiAgICAgICAgLy8gZG9uJ3QgcmV0dXJuIG51bGwgaW4gY2FzZSBtZWRpYSBub3QgbG9hZGVkIHlldCAocmVhZHlzdGF0ZSA9PT0gMClcbiAgICAgICAgaWYgKGxldmVsRGV0YWlscy5QVFNLbm93biAmJiBidWZmZXJFbmQgPiBlbmQgJiYgbWVkaWEgJiYgbWVkaWEucmVhZHlTdGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc3RhcnRGcmFnUmVxdWVzdGVkICYmICFsZXZlbERldGFpbHMuUFRTS25vd24pIHtcbiAgICAgICAgICAgIC8qIHdlIGFyZSBzd2l0Y2hpbmcgbGV2ZWwgb24gbGl2ZSBwbGF5bGlzdCwgYnV0IHdlIGRvbid0IGhhdmUgYW55IFBUUyBpbmZvIGZvciB0aGF0IHF1YWxpdHkgbGV2ZWwgLi4uXG4gICAgICAgICAgICAgICB0cnkgdG8gbG9hZCBmcmFnIG1hdGNoaW5nIHdpdGggbmV4dCBTTi5cbiAgICAgICAgICAgICAgIGV2ZW4gaWYgU04gYXJlIG5vdCBzeW5jaHJvbml6ZWQgYmV0d2VlbiBwbGF5bGlzdHMsIGxvYWRpbmcgdGhpcyBmcmFnIHdpbGwgaGVscCB1c1xuICAgICAgICAgICAgICAgY29tcHV0ZSBwbGF5bGlzdCBzbGlkaW5nIGFuZCBmaW5kIHRoZSByaWdodCBvbmUgYWZ0ZXIgaW4gY2FzZSBpdCB3YXMgbm90IHRoZSByaWdodCBjb25zZWN1dGl2ZSBvbmUgKi9cbiAgICAgICAgICAgIGlmIChmcmFnUHJldmlvdXMpIHtcbiAgICAgICAgICAgICAgICBpZiAobGV2ZWxEZXRhaWxzLmhhc1Byb2dyYW1EYXRlVGltZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBSZWxpZXMgb24gUERUIGluIG9yZGVyIHRvIHN3aXRjaCBiaXRyYXRlcyAoU3VwcG9ydCBFWFQtWC1ESVNDT05USU5VSVRZIHdpdGhvdXQgRVhULVgtRElTQ09OVElOVUlUWS1TRVFVRU5DRSlcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLmxvZyhcImxpdmUgcGxheWxpc3QsIHN3aXRjaGluZyBwbGF5bGlzdCwgbG9hZCBmcmFnIHdpdGggc2FtZSBQRFQ6IFwiICsgZnJhZ1ByZXZpb3VzLnByb2dyYW1EYXRlVGltZSk7XG4gICAgICAgICAgICAgICAgICAgIGZyYWcgPSBmcmFnbWVudF9maW5kZXJzXzEuZmluZEZyYWdtZW50QnlQRFQoZnJhZ21lbnRzLCBmcmFnUHJldmlvdXMuZW5kUHJvZ3JhbURhdGVUaW1lLCBjb25maWcubWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBVc2VzIGJ1ZmZlciBhbmQgc2VxdWVuY2UgbnVtYmVyIHRvIGNhbGN1bGF0ZSBzd2l0Y2ggc2VnbWVudCAocmVxdWlyZWQgaWYgdXNpbmcgRVhULVgtRElTQ09OVElOVUlUWS1TRVFVRU5DRSlcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRhcmdldFNOID0gZnJhZ1ByZXZpb3VzLnNuICsgMTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhcmdldFNOID49IGxldmVsRGV0YWlscy5zdGFydFNOICYmIHRhcmdldFNOIDw9IGxldmVsRGV0YWlscy5lbmRTTikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZyYWdOZXh0ID0gZnJhZ21lbnRzW3RhcmdldFNOIC0gbGV2ZWxEZXRhaWxzLnN0YXJ0U05dO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZyYWdQcmV2aW91cy5jYyA9PT0gZnJhZ05leHQuY2MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcmFnID0gZnJhZ05leHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLmxvZyhcImxpdmUgcGxheWxpc3QsIHN3aXRjaGluZyBwbGF5bGlzdCwgbG9hZCBmcmFnIHdpdGggbmV4dCBTTjogXCIgKyBmcmFnLnNuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBuZXh0IGZyYWcgU04gbm90IGF2YWlsYWJsZSAob3Igbm90IHdpdGggc2FtZSBjb250aW51aXR5IGNvdW50ZXIpXG4gICAgICAgICAgICAgICAgICAgIC8vIGxvb2sgZm9yIGEgZnJhZyBzaGFyaW5nIHRoZSBzYW1lIENDXG4gICAgICAgICAgICAgICAgICAgIGlmICghZnJhZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZnJhZyA9IGJpbmFyeV9zZWFyY2hfMS5kZWZhdWx0LnNlYXJjaChmcmFnbWVudHMsIGZ1bmN0aW9uIChmcmFnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZyYWdQcmV2aW91cy5jYyAtIGZyYWcuY2M7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmcmFnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLmxvZyhcImxpdmUgcGxheWxpc3QsIHN3aXRjaGluZyBwbGF5bGlzdCwgbG9hZCBmcmFnIHdpdGggc2FtZSBDQzogXCIgKyBmcmFnLnNuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZnJhZykge1xuICAgICAgICAgICAgICAgIC8qIHdlIGhhdmUgbm8gaWRlYSBhYm91dCB3aGljaCBmcmFnbWVudCBzaG91bGQgYmUgbG9hZGVkLlxuICAgICAgICAgICAgICAgICAgIHNvIGxldCdzIGxvYWQgbWlkIGZyYWdtZW50LiBpdCB3aWxsIGhlbHAgY29tcHV0aW5nIHBsYXlsaXN0IHNsaWRpbmcgYW5kIGZpbmQgdGhlIHJpZ2h0IG9uZVxuICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgZnJhZyA9IGZyYWdtZW50c1tNYXRoLm1pbihmcmFnTGVuIC0gMSwgTWF0aC5yb3VuZChmcmFnTGVuIC8gMikpXTtcbiAgICAgICAgICAgICAgICBsb2dnZXJfMS5sb2dnZXIubG9nKFwibGl2ZSBwbGF5bGlzdCwgc3dpdGNoaW5nIHBsYXlsaXN0LCB1bmtub3duLCBsb2FkIG1pZGRsZSBmcmFnIDogXCIgKyBmcmFnLnNuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnJhZztcbiAgICB9O1xuICAgIFN0cmVhbUNvbnRyb2xsZXIucHJvdG90eXBlLl9maW5kRnJhZ21lbnQgPSBmdW5jdGlvbiAoc3RhcnQsIGZyYWdQcmV2aW91cywgZnJhZ0xlbiwgZnJhZ21lbnRzLCBidWZmZXJFbmQsIGVuZCwgbGV2ZWxEZXRhaWxzKSB7XG4gICAgICAgIHZhciBjb25maWcgPSB0aGlzLmhscy5jb25maWc7XG4gICAgICAgIHZhciBmcmFnO1xuICAgICAgICBpZiAoYnVmZmVyRW5kIDwgZW5kKSB7XG4gICAgICAgICAgICB2YXIgbG9va3VwVG9sZXJhbmNlID0gKGJ1ZmZlckVuZCA+IGVuZCAtIGNvbmZpZy5tYXhGcmFnTG9va1VwVG9sZXJhbmNlKSA/IDAgOiBjb25maWcubWF4RnJhZ0xvb2tVcFRvbGVyYW5jZTtcbiAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgdG9sZXJhbmNlIGlmIGl0IHdvdWxkIHB1dCB0aGUgYnVmZmVyRW5kIHBhc3QgdGhlIGFjdHVhbCBlbmQgb2Ygc3RyZWFtXG4gICAgICAgICAgICAvLyBVc2VzIGJ1ZmZlciBhbmQgc2VxdWVuY2UgbnVtYmVyIHRvIGNhbGN1bGF0ZSBzd2l0Y2ggc2VnbWVudCAocmVxdWlyZWQgaWYgdXNpbmcgRVhULVgtRElTQ09OVElOVUlUWS1TRVFVRU5DRSlcbiAgICAgICAgICAgIGZyYWcgPSBmcmFnbWVudF9maW5kZXJzXzEuZmluZEZyYWdtZW50QnlQVFMoZnJhZ1ByZXZpb3VzLCBmcmFnbWVudHMsIGJ1ZmZlckVuZCwgbG9va3VwVG9sZXJhbmNlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIHJlYWNoIGVuZCBvZiBwbGF5bGlzdFxuICAgICAgICAgICAgZnJhZyA9IGZyYWdtZW50c1tmcmFnTGVuIC0gMV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZyYWcpIHtcbiAgICAgICAgICAgIHZhciBjdXJTTklkeCA9IGZyYWcuc24gLSBsZXZlbERldGFpbHMuc3RhcnRTTjtcbiAgICAgICAgICAgIHZhciBzYW1lTGV2ZWwgPSBmcmFnUHJldmlvdXMgJiYgZnJhZy5sZXZlbCA9PT0gZnJhZ1ByZXZpb3VzLmxldmVsO1xuICAgICAgICAgICAgdmFyIHByZXZGcmFnID0gZnJhZ21lbnRzW2N1clNOSWR4IC0gMV07XG4gICAgICAgICAgICB2YXIgbmV4dEZyYWcgPSBmcmFnbWVudHNbY3VyU05JZHggKyAxXTtcbiAgICAgICAgICAgIC8vIGxvZ2dlci5sb2coJ2ZpbmQgU04gbWF0Y2hpbmcgd2l0aCBwb3M6JyArICBidWZmZXJFbmQgKyAnOicgKyBmcmFnLnNuKTtcbiAgICAgICAgICAgIGlmIChmcmFnUHJldmlvdXMgJiYgZnJhZy5zbiA9PT0gZnJhZ1ByZXZpb3VzLnNuKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNhbWVMZXZlbCAmJiAhZnJhZy5iYWNrdHJhY2tlZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZnJhZy5zbiA8IGxldmVsRGV0YWlscy5lbmRTTikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRlbHRhUFRTID0gZnJhZ1ByZXZpb3VzLmRlbHRhUFRTO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlcmUgaXMgYSBzaWduaWZpY2FudCBkZWx0YSBiZXR3ZWVuIGF1ZGlvIGFuZCB2aWRlbywgbGFyZ2VyIHRoYW4gbWF4IGFsbG93ZWQgaG9sZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFuZCBpZiBwcmV2aW91cyByZW11eGVkIGZyYWdtZW50IGRpZCBub3Qgc3RhcnQgd2l0aCBhIGtleWZyYW1lLiAoZnJhZ1ByZXZpb3VzLmRyb3BwZWQpXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBsZXQncyB0cnkgdG8gbG9hZCBwcmV2aW91cyBmcmFnbWVudCBhZ2FpbiB0byBnZXQgbGFzdCBrZXlmcmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlbiB3ZSB3aWxsIHJlbG9hZCBhZ2FpbiBjdXJyZW50IGZyYWdtZW50ICh0aGF0IHdheSB3ZSBzaG91bGQgYmUgYWJsZSB0byBmaWxsIHRoZSBidWZmZXIgaG9sZSAuLi4pXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGVsdGFQVFMgJiYgZGVsdGFQVFMgPiBjb25maWcubWF4QnVmZmVySG9sZSAmJiBmcmFnUHJldmlvdXMuZHJvcHBlZCAmJiBjdXJTTklkeCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyYWcgPSBwcmV2RnJhZztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXJfMS5sb2dnZXIud2FybignU04ganVzdCBsb2FkZWQsIHdpdGggbGFyZ2UgUFRTIGdhcCBiZXR3ZWVuIGF1ZGlvIGFuZCB2aWRlbywgbWF5YmUgZnJhZyBpcyBub3Qgc3RhcnRpbmcgd2l0aCBhIGtleWZyYW1lID8gbG9hZCBwcmV2aW91cyBvbmUgdG8gdHJ5IHRvIG92ZXJjb21lIHRoaXMnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyYWcgPSBuZXh0RnJhZztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXJfMS5sb2dnZXIubG9nKFwiU04ganVzdCBsb2FkZWQsIGxvYWQgbmV4dCBvbmU6IFwiICsgZnJhZy5zbiwgZnJhZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmcmFnID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChmcmFnLmJhY2t0cmFja2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE9ubHkgYmFja3RyYWNrIGEgbWF4IG9mIDEgY29uc2VjdXRpdmUgZnJhZ21lbnQgdG8gcHJldmVudCBzbGlkaW5nIGJhY2sgdG9vIGZhciB3aGVuIGxpdHRsZSBvciBubyBmcmFncyBzdGFydCB3aXRoIGtleWZyYW1lc1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dEZyYWcgJiYgbmV4dEZyYWcuYmFja3RyYWNrZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmxvZ2dlci53YXJuKFwiQWxyZWFkeSBiYWNrdHJhY2tlZCBmcm9tIGZyYWdtZW50IFwiICsgbmV4dEZyYWcuc24gKyBcIiwgd2lsbCBub3QgYmFja3RyYWNrIHRvIGZyYWdtZW50IFwiICsgZnJhZy5zbiArIFwiLiBMb2FkaW5nIGZyYWdtZW50IFwiICsgbmV4dEZyYWcuc24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgZnJhZyA9IG5leHRGcmFnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgYSBmcmFnbWVudCBoYXMgZHJvcHBlZCBmcmFtZXMgYW5kIGl0J3MgaW4gYSBzYW1lIGxldmVsL3NlcXVlbmNlLCBsb2FkIHRoZSBwcmV2aW91cyBmcmFnbWVudCB0byB0cnkgYW5kIGZpbmQgdGhlIGtleWZyYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXNldCB0aGUgZHJvcHBlZCBjb3VudCBub3cgc2luY2UgaXQgd29uJ3QgYmUgcmVzZXQgdW50aWwgd2UgcGFyc2UgdGhlIGZyYWdtZW50IGFnYWluLCB3aGljaCBwcmV2ZW50cyBpbmZpbml0ZSBiYWNrdHJhY2tpbmcgb24gdGhlIHNhbWUgc2VnbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLndhcm4oJ0xvYWRlZCBmcmFnbWVudCB3aXRoIGRyb3BwZWQgZnJhbWVzLCBiYWNrdHJhY2tpbmcgMSBzZWdtZW50IHRvIGZpbmQgYSBrZXlmcmFtZScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZnJhZy5kcm9wcGVkID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcmV2RnJhZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyYWcgPSBwcmV2RnJhZztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcmFnLmJhY2t0cmFja2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGN1clNOSWR4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FuJ3QgYmFja3RyYWNrIG9uIHZlcnkgZmlyc3QgZnJhZ21lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcmFnID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnJhZztcbiAgICB9O1xuICAgIFN0cmVhbUNvbnRyb2xsZXIucHJvdG90eXBlLl9sb2FkS2V5ID0gZnVuY3Rpb24gKGZyYWcpIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IGJhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfMS5TdGF0ZS5LRVlfTE9BRElORztcbiAgICAgICAgdGhpcy5obHMudHJpZ2dlcihldmVudHNfMS5kZWZhdWx0LktFWV9MT0FESU5HLCB7IGZyYWc6IGZyYWcgfSk7XG4gICAgfTtcbiAgICBTdHJlYW1Db250cm9sbGVyLnByb3RvdHlwZS5fbG9hZEZyYWdtZW50ID0gZnVuY3Rpb24gKGZyYWcpIHtcbiAgICAgICAgLy8gQ2hlY2sgaWYgZnJhZ21lbnQgaXMgbm90IGxvYWRlZFxuICAgICAgICB2YXIgZnJhZ1N0YXRlID0gdGhpcy5mcmFnbWVudFRyYWNrZXIuZ2V0U3RhdGUoZnJhZyk7XG4gICAgICAgIHRoaXMuZnJhZ0N1cnJlbnQgPSBmcmFnO1xuICAgICAgICB0aGlzLnN0YXJ0RnJhZ1JlcXVlc3RlZCA9IHRydWU7XG4gICAgICAgIC8vIERvbid0IHVwZGF0ZSBuZXh0TG9hZFBvc2l0aW9uIGZvciBmcmFnbWVudHMgd2hpY2ggYXJlIG5vdCBidWZmZXJlZFxuICAgICAgICBpZiAoTnVtYmVyLmlzRmluaXRlKGZyYWcuc24pICYmICFmcmFnLmJpdHJhdGVUZXN0KSB7XG4gICAgICAgICAgICB0aGlzLm5leHRMb2FkUG9zaXRpb24gPSBmcmFnLnN0YXJ0ICsgZnJhZy5kdXJhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICAvLyBBbGxvdyBiYWNrdHJhY2tlZCBmcmFnbWVudHMgdG8gbG9hZFxuICAgICAgICBpZiAoZnJhZy5iYWNrdHJhY2tlZCB8fCBmcmFnU3RhdGUgPT09IGZyYWdtZW50X3RyYWNrZXJfMS5GcmFnbWVudFN0YXRlLk5PVF9MT0FERUQgfHwgZnJhZ1N0YXRlID09PSBmcmFnbWVudF90cmFja2VyXzEuRnJhZ21lbnRTdGF0ZS5QQVJUSUFMKSB7XG4gICAgICAgICAgICBmcmFnLmF1dG9MZXZlbCA9IHRoaXMuaGxzLmF1dG9MZXZlbEVuYWJsZWQ7XG4gICAgICAgICAgICBmcmFnLmJpdHJhdGVUZXN0ID0gdGhpcy5iaXRyYXRlVGVzdDtcbiAgICAgICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoZXZlbnRzXzEuZGVmYXVsdC5GUkFHX0xPQURJTkcsIHsgZnJhZzogZnJhZyB9KTtcbiAgICAgICAgICAgIC8vIGxhenkgZGVtdXhlciBpbml0LCBhcyB0aGlzIGNvdWxkIHRha2Ugc29tZSB0aW1lIC4uLiBkbyBpdCBkdXJpbmcgZnJhZyBsb2FkaW5nXG4gICAgICAgICAgICBpZiAoIXRoaXMuZGVtdXhlcikge1xuICAgICAgICAgICAgICAgIHRoaXMuZGVtdXhlciA9IG5ldyBkZW11eGVyXzEuZGVmYXVsdCh0aGlzLmhscywgJ21haW4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBiYXNlX3N0cmVhbV9jb250cm9sbGVyXzEuU3RhdGUuRlJBR19MT0FESU5HO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGZyYWdTdGF0ZSA9PT0gZnJhZ21lbnRfdHJhY2tlcl8xLkZyYWdtZW50U3RhdGUuQVBQRU5ESU5HKSB7XG4gICAgICAgICAgICAvLyBMb3dlciB0aGUgYnVmZmVyIHNpemUgYW5kIHRyeSBhZ2FpblxuICAgICAgICAgICAgaWYgKHRoaXMuX3JlZHVjZU1heEJ1ZmZlckxlbmd0aChmcmFnLmR1cmF0aW9uKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyLnJlbW92ZUZyYWdtZW50KGZyYWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU3RyZWFtQ29udHJvbGxlci5wcm90b3R5cGUsIFwic3RhdGVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdGF0ZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAobmV4dFN0YXRlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zdGF0ZSAhPT0gbmV4dFN0YXRlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHByZXZpb3VzU3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXRlID0gbmV4dFN0YXRlO1xuICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmxvZ2dlci5sb2coXCJtYWluIHN0cmVhbTpcIiArIHByZXZpb3VzU3RhdGUgKyBcIi0+XCIgKyBuZXh0U3RhdGUpO1xuICAgICAgICAgICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoZXZlbnRzXzEuZGVmYXVsdC5TVFJFQU1fU1RBVEVfVFJBTlNJVElPTiwgeyBwcmV2aW91c1N0YXRlOiBwcmV2aW91c1N0YXRlLCBuZXh0U3RhdGU6IG5leHRTdGF0ZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgU3RyZWFtQ29udHJvbGxlci5wcm90b3R5cGUuZ2V0QnVmZmVyZWRGcmFnID0gZnVuY3Rpb24gKHBvc2l0aW9uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZyYWdtZW50VHJhY2tlci5nZXRCdWZmZXJlZEZyYWcocG9zaXRpb24sIHBsYXlsaXN0X2xvYWRlcl8xLmRlZmF1bHQuTGV2ZWxUeXBlLk1BSU4pO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFN0cmVhbUNvbnRyb2xsZXIucHJvdG90eXBlLCBcImN1cnJlbnRMZXZlbFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG1lZGlhID0gdGhpcy5tZWRpYTtcbiAgICAgICAgICAgIGlmIChtZWRpYSkge1xuICAgICAgICAgICAgICAgIHZhciBmcmFnID0gdGhpcy5nZXRCdWZmZXJlZEZyYWcobWVkaWEuY3VycmVudFRpbWUpO1xuICAgICAgICAgICAgICAgIGlmIChmcmFnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmcmFnLmxldmVsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFN0cmVhbUNvbnRyb2xsZXIucHJvdG90eXBlLCBcIm5leHRCdWZmZXJlZEZyYWdcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBtZWRpYSA9IHRoaXMubWVkaWE7XG4gICAgICAgICAgICBpZiAobWVkaWEpIHtcbiAgICAgICAgICAgICAgICAvLyBmaXJzdCBnZXQgZW5kIHJhbmdlIG9mIGN1cnJlbnQgZnJhZ21lbnRcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5mb2xsb3dpbmdCdWZmZXJlZEZyYWcodGhpcy5nZXRCdWZmZXJlZEZyYWcobWVkaWEuY3VycmVudFRpbWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBTdHJlYW1Db250cm9sbGVyLnByb3RvdHlwZS5mb2xsb3dpbmdCdWZmZXJlZEZyYWcgPSBmdW5jdGlvbiAoZnJhZykge1xuICAgICAgICBpZiAoZnJhZykge1xuICAgICAgICAgICAgLy8gdHJ5IHRvIGdldCByYW5nZSBvZiBuZXh0IGZyYWdtZW50ICg1MDBtcyBhZnRlciB0aGlzIHJhbmdlKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QnVmZmVyZWRGcmFnKGZyYWcuZW5kUFRTICsgMC41KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTdHJlYW1Db250cm9sbGVyLnByb3RvdHlwZSwgXCJuZXh0TGV2ZWxcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBmcmFnID0gdGhpcy5uZXh0QnVmZmVyZWRGcmFnO1xuICAgICAgICAgICAgaWYgKGZyYWcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnJhZy5sZXZlbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgU3RyZWFtQ29udHJvbGxlci5wcm90b3R5cGUuX2NoZWNrRnJhZ21lbnRDaGFuZ2VkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZnJhZ1BsYXlpbmdDdXJyZW50LCBjdXJyZW50VGltZSwgdmlkZW8gPSB0aGlzLm1lZGlhO1xuICAgICAgICBpZiAodmlkZW8gJiYgdmlkZW8ucmVhZHlTdGF0ZSAmJiB2aWRlby5zZWVraW5nID09PSBmYWxzZSkge1xuICAgICAgICAgICAgY3VycmVudFRpbWUgPSB2aWRlby5jdXJyZW50VGltZTtcbiAgICAgICAgICAgIC8qIGlmIHZpZGVvIGVsZW1lbnQgaXMgaW4gc2Vla2VkIHN0YXRlLCBjdXJyZW50VGltZSBjYW4gb25seSBpbmNyZWFzZS5cbiAgICAgICAgICAgICAgKGFzc3VtaW5nIHRoYXQgcGxheWJhY2sgcmF0ZSBpcyBwb3NpdGl2ZSAuLi4pXG4gICAgICAgICAgICAgIEFzIHNvbWV0aW1lcyBjdXJyZW50VGltZSBqdW1wcyBiYWNrIHRvIHplcm8gYWZ0ZXIgYVxuICAgICAgICAgICAgICBtZWRpYSBkZWNvZGUgZXJyb3IsIGNoZWNrIHRoaXMsIHRvIGF2b2lkIHNlZWtpbmcgYmFjayB0b1xuICAgICAgICAgICAgICB3cm9uZyBwb3NpdGlvbiBhZnRlciBhIG1lZGlhIGRlY29kZSBlcnJvclxuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmIChjdXJyZW50VGltZSA+IHRoaXMubGFzdEN1cnJlbnRUaW1lKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sYXN0Q3VycmVudFRpbWUgPSBjdXJyZW50VGltZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChidWZmZXJfaGVscGVyXzEuQnVmZmVySGVscGVyLmlzQnVmZmVyZWQodmlkZW8sIGN1cnJlbnRUaW1lKSkge1xuICAgICAgICAgICAgICAgIGZyYWdQbGF5aW5nQ3VycmVudCA9IHRoaXMuZ2V0QnVmZmVyZWRGcmFnKGN1cnJlbnRUaW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGJ1ZmZlcl9oZWxwZXJfMS5CdWZmZXJIZWxwZXIuaXNCdWZmZXJlZCh2aWRlbywgY3VycmVudFRpbWUgKyAwLjEpKSB7XG4gICAgICAgICAgICAgICAgLyogZW5zdXJlIHRoYXQgRlJBR19DSEFOR0VEIGV2ZW50IGlzIHRyaWdnZXJlZCBhdCBzdGFydHVwLFxuICAgICAgICAgICAgICAgICAgd2hlbiBmaXJzdCB2aWRlbyBmcmFtZSBpcyBkaXNwbGF5ZWQgYW5kIHBsYXliYWNrIGlzIHBhdXNlZC5cbiAgICAgICAgICAgICAgICAgIGFkZCBhIHRvbGVyYW5jZSBvZiAxMDBtcywgaW4gY2FzZSBjdXJyZW50IHBvc2l0aW9uIGlzIG5vdCBidWZmZXJlZCxcbiAgICAgICAgICAgICAgICAgIGNoZWNrIGlmIGN1cnJlbnQgcG9zKzEwMG1zIGlzIGJ1ZmZlcmVkIGFuZCB1c2UgdGhhdCBidWZmZXIgcmFuZ2VcbiAgICAgICAgICAgICAgICAgIGZvciBGUkFHX0NIQU5HRUQgZXZlbnQgcmVwb3J0aW5nICovXG4gICAgICAgICAgICAgICAgZnJhZ1BsYXlpbmdDdXJyZW50ID0gdGhpcy5nZXRCdWZmZXJlZEZyYWcoY3VycmVudFRpbWUgKyAwLjEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZyYWdQbGF5aW5nQ3VycmVudCkge1xuICAgICAgICAgICAgICAgIHZhciBmcmFnUGxheWluZyA9IGZyYWdQbGF5aW5nQ3VycmVudDtcbiAgICAgICAgICAgICAgICBpZiAoZnJhZ1BsYXlpbmcgIT09IHRoaXMuZnJhZ1BsYXlpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5obHMudHJpZ2dlcihldmVudHNfMS5kZWZhdWx0LkZSQUdfQ0hBTkdFRCwgeyBmcmFnOiBmcmFnUGxheWluZyB9KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZyYWdQbGF5aW5nTGV2ZWwgPSBmcmFnUGxheWluZy5sZXZlbDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmZyYWdQbGF5aW5nIHx8IHRoaXMuZnJhZ1BsYXlpbmcubGV2ZWwgIT09IGZyYWdQbGF5aW5nTGV2ZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoZXZlbnRzXzEuZGVmYXVsdC5MRVZFTF9TV0lUQ0hFRCwgeyBsZXZlbDogZnJhZ1BsYXlpbmdMZXZlbCB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmZyYWdQbGF5aW5nID0gZnJhZ1BsYXlpbmc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICAvKlxuICAgICAgb24gaW1tZWRpYXRlIGxldmVsIHN3aXRjaCA6XG4gICAgICAgLSBwYXVzZSBwbGF5YmFjayBpZiBwbGF5aW5nXG4gICAgICAgLSBjYW5jZWwgYW55IHBlbmRpbmcgbG9hZCByZXF1ZXN0XG4gICAgICAgLSBhbmQgdHJpZ2dlciBhIGJ1ZmZlciBmbHVzaFxuICAgICovXG4gICAgU3RyZWFtQ29udHJvbGxlci5wcm90b3R5cGUuaW1tZWRpYXRlTGV2ZWxTd2l0Y2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGxvZ2dlcl8xLmxvZ2dlci5sb2coJ2ltbWVkaWF0ZUxldmVsU3dpdGNoJyk7XG4gICAgICAgIGlmICghdGhpcy5pbW1lZGlhdGVTd2l0Y2gpIHtcbiAgICAgICAgICAgIHRoaXMuaW1tZWRpYXRlU3dpdGNoID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBtZWRpYSA9IHRoaXMubWVkaWEsIHByZXZpb3VzbHlQYXVzZWQgPSB2b2lkIDA7XG4gICAgICAgICAgICBpZiAobWVkaWEpIHtcbiAgICAgICAgICAgICAgICBwcmV2aW91c2x5UGF1c2VkID0gbWVkaWEucGF1c2VkO1xuICAgICAgICAgICAgICAgIG1lZGlhLnBhdXNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBkb24ndCByZXN0YXJ0IHBsYXliYWNrIGFmdGVyIGluc3RhbnQgbGV2ZWwgc3dpdGNoIGluIGNhc2UgbWVkaWEgbm90IGF0dGFjaGVkXG4gICAgICAgICAgICAgICAgcHJldmlvdXNseVBhdXNlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnByZXZpb3VzbHlQYXVzZWQgPSBwcmV2aW91c2x5UGF1c2VkO1xuICAgICAgICB9XG4gICAgICAgIHZhciBmcmFnQ3VycmVudCA9IHRoaXMuZnJhZ0N1cnJlbnQ7XG4gICAgICAgIGlmIChmcmFnQ3VycmVudCAmJiBmcmFnQ3VycmVudC5sb2FkZXIpIHtcbiAgICAgICAgICAgIGZyYWdDdXJyZW50LmxvYWRlci5hYm9ydCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZnJhZ0N1cnJlbnQgPSBudWxsO1xuICAgICAgICAvLyBmbHVzaCBldmVyeXRoaW5nXG4gICAgICAgIHRoaXMuZmx1c2hNYWluQnVmZmVyKDAsIE51bWJlci5QT1NJVElWRV9JTkZJTklUWSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBvbiBpbW1lZGlhdGUgbGV2ZWwgc3dpdGNoIGVuZCwgYWZ0ZXIgbmV3IGZyYWdtZW50IGhhcyBiZWVuIGJ1ZmZlcmVkOlxuICAgICAqIC0gbnVkZ2UgdmlkZW8gZGVjb2RlciBieSBzbGlnaHRseSBhZGp1c3RpbmcgdmlkZW8gY3VycmVudFRpbWUgKGlmIGN1cnJlbnRUaW1lIGJ1ZmZlcmVkKVxuICAgICAqIC0gcmVzdW1lIHRoZSBwbGF5YmFjayBpZiBuZWVkZWRcbiAgICAgKi9cbiAgICBTdHJlYW1Db250cm9sbGVyLnByb3RvdHlwZS5pbW1lZGlhdGVMZXZlbFN3aXRjaEVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG1lZGlhID0gdGhpcy5tZWRpYTtcbiAgICAgICAgaWYgKG1lZGlhICYmIG1lZGlhLmJ1ZmZlcmVkLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5pbW1lZGlhdGVTd2l0Y2ggPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChidWZmZXJfaGVscGVyXzEuQnVmZmVySGVscGVyLmlzQnVmZmVyZWQobWVkaWEsIG1lZGlhLmN1cnJlbnRUaW1lKSkge1xuICAgICAgICAgICAgICAgIC8vIG9ubHkgbnVkZ2UgaWYgY3VycmVudFRpbWUgaXMgYnVmZmVyZWRcbiAgICAgICAgICAgICAgICBtZWRpYS5jdXJyZW50VGltZSAtPSAwLjAwMDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMucHJldmlvdXNseVBhdXNlZCkge1xuICAgICAgICAgICAgICAgIG1lZGlhLnBsYXkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogdHJ5IHRvIHN3aXRjaCBBU0FQIHdpdGhvdXQgYnJlYWtpbmcgdmlkZW8gcGxheWJhY2s6XG4gICAgICogaW4gb3JkZXIgdG8gZW5zdXJlIHNtb290aCBidXQgcXVpY2sgbGV2ZWwgc3dpdGNoaW5nLFxuICAgICAqIHdlIG5lZWQgdG8gZmluZCB0aGUgbmV4dCBmbHVzaGFibGUgYnVmZmVyIHJhbmdlXG4gICAgICogd2Ugc2hvdWxkIHRha2UgaW50byBhY2NvdW50IG5ldyBzZWdtZW50IGZldGNoIHRpbWVcbiAgICAgKi9cbiAgICBTdHJlYW1Db250cm9sbGVyLnByb3RvdHlwZS5uZXh0TGV2ZWxTd2l0Y2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBtZWRpYSA9IHRoaXMubWVkaWE7XG4gICAgICAgIC8vIGVuc3VyZSB0aGF0IG1lZGlhIGlzIGRlZmluZWQgYW5kIHRoYXQgbWV0YWRhdGEgYXJlIGF2YWlsYWJsZSAodG8gcmV0cmlldmUgY3VycmVudFRpbWUpXG4gICAgICAgIGlmIChtZWRpYSAmJiBtZWRpYS5yZWFkeVN0YXRlKSB7XG4gICAgICAgICAgICB2YXIgZmV0Y2hkZWxheSA9IHZvaWQgMCwgZnJhZ1BsYXlpbmdDdXJyZW50ID0gdm9pZCAwLCBuZXh0QnVmZmVyZWRGcmFnID0gdm9pZCAwO1xuICAgICAgICAgICAgZnJhZ1BsYXlpbmdDdXJyZW50ID0gdGhpcy5nZXRCdWZmZXJlZEZyYWcobWVkaWEuY3VycmVudFRpbWUpO1xuICAgICAgICAgICAgaWYgKGZyYWdQbGF5aW5nQ3VycmVudCAmJiBmcmFnUGxheWluZ0N1cnJlbnQuc3RhcnRQVFMgPiAxKSB7XG4gICAgICAgICAgICAgICAgLy8gZmx1c2ggYnVmZmVyIHByZWNlZGluZyBjdXJyZW50IGZyYWdtZW50IChmbHVzaCB1bnRpbCBjdXJyZW50IGZyYWdtZW50IHN0YXJ0IG9mZnNldClcbiAgICAgICAgICAgICAgICAvLyBtaW51cyAxcyB0byBhdm9pZCB2aWRlbyBmcmVlemluZywgdGhhdCBjb3VsZCBoYXBwZW4gaWYgd2UgZmx1c2gga2V5ZnJhbWUgb2YgY3VycmVudCB2aWRlbyAuLi5cbiAgICAgICAgICAgICAgICB0aGlzLmZsdXNoTWFpbkJ1ZmZlcigwLCBmcmFnUGxheWluZ0N1cnJlbnQuc3RhcnRQVFMgLSAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghbWVkaWEucGF1c2VkKSB7XG4gICAgICAgICAgICAgICAgLy8gYWRkIGEgc2FmZXR5IGRlbGF5IG9mIDFzXG4gICAgICAgICAgICAgICAgdmFyIG5leHRMZXZlbElkID0gdGhpcy5obHMubmV4dExvYWRMZXZlbCwgbmV4dExldmVsID0gdGhpcy5sZXZlbHNbbmV4dExldmVsSWRdLCBmcmFnTGFzdEticHMgPSB0aGlzLmZyYWdMYXN0S2JwcztcbiAgICAgICAgICAgICAgICBpZiAoZnJhZ0xhc3RLYnBzICYmIHRoaXMuZnJhZ0N1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgZmV0Y2hkZWxheSA9IHRoaXMuZnJhZ0N1cnJlbnQuZHVyYXRpb24gKiBuZXh0TGV2ZWwuYml0cmF0ZSAvICgxMDAwICogZnJhZ0xhc3RLYnBzKSArIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmZXRjaGRlbGF5ID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmZXRjaGRlbGF5ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGxvZ2dlci5sb2coJ2ZldGNoZGVsYXk6JytmZXRjaGRlbGF5KTtcbiAgICAgICAgICAgIC8vIGZpbmQgYnVmZmVyIHJhbmdlIHRoYXQgd2lsbCBiZSByZWFjaGVkIG9uY2UgbmV3IGZyYWdtZW50IHdpbGwgYmUgZmV0Y2hlZFxuICAgICAgICAgICAgbmV4dEJ1ZmZlcmVkRnJhZyA9IHRoaXMuZ2V0QnVmZmVyZWRGcmFnKG1lZGlhLmN1cnJlbnRUaW1lICsgZmV0Y2hkZWxheSk7XG4gICAgICAgICAgICBpZiAobmV4dEJ1ZmZlcmVkRnJhZykge1xuICAgICAgICAgICAgICAgIC8vIHdlIGNhbiBmbHVzaCBidWZmZXIgcmFuZ2UgZm9sbG93aW5nIHRoaXMgb25lIHdpdGhvdXQgc3RhbGxpbmcgcGxheWJhY2tcbiAgICAgICAgICAgICAgICBuZXh0QnVmZmVyZWRGcmFnID0gdGhpcy5mb2xsb3dpbmdCdWZmZXJlZEZyYWcobmV4dEJ1ZmZlcmVkRnJhZyk7XG4gICAgICAgICAgICAgICAgaWYgKG5leHRCdWZmZXJlZEZyYWcpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgd2UgYXJlIGhlcmUsIHdlIGNhbiBhbHNvIGNhbmNlbCBhbnkgbG9hZGluZy9kZW11eGluZyBpbiBwcm9ncmVzcywgYXMgdGhleSBhcmUgdXNlbGVzc1xuICAgICAgICAgICAgICAgICAgICB2YXIgZnJhZ0N1cnJlbnQgPSB0aGlzLmZyYWdDdXJyZW50O1xuICAgICAgICAgICAgICAgICAgICBpZiAoZnJhZ0N1cnJlbnQgJiYgZnJhZ0N1cnJlbnQubG9hZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmcmFnQ3VycmVudC5sb2FkZXIuYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmZyYWdDdXJyZW50ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgLy8gc3RhcnQgZmx1c2ggcG9zaXRpb24gaXMgdGhlIHN0YXJ0IFBUUyBvZiBuZXh0IGJ1ZmZlcmVkIGZyYWcuXG4gICAgICAgICAgICAgICAgICAgIC8vIHdlIHVzZSBmcmFnLm5heFN0YXJ0UFRTIHdoaWNoIGlzIG1heChhdWRpbyBzdGFydFBUUywgdmlkZW8gc3RhcnRQVFMpLlxuICAgICAgICAgICAgICAgICAgICAvLyBpbiBjYXNlIHRoZXJlIGlzIGEgc21hbGwgUFRTIERlbHRhIGJldHdlZW4gYXVkaW8gYW5kIHZpZGVvLCB1c2luZyBtYXhTdGFydFBUUyBhdm9pZHMgZmx1c2hpbmcgbGFzdCBzYW1wbGVzIGZyb20gY3VycmVudCBmcmFnbWVudFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmZsdXNoTWFpbkJ1ZmZlcihuZXh0QnVmZmVyZWRGcmFnLm1heFN0YXJ0UFRTLCBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgU3RyZWFtQ29udHJvbGxlci5wcm90b3R5cGUuZmx1c2hNYWluQnVmZmVyID0gZnVuY3Rpb24gKHN0YXJ0T2Zmc2V0LCBlbmRPZmZzZXQpIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IGJhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfMS5TdGF0ZS5CVUZGRVJfRkxVU0hJTkc7XG4gICAgICAgIHZhciBmbHVzaFNjb3BlID0geyBzdGFydE9mZnNldDogc3RhcnRPZmZzZXQsIGVuZE9mZnNldDogZW5kT2Zmc2V0IH07XG4gICAgICAgIC8vIGlmIGFsdGVybmF0ZSBhdWRpbyB0cmFja3MgYXJlIHVzZWQsIG9ubHkgZmx1c2ggdmlkZW8sIG90aGVyd2lzZSBmbHVzaCBldmVyeXRoaW5nXG4gICAgICAgIGlmICh0aGlzLmFsdEF1ZGlvKSB7XG4gICAgICAgICAgICBmbHVzaFNjb3BlLnR5cGUgPSAndmlkZW8nO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoZXZlbnRzXzEuZGVmYXVsdC5CVUZGRVJfRkxVU0hJTkcsIGZsdXNoU2NvcGUpO1xuICAgIH07XG4gICAgU3RyZWFtQ29udHJvbGxlci5wcm90b3R5cGUub25NZWRpYUF0dGFjaGVkID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdmFyIG1lZGlhID0gdGhpcy5tZWRpYSA9IHRoaXMubWVkaWFCdWZmZXIgPSBkYXRhLm1lZGlhO1xuICAgICAgICB0aGlzLm9udnNlZWtpbmcgPSB0aGlzLm9uTWVkaWFTZWVraW5nLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub252c2Vla2VkID0gdGhpcy5vbk1lZGlhU2Vla2VkLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub252ZW5kZWQgPSB0aGlzLm9uTWVkaWFFbmRlZC5iaW5kKHRoaXMpO1xuICAgICAgICBtZWRpYS5hZGRFdmVudExpc3RlbmVyKCdzZWVraW5nJywgdGhpcy5vbnZzZWVraW5nKTtcbiAgICAgICAgbWVkaWEuYWRkRXZlbnRMaXN0ZW5lcignc2Vla2VkJywgdGhpcy5vbnZzZWVrZWQpO1xuICAgICAgICBtZWRpYS5hZGRFdmVudExpc3RlbmVyKCdlbmRlZCcsIHRoaXMub252ZW5kZWQpO1xuICAgICAgICB2YXIgY29uZmlnID0gdGhpcy5jb25maWc7XG4gICAgICAgIGlmICh0aGlzLmxldmVscyAmJiBjb25maWcuYXV0b1N0YXJ0TG9hZCkge1xuICAgICAgICAgICAgdGhpcy5obHMuc3RhcnRMb2FkKGNvbmZpZy5zdGFydFBvc2l0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmdhcENvbnRyb2xsZXIgPSBuZXcgZ2FwX2NvbnRyb2xsZXJfMS5kZWZhdWx0KGNvbmZpZywgbWVkaWEsIHRoaXMuZnJhZ21lbnRUcmFja2VyLCB0aGlzLmhscyk7XG4gICAgfTtcbiAgICBTdHJlYW1Db250cm9sbGVyLnByb3RvdHlwZS5vbk1lZGlhRGV0YWNoaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbWVkaWEgPSB0aGlzLm1lZGlhO1xuICAgICAgICBpZiAobWVkaWEgJiYgbWVkaWEuZW5kZWQpIHtcbiAgICAgICAgICAgIGxvZ2dlcl8xLmxvZ2dlci5sb2coJ01TRSBkZXRhY2hpbmcgYW5kIHZpZGVvIGVuZGVkLCByZXNldCBzdGFydFBvc2l0aW9uJyk7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0UG9zaXRpb24gPSB0aGlzLmxhc3RDdXJyZW50VGltZSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmVzZXQgZnJhZ21lbnQgYmFja3RyYWNrZWQgZmxhZ1xuICAgICAgICB2YXIgbGV2ZWxzID0gdGhpcy5sZXZlbHM7XG4gICAgICAgIGlmIChsZXZlbHMpIHtcbiAgICAgICAgICAgIGxldmVscy5mb3JFYWNoKGZ1bmN0aW9uIChsZXZlbCkge1xuICAgICAgICAgICAgICAgIGlmIChsZXZlbC5kZXRhaWxzKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldmVsLmRldGFpbHMuZnJhZ21lbnRzLmZvckVhY2goZnVuY3Rpb24gKGZyYWdtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmcmFnbWVudC5iYWNrdHJhY2tlZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmVtb3ZlIHZpZGVvIGxpc3RlbmVyc1xuICAgICAgICBpZiAobWVkaWEpIHtcbiAgICAgICAgICAgIG1lZGlhLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3NlZWtpbmcnLCB0aGlzLm9udnNlZWtpbmcpO1xuICAgICAgICAgICAgbWVkaWEucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Vla2VkJywgdGhpcy5vbnZzZWVrZWQpO1xuICAgICAgICAgICAgbWVkaWEucmVtb3ZlRXZlbnRMaXN0ZW5lcignZW5kZWQnLCB0aGlzLm9udmVuZGVkKTtcbiAgICAgICAgICAgIHRoaXMub252c2Vla2luZyA9IHRoaXMub252c2Vla2VkID0gdGhpcy5vbnZlbmRlZCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tZWRpYSA9IHRoaXMubWVkaWFCdWZmZXIgPSBudWxsO1xuICAgICAgICB0aGlzLmxvYWRlZG1ldGFkYXRhID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc3RvcExvYWQoKTtcbiAgICB9O1xuICAgIFN0cmVhbUNvbnRyb2xsZXIucHJvdG90eXBlLm9uTWVkaWFTZWVrZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBtZWRpYSA9IHRoaXMubWVkaWEsIGN1cnJlbnRUaW1lID0gbWVkaWEgPyBtZWRpYS5jdXJyZW50VGltZSA6IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKE51bWJlci5pc0Zpbml0ZShjdXJyZW50VGltZSkpIHtcbiAgICAgICAgICAgIGxvZ2dlcl8xLmxvZ2dlci5sb2coXCJtZWRpYSBzZWVrZWQgdG8gXCIgKyBjdXJyZW50VGltZS50b0ZpeGVkKDMpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyB0aWNrIHRvIHNwZWVkIHVwIEZSQUdNRU5UX1BMQVlJTkcgdHJpZ2dlcmluZ1xuICAgICAgICB0aGlzLnRpY2soKTtcbiAgICB9O1xuICAgIFN0cmVhbUNvbnRyb2xsZXIucHJvdG90eXBlLm9uTWFuaWZlc3RMb2FkaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyByZXNldCBidWZmZXIgb24gbWFuaWZlc3QgbG9hZGluZ1xuICAgICAgICBsb2dnZXJfMS5sb2dnZXIubG9nKCd0cmlnZ2VyIEJVRkZFUl9SRVNFVCcpO1xuICAgICAgICB0aGlzLmhscy50cmlnZ2VyKGV2ZW50c18xLmRlZmF1bHQuQlVGRkVSX1JFU0VUKTtcbiAgICAgICAgdGhpcy5mcmFnbWVudFRyYWNrZXIucmVtb3ZlQWxsRnJhZ21lbnRzKCk7XG4gICAgICAgIHRoaXMuc3RhbGxlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnN0YXJ0UG9zaXRpb24gPSB0aGlzLmxhc3RDdXJyZW50VGltZSA9IDA7XG4gICAgfTtcbiAgICBTdHJlYW1Db250cm9sbGVyLnByb3RvdHlwZS5vbk1hbmlmZXN0UGFyc2VkID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdmFyIGFhYyA9IGZhbHNlLCBoZWFhYyA9IGZhbHNlLCBjb2RlYztcbiAgICAgICAgZGF0YS5sZXZlbHMuZm9yRWFjaChmdW5jdGlvbiAobGV2ZWwpIHtcbiAgICAgICAgICAgIC8vIGRldGVjdCBpZiB3ZSBoYXZlIGRpZmZlcmVudCBraW5kIG9mIGF1ZGlvIGNvZGVjcyB1c2VkIGFtb25nc3QgcGxheWxpc3RzXG4gICAgICAgICAgICBjb2RlYyA9IGxldmVsLmF1ZGlvQ29kZWM7XG4gICAgICAgICAgICBpZiAoY29kZWMpIHtcbiAgICAgICAgICAgICAgICBpZiAoY29kZWMuaW5kZXhPZignbXA0YS40MC4yJykgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGFhYyA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjb2RlYy5pbmRleE9mKCdtcDRhLjQwLjUnKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhYWMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuYXVkaW9Db2RlY1N3aXRjaCA9IChhYWMgJiYgaGVhYWMpO1xuICAgICAgICBpZiAodGhpcy5hdWRpb0NvZGVjU3dpdGNoKSB7XG4gICAgICAgICAgICBsb2dnZXJfMS5sb2dnZXIubG9nKCdib3RoIEFBQy9IRS1BQUMgYXVkaW8gZm91bmQgaW4gbGV2ZWxzOyBkZWNsYXJpbmcgbGV2ZWwgY29kZWMgYXMgSEUtQUFDJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sZXZlbHMgPSBkYXRhLmxldmVscztcbiAgICAgICAgdGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQgPSBmYWxzZTtcbiAgICAgICAgdmFyIGNvbmZpZyA9IHRoaXMuY29uZmlnO1xuICAgICAgICBpZiAoY29uZmlnLmF1dG9TdGFydExvYWQgfHwgdGhpcy5mb3JjZVN0YXJ0TG9hZCkge1xuICAgICAgICAgICAgdGhpcy5obHMuc3RhcnRMb2FkKGNvbmZpZy5zdGFydFBvc2l0aW9uKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU3RyZWFtQ29udHJvbGxlci5wcm90b3R5cGUub25MZXZlbExvYWRlZCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHZhciBuZXdEZXRhaWxzID0gZGF0YS5kZXRhaWxzO1xuICAgICAgICB2YXIgbmV3TGV2ZWxJZCA9IGRhdGEubGV2ZWw7XG4gICAgICAgIHZhciBsYXN0TGV2ZWwgPSB0aGlzLmxldmVsc1t0aGlzLmxldmVsTGFzdExvYWRlZF07XG4gICAgICAgIHZhciBjdXJMZXZlbCA9IHRoaXMubGV2ZWxzW25ld0xldmVsSWRdO1xuICAgICAgICB2YXIgZHVyYXRpb24gPSBuZXdEZXRhaWxzLnRvdGFsZHVyYXRpb247XG4gICAgICAgIHZhciBzbGlkaW5nID0gMDtcbiAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLmxvZyhcImxldmVsIFwiICsgbmV3TGV2ZWxJZCArIFwiIGxvYWRlZCBbXCIgKyBuZXdEZXRhaWxzLnN0YXJ0U04gKyBcIixcIiArIG5ld0RldGFpbHMuZW5kU04gKyBcIl0sZHVyYXRpb246XCIgKyBkdXJhdGlvbik7XG4gICAgICAgIGlmIChuZXdEZXRhaWxzLmxpdmUpIHtcbiAgICAgICAgICAgIHZhciBjdXJEZXRhaWxzID0gY3VyTGV2ZWwuZGV0YWlscztcbiAgICAgICAgICAgIGlmIChjdXJEZXRhaWxzICYmIG5ld0RldGFpbHMuZnJhZ21lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAvLyB3ZSBhbHJlYWR5IGhhdmUgZGV0YWlscyBmb3IgdGhhdCBsZXZlbCwgbWVyZ2UgdGhlbVxuICAgICAgICAgICAgICAgIExldmVsSGVscGVyLm1lcmdlRGV0YWlscyhjdXJEZXRhaWxzLCBuZXdEZXRhaWxzKTtcbiAgICAgICAgICAgICAgICBzbGlkaW5nID0gbmV3RGV0YWlscy5mcmFnbWVudHNbMF0uc3RhcnQ7XG4gICAgICAgICAgICAgICAgdGhpcy5saXZlU3luY1Bvc2l0aW9uID0gdGhpcy5jb21wdXRlTGl2ZVBvc2l0aW9uKHNsaWRpbmcsIGN1ckRldGFpbHMpO1xuICAgICAgICAgICAgICAgIGlmIChuZXdEZXRhaWxzLlBUU0tub3duICYmIE51bWJlci5pc0Zpbml0ZShzbGlkaW5nKSkge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXJfMS5sb2dnZXIubG9nKFwibGl2ZSBwbGF5bGlzdCBzbGlkaW5nOlwiICsgc2xpZGluZy50b0ZpeGVkKDMpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmxvZ2dlci5sb2coJ2xpdmUgcGxheWxpc3QgLSBvdXRkYXRlZCBQVFMsIHVua25vd24gc2xpZGluZycpO1xuICAgICAgICAgICAgICAgICAgICBkaXNjb250aW51aXRpZXNfMS5hbGlnblN0cmVhbSh0aGlzLmZyYWdQcmV2aW91cywgbGFzdExldmVsLCBuZXdEZXRhaWxzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsb2dnZXJfMS5sb2dnZXIubG9nKCdsaXZlIHBsYXlsaXN0IC0gZmlyc3QgbG9hZCwgdW5rbm93biBzbGlkaW5nJyk7XG4gICAgICAgICAgICAgICAgbmV3RGV0YWlscy5QVFNLbm93biA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGRpc2NvbnRpbnVpdGllc18xLmFsaWduU3RyZWFtKHRoaXMuZnJhZ1ByZXZpb3VzLCBsYXN0TGV2ZWwsIG5ld0RldGFpbHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbmV3RGV0YWlscy5QVFNLbm93biA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIG92ZXJyaWRlIGxldmVsIGluZm9cbiAgICAgICAgY3VyTGV2ZWwuZGV0YWlscyA9IG5ld0RldGFpbHM7XG4gICAgICAgIHRoaXMubGV2ZWxMYXN0TG9hZGVkID0gbmV3TGV2ZWxJZDtcbiAgICAgICAgdGhpcy5obHMudHJpZ2dlcihldmVudHNfMS5kZWZhdWx0LkxFVkVMX1VQREFURUQsIHsgZGV0YWlsczogbmV3RGV0YWlscywgbGV2ZWw6IG5ld0xldmVsSWQgfSk7XG4gICAgICAgIGlmICh0aGlzLnN0YXJ0RnJhZ1JlcXVlc3RlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIC8vIGNvbXB1dGUgc3RhcnQgcG9zaXRpb24gaWYgc2V0IHRvIC0xLiB1c2UgaXQgc3RyYWlnaHQgYXdheSBpZiB2YWx1ZSBpcyBkZWZpbmVkXG4gICAgICAgICAgICBpZiAodGhpcy5zdGFydFBvc2l0aW9uID09PSAtMSB8fCB0aGlzLmxhc3RDdXJyZW50VGltZSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAvLyBmaXJzdCwgY2hlY2sgaWYgc3RhcnQgdGltZSBvZmZzZXQgaGFzIGJlZW4gc2V0IGluIHBsYXlsaXN0LCBpZiB5ZXMsIHVzZSB0aGlzIHZhbHVlXG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0VGltZU9mZnNldCA9IG5ld0RldGFpbHMuc3RhcnRUaW1lT2Zmc2V0O1xuICAgICAgICAgICAgICAgIGlmIChOdW1iZXIuaXNGaW5pdGUoc3RhcnRUaW1lT2Zmc2V0KSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhcnRUaW1lT2Zmc2V0IDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLmxvZyhcIm5lZ2F0aXZlIHN0YXJ0IHRpbWUgb2Zmc2V0IFwiICsgc3RhcnRUaW1lT2Zmc2V0ICsgXCIsIGNvdW50IGZyb20gZW5kIG9mIGxhc3QgZnJhZ21lbnRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydFRpbWVPZmZzZXQgPSBzbGlkaW5nICsgZHVyYXRpb24gKyBzdGFydFRpbWVPZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLmxvZyhcInN0YXJ0IHRpbWUgb2Zmc2V0IGZvdW5kIGluIHBsYXlsaXN0LCBhZGp1c3Qgc3RhcnRQb3NpdGlvbiB0byBcIiArIHN0YXJ0VGltZU9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRQb3NpdGlvbiA9IHN0YXJ0VGltZU9mZnNldDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIGxpdmUgcGxheWxpc3QsIHNldCBzdGFydCBwb3NpdGlvbiB0byBiZSBmcmFnbWVudCBOLXRoaXMuY29uZmlnLmxpdmVTeW5jRHVyYXRpb25Db3VudCAodXN1YWxseSAzKVxuICAgICAgICAgICAgICAgICAgICBpZiAobmV3RGV0YWlscy5saXZlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0UG9zaXRpb24gPSB0aGlzLmNvbXB1dGVMaXZlUG9zaXRpb24oc2xpZGluZywgbmV3RGV0YWlscyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXJfMS5sb2dnZXIubG9nKFwiY29uZmlndXJlIHN0YXJ0UG9zaXRpb24gdG8gXCIgKyB0aGlzLnN0YXJ0UG9zaXRpb24pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGFydFBvc2l0aW9uID0gMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmxhc3RDdXJyZW50VGltZSA9IHRoaXMuc3RhcnRQb3NpdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubmV4dExvYWRQb3NpdGlvbiA9IHRoaXMuc3RhcnRQb3NpdGlvbjtcbiAgICAgICAgfVxuICAgICAgICAvLyBvbmx5IHN3aXRjaCBiYXRjayB0byBJRExFIHN0YXRlIGlmIHdlIHdlcmUgd2FpdGluZyBmb3IgbGV2ZWwgdG8gc3RhcnQgZG93bmxvYWRpbmcgYSBuZXcgZnJhZ21lbnRcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IGJhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfMS5TdGF0ZS5XQUlUSU5HX0xFVkVMKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gYmFzZV9zdHJlYW1fY29udHJvbGxlcl8xLlN0YXRlLklETEU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdHJpZ2dlciBoYW5kbGVyIHJpZ2h0IG5vd1xuICAgICAgICB0aGlzLnRpY2soKTtcbiAgICB9O1xuICAgIFN0cmVhbUNvbnRyb2xsZXIucHJvdG90eXBlLm9uS2V5TG9hZGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gYmFzZV9zdHJlYW1fY29udHJvbGxlcl8xLlN0YXRlLktFWV9MT0FESU5HKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gYmFzZV9zdHJlYW1fY29udHJvbGxlcl8xLlN0YXRlLklETEU7XG4gICAgICAgICAgICB0aGlzLnRpY2soKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU3RyZWFtQ29udHJvbGxlci5wcm90b3R5cGUub25GcmFnTG9hZGVkID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcywgZnJhZ0N1cnJlbnQgPSBfYS5mcmFnQ3VycmVudCwgaGxzID0gX2EuaGxzLCBsZXZlbHMgPSBfYS5sZXZlbHMsIG1lZGlhID0gX2EubWVkaWE7XG4gICAgICAgIHZhciBmcmFnTG9hZGVkID0gZGF0YS5mcmFnO1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gYmFzZV9zdHJlYW1fY29udHJvbGxlcl8xLlN0YXRlLkZSQUdfTE9BRElORyAmJlxuICAgICAgICAgICAgZnJhZ0N1cnJlbnQgJiZcbiAgICAgICAgICAgIGZyYWdMb2FkZWQudHlwZSA9PT0gJ21haW4nICYmXG4gICAgICAgICAgICBmcmFnTG9hZGVkLmxldmVsID09PSBmcmFnQ3VycmVudC5sZXZlbCAmJlxuICAgICAgICAgICAgZnJhZ0xvYWRlZC5zbiA9PT0gZnJhZ0N1cnJlbnQuc24pIHtcbiAgICAgICAgICAgIHZhciBzdGF0cyA9IGRhdGEuc3RhdHM7XG4gICAgICAgICAgICB2YXIgY3VycmVudExldmVsID0gbGV2ZWxzW2ZyYWdDdXJyZW50LmxldmVsXTtcbiAgICAgICAgICAgIHZhciBkZXRhaWxzID0gY3VycmVudExldmVsLmRldGFpbHM7XG4gICAgICAgICAgICAvLyByZXNldCBmcmFnIGJpdHJhdGUgdGVzdCBpbiBhbnkgY2FzZSBhZnRlciBmcmFnIGxvYWRlZCBldmVudFxuICAgICAgICAgICAgLy8gaWYgdGhpcyBmcmFnIHdhcyBsb2FkZWQgdG8gcGVyZm9ybSBhIGJpdHJhdGUgdGVzdCBBTkQgaWYgaGxzLm5leHRMb2FkTGV2ZWwgaXMgZ3JlYXRlciB0aGFuIDBcbiAgICAgICAgICAgIC8vIHRoZW4gdGhpcyBtZWFucyB0aGF0IHdlIHNob3VsZCBiZSBhYmxlIHRvIGxvYWQgYSBmcmFnbWVudCBhdCBhIGhpZ2hlciBxdWFsaXR5IGxldmVsXG4gICAgICAgICAgICB0aGlzLmJpdHJhdGVUZXN0ID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLnN0YXRzID0gc3RhdHM7XG4gICAgICAgICAgICBsb2dnZXJfMS5sb2dnZXIubG9nKFwiTG9hZGVkIFwiICsgZnJhZ0N1cnJlbnQuc24gKyBcIiBvZiBbXCIgKyBkZXRhaWxzLnN0YXJ0U04gKyBcIiAsXCIgKyBkZXRhaWxzLmVuZFNOICsgXCJdLGxldmVsIFwiICsgZnJhZ0N1cnJlbnQubGV2ZWwpO1xuICAgICAgICAgICAgaWYgKGZyYWdMb2FkZWQuYml0cmF0ZVRlc3QgJiYgaGxzLm5leHRMb2FkTGV2ZWwpIHtcbiAgICAgICAgICAgICAgICAvLyBzd2l0Y2ggYmFjayB0byBJRExFIHN0YXRlIC4uLiB3ZSBqdXN0IGxvYWRlZCBhIGZyYWdtZW50IHRvIGRldGVybWluZSBhZGVxdWF0ZSBzdGFydCBiaXRyYXRlIGFuZCBpbml0aWFsaXplIGF1dG9zd2l0Y2ggYWxnb1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBiYXNlX3N0cmVhbV9jb250cm9sbGVyXzEuU3RhdGUuSURMRTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0RnJhZ1JlcXVlc3RlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHN0YXRzLnRwYXJzZWQgPSBzdGF0cy50YnVmZmVyZWQgPSB3aW5kb3cucGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgICAgICAgICAgaGxzLnRyaWdnZXIoZXZlbnRzXzEuZGVmYXVsdC5GUkFHX0JVRkZFUkVELCB7IHN0YXRzOiBzdGF0cywgZnJhZzogZnJhZ0N1cnJlbnQsIGlkOiAnbWFpbicgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy50aWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChmcmFnTG9hZGVkLnNuID09PSAnaW5pdFNlZ21lbnQnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IGJhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfMS5TdGF0ZS5JRExFO1xuICAgICAgICAgICAgICAgIHN0YXRzLnRwYXJzZWQgPSBzdGF0cy50YnVmZmVyZWQgPSB3aW5kb3cucGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgICAgICAgICAgZGV0YWlscy5pbml0U2VnbWVudC5kYXRhID0gZGF0YS5wYXlsb2FkO1xuICAgICAgICAgICAgICAgIGhscy50cmlnZ2VyKGV2ZW50c18xLmRlZmF1bHQuRlJBR19CVUZGRVJFRCwgeyBzdGF0czogc3RhdHMsIGZyYWc6IGZyYWdDdXJyZW50LCBpZDogJ21haW4nIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMudGljaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLmxvZyhcIlBhcnNpbmcgXCIgKyBmcmFnQ3VycmVudC5zbiArIFwiIG9mIFtcIiArIGRldGFpbHMuc3RhcnRTTiArIFwiICxcIiArIGRldGFpbHMuZW5kU04gKyBcIl0sbGV2ZWwgXCIgKyBmcmFnQ3VycmVudC5sZXZlbCArIFwiLCBjYyBcIiArIGZyYWdDdXJyZW50LmNjKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gYmFzZV9zdHJlYW1fY29udHJvbGxlcl8xLlN0YXRlLlBBUlNJTkc7XG4gICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nQnVmZmVyaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmFwcGVuZGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgLy8gQml0cmF0ZSB0ZXN0IGZyYWdzIGFyZSBub3QgdXN1YWxseSBidWZmZXJlZCBzbyB0aGUgZnJhZ21lbnQgdHJhY2tlciBpZ25vcmVzIHRoZW0uIElmIEhscy5qcyBkZWNpZGVzIHRvIGJ1ZmZlclxuICAgICAgICAgICAgICAgIC8vIGl0IChhbmQgdGhlcmVmb3JlIGVuZHMgdXAgYXQgdGhpcyBsaW5lKSwgdGhlbiB0aGUgZnJhZ21lbnQgdHJhY2tlciBuZWVkcyB0byBiZSBtYW51YWxseSBpbmZvcm1lZC5cbiAgICAgICAgICAgICAgICBpZiAoZnJhZ0xvYWRlZC5iaXRyYXRlVGVzdCkge1xuICAgICAgICAgICAgICAgICAgICBmcmFnTG9hZGVkLmJpdHJhdGVUZXN0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyLm9uRnJhZ0xvYWRlZCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBmcmFnOiBmcmFnTG9hZGVkXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyB0aW1lIE9mZnNldCBpcyBhY2N1cmF0ZSBpZiBsZXZlbCBQVFMgaXMga25vd24sIG9yIGlmIHBsYXlsaXN0IGlzIG5vdCBzbGlkaW5nIChub3QgbGl2ZSkgYW5kIGlmIG1lZGlhIGlzIG5vdCBzZWVraW5nICh0aGlzIGlzIHRvIG92ZXJjb21lIHBvdGVudGlhbCB0aW1lc3RhbXAgZHJpZnRzIGJldHdlZW4gcGxheWxpc3RzIGFuZCBmcmFnbWVudHMpXG4gICAgICAgICAgICAgICAgdmFyIGFjY3VyYXRlVGltZU9mZnNldCA9ICEobWVkaWEgJiYgbWVkaWEuc2Vla2luZykgJiYgKGRldGFpbHMuUFRTS25vd24gfHwgIWRldGFpbHMubGl2ZSk7XG4gICAgICAgICAgICAgICAgdmFyIGluaXRTZWdtZW50RGF0YSA9IGRldGFpbHMuaW5pdFNlZ21lbnQgPyBkZXRhaWxzLmluaXRTZWdtZW50LmRhdGEgOiBbXTtcbiAgICAgICAgICAgICAgICB2YXIgYXVkaW9Db2RlYyA9IHRoaXMuX2dldEF1ZGlvQ29kZWMoY3VycmVudExldmVsKTtcbiAgICAgICAgICAgICAgICAvLyB0cmFuc211eCB0aGUgTVBFRy1UUyBkYXRhIHRvIElTTy1CTUZGIHNlZ21lbnRzXG4gICAgICAgICAgICAgICAgdmFyIGRlbXV4ZXIgPSB0aGlzLmRlbXV4ZXIgPSB0aGlzLmRlbXV4ZXIgfHwgbmV3IGRlbXV4ZXJfMS5kZWZhdWx0KHRoaXMuaGxzLCAnbWFpbicpO1xuICAgICAgICAgICAgICAgIGRlbXV4ZXIucHVzaChkYXRhLnBheWxvYWQsIGluaXRTZWdtZW50RGF0YSwgYXVkaW9Db2RlYywgY3VycmVudExldmVsLnZpZGVvQ29kZWMsIGZyYWdDdXJyZW50LCBkZXRhaWxzLnRvdGFsZHVyYXRpb24sIGFjY3VyYXRlVGltZU9mZnNldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5mcmFnTG9hZEVycm9yID0gMDtcbiAgICB9O1xuICAgIFN0cmVhbUNvbnRyb2xsZXIucHJvdG90eXBlLm9uRnJhZ1BhcnNpbmdJbml0U2VnbWVudCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHZhciBmcmFnQ3VycmVudCA9IHRoaXMuZnJhZ0N1cnJlbnQ7XG4gICAgICAgIHZhciBmcmFnTmV3ID0gZGF0YS5mcmFnO1xuICAgICAgICBpZiAoZnJhZ0N1cnJlbnQgJiZcbiAgICAgICAgICAgIGRhdGEuaWQgPT09ICdtYWluJyAmJlxuICAgICAgICAgICAgZnJhZ05ldy5zbiA9PT0gZnJhZ0N1cnJlbnQuc24gJiZcbiAgICAgICAgICAgIGZyYWdOZXcubGV2ZWwgPT09IGZyYWdDdXJyZW50LmxldmVsICYmXG4gICAgICAgICAgICB0aGlzLnN0YXRlID09PSBiYXNlX3N0cmVhbV9jb250cm9sbGVyXzEuU3RhdGUuUEFSU0lORykge1xuICAgICAgICAgICAgdmFyIHRyYWNrcyA9IGRhdGEudHJhY2tzLCB0cmFja05hbWUgPSB2b2lkIDAsIHRyYWNrID0gdm9pZCAwO1xuICAgICAgICAgICAgLy8gaWYgYXVkaW8gdHJhY2sgaXMgZXhwZWN0ZWQgdG8gY29tZSBmcm9tIGF1ZGlvIHN0cmVhbSBjb250cm9sbGVyLCBkaXNjYXJkIGFueSBjb21pbmcgZnJvbSBtYWluXG4gICAgICAgICAgICBpZiAodHJhY2tzLmF1ZGlvICYmIHRoaXMuYWx0QXVkaW8pIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgdHJhY2tzLmF1ZGlvO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaW5jbHVkZSBsZXZlbENvZGVjIGluIGF1ZGlvIGFuZCB2aWRlbyB0cmFja3NcbiAgICAgICAgICAgIHRyYWNrID0gdHJhY2tzLmF1ZGlvO1xuICAgICAgICAgICAgaWYgKHRyYWNrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGF1ZGlvQ29kZWMgPSB0aGlzLmxldmVsc1t0aGlzLmxldmVsXS5hdWRpb0NvZGVjLCB1YSA9IG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICBpZiAoYXVkaW9Db2RlYyAmJiB0aGlzLmF1ZGlvQ29kZWNTd2FwKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmxvZ2dlci5sb2coJ3N3YXBwaW5nIHBsYXlsaXN0IGF1ZGlvIGNvZGVjJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhdWRpb0NvZGVjLmluZGV4T2YoJ21wNGEuNDAuNScpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXVkaW9Db2RlYyA9ICdtcDRhLjQwLjInO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXVkaW9Db2RlYyA9ICdtcDRhLjQwLjUnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGluIGNhc2UgQUFDIGFuZCBIRS1BQUMgYXVkaW8gY29kZWNzIGFyZSBzaWduYWxsZWQgaW4gbWFuaWZlc3RcbiAgICAgICAgICAgICAgICAvLyBmb3JjZSBIRS1BQUMgLCBhcyBpdCBzZWVtcyB0aGF0IG1vc3QgYnJvd3NlcnMgcHJlZmVycyB0aGF0IHdheSxcbiAgICAgICAgICAgICAgICAvLyBleGNlcHQgZm9yIG1vbm8gc3RyZWFtcyBPUiBvbiBGRlxuICAgICAgICAgICAgICAgIC8vIHRoZXNlIGNvbmRpdGlvbnMgbWlnaHQgbmVlZCB0byBiZSByZXZpZXdlZCAuLi5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5hdWRpb0NvZGVjU3dpdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGRvbid0IGZvcmNlIEhFLUFBQyBpZiBtb25vIHN0cmVhbVxuICAgICAgICAgICAgICAgICAgICBpZiAodHJhY2subWV0YWRhdGEuY2hhbm5lbENvdW50ICE9PSAxICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBkb24ndCBmb3JjZSBIRS1BQUMgaWYgZmlyZWZveFxuICAgICAgICAgICAgICAgICAgICAgICAgdWEuaW5kZXhPZignZmlyZWZveCcpID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXVkaW9Db2RlYyA9ICdtcDRhLjQwLjUnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEhFLUFBQyBpcyBicm9rZW4gb24gQW5kcm9pZCwgYWx3YXlzIHNpZ25hbCBhdWRpbyBjb2RlYyBhcyBBQUMgZXZlbiBpZiB2YXJpYW50IG1hbmlmZXN0IHN0YXRlcyBvdGhlcndpc2VcbiAgICAgICAgICAgICAgICBpZiAodWEuaW5kZXhPZignYW5kcm9pZCcpICE9PSAtMSAmJiB0cmFjay5jb250YWluZXIgIT09ICdhdWRpby9tcGVnJykgeyAvLyBFeGNsdWRlIG1wZWcgYXVkaW9cbiAgICAgICAgICAgICAgICAgICAgYXVkaW9Db2RlYyA9ICdtcDRhLjQwLjInO1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXJfMS5sb2dnZXIubG9nKFwiQW5kcm9pZDogZm9yY2UgYXVkaW8gY29kZWMgdG8gXCIgKyBhdWRpb0NvZGVjKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHJhY2subGV2ZWxDb2RlYyA9IGF1ZGlvQ29kZWM7XG4gICAgICAgICAgICAgICAgdHJhY2suaWQgPSBkYXRhLmlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJhY2sgPSB0cmFja3MudmlkZW87XG4gICAgICAgICAgICBpZiAodHJhY2spIHtcbiAgICAgICAgICAgICAgICB0cmFjay5sZXZlbENvZGVjID0gdGhpcy5sZXZlbHNbdGhpcy5sZXZlbF0udmlkZW9Db2RlYztcbiAgICAgICAgICAgICAgICB0cmFjay5pZCA9IGRhdGEuaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmhscy50cmlnZ2VyKGV2ZW50c18xLmRlZmF1bHQuQlVGRkVSX0NPREVDUywgdHJhY2tzKTtcbiAgICAgICAgICAgIC8vIGxvb3AgdGhyb3VnaCB0cmFja3MgdGhhdCBhcmUgZ29pbmcgdG8gYmUgcHJvdmlkZWQgdG8gYnVmZmVyQ29udHJvbGxlclxuICAgICAgICAgICAgZm9yICh0cmFja05hbWUgaW4gdHJhY2tzKSB7XG4gICAgICAgICAgICAgICAgdHJhY2sgPSB0cmFja3NbdHJhY2tOYW1lXTtcbiAgICAgICAgICAgICAgICBsb2dnZXJfMS5sb2dnZXIubG9nKFwibWFpbiB0cmFjazpcIiArIHRyYWNrTmFtZSArIFwiLGNvbnRhaW5lcjpcIiArIHRyYWNrLmNvbnRhaW5lciArIFwiLGNvZGVjc1tsZXZlbC9wYXJzZWRdPVtcIiArIHRyYWNrLmxldmVsQ29kZWMgKyBcIi9cIiArIHRyYWNrLmNvZGVjICsgXCJdXCIpO1xuICAgICAgICAgICAgICAgIHZhciBpbml0U2VnbWVudCA9IHRyYWNrLmluaXRTZWdtZW50O1xuICAgICAgICAgICAgICAgIGlmIChpbml0U2VnbWVudCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFwcGVuZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgLy8gYXJtIHBlbmRpbmcgQnVmZmVyaW5nIGZsYWcgYmVmb3JlIGFwcGVuZGluZyBhIHNlZ21lbnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nQnVmZmVyaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5obHMudHJpZ2dlcihldmVudHNfMS5kZWZhdWx0LkJVRkZFUl9BUFBFTkRJTkcsIHsgdHlwZTogdHJhY2tOYW1lLCBkYXRhOiBpbml0U2VnbWVudCwgcGFyZW50OiAnbWFpbicsIGNvbnRlbnQ6ICdpbml0U2VnbWVudCcgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdHJpZ2dlciBoYW5kbGVyIHJpZ2h0IG5vd1xuICAgICAgICAgICAgdGhpcy50aWNrKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN0cmVhbUNvbnRyb2xsZXIucHJvdG90eXBlLm9uRnJhZ1BhcnNpbmdEYXRhID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGZyYWdDdXJyZW50ID0gdGhpcy5mcmFnQ3VycmVudDtcbiAgICAgICAgdmFyIGZyYWdOZXcgPSBkYXRhLmZyYWc7XG4gICAgICAgIGlmIChmcmFnQ3VycmVudCAmJlxuICAgICAgICAgICAgZGF0YS5pZCA9PT0gJ21haW4nICYmXG4gICAgICAgICAgICBmcmFnTmV3LnNuID09PSBmcmFnQ3VycmVudC5zbiAmJlxuICAgICAgICAgICAgZnJhZ05ldy5sZXZlbCA9PT0gZnJhZ0N1cnJlbnQubGV2ZWwgJiZcbiAgICAgICAgICAgICEoZGF0YS50eXBlID09PSAnYXVkaW8nICYmIHRoaXMuYWx0QXVkaW8pICYmIC8vIGZpbHRlciBvdXQgbWFpbiBhdWRpbyBpZiBhdWRpbyB0cmFjayBpcyBsb2FkZWQgdGhyb3VnaCBhdWRpbyBzdHJlYW0gY29udHJvbGxlclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9PT0gYmFzZV9zdHJlYW1fY29udHJvbGxlcl8xLlN0YXRlLlBBUlNJTkcpIHtcbiAgICAgICAgICAgIHZhciBsZXZlbCA9IHRoaXMubGV2ZWxzW3RoaXMubGV2ZWxdLCBmcmFnID0gZnJhZ0N1cnJlbnQ7XG4gICAgICAgICAgICBpZiAoIU51bWJlci5pc0Zpbml0ZShkYXRhLmVuZFBUUykpIHtcbiAgICAgICAgICAgICAgICBkYXRhLmVuZFBUUyA9IGRhdGEuc3RhcnRQVFMgKyBmcmFnQ3VycmVudC5kdXJhdGlvbjtcbiAgICAgICAgICAgICAgICBkYXRhLmVuZERUUyA9IGRhdGEuc3RhcnREVFMgKyBmcmFnQ3VycmVudC5kdXJhdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkYXRhLmhhc0F1ZGlvID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgZnJhZy5hZGRFbGVtZW50YXJ5U3RyZWFtKGZyYWdtZW50XzEuZGVmYXVsdC5FbGVtZW50YXJ5U3RyZWFtVHlwZXMuQVVESU8pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRhdGEuaGFzVmlkZW8gPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICBmcmFnLmFkZEVsZW1lbnRhcnlTdHJlYW0oZnJhZ21lbnRfMS5kZWZhdWx0LkVsZW1lbnRhcnlTdHJlYW1UeXBlcy5WSURFTyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsb2dnZXJfMS5sb2dnZXIubG9nKFwiUGFyc2VkIFwiICsgZGF0YS50eXBlICsgXCIsUFRTOltcIiArIGRhdGEuc3RhcnRQVFMudG9GaXhlZCgzKSArIFwiLFwiICsgZGF0YS5lbmRQVFMudG9GaXhlZCgzKSArIFwiXSxEVFM6W1wiICsgZGF0YS5zdGFydERUUy50b0ZpeGVkKDMpICsgXCIvXCIgKyBkYXRhLmVuZERUUy50b0ZpeGVkKDMpICsgXCJdLG5iOlwiICsgZGF0YS5uYiArIFwiLGRyb3BwZWQ6XCIgKyAoZGF0YS5kcm9wcGVkIHx8IDApKTtcbiAgICAgICAgICAgIC8vIERldGVjdCBnYXBzIGluIGEgZnJhZ21lbnQgIGFuZCB0cnkgdG8gZml4IGl0IGJ5IGZpbmRpbmcgYSBrZXlmcmFtZSBpbiB0aGUgcHJldmlvdXMgZnJhZ21lbnQgKHNlZSBfZmluZEZyYWdtZW50cylcbiAgICAgICAgICAgIGlmIChkYXRhLnR5cGUgPT09ICd2aWRlbycpIHtcbiAgICAgICAgICAgICAgICBmcmFnLmRyb3BwZWQgPSBkYXRhLmRyb3BwZWQ7XG4gICAgICAgICAgICAgICAgaWYgKGZyYWcuZHJvcHBlZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWZyYWcuYmFja3RyYWNrZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsZXZlbERldGFpbHMgPSBsZXZlbC5kZXRhaWxzO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxldmVsRGV0YWlscyAmJiBmcmFnLnNuID09PSBsZXZlbERldGFpbHMuc3RhcnRTTikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmxvZ2dlci53YXJuKCdtaXNzaW5nIHZpZGVvIGZyYW1lKHMpIG9uIGZpcnN0IGZyYWcsIGFwcGVuZGluZyB3aXRoIGdhcCcsIGZyYWcuc24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLndhcm4oJ21pc3NpbmcgdmlkZW8gZnJhbWUocyksIGJhY2t0cmFja2luZyBmcmFnbWVudCcsIGZyYWcuc24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJldHVybiBiYWNrIHRvIHRoZSBJRExFIHN0YXRlIHdpdGhvdXQgYXBwZW5kaW5nIHRvIGJ1ZmZlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENhdXNlcyBmaW5kRnJhZ21lbnRzIHRvIGJhY2t0cmFjayBhIHNlZ21lbnQgYW5kIGZpbmQgdGhlIGtleWZyYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXVkaW8gZnJhZ21lbnRzIGFycml2aW5nIGJlZm9yZSB2aWRlbyBzZXRzIHRoZSBuZXh0TG9hZFBvc2l0aW9uLCBjYXVzaW5nIF9maW5kRnJhZ21lbnRzIHRvIHNraXAgdGhlIGJhY2t0cmFja2VkIGZyYWdtZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5mcmFnbWVudFRyYWNrZXIucmVtb3ZlRnJhZ21lbnQoZnJhZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJhZy5iYWNrdHJhY2tlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5uZXh0TG9hZFBvc2l0aW9uID0gZGF0YS5zdGFydFBUUztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gYmFzZV9zdHJlYW1fY29udHJvbGxlcl8xLlN0YXRlLklETEU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5mcmFnUHJldmlvdXMgPSBmcmFnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudGljaygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmxvZ2dlci53YXJuKCdBbHJlYWR5IGJhY2t0cmFja2VkIG9uIHRoaXMgZnJhZ21lbnQsIGFwcGVuZGluZyB3aXRoIHRoZSBnYXAnLCBmcmFnLnNuKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gT25seSByZXNldCB0aGUgYmFja3RyYWNrZWQgZmxhZyBpZiB3ZSd2ZSBsb2FkZWQgdGhlIGZyYWcgd2l0aG91dCBhbnkgZHJvcHBlZCBmcmFtZXNcbiAgICAgICAgICAgICAgICAgICAgZnJhZy5iYWNrdHJhY2tlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBkcmlmdCA9IExldmVsSGVscGVyLnVwZGF0ZUZyYWdQVFNEVFMobGV2ZWwuZGV0YWlscywgZnJhZywgZGF0YS5zdGFydFBUUywgZGF0YS5lbmRQVFMsIGRhdGEuc3RhcnREVFMsIGRhdGEuZW5kRFRTKSwgaGxzXzIgPSB0aGlzLmhscztcbiAgICAgICAgICAgIGhsc18yLnRyaWdnZXIoZXZlbnRzXzEuZGVmYXVsdC5MRVZFTF9QVFNfVVBEQVRFRCwgeyBkZXRhaWxzOiBsZXZlbC5kZXRhaWxzLCBsZXZlbDogdGhpcy5sZXZlbCwgZHJpZnQ6IGRyaWZ0LCB0eXBlOiBkYXRhLnR5cGUsIHN0YXJ0OiBkYXRhLnN0YXJ0UFRTLCBlbmQ6IGRhdGEuZW5kUFRTIH0pO1xuICAgICAgICAgICAgLy8gaGFzIHJlbXV4ZXIgZHJvcHBlZCB2aWRlbyBmcmFtZXMgbG9jYXRlZCBiZWZvcmUgZmlyc3Qga2V5ZnJhbWUgP1xuICAgICAgICAgICAgW2RhdGEuZGF0YTEsIGRhdGEuZGF0YTJdLmZvckVhY2goZnVuY3Rpb24gKGJ1ZmZlcikge1xuICAgICAgICAgICAgICAgIC8vIG9ubHkgYXBwZW5kIGluIFBBUlNJTkcgc3RhdGUgKHJhdGlvbmFsZSBpcyB0aGF0IGFuIGFwcGVuZGluZyBlcnJvciBjb3VsZCBoYXBwZW4gc3luY2hyb25vdXNseSBvbiBmaXJzdCBzZWdtZW50IGFwcGVuZGluZylcbiAgICAgICAgICAgICAgICAvLyBpbiB0aGF0IGNhc2UgaXQgaXMgdXNlbGVzcyB0byBhcHBlbmQgZm9sbG93aW5nIHNlZ21lbnRzXG4gICAgICAgICAgICAgICAgaWYgKGJ1ZmZlciAmJiBidWZmZXIubGVuZ3RoICYmIF90aGlzLnN0YXRlID09PSBiYXNlX3N0cmVhbV9jb250cm9sbGVyXzEuU3RhdGUuUEFSU0lORykge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5hcHBlbmRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIC8vIGFybSBwZW5kaW5nIEJ1ZmZlcmluZyBmbGFnIGJlZm9yZSBhcHBlbmRpbmcgYSBzZWdtZW50XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnBlbmRpbmdCdWZmZXJpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBobHNfMi50cmlnZ2VyKGV2ZW50c18xLmRlZmF1bHQuQlVGRkVSX0FQUEVORElORywgeyB0eXBlOiBkYXRhLnR5cGUsIGRhdGE6IGJ1ZmZlciwgcGFyZW50OiAnbWFpbicsIGNvbnRlbnQ6ICdkYXRhJyB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIHRyaWdnZXIgaGFuZGxlciByaWdodCBub3dcbiAgICAgICAgICAgIHRoaXMudGljaygpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTdHJlYW1Db250cm9sbGVyLnByb3RvdHlwZS5vbkZyYWdQYXJzZWQgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB2YXIgZnJhZ0N1cnJlbnQgPSB0aGlzLmZyYWdDdXJyZW50O1xuICAgICAgICB2YXIgZnJhZ05ldyA9IGRhdGEuZnJhZztcbiAgICAgICAgaWYgKGZyYWdDdXJyZW50ICYmXG4gICAgICAgICAgICBkYXRhLmlkID09PSAnbWFpbicgJiZcbiAgICAgICAgICAgIGZyYWdOZXcuc24gPT09IGZyYWdDdXJyZW50LnNuICYmXG4gICAgICAgICAgICBmcmFnTmV3LmxldmVsID09PSBmcmFnQ3VycmVudC5sZXZlbCAmJlxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9PT0gYmFzZV9zdHJlYW1fY29udHJvbGxlcl8xLlN0YXRlLlBBUlNJTkcpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdHMudHBhcnNlZCA9IHdpbmRvdy5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBiYXNlX3N0cmVhbV9jb250cm9sbGVyXzEuU3RhdGUuUEFSU0VEO1xuICAgICAgICAgICAgdGhpcy5fY2hlY2tBcHBlbmRlZFBhcnNlZCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTdHJlYW1Db250cm9sbGVyLnByb3RvdHlwZS5vbkF1ZGlvVHJhY2tTd2l0Y2hpbmcgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAvLyBpZiBhbnkgVVJMIGZvdW5kIG9uIG5ldyBhdWRpbyB0cmFjaywgaXQgaXMgYW4gYWx0ZXJuYXRlIGF1ZGlvIHRyYWNrXG4gICAgICAgIHZhciBhbHRBdWRpbyA9ICEhZGF0YS51cmwsIHRyYWNrSWQgPSBkYXRhLmlkO1xuICAgICAgICAvLyBpZiB3ZSBzd2l0Y2ggb24gbWFpbiBhdWRpbywgZW5zdXJlIHRoYXQgbWFpbiBmcmFnbWVudCBzY2hlZHVsaW5nIGlzIHN5bmNlZCB3aXRoIG1lZGlhLmJ1ZmZlcmVkXG4gICAgICAgIC8vIGRvbid0IGRvIGFueXRoaW5nIGlmIHdlIHN3aXRjaCB0byBhbHQgYXVkaW86IGF1ZGlvIHN0cmVhbSBjb250cm9sbGVyIGlzIGhhbmRsaW5nIGl0LlxuICAgICAgICAvLyB3ZSB3aWxsIGp1c3QgaGF2ZSB0byBjaGFuZ2UgYnVmZmVyIHNjaGVkdWxpbmcgb24gYXVkaW9UcmFja1N3aXRjaGVkXG4gICAgICAgIGlmICghYWx0QXVkaW8pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm1lZGlhQnVmZmVyICE9PSB0aGlzLm1lZGlhKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLmxvZygnc3dpdGNoaW5nIG9uIG1haW4gYXVkaW8sIHVzZSBtZWRpYS5idWZmZXJlZCB0byBzY2hlZHVsZSBtYWluIGZyYWdtZW50IGxvYWRpbmcnKTtcbiAgICAgICAgICAgICAgICB0aGlzLm1lZGlhQnVmZmVyID0gdGhpcy5tZWRpYTtcbiAgICAgICAgICAgICAgICB2YXIgZnJhZ0N1cnJlbnQgPSB0aGlzLmZyYWdDdXJyZW50O1xuICAgICAgICAgICAgICAgIC8vIHdlIG5lZWQgdG8gcmVmaWxsIGF1ZGlvIGJ1ZmZlciBmcm9tIG1haW46IGNhbmNlbCBhbnkgZnJhZyBsb2FkaW5nIHRvIHNwZWVkIHVwIGF1ZGlvIHN3aXRjaFxuICAgICAgICAgICAgICAgIGlmIChmcmFnQ3VycmVudC5sb2FkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLmxvZygnc3dpdGNoaW5nIHRvIG1haW4gYXVkaW8gdHJhY2ssIGNhbmNlbCBtYWluIGZyYWdtZW50IGxvYWQnKTtcbiAgICAgICAgICAgICAgICAgICAgZnJhZ0N1cnJlbnQubG9hZGVyLmFib3J0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuZnJhZ0N1cnJlbnQgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMuZnJhZ1ByZXZpb3VzID0gbnVsbDtcbiAgICAgICAgICAgICAgICAvLyBkZXN0cm95IGRlbXV4ZXIgdG8gZm9yY2UgaW5pdCBzZWdtZW50IGdlbmVyYXRpb24gKGZvbGxvd2luZyBhdWRpbyBzd2l0Y2gpXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZGVtdXhlcikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlbXV4ZXIuZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlbXV4ZXIgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBzd2l0Y2ggdG8gSURMRSBzdGF0ZSB0byBsb2FkIG5ldyBmcmFnbWVudFxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBiYXNlX3N0cmVhbV9jb250cm9sbGVyXzEuU3RhdGUuSURMRTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBobHNfMyA9IHRoaXMuaGxzO1xuICAgICAgICAgICAgLy8gc3dpdGNoaW5nIHRvIG1haW4gYXVkaW8sIGZsdXNoIGFsbCBhdWRpbyBhbmQgdHJpZ2dlciB0cmFjayBzd2l0Y2hlZFxuICAgICAgICAgICAgaGxzXzMudHJpZ2dlcihldmVudHNfMS5kZWZhdWx0LkJVRkZFUl9GTFVTSElORywgeyBzdGFydE9mZnNldDogMCwgZW5kT2Zmc2V0OiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksIHR5cGU6ICdhdWRpbycgfSk7XG4gICAgICAgICAgICBobHNfMy50cmlnZ2VyKGV2ZW50c18xLmRlZmF1bHQuQVVESU9fVFJBQ0tfU1dJVENIRUQsIHsgaWQ6IHRyYWNrSWQgfSk7XG4gICAgICAgICAgICB0aGlzLmFsdEF1ZGlvID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN0cmVhbUNvbnRyb2xsZXIucHJvdG90eXBlLm9uQXVkaW9UcmFja1N3aXRjaGVkID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdmFyIHRyYWNrSWQgPSBkYXRhLmlkLCBhbHRBdWRpbyA9ICEhdGhpcy5obHMuYXVkaW9UcmFja3NbdHJhY2tJZF0udXJsO1xuICAgICAgICBpZiAoYWx0QXVkaW8pIHtcbiAgICAgICAgICAgIHZhciB2aWRlb0J1ZmZlciA9IHRoaXMudmlkZW9CdWZmZXI7XG4gICAgICAgICAgICAvLyBpZiB3ZSBzd2l0Y2hlZCBvbiBhbHRlcm5hdGUgYXVkaW8sIGVuc3VyZSB0aGF0IG1haW4gZnJhZ21lbnQgc2NoZWR1bGluZyBpcyBzeW5jZWQgd2l0aCB2aWRlbyBzb3VyY2VidWZmZXIgYnVmZmVyZWRcbiAgICAgICAgICAgIGlmICh2aWRlb0J1ZmZlciAmJiB0aGlzLm1lZGlhQnVmZmVyICE9PSB2aWRlb0J1ZmZlcikge1xuICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmxvZ2dlci5sb2coJ3N3aXRjaGluZyBvbiBhbHRlcm5hdGUgYXVkaW8sIHVzZSB2aWRlby5idWZmZXJlZCB0byBzY2hlZHVsZSBtYWluIGZyYWdtZW50IGxvYWRpbmcnKTtcbiAgICAgICAgICAgICAgICB0aGlzLm1lZGlhQnVmZmVyID0gdmlkZW9CdWZmZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hbHRBdWRpbyA9IGFsdEF1ZGlvO1xuICAgICAgICB0aGlzLnRpY2soKTtcbiAgICB9O1xuICAgIFN0cmVhbUNvbnRyb2xsZXIucHJvdG90eXBlLm9uQnVmZmVyQ3JlYXRlZCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHZhciB0cmFja3MgPSBkYXRhLnRyYWNrcywgbWVkaWFUcmFjaywgbmFtZSwgYWx0ZXJuYXRlID0gZmFsc2U7XG4gICAgICAgIGZvciAodmFyIHR5cGUgaW4gdHJhY2tzKSB7XG4gICAgICAgICAgICB2YXIgdHJhY2sgPSB0cmFja3NbdHlwZV07XG4gICAgICAgICAgICBpZiAodHJhY2suaWQgPT09ICdtYWluJykge1xuICAgICAgICAgICAgICAgIG5hbWUgPSB0eXBlO1xuICAgICAgICAgICAgICAgIG1lZGlhVHJhY2sgPSB0cmFjaztcbiAgICAgICAgICAgICAgICAvLyBrZWVwIHZpZGVvIHNvdXJjZSBidWZmZXIgcmVmZXJlbmNlXG4gICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09ICd2aWRlbycpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52aWRlb0J1ZmZlciA9IHRyYWNrc1t0eXBlXS5idWZmZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYWx0ZXJuYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYWx0ZXJuYXRlICYmIG1lZGlhVHJhY2spIHtcbiAgICAgICAgICAgIGxvZ2dlcl8xLmxvZ2dlci5sb2coXCJhbHRlcm5hdGUgdHJhY2sgZm91bmQsIHVzZSBcIiArIG5hbWUgKyBcIi5idWZmZXJlZCB0byBzY2hlZHVsZSBtYWluIGZyYWdtZW50IGxvYWRpbmdcIik7XG4gICAgICAgICAgICB0aGlzLm1lZGlhQnVmZmVyID0gbWVkaWFUcmFjay5idWZmZXI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm1lZGlhQnVmZmVyID0gdGhpcy5tZWRpYTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU3RyZWFtQ29udHJvbGxlci5wcm90b3R5cGUub25CdWZmZXJBcHBlbmRlZCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIGlmIChkYXRhLnBhcmVudCA9PT0gJ21haW4nKSB7XG4gICAgICAgICAgICB2YXIgc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgICAgICAgICAgaWYgKHN0YXRlID09PSBiYXNlX3N0cmVhbV9jb250cm9sbGVyXzEuU3RhdGUuUEFSU0lORyB8fCBzdGF0ZSA9PT0gYmFzZV9zdHJlYW1fY29udHJvbGxlcl8xLlN0YXRlLlBBUlNFRCkge1xuICAgICAgICAgICAgICAgIC8vIGNoZWNrIGlmIGFsbCBidWZmZXJzIGhhdmUgYmVlbiBhcHBlbmRlZFxuICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ0J1ZmZlcmluZyA9IChkYXRhLnBlbmRpbmcgPiAwKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9jaGVja0FwcGVuZGVkUGFyc2VkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN0cmVhbUNvbnRyb2xsZXIucHJvdG90eXBlLl9jaGVja0FwcGVuZGVkUGFyc2VkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyB0cmlnZ2VyIGhhbmRsZXIgcmlnaHQgbm93XG4gICAgICAgIGlmICh0aGlzLnN0YXRlID09PSBiYXNlX3N0cmVhbV9jb250cm9sbGVyXzEuU3RhdGUuUEFSU0VEICYmICghdGhpcy5hcHBlbmRlZCB8fCAhdGhpcy5wZW5kaW5nQnVmZmVyaW5nKSkge1xuICAgICAgICAgICAgdmFyIGZyYWcgPSB0aGlzLmZyYWdDdXJyZW50O1xuICAgICAgICAgICAgaWYgKGZyYWcpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWVkaWEgPSB0aGlzLm1lZGlhQnVmZmVyID8gdGhpcy5tZWRpYUJ1ZmZlciA6IHRoaXMubWVkaWE7XG4gICAgICAgICAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLmxvZyhcIm1haW4gYnVmZmVyZWQgOiBcIiArIHRpbWVfcmFuZ2VzXzEuZGVmYXVsdC50b1N0cmluZyhtZWRpYS5idWZmZXJlZCkpO1xuICAgICAgICAgICAgICAgIHRoaXMuZnJhZ1ByZXZpb3VzID0gZnJhZztcbiAgICAgICAgICAgICAgICB2YXIgc3RhdHMgPSB0aGlzLnN0YXRzO1xuICAgICAgICAgICAgICAgIHN0YXRzLnRidWZmZXJlZCA9IHdpbmRvdy5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgICAgICAgICAvLyB3ZSBzaG91bGQgZ2V0IHJpZCBvZiB0aGlzLmZyYWdMYXN0S2Jwc1xuICAgICAgICAgICAgICAgIHRoaXMuZnJhZ0xhc3RLYnBzID0gTWF0aC5yb3VuZCg4ICogc3RhdHMudG90YWwgLyAoc3RhdHMudGJ1ZmZlcmVkIC0gc3RhdHMudGZpcnN0KSk7XG4gICAgICAgICAgICAgICAgdGhpcy5obHMudHJpZ2dlcihldmVudHNfMS5kZWZhdWx0LkZSQUdfQlVGRkVSRUQsIHsgc3RhdHM6IHN0YXRzLCBmcmFnOiBmcmFnLCBpZDogJ21haW4nIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBiYXNlX3N0cmVhbV9jb250cm9sbGVyXzEuU3RhdGUuSURMRTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudGljaygpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTdHJlYW1Db250cm9sbGVyLnByb3RvdHlwZS5vbkVycm9yID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdmFyIGZyYWcgPSBkYXRhLmZyYWcgfHwgdGhpcy5mcmFnQ3VycmVudDtcbiAgICAgICAgLy8gZG9uJ3QgaGFuZGxlIGZyYWcgZXJyb3Igbm90IHJlbGF0ZWQgdG8gbWFpbiBmcmFnbWVudFxuICAgICAgICBpZiAoZnJhZyAmJiBmcmFnLnR5cGUgIT09ICdtYWluJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIDAuNSA6IHRvbGVyYW5jZSBuZWVkZWQgYXMgc29tZSBicm93c2VycyBzdGFsbHMgcGxheWJhY2sgYmVmb3JlIHJlYWNoaW5nIGJ1ZmZlcmVkIGVuZFxuICAgICAgICB2YXIgbWVkaWFCdWZmZXJlZCA9ICEhdGhpcy5tZWRpYSAmJiBidWZmZXJfaGVscGVyXzEuQnVmZmVySGVscGVyLmlzQnVmZmVyZWQodGhpcy5tZWRpYSwgdGhpcy5tZWRpYS5jdXJyZW50VGltZSkgJiYgYnVmZmVyX2hlbHBlcl8xLkJ1ZmZlckhlbHBlci5pc0J1ZmZlcmVkKHRoaXMubWVkaWEsIHRoaXMubWVkaWEuY3VycmVudFRpbWUgKyAwLjUpO1xuICAgICAgICBzd2l0Y2ggKGRhdGEuZGV0YWlscykge1xuICAgICAgICAgICAgY2FzZSBlcnJvcnNfMS5FcnJvckRldGFpbHMuRlJBR19MT0FEX0VSUk9SOlxuICAgICAgICAgICAgY2FzZSBlcnJvcnNfMS5FcnJvckRldGFpbHMuRlJBR19MT0FEX1RJTUVPVVQ6XG4gICAgICAgICAgICBjYXNlIGVycm9yc18xLkVycm9yRGV0YWlscy5LRVlfTE9BRF9FUlJPUjpcbiAgICAgICAgICAgIGNhc2UgZXJyb3JzXzEuRXJyb3JEZXRhaWxzLktFWV9MT0FEX1RJTUVPVVQ6XG4gICAgICAgICAgICAgICAgaWYgKCFkYXRhLmZhdGFsKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGtlZXAgcmV0cnlpbmcgdW50aWwgdGhlIGxpbWl0IHdpbGwgYmUgcmVhY2hlZFxuICAgICAgICAgICAgICAgICAgICBpZiAoKHRoaXMuZnJhZ0xvYWRFcnJvciArIDEpIDw9IHRoaXMuY29uZmlnLmZyYWdMb2FkaW5nTWF4UmV0cnkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGV4cG9uZW50aWFsIGJhY2tvZmYgY2FwcGVkIHRvIGNvbmZpZy5mcmFnTG9hZGluZ01heFJldHJ5VGltZW91dFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRlbGF5ID0gTWF0aC5taW4oTWF0aC5wb3coMiwgdGhpcy5mcmFnTG9hZEVycm9yKSAqIHRoaXMuY29uZmlnLmZyYWdMb2FkaW5nUmV0cnlEZWxheSwgdGhpcy5jb25maWcuZnJhZ0xvYWRpbmdNYXhSZXRyeVRpbWVvdXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLndhcm4oXCJtZWRpYUNvbnRyb2xsZXI6IGZyYWcgbG9hZGluZyBmYWlsZWQsIHJldHJ5IGluIFwiICsgZGVsYXkgKyBcIiBtc1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmV0cnlEYXRlID0gd2luZG93LnBlcmZvcm1hbmNlLm5vdygpICsgZGVsYXk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByZXRyeSBsb2FkaW5nIHN0YXRlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiBsb2FkZWRtZXRhZGF0YSBpcyBub3Qgc2V0LCBpdCBtZWFucyB0aGF0IHdlIGFyZSBlbWVyZ2VuY3kgc3dpdGNoIGRvd24gb24gZmlyc3QgZnJhZ1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW4gdGhhdCBjYXNlLCByZXNldCBzdGFydEZyYWdSZXF1ZXN0ZWQgZmxhZ1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmxvYWRlZG1ldGFkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5leHRMb2FkUG9zaXRpb24gPSB0aGlzLnN0YXJ0UG9zaXRpb247XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZyYWdMb2FkRXJyb3IrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBiYXNlX3N0cmVhbV9jb250cm9sbGVyXzEuU3RhdGUuRlJBR19MT0FESU5HX1dBSVRJTkdfUkVUUlk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXJfMS5sb2dnZXIuZXJyb3IoXCJtZWRpYUNvbnRyb2xsZXI6IFwiICsgZGF0YS5kZXRhaWxzICsgXCIgcmVhY2hlcyBtYXggcmV0cnksIHJlZGlzcGF0Y2ggYXMgZmF0YWwgLi4uXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3dpdGNoIGVycm9yIHRvIGZhdGFsXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhLmZhdGFsID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBiYXNlX3N0cmVhbV9jb250cm9sbGVyXzEuU3RhdGUuRVJST1I7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIGVycm9yc18xLkVycm9yRGV0YWlscy5MRVZFTF9MT0FEX0VSUk9SOlxuICAgICAgICAgICAgY2FzZSBlcnJvcnNfMS5FcnJvckRldGFpbHMuTEVWRUxfTE9BRF9USU1FT1VUOlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlICE9PSBiYXNlX3N0cmVhbV9jb250cm9sbGVyXzEuU3RhdGUuRVJST1IpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEuZmF0YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIGZhdGFsIGVycm9yLCBzdG9wIHByb2Nlc3NpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBiYXNlX3N0cmVhbV9jb250cm9sbGVyXzEuU3RhdGUuRVJST1I7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXJfMS5sb2dnZXIud2FybihcInN0cmVhbUNvbnRyb2xsZXI6IFwiICsgZGF0YS5kZXRhaWxzICsgXCIsc3dpdGNoIHRvIFwiICsgdGhpcy5zdGF0ZSArIFwiIHN0YXRlIC4uLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGluIGNhc2Ugb2Ygbm9uIGZhdGFsIGVycm9yIHdoaWxlIGxvYWRpbmcgbGV2ZWwsIGlmIGxldmVsIGNvbnRyb2xsZXIgaXMgbm90IHJldHJ5aW5nIHRvIGxvYWQgbGV2ZWwgLCBzd2l0Y2ggYmFjayB0byBJRExFXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWRhdGEubGV2ZWxSZXRyeSAmJiB0aGlzLnN0YXRlID09PSBiYXNlX3N0cmVhbV9jb250cm9sbGVyXzEuU3RhdGUuV0FJVElOR19MRVZFTCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBiYXNlX3N0cmVhbV9jb250cm9sbGVyXzEuU3RhdGUuSURMRTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgZXJyb3JzXzEuRXJyb3JEZXRhaWxzLkJVRkZFUl9GVUxMX0VSUk9SOlxuICAgICAgICAgICAgICAgIC8vIGlmIGluIGFwcGVuZGluZyBzdGF0ZVxuICAgICAgICAgICAgICAgIGlmIChkYXRhLnBhcmVudCA9PT0gJ21haW4nICYmICh0aGlzLnN0YXRlID09PSBiYXNlX3N0cmVhbV9jb250cm9sbGVyXzEuU3RhdGUuUEFSU0lORyB8fCB0aGlzLnN0YXRlID09PSBiYXNlX3N0cmVhbV9jb250cm9sbGVyXzEuU3RhdGUuUEFSU0VEKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyByZWR1Y2UgbWF4IGJ1ZiBsZW4gaWYgY3VycmVudCBwb3NpdGlvbiBpcyBidWZmZXJlZFxuICAgICAgICAgICAgICAgICAgICBpZiAobWVkaWFCdWZmZXJlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVkdWNlTWF4QnVmZmVyTGVuZ3RoKHRoaXMuY29uZmlnLm1heEJ1ZmZlckxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gYmFzZV9zdHJlYW1fY29udHJvbGxlcl8xLlN0YXRlLklETEU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjdXJyZW50IHBvc2l0aW9uIGlzIG5vdCBidWZmZXJlZCwgYnV0IGJyb3dzZXIgaXMgc3RpbGwgY29tcGxhaW5pbmcgYWJvdXQgYnVmZmVyIGZ1bGwgZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgaGFwcGVucyBvbiBJRS9FZGdlLCByZWZlciB0byBodHRwczovL2dpdGh1Yi5jb20vdmlkZW8tZGV2L2hscy5qcy9wdWxsLzcwOFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW4gdGhhdCBjYXNlIGZsdXNoIHRoZSB3aG9sZSBidWZmZXIgdG8gcmVjb3ZlclxuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLndhcm4oJ2J1ZmZlciBmdWxsIGVycm9yIGFsc28gbWVkaWEuY3VycmVudFRpbWUgaXMgbm90IGJ1ZmZlcmVkLCBmbHVzaCBldmVyeXRoaW5nJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZyYWdDdXJyZW50ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZsdXNoIGV2ZXJ5dGhpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZmx1c2hNYWluQnVmZmVyKDAsIE51bWJlci5QT1NJVElWRV9JTkZJTklUWSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTdHJlYW1Db250cm9sbGVyLnByb3RvdHlwZS5fcmVkdWNlTWF4QnVmZmVyTGVuZ3RoID0gZnVuY3Rpb24gKG1pbkxlbmd0aCkge1xuICAgICAgICB2YXIgY29uZmlnID0gdGhpcy5jb25maWc7XG4gICAgICAgIGlmIChjb25maWcubWF4TWF4QnVmZmVyTGVuZ3RoID49IG1pbkxlbmd0aCkge1xuICAgICAgICAgICAgLy8gcmVkdWNlIG1heCBidWZmZXIgbGVuZ3RoIGFzIGl0IG1pZ2h0IGJlIHRvbyBoaWdoLiB3ZSBkbyB0aGlzIHRvIGF2b2lkIGxvb3AgZmx1c2hpbmcgLi4uXG4gICAgICAgICAgICBjb25maWcubWF4TWF4QnVmZmVyTGVuZ3RoIC89IDI7XG4gICAgICAgICAgICBsb2dnZXJfMS5sb2dnZXIud2FybihcIm1haW46cmVkdWNlIG1heCBidWZmZXIgbGVuZ3RoIHRvIFwiICsgY29uZmlnLm1heE1heEJ1ZmZlckxlbmd0aCArIFwic1wiKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB0aGUgaGVhbHRoIG9mIHRoZSBidWZmZXIgYW5kIGF0dGVtcHRzIHRvIHJlc29sdmUgcGxheWJhY2sgc3RhbGxzLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgU3RyZWFtQ29udHJvbGxlci5wcm90b3R5cGUuX2NoZWNrQnVmZmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbWVkaWEgPSB0aGlzLm1lZGlhO1xuICAgICAgICBpZiAoIW1lZGlhIHx8IG1lZGlhLnJlYWR5U3RhdGUgPT09IDApIHtcbiAgICAgICAgICAgIC8vIEV4aXQgZWFybHkgaWYgd2UgZG9uJ3QgaGF2ZSBtZWRpYSBvciBpZiB0aGUgbWVkaWEgaGFzbid0IGJ1ZmZlcmQgYW55dGhpbmcgeWV0IChyZWFkeVN0YXRlIDApXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1lZGlhQnVmZmVyID0gdGhpcy5tZWRpYUJ1ZmZlciA/IHRoaXMubWVkaWFCdWZmZXIgOiBtZWRpYTtcbiAgICAgICAgdmFyIGJ1ZmZlcmVkID0gbWVkaWFCdWZmZXIuYnVmZmVyZWQ7XG4gICAgICAgIGlmICghdGhpcy5sb2FkZWRtZXRhZGF0YSAmJiBidWZmZXJlZC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMubG9hZGVkbWV0YWRhdGEgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fc2Vla1RvU3RhcnRQb3MoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmltbWVkaWF0ZVN3aXRjaCkge1xuICAgICAgICAgICAgdGhpcy5pbW1lZGlhdGVMZXZlbFN3aXRjaEVuZCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5nYXBDb250cm9sbGVyLnBvbGwodGhpcy5sYXN0Q3VycmVudFRpbWUsIGJ1ZmZlcmVkKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU3RyZWFtQ29udHJvbGxlci5wcm90b3R5cGUub25GcmFnTG9hZEVtZXJnZW5jeUFib3J0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBiYXNlX3N0cmVhbV9jb250cm9sbGVyXzEuU3RhdGUuSURMRTtcbiAgICAgICAgLy8gaWYgbG9hZGVkbWV0YWRhdGEgaXMgbm90IHNldCwgaXQgbWVhbnMgdGhhdCB3ZSBhcmUgZW1lcmdlbmN5IHN3aXRjaCBkb3duIG9uIGZpcnN0IGZyYWdcbiAgICAgICAgLy8gaW4gdGhhdCBjYXNlLCByZXNldCBzdGFydEZyYWdSZXF1ZXN0ZWQgZmxhZ1xuICAgICAgICBpZiAoIXRoaXMubG9hZGVkbWV0YWRhdGEpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhcnRGcmFnUmVxdWVzdGVkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLm5leHRMb2FkUG9zaXRpb24gPSB0aGlzLnN0YXJ0UG9zaXRpb247XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50aWNrKCk7XG4gICAgfTtcbiAgICBTdHJlYW1Db250cm9sbGVyLnByb3RvdHlwZS5vbkJ1ZmZlckZsdXNoZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8qIGFmdGVyIHN1Y2Nlc3NmdWwgYnVmZmVyIGZsdXNoaW5nLCBmaWx0ZXIgZmx1c2hlZCBmcmFnbWVudHMgZnJvbSBidWZmZXJlZEZyYWdzXG4gICAgICAgICAgdXNlIG1lZGlhQnVmZmVyZWQgaW5zdGVhZCBvZiBtZWRpYSAoc28gdGhhdCB3ZSB3aWxsIGNoZWNrIGFnYWluc3QgdmlkZW8uYnVmZmVyZWQgcmFuZ2VzIGluIGNhc2Ugb2YgYWx0IGF1ZGlvIHRyYWNrKVxuICAgICAgICAqL1xuICAgICAgICB2YXIgbWVkaWEgPSB0aGlzLm1lZGlhQnVmZmVyID8gdGhpcy5tZWRpYUJ1ZmZlciA6IHRoaXMubWVkaWE7XG4gICAgICAgIGlmIChtZWRpYSkge1xuICAgICAgICAgICAgLy8gZmlsdGVyIGZyYWdtZW50cyBwb3RlbnRpYWxseSBldmljdGVkIGZyb20gYnVmZmVyLiB0aGlzIGlzIHRvIGF2b2lkIG1lbWxlYWsgb24gbGl2ZSBzdHJlYW1zXG4gICAgICAgICAgICB0aGlzLmZyYWdtZW50VHJhY2tlci5kZXRlY3RFdmljdGVkRnJhZ21lbnRzKGZyYWdtZW50XzEuZGVmYXVsdC5FbGVtZW50YXJ5U3RyZWFtVHlwZXMuVklERU8sIG1lZGlhLmJ1ZmZlcmVkKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBtb3ZlIHRvIElETEUgb25jZSBmbHVzaCBjb21wbGV0ZS4gdGhpcyBzaG91bGQgdHJpZ2dlciBuZXcgZnJhZ21lbnQgbG9hZGluZ1xuICAgICAgICB0aGlzLnN0YXRlID0gYmFzZV9zdHJlYW1fY29udHJvbGxlcl8xLlN0YXRlLklETEU7XG4gICAgICAgIC8vIHJlc2V0IHJlZmVyZW5jZSB0byBmcmFnXG4gICAgICAgIHRoaXMuZnJhZ1ByZXZpb3VzID0gbnVsbDtcbiAgICB9O1xuICAgIFN0cmVhbUNvbnRyb2xsZXIucHJvdG90eXBlLnN3YXBBdWRpb0NvZGVjID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmF1ZGlvQ29kZWNTd2FwID0gIXRoaXMuYXVkaW9Db2RlY1N3YXA7XG4gICAgfTtcbiAgICBTdHJlYW1Db250cm9sbGVyLnByb3RvdHlwZS5jb21wdXRlTGl2ZVBvc2l0aW9uID0gZnVuY3Rpb24gKHNsaWRpbmcsIGxldmVsRGV0YWlscykge1xuICAgICAgICB2YXIgdGFyZ2V0TGF0ZW5jeSA9IHRoaXMuY29uZmlnLmxpdmVTeW5jRHVyYXRpb24gIT09IHVuZGVmaW5lZCA/IHRoaXMuY29uZmlnLmxpdmVTeW5jRHVyYXRpb24gOiB0aGlzLmNvbmZpZy5saXZlU3luY0R1cmF0aW9uQ291bnQgKiBsZXZlbERldGFpbHMudGFyZ2V0ZHVyYXRpb247XG4gICAgICAgIHJldHVybiBzbGlkaW5nICsgTWF0aC5tYXgoMCwgbGV2ZWxEZXRhaWxzLnRvdGFsZHVyYXRpb24gLSB0YXJnZXRMYXRlbmN5KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNlZWtzIHRvIHRoZSBzZXQgc3RhcnRQb3NpdGlvbiBpZiBub3QgZXF1YWwgdG8gdGhlIG1lZGlhRWxlbWVudCdzIGN1cnJlbnQgdGltZS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIFN0cmVhbUNvbnRyb2xsZXIucHJvdG90eXBlLl9zZWVrVG9TdGFydFBvcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG1lZGlhID0gdGhpcy5tZWRpYTtcbiAgICAgICAgdmFyIGN1cnJlbnRUaW1lID0gbWVkaWEuY3VycmVudFRpbWU7XG4gICAgICAgIC8vIG9ubHkgYWRqdXN0IGN1cnJlbnRUaW1lIGlmIGRpZmZlcmVudCBmcm9tIHN0YXJ0UG9zaXRpb24gb3IgaWYgc3RhcnRQb3NpdGlvbiBub3QgYnVmZmVyZWRcbiAgICAgICAgLy8gYXQgdGhhdCBzdGFnZSwgdGhlcmUgc2hvdWxkIGJlIG9ubHkgb25lIGJ1ZmZlcmVkIHJhbmdlLCBhcyB3ZSByZWFjaCB0aGF0IGNvZGUgYWZ0ZXIgZmlyc3QgZnJhZ21lbnQgaGFzIGJlZW4gYnVmZmVyZWRcbiAgICAgICAgdmFyIHN0YXJ0UG9zaXRpb24gPSBtZWRpYS5zZWVraW5nID8gY3VycmVudFRpbWUgOiB0aGlzLnN0YXJ0UG9zaXRpb247XG4gICAgICAgIC8vIGlmIGN1cnJlbnRUaW1lIG5vdCBtYXRjaGluZyB3aXRoIGV4cGVjdGVkIHN0YXJ0UG9zaXRpb24gb3Igc3RhcnRQb3NpdGlvbiBub3QgYnVmZmVyZWQgYnV0IGNsb3NlIHRvIGZpcnN0IGJ1ZmZlcmVkXG4gICAgICAgIGlmIChjdXJyZW50VGltZSAhPT0gc3RhcnRQb3NpdGlvbikge1xuICAgICAgICAgICAgLy8gaWYgc3RhcnRQb3NpdGlvbiBub3QgYnVmZmVyZWQsIGxldCdzIHNlZWsgdG8gYnVmZmVyZWQuc3RhcnQoMClcbiAgICAgICAgICAgIGxvZ2dlcl8xLmxvZ2dlci5sb2coXCJ0YXJnZXQgc3RhcnQgcG9zaXRpb24gbm90IGJ1ZmZlcmVkLCBzZWVrIHRvIGJ1ZmZlcmVkLnN0YXJ0KDApIFwiICsgc3RhcnRQb3NpdGlvbiArIFwiIGZyb20gY3VycmVudCB0aW1lIFwiICsgY3VycmVudFRpbWUgKyBcIiBcIik7XG4gICAgICAgICAgICBtZWRpYS5jdXJyZW50VGltZSA9IHN0YXJ0UG9zaXRpb247XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN0cmVhbUNvbnRyb2xsZXIucHJvdG90eXBlLl9nZXRBdWRpb0NvZGVjID0gZnVuY3Rpb24gKGN1cnJlbnRMZXZlbCkge1xuICAgICAgICB2YXIgYXVkaW9Db2RlYyA9IHRoaXMuY29uZmlnLmRlZmF1bHRBdWRpb0NvZGVjIHx8IGN1cnJlbnRMZXZlbC5hdWRpb0NvZGVjO1xuICAgICAgICBpZiAodGhpcy5hdWRpb0NvZGVjU3dhcCkge1xuICAgICAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLmxvZygnc3dhcHBpbmcgcGxheWxpc3QgYXVkaW8gY29kZWMnKTtcbiAgICAgICAgICAgIGlmIChhdWRpb0NvZGVjKSB7XG4gICAgICAgICAgICAgICAgaWYgKGF1ZGlvQ29kZWMuaW5kZXhPZignbXA0YS40MC41JykgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGF1ZGlvQ29kZWMgPSAnbXA0YS40MC4yJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGF1ZGlvQ29kZWMgPSAnbXA0YS40MC41JztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGF1ZGlvQ29kZWM7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU3RyZWFtQ29udHJvbGxlci5wcm90b3R5cGUsIFwibGl2ZVN5bmNQb3NpdGlvblwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xpdmVTeW5jUG9zaXRpb247XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9saXZlU3luY1Bvc2l0aW9uID0gdmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBTdHJlYW1Db250cm9sbGVyO1xufShiYXNlX3N0cmVhbV9jb250cm9sbGVyXzEuZGVmYXVsdCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gU3RyZWFtQ29udHJvbGxlcjtcblxuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovfS5jYWxsKHRoaXMsIF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vc3JjL3BvbHlmaWxscy9udW1iZXIgKi8gXCIuL3NyYy9wb2x5ZmlsbHMvbnVtYmVyLmpzXCIpW1wiTnVtYmVyXCJdKSlcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvY29udHJvbGxlci9zdWJ0aXRsZS1zdHJlYW0tY29udHJvbGxlci5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2NvbnRyb2xsZXIvc3VidGl0bGUtc3RyZWFtLWNvbnRyb2xsZXIuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyoqXG4gKiBAY2xhc3MgU3VidGl0bGVTdHJlYW1Db250cm9sbGVyXG4gKi9cbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGV2ZW50c18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZXZlbnRzICovIFwiLi9zcmMvZXZlbnRzLmpzXCIpO1xudmFyIGxvZ2dlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvbG9nZ2VyICovIFwiLi9zcmMvdXRpbHMvbG9nZ2VyLmpzXCIpO1xudmFyIGRlY3J5cHRlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vY3J5cHQvZGVjcnlwdGVyICovIFwiLi9zcmMvY3J5cHQvZGVjcnlwdGVyLmpzXCIpO1xudmFyIGJ1ZmZlcl9oZWxwZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL2J1ZmZlci1oZWxwZXIgKi8gXCIuL3NyYy91dGlscy9idWZmZXItaGVscGVyLmpzXCIpO1xudmFyIGZyYWdtZW50X2ZpbmRlcnNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZnJhZ21lbnQtZmluZGVycyAqLyBcIi4vc3JjL2NvbnRyb2xsZXIvZnJhZ21lbnQtZmluZGVycy5qc1wiKTtcbnZhciBmcmFnbWVudF90cmFja2VyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ZyYWdtZW50LXRyYWNrZXIgKi8gXCIuL3NyYy9jb250cm9sbGVyL2ZyYWdtZW50LXRyYWNrZXIuanNcIik7XG52YXIgYmFzZV9zdHJlYW1fY29udHJvbGxlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9iYXNlLXN0cmVhbS1jb250cm9sbGVyICovIFwiLi9zcmMvY29udHJvbGxlci9iYXNlLXN0cmVhbS1jb250cm9sbGVyLmpzXCIpO1xudmFyIGxldmVsX2hlbHBlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9sZXZlbC1oZWxwZXIgKi8gXCIuL3NyYy9jb250cm9sbGVyL2xldmVsLWhlbHBlci5qc1wiKTtcbnZhciBwZXJmb3JtYW5jZSA9IHdpbmRvdy5wZXJmb3JtYW5jZTtcbnZhciBUSUNLX0lOVEVSVkFMID0gNTAwOyAvLyBob3cgb2Z0ZW4gdG8gdGljayBpbiBtc1xudmFyIFN1YnRpdGxlU3RyZWFtQ29udHJvbGxlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU3VidGl0bGVTdHJlYW1Db250cm9sbGVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFN1YnRpdGxlU3RyZWFtQ29udHJvbGxlcihobHMsIGZyYWdtZW50VHJhY2tlcikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBobHMsIGV2ZW50c18xLmRlZmF1bHQuTUVESUFfQVRUQUNIRUQsIGV2ZW50c18xLmRlZmF1bHQuTUVESUFfREVUQUNISU5HLCBldmVudHNfMS5kZWZhdWx0LkVSUk9SLCBldmVudHNfMS5kZWZhdWx0LktFWV9MT0FERUQsIGV2ZW50c18xLmRlZmF1bHQuRlJBR19MT0FERUQsIGV2ZW50c18xLmRlZmF1bHQuU1VCVElUTEVfVFJBQ0tTX1VQREFURUQsIGV2ZW50c18xLmRlZmF1bHQuU1VCVElUTEVfVFJBQ0tfU1dJVENILCBldmVudHNfMS5kZWZhdWx0LlNVQlRJVExFX1RSQUNLX0xPQURFRCwgZXZlbnRzXzEuZGVmYXVsdC5TVUJUSVRMRV9GUkFHX1BST0NFU1NFRCwgZXZlbnRzXzEuZGVmYXVsdC5MRVZFTF9VUERBVEVEKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5mcmFnbWVudFRyYWNrZXIgPSBmcmFnbWVudFRyYWNrZXI7XG4gICAgICAgIF90aGlzLmNvbmZpZyA9IGhscy5jb25maWc7XG4gICAgICAgIF90aGlzLnN0YXRlID0gYmFzZV9zdHJlYW1fY29udHJvbGxlcl8xLlN0YXRlLlNUT1BQRUQ7XG4gICAgICAgIF90aGlzLnRyYWNrcyA9IFtdO1xuICAgICAgICBfdGhpcy50cmFja3NCdWZmZXJlZCA9IFtdO1xuICAgICAgICBfdGhpcy5jdXJyZW50VHJhY2tJZCA9IC0xO1xuICAgICAgICBfdGhpcy5kZWNyeXB0ZXIgPSBuZXcgZGVjcnlwdGVyXzEuZGVmYXVsdChobHMsIGhscy5jb25maWcpO1xuICAgICAgICAvLyBsYXN0QVZTdGFydCBzdG9yZXMgdGhlIHRpbWUgaW4gc2Vjb25kcyBmb3IgdGhlIHN0YXJ0IHRpbWUgb2YgYSBsZXZlbCBsb2FkXG4gICAgICAgIF90aGlzLmxhc3RBVlN0YXJ0ID0gMDtcbiAgICAgICAgX3RoaXMuX29uTWVkaWFTZWVraW5nID0gX3RoaXMub25NZWRpYVNlZWtpbmcuYmluZChfdGhpcyk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgU3VidGl0bGVTdHJlYW1Db250cm9sbGVyLnByb3RvdHlwZS5vblN1YnRpdGxlRnJhZ1Byb2Nlc3NlZCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHZhciBmcmFnID0gZGF0YS5mcmFnLCBzdWNjZXNzID0gZGF0YS5zdWNjZXNzO1xuICAgICAgICB0aGlzLmZyYWdQcmV2aW91cyA9IGZyYWc7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBiYXNlX3N0cmVhbV9jb250cm9sbGVyXzEuU3RhdGUuSURMRTtcbiAgICAgICAgaWYgKCFzdWNjZXNzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJ1ZmZlcmVkID0gdGhpcy50cmFja3NCdWZmZXJlZFt0aGlzLmN1cnJlbnRUcmFja0lkXTtcbiAgICAgICAgaWYgKCFidWZmZXJlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIENyZWF0ZS91cGRhdGUgYSBidWZmZXJlZCBhcnJheSBtYXRjaGluZyB0aGUgaW50ZXJmYWNlIHVzZWQgYnkgQnVmZmVySGVscGVyLmJ1ZmZlcmVkSW5mb1xuICAgICAgICAvLyBzbyB3ZSBjYW4gcmUtdXNlIHRoZSBsb2dpYyB1c2VkIHRvIGRldGVjdCBob3cgbXVjaCBoYXZlIGJlZW4gYnVmZmVyZWRcbiAgICAgICAgdmFyIHRpbWVSYW5nZTtcbiAgICAgICAgdmFyIGZyYWdTdGFydCA9IGZyYWcuc3RhcnQ7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnVmZmVyZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChmcmFnU3RhcnQgPj0gYnVmZmVyZWRbaV0uc3RhcnQgJiYgZnJhZ1N0YXJ0IDw9IGJ1ZmZlcmVkW2ldLmVuZCkge1xuICAgICAgICAgICAgICAgIHRpbWVSYW5nZSA9IGJ1ZmZlcmVkW2ldO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBmcmFnRW5kID0gZnJhZy5zdGFydCArIGZyYWcuZHVyYXRpb247XG4gICAgICAgIGlmICh0aW1lUmFuZ2UpIHtcbiAgICAgICAgICAgIHRpbWVSYW5nZS5lbmQgPSBmcmFnRW5kO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGltZVJhbmdlID0ge1xuICAgICAgICAgICAgICAgIHN0YXJ0OiBmcmFnU3RhcnQsXG4gICAgICAgICAgICAgICAgZW5kOiBmcmFnRW5kXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgYnVmZmVyZWQucHVzaCh0aW1lUmFuZ2UpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTdWJ0aXRsZVN0cmVhbUNvbnRyb2xsZXIucHJvdG90eXBlLm9uTWVkaWFBdHRhY2hlZCA9IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgbWVkaWEgPSBfYS5tZWRpYTtcbiAgICAgICAgdGhpcy5tZWRpYSA9IG1lZGlhO1xuICAgICAgICBtZWRpYS5hZGRFdmVudExpc3RlbmVyKCdzZWVraW5nJywgdGhpcy5fb25NZWRpYVNlZWtpbmcpO1xuICAgICAgICB0aGlzLnN0YXRlID0gYmFzZV9zdHJlYW1fY29udHJvbGxlcl8xLlN0YXRlLklETEU7XG4gICAgfTtcbiAgICBTdWJ0aXRsZVN0cmVhbUNvbnRyb2xsZXIucHJvdG90eXBlLm9uTWVkaWFEZXRhY2hpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMubWVkaWEucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Vla2luZycsIHRoaXMuX29uTWVkaWFTZWVraW5nKTtcbiAgICAgICAgdGhpcy5tZWRpYSA9IG51bGw7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBiYXNlX3N0cmVhbV9jb250cm9sbGVyXzEuU3RhdGUuU1RPUFBFRDtcbiAgICB9O1xuICAgIC8vIElmIHNvbWV0aGluZyBnb2VzIHdyb25nLCBwcm9jZWVkIHRvIG5leHQgZnJhZywgaWYgd2Ugd2VyZSBwcm9jZXNzaW5nIG9uZS5cbiAgICBTdWJ0aXRsZVN0cmVhbUNvbnRyb2xsZXIucHJvdG90eXBlLm9uRXJyb3IgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB2YXIgZnJhZyA9IGRhdGEuZnJhZztcbiAgICAgICAgLy8gZG9uJ3QgaGFuZGxlIGVycm9yIG5vdCByZWxhdGVkIHRvIHN1YnRpdGxlIGZyYWdtZW50XG4gICAgICAgIGlmICghZnJhZyB8fCBmcmFnLnR5cGUgIT09ICdzdWJ0aXRsZScpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXRlID0gYmFzZV9zdHJlYW1fY29udHJvbGxlcl8xLlN0YXRlLklETEU7XG4gICAgfTtcbiAgICAvLyBHb3QgYWxsIG5ldyBzdWJ0aXRsZSB0cmFja3MuXG4gICAgU3VidGl0bGVTdHJlYW1Db250cm9sbGVyLnByb3RvdHlwZS5vblN1YnRpdGxlVHJhY2tzVXBkYXRlZCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGxvZ2dlcl8xLmxvZ2dlci5sb2coJ3N1YnRpdGxlIHRyYWNrcyB1cGRhdGVkJyk7XG4gICAgICAgIHRoaXMudHJhY2tzQnVmZmVyZWQgPSBbXTtcbiAgICAgICAgdGhpcy50cmFja3MgPSBkYXRhLnN1YnRpdGxlVHJhY2tzO1xuICAgICAgICB0aGlzLnRyYWNrcy5mb3JFYWNoKGZ1bmN0aW9uICh0cmFjaykge1xuICAgICAgICAgICAgX3RoaXMudHJhY2tzQnVmZmVyZWRbdHJhY2suaWRdID0gW107XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgU3VidGl0bGVTdHJlYW1Db250cm9sbGVyLnByb3RvdHlwZS5vblN1YnRpdGxlVHJhY2tTd2l0Y2ggPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB0aGlzLmN1cnJlbnRUcmFja0lkID0gZGF0YS5pZDtcbiAgICAgICAgaWYgKCF0aGlzLnRyYWNrcyB8fCB0aGlzLmN1cnJlbnRUcmFja0lkID09PSAtMSkge1xuICAgICAgICAgICAgdGhpcy5jbGVhckludGVydmFsKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2hlY2sgaWYgdHJhY2sgaGFzIHRoZSBuZWNlc3NhcnkgZGV0YWlscyB0byBsb2FkIGZyYWdtZW50c1xuICAgICAgICB2YXIgY3VycmVudFRyYWNrID0gdGhpcy50cmFja3NbdGhpcy5jdXJyZW50VHJhY2tJZF07XG4gICAgICAgIGlmIChjdXJyZW50VHJhY2sgJiYgY3VycmVudFRyYWNrLmRldGFpbHMpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0SW50ZXJ2YWwoVElDS19JTlRFUlZBTCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIEdvdCBhIG5ldyBzZXQgb2Ygc3VidGl0bGUgZnJhZ21lbnRzLlxuICAgIFN1YnRpdGxlU3RyZWFtQ29udHJvbGxlci5wcm90b3R5cGUub25TdWJ0aXRsZVRyYWNrTG9hZGVkID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdmFyIGlkID0gZGF0YS5pZCwgZGV0YWlscyA9IGRhdGEuZGV0YWlscztcbiAgICAgICAgdmFyIF9hID0gdGhpcywgY3VycmVudFRyYWNrSWQgPSBfYS5jdXJyZW50VHJhY2tJZCwgdHJhY2tzID0gX2EudHJhY2tzO1xuICAgICAgICB2YXIgY3VycmVudFRyYWNrID0gdHJhY2tzW2N1cnJlbnRUcmFja0lkXTtcbiAgICAgICAgaWYgKGlkID49IHRyYWNrcy5sZW5ndGggfHwgaWQgIT09IGN1cnJlbnRUcmFja0lkIHx8ICFjdXJyZW50VHJhY2spIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGV0YWlscy5saXZlKSB7XG4gICAgICAgICAgICBsZXZlbF9oZWxwZXJfMS5tZXJnZVN1YnRpdGxlUGxheWxpc3RzKGN1cnJlbnRUcmFjay5kZXRhaWxzLCBkZXRhaWxzLCB0aGlzLmxhc3RBVlN0YXJ0KTtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50VHJhY2suZGV0YWlscyA9IGRldGFpbHM7XG4gICAgICAgIHRoaXMuc2V0SW50ZXJ2YWwoVElDS19JTlRFUlZBTCk7XG4gICAgfTtcbiAgICBTdWJ0aXRsZVN0cmVhbUNvbnRyb2xsZXIucHJvdG90eXBlLm9uS2V5TG9hZGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gYmFzZV9zdHJlYW1fY29udHJvbGxlcl8xLlN0YXRlLktFWV9MT0FESU5HKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gYmFzZV9zdHJlYW1fY29udHJvbGxlcl8xLlN0YXRlLklETEU7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN1YnRpdGxlU3RyZWFtQ29udHJvbGxlci5wcm90b3R5cGUub25GcmFnTG9hZGVkID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdmFyIGZyYWdDdXJyZW50ID0gdGhpcy5mcmFnQ3VycmVudDtcbiAgICAgICAgdmFyIGRlY3J5cHREYXRhID0gZGF0YS5mcmFnLmRlY3J5cHRkYXRhO1xuICAgICAgICB2YXIgZnJhZ0xvYWRlZCA9IGRhdGEuZnJhZztcbiAgICAgICAgdmFyIGhscyA9IHRoaXMuaGxzO1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gYmFzZV9zdHJlYW1fY29udHJvbGxlcl8xLlN0YXRlLkZSQUdfTE9BRElORyAmJlxuICAgICAgICAgICAgZnJhZ0N1cnJlbnQgJiZcbiAgICAgICAgICAgIGRhdGEuZnJhZy50eXBlID09PSAnc3VidGl0bGUnICYmXG4gICAgICAgICAgICBmcmFnQ3VycmVudC5zbiA9PT0gZGF0YS5mcmFnLnNuKSB7XG4gICAgICAgICAgICAvLyBjaGVjayB0byBzZWUgaWYgdGhlIHBheWxvYWQgbmVlZHMgdG8gYmUgZGVjcnlwdGVkXG4gICAgICAgICAgICBpZiAoZGF0YS5wYXlsb2FkLmJ5dGVMZW5ndGggPiAwICYmIChkZWNyeXB0RGF0YSAmJiBkZWNyeXB0RGF0YS5rZXkgJiYgZGVjcnlwdERhdGEubWV0aG9kID09PSAnQUVTLTEyOCcpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0VGltZV8xID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgICAgICAgICAgLy8gZGVjcnlwdCB0aGUgc3VidGl0bGVzXG4gICAgICAgICAgICAgICAgdGhpcy5kZWNyeXB0ZXIuZGVjcnlwdChkYXRhLnBheWxvYWQsIGRlY3J5cHREYXRhLmtleS5idWZmZXIsIGRlY3J5cHREYXRhLml2LmJ1ZmZlciwgZnVuY3Rpb24gKGRlY3J5cHRlZERhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVuZFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgICAgICAgICAgICAgaGxzLnRyaWdnZXIoZXZlbnRzXzEuZGVmYXVsdC5GUkFHX0RFQ1JZUFRFRCwgeyBmcmFnOiBmcmFnTG9hZGVkLCBwYXlsb2FkOiBkZWNyeXB0ZWREYXRhLCBzdGF0czogeyB0c3RhcnQ6IHN0YXJ0VGltZV8xLCB0ZGVjcnlwdDogZW5kVGltZSB9IH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBTdWJ0aXRsZVN0cmVhbUNvbnRyb2xsZXIucHJvdG90eXBlLm9uTGV2ZWxVcGRhdGVkID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBkZXRhaWxzID0gX2EuZGV0YWlscztcbiAgICAgICAgdmFyIGZyYWdzID0gZGV0YWlscy5mcmFnbWVudHM7XG4gICAgICAgIHRoaXMubGFzdEFWU3RhcnQgPSBmcmFncy5sZW5ndGggPyBmcmFnc1swXS5zdGFydCA6IDA7XG4gICAgfTtcbiAgICBTdWJ0aXRsZVN0cmVhbUNvbnRyb2xsZXIucHJvdG90eXBlLmRvVGljayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLm1lZGlhKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gYmFzZV9zdHJlYW1fY29udHJvbGxlcl8xLlN0YXRlLklETEU7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoICh0aGlzLnN0YXRlKSB7XG4gICAgICAgICAgICBjYXNlIGJhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfMS5TdGF0ZS5JRExFOiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hID0gdGhpcywgY29uZmlnID0gX2EuY29uZmlnLCBjdXJyZW50VHJhY2tJZCA9IF9hLmN1cnJlbnRUcmFja0lkLCBmcmFnbWVudFRyYWNrZXIgPSBfYS5mcmFnbWVudFRyYWNrZXIsIG1lZGlhID0gX2EubWVkaWEsIHRyYWNrcyA9IF9hLnRyYWNrcztcbiAgICAgICAgICAgICAgICBpZiAoIXRyYWNrcyB8fCAhdHJhY2tzW2N1cnJlbnRUcmFja0lkXSB8fCAhdHJhY2tzW2N1cnJlbnRUcmFja0lkXS5kZXRhaWxzKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgbWF4QnVmZmVySG9sZSA9IGNvbmZpZy5tYXhCdWZmZXJIb2xlLCBtYXhGcmFnTG9va1VwVG9sZXJhbmNlID0gY29uZmlnLm1heEZyYWdMb29rVXBUb2xlcmFuY2U7XG4gICAgICAgICAgICAgICAgdmFyIG1heENvbmZpZ0J1ZmZlciA9IE1hdGgubWluKGNvbmZpZy5tYXhCdWZmZXJMZW5ndGgsIGNvbmZpZy5tYXhNYXhCdWZmZXJMZW5ndGgpO1xuICAgICAgICAgICAgICAgIHZhciBidWZmZXJlZEluZm8gPSBidWZmZXJfaGVscGVyXzEuQnVmZmVySGVscGVyLmJ1ZmZlcmVkSW5mbyh0aGlzLl9nZXRCdWZmZXJlZCgpLCBtZWRpYS5jdXJyZW50VGltZSwgbWF4QnVmZmVySG9sZSk7XG4gICAgICAgICAgICAgICAgdmFyIGJ1ZmZlckVuZCA9IGJ1ZmZlcmVkSW5mby5lbmQsIGJ1ZmZlckxlbiA9IGJ1ZmZlcmVkSW5mby5sZW47XG4gICAgICAgICAgICAgICAgdmFyIHRyYWNrRGV0YWlscyA9IHRyYWNrc1tjdXJyZW50VHJhY2tJZF0uZGV0YWlscztcbiAgICAgICAgICAgICAgICB2YXIgZnJhZ21lbnRzID0gdHJhY2tEZXRhaWxzLmZyYWdtZW50cztcbiAgICAgICAgICAgICAgICB2YXIgZnJhZ0xlbiA9IGZyYWdtZW50cy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgdmFyIGVuZCA9IGZyYWdtZW50c1tmcmFnTGVuIC0gMV0uc3RhcnQgKyBmcmFnbWVudHNbZnJhZ0xlbiAtIDFdLmR1cmF0aW9uO1xuICAgICAgICAgICAgICAgIGlmIChidWZmZXJMZW4gPiBtYXhDb25maWdCdWZmZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgZm91bmRGcmFnID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgIHZhciBmcmFnUHJldmlvdXMgPSB0aGlzLmZyYWdQcmV2aW91cztcbiAgICAgICAgICAgICAgICBpZiAoYnVmZmVyRW5kIDwgZW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmcmFnUHJldmlvdXMgJiYgdHJhY2tEZXRhaWxzLmhhc1Byb2dyYW1EYXRlVGltZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm91bmRGcmFnID0gZnJhZ21lbnRfZmluZGVyc18xLmZpbmRGcmFnbWVudEJ5UERUKGZyYWdtZW50cywgZnJhZ1ByZXZpb3VzLmVuZFByb2dyYW1EYXRlVGltZSwgbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFmb3VuZEZyYWcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvdW5kRnJhZyA9IGZyYWdtZW50X2ZpbmRlcnNfMS5maW5kRnJhZ21lbnRCeVBUUyhmcmFnUHJldmlvdXMsIGZyYWdtZW50cywgYnVmZmVyRW5kLCBtYXhGcmFnTG9va1VwVG9sZXJhbmNlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZm91bmRGcmFnID0gZnJhZ21lbnRzW2ZyYWdMZW4gLSAxXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGZvdW5kRnJhZyAmJiBmb3VuZEZyYWcuZW5jcnlwdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmxvZ2dlci5sb2coXCJMb2FkaW5nIGtleSBmb3IgXCIgKyBmb3VuZEZyYWcuc24pO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gYmFzZV9zdHJlYW1fY29udHJvbGxlcl8xLlN0YXRlLktFWV9MT0FESU5HO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmhscy50cmlnZ2VyKGV2ZW50c18xLmRlZmF1bHQuS0VZX0xPQURJTkcsIHsgZnJhZzogZm91bmRGcmFnIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChmb3VuZEZyYWcgJiYgZnJhZ21lbnRUcmFja2VyLmdldFN0YXRlKGZvdW5kRnJhZykgPT09IGZyYWdtZW50X3RyYWNrZXJfMS5GcmFnbWVudFN0YXRlLk5PVF9MT0FERUQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gb25seSBsb2FkIGlmIGZyYWdtZW50IGlzIG5vdCBsb2FkZWRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mcmFnQ3VycmVudCA9IGZvdW5kRnJhZztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IGJhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfMS5TdGF0ZS5GUkFHX0xPQURJTkc7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoZXZlbnRzXzEuZGVmYXVsdC5GUkFHX0xPQURJTkcsIHsgZnJhZzogZm91bmRGcmFnIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgU3VidGl0bGVTdHJlYW1Db250cm9sbGVyLnByb3RvdHlwZS5zdG9wTG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5sYXN0QVZTdGFydCA9IDA7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuc3RvcExvYWQuY2FsbCh0aGlzKTtcbiAgICB9O1xuICAgIFN1YnRpdGxlU3RyZWFtQ29udHJvbGxlci5wcm90b3R5cGUuX2dldEJ1ZmZlcmVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFja3NCdWZmZXJlZFt0aGlzLmN1cnJlbnRUcmFja0lkXSB8fCBbXTtcbiAgICB9O1xuICAgIFN1YnRpdGxlU3RyZWFtQ29udHJvbGxlci5wcm90b3R5cGUub25NZWRpYVNlZWtpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZnJhZ1ByZXZpb3VzID0gbnVsbDtcbiAgICB9O1xuICAgIHJldHVybiBTdWJ0aXRsZVN0cmVhbUNvbnRyb2xsZXI7XG59KGJhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfMS5kZWZhdWx0KSk7XG5leHBvcnRzLlN1YnRpdGxlU3RyZWFtQ29udHJvbGxlciA9IFN1YnRpdGxlU3RyZWFtQ29udHJvbGxlcjtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9jb250cm9sbGVyL3N1YnRpdGxlLXRyYWNrLWNvbnRyb2xsZXIuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2NvbnRyb2xsZXIvc3VidGl0bGUtdHJhY2stY29udHJvbGxlci5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qISBNb2R1bGVDb25jYXRlbmF0aW9uIGJhaWxvdXQ6IE1vZHVsZSBpcyBub3QgYW4gRUNNQVNjcmlwdCBtb2R1bGUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi8oZnVuY3Rpb24oTnVtYmVyKSB7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBldmVudHNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2V2ZW50cyAqLyBcIi4vc3JjL2V2ZW50cy5qc1wiKTtcbnZhciBldmVudF9oYW5kbGVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9ldmVudC1oYW5kbGVyICovIFwiLi9zcmMvZXZlbnQtaGFuZGxlci5qc1wiKTtcbnZhciBsb2dnZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL2xvZ2dlciAqLyBcIi4vc3JjL3V0aWxzL2xvZ2dlci5qc1wiKTtcbnZhciBsZXZlbF9oZWxwZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vbGV2ZWwtaGVscGVyICovIFwiLi9zcmMvY29udHJvbGxlci9sZXZlbC1oZWxwZXIuanNcIik7XG52YXIgU3VidGl0bGVUcmFja0NvbnRyb2xsZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFN1YnRpdGxlVHJhY2tDb250cm9sbGVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFN1YnRpdGxlVHJhY2tDb250cm9sbGVyKGhscykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBobHMsIGV2ZW50c18xLmRlZmF1bHQuTUVESUFfQVRUQUNIRUQsIGV2ZW50c18xLmRlZmF1bHQuTUVESUFfREVUQUNISU5HLCBldmVudHNfMS5kZWZhdWx0Lk1BTklGRVNUX0xPQURFRCwgZXZlbnRzXzEuZGVmYXVsdC5TVUJUSVRMRV9UUkFDS19MT0FERUQpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnRyYWNrcyA9IFtdO1xuICAgICAgICBfdGhpcy50cmFja0lkID0gLTE7XG4gICAgICAgIF90aGlzLm1lZGlhID0gbnVsbDtcbiAgICAgICAgX3RoaXMuc3RvcHBlZCA9IHRydWU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtib29sZWFufSBzdWJ0aXRsZURpc3BsYXkgRW5hYmxlL2Rpc2FibGUgc3VidGl0bGUgZGlzcGxheSByZW5kZXJpbmdcbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLnN1YnRpdGxlRGlzcGxheSA9IHRydWU7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgU3VidGl0bGVUcmFja0NvbnRyb2xsZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGV2ZW50X2hhbmRsZXJfMS5kZWZhdWx0LnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcyk7XG4gICAgfTtcbiAgICAvLyBMaXN0ZW4gZm9yIHN1YnRpdGxlIHRyYWNrIGNoYW5nZSwgdGhlbiBleHRyYWN0IHRoZSBjdXJyZW50IHRyYWNrIElELlxuICAgIFN1YnRpdGxlVHJhY2tDb250cm9sbGVyLnByb3RvdHlwZS5vbk1lZGlhQXR0YWNoZWQgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLm1lZGlhID0gZGF0YS5tZWRpYTtcbiAgICAgICAgaWYgKCF0aGlzLm1lZGlhKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucXVldWVkRGVmYXVsdFRyYWNrKSB7XG4gICAgICAgICAgICB0aGlzLnN1YnRpdGxlVHJhY2sgPSB0aGlzLnF1ZXVlZERlZmF1bHRUcmFjaztcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnF1ZXVlZERlZmF1bHRUcmFjaztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRyYWNrQ2hhbmdlTGlzdGVuZXIgPSB0aGlzLl9vblRleHRUcmFja3NDaGFuZ2VkLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMudXNlVGV4dFRyYWNrUG9sbGluZyA9ICEodGhpcy5tZWRpYS50ZXh0VHJhY2tzICYmICdvbmNoYW5nZScgaW4gdGhpcy5tZWRpYS50ZXh0VHJhY2tzKTtcbiAgICAgICAgaWYgKHRoaXMudXNlVGV4dFRyYWNrUG9sbGluZykge1xuICAgICAgICAgICAgdGhpcy5zdWJ0aXRsZVBvbGxpbmdJbnRlcnZhbCA9IHNldEludGVydmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy50cmFja0NoYW5nZUxpc3RlbmVyKCk7XG4gICAgICAgICAgICB9LCA1MDApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5tZWRpYS50ZXh0VHJhY2tzLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHRoaXMudHJhY2tDaGFuZ2VMaXN0ZW5lcik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN1YnRpdGxlVHJhY2tDb250cm9sbGVyLnByb3RvdHlwZS5vbk1lZGlhRGV0YWNoaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMubWVkaWEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy51c2VUZXh0VHJhY2tQb2xsaW5nKSB7XG4gICAgICAgICAgICBjbGVhckludGVydmFsKHRoaXMuc3VidGl0bGVQb2xsaW5nSW50ZXJ2YWwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5tZWRpYS50ZXh0VHJhY2tzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHRoaXMudHJhY2tDaGFuZ2VMaXN0ZW5lcik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tZWRpYSA9IG51bGw7XG4gICAgfTtcbiAgICAvLyBGaXJlZCB3aGVuZXZlciBhIG5ldyBtYW5pZmVzdCBpcyBsb2FkZWQuXG4gICAgU3VidGl0bGVUcmFja0NvbnRyb2xsZXIucHJvdG90eXBlLm9uTWFuaWZlc3RMb2FkZWQgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgdHJhY2tzID0gZGF0YS5zdWJ0aXRsZXMgfHwgW107XG4gICAgICAgIHRoaXMudHJhY2tzID0gdHJhY2tzO1xuICAgICAgICB0aGlzLmhscy50cmlnZ2VyKGV2ZW50c18xLmRlZmF1bHQuU1VCVElUTEVfVFJBQ0tTX1VQREFURUQsIHsgc3VidGl0bGVUcmFja3M6IHRyYWNrcyB9KTtcbiAgICAgICAgLy8gbG9vcCB0aHJvdWdoIGF2YWlsYWJsZSBzdWJ0aXRsZSB0cmFja3MgYW5kIGF1dG9zZWxlY3QgZGVmYXVsdCBpZiBuZWVkZWRcbiAgICAgICAgLy8gVE9ETzogaW1wcm92ZSBzZWxlY3Rpb24gbG9naWMgdG8gaGFuZGxlIGZvcmNlZCwgZXRjXG4gICAgICAgIHRyYWNrcy5mb3JFYWNoKGZ1bmN0aW9uICh0cmFjaykge1xuICAgICAgICAgICAgaWYgKHRyYWNrLmRlZmF1bHQpIHtcbiAgICAgICAgICAgICAgICAvLyBzZXR0aW5nIHRoaXMuc3VidGl0bGVUcmFjayB3aWxsIHRyaWdnZXIgaW50ZXJuYWwgbG9naWNcbiAgICAgICAgICAgICAgICAvLyBpZiBtZWRpYSBoYXMgbm90IGJlZW4gYXR0YWNoZWQgeWV0LCBpdCB3aWxsIGZhaWxcbiAgICAgICAgICAgICAgICAvLyB3ZSBrZWVwIGEgcmVmZXJlbmNlIHRvIHRoZSBkZWZhdWx0IHRyYWNrIGlkXG4gICAgICAgICAgICAgICAgLy8gYW5kIHdlJ2xsIHNldCBzdWJ0aXRsZVRyYWNrIHdoZW4gb25NZWRpYUF0dGFjaGVkIGlzIHRyaWdnZXJlZFxuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5tZWRpYSkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5zdWJ0aXRsZVRyYWNrID0gdHJhY2suaWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5xdWV1ZWREZWZhdWx0VHJhY2sgPSB0cmFjay5pZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgU3VidGl0bGVUcmFja0NvbnRyb2xsZXIucHJvdG90eXBlLm9uU3VidGl0bGVUcmFja0xvYWRlZCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBpZCA9IGRhdGEuaWQsIGRldGFpbHMgPSBkYXRhLmRldGFpbHM7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIHRyYWNrSWQgPSBfYS50cmFja0lkLCB0cmFja3MgPSBfYS50cmFja3M7XG4gICAgICAgIHZhciBjdXJyZW50VHJhY2sgPSB0cmFja3NbdHJhY2tJZF07XG4gICAgICAgIGlmIChpZCA+PSB0cmFja3MubGVuZ3RoIHx8IGlkICE9PSB0cmFja0lkIHx8ICFjdXJyZW50VHJhY2sgfHwgdGhpcy5zdG9wcGVkKSB7XG4gICAgICAgICAgICB0aGlzLl9jbGVhclJlbG9hZFRpbWVyKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLmxvZyhcInN1YnRpdGxlIHRyYWNrIFwiICsgaWQgKyBcIiBsb2FkZWRcIik7XG4gICAgICAgIGlmIChkZXRhaWxzLmxpdmUpIHtcbiAgICAgICAgICAgIHZhciByZWxvYWRJbnRlcnZhbCA9IGxldmVsX2hlbHBlcl8xLmNvbXB1dGVSZWxvYWRJbnRlcnZhbChjdXJyZW50VHJhY2suZGV0YWlscywgZGV0YWlscywgZGF0YS5zdGF0cy50cmVxdWVzdCk7XG4gICAgICAgICAgICBsb2dnZXJfMS5sb2dnZXIubG9nKFwiUmVsb2FkaW5nIGxpdmUgc3VidGl0bGUgcGxheWxpc3QgaW4gXCIgKyByZWxvYWRJbnRlcnZhbCArIFwibXNcIik7XG4gICAgICAgICAgICB0aGlzLnRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX2xvYWRDdXJyZW50VHJhY2soKTtcbiAgICAgICAgICAgIH0sIHJlbG9hZEludGVydmFsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2NsZWFyUmVsb2FkVGltZXIoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU3VidGl0bGVUcmFja0NvbnRyb2xsZXIucHJvdG90eXBlLnN0YXJ0TG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5zdG9wcGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2xvYWRDdXJyZW50VHJhY2soKTtcbiAgICB9O1xuICAgIFN1YnRpdGxlVHJhY2tDb250cm9sbGVyLnByb3RvdHlwZS5zdG9wTG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5zdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fY2xlYXJSZWxvYWRUaW1lcigpO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFN1YnRpdGxlVHJhY2tDb250cm9sbGVyLnByb3RvdHlwZSwgXCJzdWJ0aXRsZVRyYWNrc1wiLCB7XG4gICAgICAgIC8qKiBnZXQgYWx0ZXJuYXRlIHN1YnRpdGxlIHRyYWNrcyBsaXN0IGZyb20gcGxheWxpc3QgKiovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudHJhY2tzO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU3VidGl0bGVUcmFja0NvbnRyb2xsZXIucHJvdG90eXBlLCBcInN1YnRpdGxlVHJhY2tcIiwge1xuICAgICAgICAvKiogZ2V0IGluZGV4IG9mIHRoZSBzZWxlY3RlZCBzdWJ0aXRsZSB0cmFjayAoaW5kZXggaW4gc3VidGl0bGUgdHJhY2sgbGlzdHMpICoqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRyYWNrSWQ7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKiBzZWxlY3QgYSBzdWJ0aXRsZSB0cmFjaywgYmFzZWQgb24gaXRzIGluZGV4IGluIHN1YnRpdGxlIHRyYWNrIGxpc3RzKiovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHN1YnRpdGxlVHJhY2tJZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMudHJhY2tJZCAhPT0gc3VidGl0bGVUcmFja0lkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdG9nZ2xlVHJhY2tNb2RlcyhzdWJ0aXRsZVRyYWNrSWQpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3NldFN1YnRpdGxlVHJhY2tJbnRlcm5hbChzdWJ0aXRsZVRyYWNrSWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBTdWJ0aXRsZVRyYWNrQ29udHJvbGxlci5wcm90b3R5cGUuX2NsZWFyUmVsb2FkVGltZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnRpbWVyKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lcik7XG4gICAgICAgICAgICB0aGlzLnRpbWVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU3VidGl0bGVUcmFja0NvbnRyb2xsZXIucHJvdG90eXBlLl9sb2FkQ3VycmVudFRyYWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCB0cmFja0lkID0gX2EudHJhY2tJZCwgdHJhY2tzID0gX2EudHJhY2tzLCBobHMgPSBfYS5obHM7XG4gICAgICAgIHZhciBjdXJyZW50VHJhY2sgPSB0cmFja3NbdHJhY2tJZF07XG4gICAgICAgIGlmICh0cmFja0lkIDwgMCB8fCAhY3VycmVudFRyYWNrIHx8IChjdXJyZW50VHJhY2suZGV0YWlscyAmJiAhY3VycmVudFRyYWNrLmRldGFpbHMubGl2ZSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsb2dnZXJfMS5sb2dnZXIubG9nKFwiTG9hZGluZyBzdWJ0aXRsZSB0cmFjayBcIiArIHRyYWNrSWQpO1xuICAgICAgICBobHMudHJpZ2dlcihldmVudHNfMS5kZWZhdWx0LlNVQlRJVExFX1RSQUNLX0xPQURJTkcsIHsgdXJsOiBjdXJyZW50VHJhY2sudXJsLCBpZDogdHJhY2tJZCB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIERpc2FibGVzIHRoZSBvbGQgc3VidGl0bGVUcmFjayBhbmQgc2V0cyBjdXJyZW50IG1vZGUgb24gdGhlIG5leHQgc3VidGl0bGVUcmFjay5cbiAgICAgKiBUaGlzIG9wZXJhdGVzIG9uIHRoZSBET00gdGV4dFRyYWNrcy5cbiAgICAgKiBBIHZhbHVlIG9mIC0xIHdpbGwgZGlzYWJsZSBhbGwgc3VidGl0bGUgdHJhY2tzLlxuICAgICAqIEBwYXJhbSBuZXdJZCAtIFRoZSBpZCBvZiB0aGUgbmV4dCB0cmFjayB0byBlbmFibGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIFN1YnRpdGxlVHJhY2tDb250cm9sbGVyLnByb3RvdHlwZS5fdG9nZ2xlVHJhY2tNb2RlcyA9IGZ1bmN0aW9uIChuZXdJZCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCBtZWRpYSA9IF9hLm1lZGlhLCBzdWJ0aXRsZURpc3BsYXkgPSBfYS5zdWJ0aXRsZURpc3BsYXksIHRyYWNrSWQgPSBfYS50cmFja0lkO1xuICAgICAgICBpZiAoIW1lZGlhKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRleHRUcmFja3MgPSBmaWx0ZXJTdWJ0aXRsZVRyYWNrcyhtZWRpYS50ZXh0VHJhY2tzKTtcbiAgICAgICAgaWYgKG5ld0lkID09PSAtMSkge1xuICAgICAgICAgICAgW10uc2xpY2UuY2FsbCh0ZXh0VHJhY2tzKS5mb3JFYWNoKGZ1bmN0aW9uICh0cmFjaykge1xuICAgICAgICAgICAgICAgIHRyYWNrLm1vZGUgPSAnZGlzYWJsZWQnO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgb2xkVHJhY2sgPSB0ZXh0VHJhY2tzW3RyYWNrSWRdO1xuICAgICAgICAgICAgaWYgKG9sZFRyYWNrKSB7XG4gICAgICAgICAgICAgICAgb2xkVHJhY2subW9kZSA9ICdkaXNhYmxlZCc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5leHRUcmFjayA9IHRleHRUcmFja3NbbmV3SWRdO1xuICAgICAgICBpZiAobmV4dFRyYWNrKSB7XG4gICAgICAgICAgICBuZXh0VHJhY2subW9kZSA9IHN1YnRpdGxlRGlzcGxheSA/ICdzaG93aW5nJyA6ICdoaWRkZW4nO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgICAqIFRoaXMgbWV0aG9kIGlzIHJlc3BvbnNpYmxlIGZvciB2YWxpZGF0aW5nIHRoZSBzdWJ0aXRsZSBpbmRleCBhbmQgcGVyaW9kaWNhbGx5IHJlbG9hZGluZyBpZiBsaXZlLlxuICAgICAgICogRGlzcGF0Y2hlcyB0aGUgU1VCVElUTEVfVFJBQ0tfU1dJVENIIGV2ZW50LCB3aGljaCBpbnN0cnVjdHMgdGhlIHN1YnRpdGxlLXN0cmVhbS1jb250cm9sbGVyIHRvIGxvYWQgdGhlIHNlbGVjdGVkIHRyYWNrLlxuICAgICAgICogQHBhcmFtIG5ld0lkIC0gVGhlIGlkIG9mIHRoZSBzdWJ0aXRsZSB0cmFjayB0byBhY3RpdmF0ZS5cbiAgICAgICAqL1xuICAgIFN1YnRpdGxlVHJhY2tDb250cm9sbGVyLnByb3RvdHlwZS5fc2V0U3VidGl0bGVUcmFja0ludGVybmFsID0gZnVuY3Rpb24gKG5ld0lkKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIGhscyA9IF9hLmhscywgdHJhY2tzID0gX2EudHJhY2tzO1xuICAgICAgICBpZiAoIU51bWJlci5pc0Zpbml0ZShuZXdJZCkgfHwgbmV3SWQgPCAtMSB8fCBuZXdJZCA+PSB0cmFja3MubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50cmFja0lkID0gbmV3SWQ7XG4gICAgICAgIGxvZ2dlcl8xLmxvZ2dlci5sb2coXCJTd2l0Y2hpbmcgdG8gc3VidGl0bGUgdHJhY2sgXCIgKyBuZXdJZCk7XG4gICAgICAgIGhscy50cmlnZ2VyKGV2ZW50c18xLmRlZmF1bHQuU1VCVElUTEVfVFJBQ0tfU1dJVENILCB7IGlkOiBuZXdJZCB9KTtcbiAgICAgICAgdGhpcy5fbG9hZEN1cnJlbnRUcmFjaygpO1xuICAgIH07XG4gICAgU3VidGl0bGVUcmFja0NvbnRyb2xsZXIucHJvdG90eXBlLl9vblRleHRUcmFja3NDaGFuZ2VkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBNZWRpYSBpcyB1bmRlZmluZWQgd2hlbiBzd2l0Y2hpbmcgc3RyZWFtcyB2aWEgbG9hZFNvdXJjZSgpXG4gICAgICAgIGlmICghdGhpcy5tZWRpYSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0cmFja0lkID0gLTE7XG4gICAgICAgIHZhciB0cmFja3MgPSBmaWx0ZXJTdWJ0aXRsZVRyYWNrcyh0aGlzLm1lZGlhLnRleHRUcmFja3MpO1xuICAgICAgICBmb3IgKHZhciBpZCA9IDA7IGlkIDwgdHJhY2tzLmxlbmd0aDsgaWQrKykge1xuICAgICAgICAgICAgaWYgKHRyYWNrc1tpZF0ubW9kZSA9PT0gJ2hpZGRlbicpIHtcbiAgICAgICAgICAgICAgICAvLyBEbyBub3QgYnJlYWsgaW4gY2FzZSB0aGVyZSBpcyBhIGZvbGxvd2luZyB0cmFjayB3aXRoIHNob3dpbmcuXG4gICAgICAgICAgICAgICAgdHJhY2tJZCA9IGlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHJhY2tzW2lkXS5tb2RlID09PSAnc2hvd2luZycpIHtcbiAgICAgICAgICAgICAgICB0cmFja0lkID0gaWQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2V0dGluZyBjdXJyZW50IHN1YnRpdGxlVHJhY2sgd2lsbCBpbnZva2UgY29kZS5cbiAgICAgICAgdGhpcy5zdWJ0aXRsZVRyYWNrID0gdHJhY2tJZDtcbiAgICB9O1xuICAgIHJldHVybiBTdWJ0aXRsZVRyYWNrQ29udHJvbGxlcjtcbn0oZXZlbnRfaGFuZGxlcl8xLmRlZmF1bHQpKTtcbmZ1bmN0aW9uIGZpbHRlclN1YnRpdGxlVHJhY2tzKHRleHRUcmFja0xpc3QpIHtcbiAgICB2YXIgdHJhY2tzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0ZXh0VHJhY2tMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciB0cmFjayA9IHRleHRUcmFja0xpc3RbaV07XG4gICAgICAgIC8vIEVkZ2UgYWRkcyBhIHRyYWNrIHdpdGhvdXQgYSBsYWJlbDsgd2UgZG9uJ3Qgd2FudCB0byB1c2UgaXRcbiAgICAgICAgaWYgKHRyYWNrLmtpbmQgPT09ICdzdWJ0aXRsZXMnICYmIHRyYWNrLmxhYmVsKSB7XG4gICAgICAgICAgICB0cmFja3MucHVzaCh0ZXh0VHJhY2tMaXN0W2ldKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJhY2tzO1xufVxuZXhwb3J0cy5kZWZhdWx0ID0gU3VidGl0bGVUcmFja0NvbnRyb2xsZXI7XG5cbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqL30uY2FsbCh0aGlzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3NyYy9wb2x5ZmlsbHMvbnVtYmVyICovIFwiLi9zcmMvcG9seWZpbGxzL251bWJlci5qc1wiKVtcIk51bWJlclwiXSkpXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2NvbnRyb2xsZXIvdGltZWxpbmUtY29udHJvbGxlci5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvY29udHJvbGxlci90aW1lbGluZS1jb250cm9sbGVyLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihOdW1iZXIpIHtcbi8qXG4gKiBUaW1lbGluZSBDb250cm9sbGVyXG4qL1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZXZlbnRzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9ldmVudHMgKi8gXCIuL3NyYy9ldmVudHMuanNcIik7XG52YXIgZXZlbnRfaGFuZGxlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZXZlbnQtaGFuZGxlciAqLyBcIi4vc3JjL2V2ZW50LWhhbmRsZXIuanNcIik7XG52YXIgY2VhXzYwOF9wYXJzZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL2NlYS02MDgtcGFyc2VyICovIFwiLi9zcmMvdXRpbHMvY2VhLTYwOC1wYXJzZXIuanNcIik7XG52YXIgb3V0cHV0X2ZpbHRlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvb3V0cHV0LWZpbHRlciAqLyBcIi4vc3JjL3V0aWxzL291dHB1dC1maWx0ZXIuanNcIik7XG52YXIgd2VidnR0X3BhcnNlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvd2VidnR0LXBhcnNlciAqLyBcIi4vc3JjL3V0aWxzL3dlYnZ0dC1wYXJzZXIuanNcIik7XG52YXIgbG9nZ2VyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy9sb2dnZXIgKi8gXCIuL3NyYy91dGlscy9sb2dnZXIuanNcIik7XG52YXIgdGV4dHRyYWNrX3V0aWxzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy90ZXh0dHJhY2stdXRpbHMgKi8gXCIuL3NyYy91dGlscy90ZXh0dHJhY2stdXRpbHMuanNcIik7XG5mdW5jdGlvbiBjYW5SZXVzZVZ0dFRleHRUcmFjayhpblVzZVRyYWNrLCBtYW5pZmVzdFRyYWNrKSB7XG4gICAgcmV0dXJuIGluVXNlVHJhY2sgJiYgaW5Vc2VUcmFjay5sYWJlbCA9PT0gbWFuaWZlc3RUcmFjay5uYW1lICYmICEoaW5Vc2VUcmFjay50ZXh0VHJhY2sxIHx8IGluVXNlVHJhY2sudGV4dFRyYWNrMik7XG59XG5mdW5jdGlvbiBpbnRlcnNlY3Rpb24oeDEsIHgyLCB5MSwgeTIpIHtcbiAgICByZXR1cm4gTWF0aC5taW4oeDIsIHkyKSAtIE1hdGgubWF4KHgxLCB5MSk7XG59XG52YXIgVGltZWxpbmVDb250cm9sbGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhUaW1lbGluZUNvbnRyb2xsZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVGltZWxpbmVDb250cm9sbGVyKGhscykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBobHMsIGV2ZW50c18xLmRlZmF1bHQuTUVESUFfQVRUQUNISU5HLCBldmVudHNfMS5kZWZhdWx0Lk1FRElBX0RFVEFDSElORywgZXZlbnRzXzEuZGVmYXVsdC5GUkFHX1BBUlNJTkdfVVNFUkRBVEEsIGV2ZW50c18xLmRlZmF1bHQuRlJBR19ERUNSWVBURUQsIGV2ZW50c18xLmRlZmF1bHQuTUFOSUZFU1RfTE9BRElORywgZXZlbnRzXzEuZGVmYXVsdC5NQU5JRkVTVF9MT0FERUQsIGV2ZW50c18xLmRlZmF1bHQuRlJBR19MT0FERUQsIGV2ZW50c18xLmRlZmF1bHQuTEVWRUxfU1dJVENISU5HLCBldmVudHNfMS5kZWZhdWx0LklOSVRfUFRTX0ZPVU5EKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5obHMgPSBobHM7XG4gICAgICAgIF90aGlzLmNvbmZpZyA9IGhscy5jb25maWc7XG4gICAgICAgIF90aGlzLmVuYWJsZWQgPSB0cnVlO1xuICAgICAgICBfdGhpcy5DdWVzID0gaGxzLmNvbmZpZy5jdWVIYW5kbGVyO1xuICAgICAgICBfdGhpcy50ZXh0VHJhY2tzID0gW107XG4gICAgICAgIF90aGlzLnRyYWNrcyA9IFtdO1xuICAgICAgICBfdGhpcy51bnBhcnNlZFZ0dEZyYWdzID0gW107XG4gICAgICAgIF90aGlzLmluaXRQVFMgPSBbXTtcbiAgICAgICAgX3RoaXMuY3VlUmFuZ2VzID0gW107XG4gICAgICAgIF90aGlzLmNhcHRpb25zVHJhY2tzID0ge307XG4gICAgICAgIF90aGlzLmNhcHRpb25zUHJvcGVydGllcyA9IHtcbiAgICAgICAgICAgIHRleHRUcmFjazE6IHtcbiAgICAgICAgICAgICAgICBsYWJlbDogX3RoaXMuY29uZmlnLmNhcHRpb25zVGV4dFRyYWNrMUxhYmVsLFxuICAgICAgICAgICAgICAgIGxhbmd1YWdlQ29kZTogX3RoaXMuY29uZmlnLmNhcHRpb25zVGV4dFRyYWNrMUxhbmd1YWdlQ29kZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRleHRUcmFjazI6IHtcbiAgICAgICAgICAgICAgICBsYWJlbDogX3RoaXMuY29uZmlnLmNhcHRpb25zVGV4dFRyYWNrMkxhYmVsLFxuICAgICAgICAgICAgICAgIGxhbmd1YWdlQ29kZTogX3RoaXMuY29uZmlnLmNhcHRpb25zVGV4dFRyYWNrMkxhbmd1YWdlQ29kZVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBpZiAoX3RoaXMuY29uZmlnLmVuYWJsZUNFQTcwOENhcHRpb25zKSB7XG4gICAgICAgICAgICB2YXIgY2hhbm5lbDEgPSBuZXcgb3V0cHV0X2ZpbHRlcl8xLmRlZmF1bHQoX3RoaXMsICd0ZXh0VHJhY2sxJyk7XG4gICAgICAgICAgICB2YXIgY2hhbm5lbDIgPSBuZXcgb3V0cHV0X2ZpbHRlcl8xLmRlZmF1bHQoX3RoaXMsICd0ZXh0VHJhY2syJyk7XG4gICAgICAgICAgICBfdGhpcy5jZWE2MDhQYXJzZXIgPSBuZXcgY2VhXzYwOF9wYXJzZXJfMS5kZWZhdWx0KDAsIGNoYW5uZWwxLCBjaGFubmVsMik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBUaW1lbGluZUNvbnRyb2xsZXIucHJvdG90eXBlLmFkZEN1ZXMgPSBmdW5jdGlvbiAodHJhY2tOYW1lLCBzdGFydFRpbWUsIGVuZFRpbWUsIHNjcmVlbikge1xuICAgICAgICAvLyBza2lwIGN1ZXMgd2hpY2ggb3ZlcmxhcCBtb3JlIHRoYW4gNTAlIHdpdGggcHJldmlvdXNseSBwYXJzZWQgdGltZSByYW5nZXNcbiAgICAgICAgdmFyIHJhbmdlcyA9IHRoaXMuY3VlUmFuZ2VzO1xuICAgICAgICB2YXIgbWVyZ2VkID0gZmFsc2U7XG4gICAgICAgIGZvciAodmFyIGkgPSByYW5nZXMubGVuZ3RoOyBpLS07KSB7XG4gICAgICAgICAgICB2YXIgY3VlUmFuZ2UgPSByYW5nZXNbaV07XG4gICAgICAgICAgICB2YXIgb3ZlcmxhcCA9IGludGVyc2VjdGlvbihjdWVSYW5nZVswXSwgY3VlUmFuZ2VbMV0sIHN0YXJ0VGltZSwgZW5kVGltZSk7XG4gICAgICAgICAgICBpZiAob3ZlcmxhcCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgY3VlUmFuZ2VbMF0gPSBNYXRoLm1pbihjdWVSYW5nZVswXSwgc3RhcnRUaW1lKTtcbiAgICAgICAgICAgICAgICBjdWVSYW5nZVsxXSA9IE1hdGgubWF4KGN1ZVJhbmdlWzFdLCBlbmRUaW1lKTtcbiAgICAgICAgICAgICAgICBtZXJnZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmICgob3ZlcmxhcCAvIChlbmRUaW1lIC0gc3RhcnRUaW1lKSkgPiAwLjUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIW1lcmdlZCkge1xuICAgICAgICAgICAgcmFuZ2VzLnB1c2goW3N0YXJ0VGltZSwgZW5kVGltZV0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuQ3Vlcy5uZXdDdWUodGhpcy5jYXB0aW9uc1RyYWNrc1t0cmFja05hbWVdLCBzdGFydFRpbWUsIGVuZFRpbWUsIHNjcmVlbik7XG4gICAgfTtcbiAgICAvLyBUcmlnZ2VyZWQgd2hlbiBhbiBpbml0aWFsIFBUUyBpcyBmb3VuZDsgdXNlZCBmb3Igc3luY2hyb25pc2F0aW9uIG9mIFdlYlZUVC5cbiAgICBUaW1lbGluZUNvbnRyb2xsZXIucHJvdG90eXBlLm9uSW5pdFB0c0ZvdW5kID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKGRhdGEuaWQgPT09ICdtYWluJykge1xuICAgICAgICAgICAgdGhpcy5pbml0UFRTW2RhdGEuZnJhZy5jY10gPSBkYXRhLmluaXRQVFM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRHVlIHRvIGFzeW5jaHJvbm91cyBwcm9jZXNzaW5nLCBpbml0aWFsIFBUUyBtYXkgYXJyaXZlIGxhdGVyIHRoYW4gdGhlIGZpcnN0IFZUVCBmcmFnbWVudHMgYXJlIGxvYWRlZC5cbiAgICAgICAgLy8gUGFyc2UgYW55IHVucGFyc2VkIGZyYWdtZW50cyB1cG9uIHJlY2VpdmluZyB0aGUgaW5pdGlhbCBQVFMuXG4gICAgICAgIGlmICh0aGlzLnVucGFyc2VkVnR0RnJhZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgdW5wYXJzZWRWdHRGcmFncyA9IHRoaXMudW5wYXJzZWRWdHRGcmFncztcbiAgICAgICAgICAgIHRoaXMudW5wYXJzZWRWdHRGcmFncyA9IFtdO1xuICAgICAgICAgICAgdW5wYXJzZWRWdHRGcmFncy5mb3JFYWNoKGZ1bmN0aW9uIChmcmFnKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMub25GcmFnTG9hZGVkKGZyYWcpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRpbWVsaW5lQ29udHJvbGxlci5wcm90b3R5cGUuZ2V0RXhpc3RpbmdUcmFjayA9IGZ1bmN0aW9uICh0cmFja05hbWUpIHtcbiAgICAgICAgdmFyIG1lZGlhID0gdGhpcy5tZWRpYTtcbiAgICAgICAgaWYgKG1lZGlhKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lZGlhLnRleHRUcmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgdGV4dFRyYWNrID0gbWVkaWEudGV4dFRyYWNrc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAodGV4dFRyYWNrW3RyYWNrTmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRleHRUcmFjaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBUaW1lbGluZUNvbnRyb2xsZXIucHJvdG90eXBlLmNyZWF0ZUNhcHRpb25zVHJhY2sgPSBmdW5jdGlvbiAodHJhY2tOYW1lKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMuY2FwdGlvbnNQcm9wZXJ0aWVzW3RyYWNrTmFtZV0sIGxhYmVsID0gX2EubGFiZWwsIGxhbmd1YWdlQ29kZSA9IF9hLmxhbmd1YWdlQ29kZTtcbiAgICAgICAgdmFyIGNhcHRpb25zVHJhY2tzID0gdGhpcy5jYXB0aW9uc1RyYWNrcztcbiAgICAgICAgaWYgKCFjYXB0aW9uc1RyYWNrc1t0cmFja05hbWVdKSB7XG4gICAgICAgICAgICAvLyBFbmFibGUgcmV1c2Ugb2YgZXhpc3RpbmcgdGV4dCB0cmFjay5cbiAgICAgICAgICAgIHZhciBleGlzdGluZ1RyYWNrID0gdGhpcy5nZXRFeGlzdGluZ1RyYWNrKHRyYWNrTmFtZSk7XG4gICAgICAgICAgICBpZiAoIWV4aXN0aW5nVHJhY2spIHtcbiAgICAgICAgICAgICAgICB2YXIgdGV4dFRyYWNrID0gdGhpcy5jcmVhdGVUZXh0VHJhY2soJ2NhcHRpb25zJywgbGFiZWwsIGxhbmd1YWdlQ29kZSk7XG4gICAgICAgICAgICAgICAgaWYgKHRleHRUcmFjaykge1xuICAgICAgICAgICAgICAgICAgICAvLyBTZXQgYSBzcGVjaWFsIHByb3BlcnR5IG9uIHRoZSB0cmFjayBzbyB3ZSBrbm93IGl0J3MgbWFuYWdlZCBieSBIbHMuanNcbiAgICAgICAgICAgICAgICAgICAgdGV4dFRyYWNrW3RyYWNrTmFtZV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBjYXB0aW9uc1RyYWNrc1t0cmFja05hbWVdID0gdGV4dFRyYWNrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNhcHRpb25zVHJhY2tzW3RyYWNrTmFtZV0gPSBleGlzdGluZ1RyYWNrO1xuICAgICAgICAgICAgICAgIHRleHR0cmFja191dGlsc18xLmNsZWFyQ3VycmVudEN1ZXMoY2FwdGlvbnNUcmFja3NbdHJhY2tOYW1lXSk7XG4gICAgICAgICAgICAgICAgdGV4dHRyYWNrX3V0aWxzXzEuc2VuZEFkZFRyYWNrRXZlbnQoY2FwdGlvbnNUcmFja3NbdHJhY2tOYW1lXSwgdGhpcy5tZWRpYSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRpbWVsaW5lQ29udHJvbGxlci5wcm90b3R5cGUuY3JlYXRlVGV4dFRyYWNrID0gZnVuY3Rpb24gKGtpbmQsIGxhYmVsLCBsYW5nKSB7XG4gICAgICAgIHZhciBtZWRpYSA9IHRoaXMubWVkaWE7XG4gICAgICAgIGlmIChtZWRpYSkge1xuICAgICAgICAgICAgcmV0dXJuIG1lZGlhLmFkZFRleHRUcmFjayhraW5kLCBsYWJlbCwgbGFuZyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRpbWVsaW5lQ29udHJvbGxlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZXZlbnRfaGFuZGxlcl8xLmRlZmF1bHQucHJvdG90eXBlLmRlc3Ryb3kuY2FsbCh0aGlzKTtcbiAgICB9O1xuICAgIFRpbWVsaW5lQ29udHJvbGxlci5wcm90b3R5cGUub25NZWRpYUF0dGFjaGluZyA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHRoaXMubWVkaWEgPSBkYXRhLm1lZGlhO1xuICAgICAgICB0aGlzLl9jbGVhblRyYWNrcygpO1xuICAgIH07XG4gICAgVGltZWxpbmVDb250cm9sbGVyLnByb3RvdHlwZS5vbk1lZGlhRGV0YWNoaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY2FwdGlvbnNUcmFja3MgPSB0aGlzLmNhcHRpb25zVHJhY2tzO1xuICAgICAgICBPYmplY3Qua2V5cyhjYXB0aW9uc1RyYWNrcykuZm9yRWFjaChmdW5jdGlvbiAodHJhY2tOYW1lKSB7XG4gICAgICAgICAgICB0ZXh0dHJhY2tfdXRpbHNfMS5jbGVhckN1cnJlbnRDdWVzKGNhcHRpb25zVHJhY2tzW3RyYWNrTmFtZV0pO1xuICAgICAgICAgICAgZGVsZXRlIGNhcHRpb25zVHJhY2tzW3RyYWNrTmFtZV07XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgVGltZWxpbmVDb250cm9sbGVyLnByb3RvdHlwZS5vbk1hbmlmZXN0TG9hZGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5sYXN0U24gPSAtMTsgLy8gRGV0ZWN0IGRpc2NvbnRpZ3VpdHkgaW4gZnJhZ21lbnQgcGFyc2luZ1xuICAgICAgICB0aGlzLnByZXZDQyA9IC0xO1xuICAgICAgICB0aGlzLnZ0dENDcyA9IHtcbiAgICAgICAgICAgIGNjT2Zmc2V0OiAwLFxuICAgICAgICAgICAgcHJlc2VudGF0aW9uT2Zmc2V0OiAwLFxuICAgICAgICAgICAgMDoge1xuICAgICAgICAgICAgICAgIHN0YXJ0OiAwLCBwcmV2Q0M6IC0xLCBuZXc6IGZhbHNlXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX2NsZWFuVHJhY2tzKCk7XG4gICAgfTtcbiAgICBUaW1lbGluZUNvbnRyb2xsZXIucHJvdG90eXBlLl9jbGVhblRyYWNrcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gY2xlYXIgb3V0ZGF0ZWQgc3VidGl0bGVzXG4gICAgICAgIHZhciBtZWRpYSA9IHRoaXMubWVkaWE7XG4gICAgICAgIGlmIChtZWRpYSkge1xuICAgICAgICAgICAgdmFyIHRleHRUcmFja3MgPSBtZWRpYS50ZXh0VHJhY2tzO1xuICAgICAgICAgICAgaWYgKHRleHRUcmFja3MpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRleHRUcmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dHRyYWNrX3V0aWxzXzEuY2xlYXJDdXJyZW50Q3Vlcyh0ZXh0VHJhY2tzW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRpbWVsaW5lQ29udHJvbGxlci5wcm90b3R5cGUub25NYW5pZmVzdExvYWRlZCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMudGV4dFRyYWNrcyA9IFtdO1xuICAgICAgICB0aGlzLnVucGFyc2VkVnR0RnJhZ3MgPSB0aGlzLnVucGFyc2VkVnR0RnJhZ3MgfHwgW107XG4gICAgICAgIHRoaXMuaW5pdFBUUyA9IFtdO1xuICAgICAgICB0aGlzLmN1ZVJhbmdlcyA9IFtdO1xuICAgICAgICBpZiAodGhpcy5jb25maWcuZW5hYmxlV2ViVlRUKSB7XG4gICAgICAgICAgICB0aGlzLnRyYWNrcyA9IGRhdGEuc3VidGl0bGVzIHx8IFtdO1xuICAgICAgICAgICAgdmFyIGluVXNlVHJhY2tzXzEgPSB0aGlzLm1lZGlhID8gdGhpcy5tZWRpYS50ZXh0VHJhY2tzIDogW107XG4gICAgICAgICAgICB0aGlzLnRyYWNrcy5mb3JFYWNoKGZ1bmN0aW9uICh0cmFjaywgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGV4dFRyYWNrO1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCA8IGluVXNlVHJhY2tzXzEubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpblVzZVRyYWNrID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpblVzZVRyYWNrc18xLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2FuUmV1c2VWdHRUZXh0VHJhY2soaW5Vc2VUcmFja3NfMVtpXSwgdHJhY2spKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5Vc2VUcmFjayA9IGluVXNlVHJhY2tzXzFbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gUmV1c2UgdHJhY2tzIHdpdGggdGhlIHNhbWUgbGFiZWwsIGJ1dCBkbyBub3QgcmV1c2UgNjA4LzcwOCB0cmFja3NcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluVXNlVHJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHRUcmFjayA9IGluVXNlVHJhY2s7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCF0ZXh0VHJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dFRyYWNrID0gX3RoaXMuY3JlYXRlVGV4dFRyYWNrKCdzdWJ0aXRsZXMnLCB0cmFjay5uYW1lLCB0cmFjay5sYW5nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRyYWNrLmRlZmF1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dFRyYWNrLm1vZGUgPSBfdGhpcy5obHMuc3VidGl0bGVEaXNwbGF5ID8gJ3Nob3dpbmcnIDogJ2hpZGRlbic7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0VHJhY2subW9kZSA9ICdkaXNhYmxlZCc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF90aGlzLnRleHRUcmFja3MucHVzaCh0ZXh0VHJhY2spO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRpbWVsaW5lQ29udHJvbGxlci5wcm90b3R5cGUub25MZXZlbFN3aXRjaGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5lbmFibGVkID0gdGhpcy5obHMuY3VycmVudExldmVsLmNsb3NlZENhcHRpb25zICE9PSAnTk9ORSc7XG4gICAgfTtcbiAgICBUaW1lbGluZUNvbnRyb2xsZXIucHJvdG90eXBlLm9uRnJhZ0xvYWRlZCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHZhciBmcmFnID0gZGF0YS5mcmFnLCBwYXlsb2FkID0gZGF0YS5wYXlsb2FkO1xuICAgICAgICBpZiAoZnJhZy50eXBlID09PSAnbWFpbicpIHtcbiAgICAgICAgICAgIHZhciBzbiA9IGZyYWcuc247XG4gICAgICAgICAgICAvLyBpZiB0aGlzIGZyYWcgaXNuJ3QgY29udGlndW91cywgY2xlYXIgdGhlIHBhcnNlciBzbyBjdWVzIHdpdGggYmFkIHN0YXJ0L2VuZCB0aW1lcyBhcmVuJ3QgYWRkZWQgdG8gdGhlIHRleHRUcmFja1xuICAgICAgICAgICAgaWYgKHNuICE9PSB0aGlzLmxhc3RTbiArIDEpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2VhNjA4UGFyc2VyID0gdGhpcy5jZWE2MDhQYXJzZXI7XG4gICAgICAgICAgICAgICAgaWYgKGNlYTYwOFBhcnNlcikge1xuICAgICAgICAgICAgICAgICAgICBjZWE2MDhQYXJzZXIucmVzZXQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmxhc3RTbiA9IHNuO1xuICAgICAgICB9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgYnJhY2Utc3R5bGVcbiAgICAgICAgLy8gSWYgZnJhZ21lbnQgaXMgc3VidGl0bGUgdHlwZSwgcGFyc2UgYXMgV2ViVlRULlxuICAgICAgICBlbHNlIGlmIChmcmFnLnR5cGUgPT09ICdzdWJ0aXRsZScpIHtcbiAgICAgICAgICAgIGlmIChwYXlsb2FkLmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBuZWVkIGFuIGluaXRpYWwgc3luY2hyb25pc2F0aW9uIFBUUy4gU3RvcmUgZnJhZ21lbnRzIGFzIGxvbmcgYXMgbm9uZSBoYXMgYXJyaXZlZC5cbiAgICAgICAgICAgICAgICBpZiAoIU51bWJlci5pc0Zpbml0ZSh0aGlzLmluaXRQVFNbZnJhZy5jY10pKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudW5wYXJzZWRWdHRGcmFncy5wdXNoKGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5pbml0UFRTLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZmluaXNoIHVuc3VjY2Vzc2Z1bGx5LCBvdGhlcndpc2UgdGhlIHN1YnRpdGxlLXN0cmVhbS1jb250cm9sbGVyIGNvdWxkIGJlIGJsb2NrZWQgZnJvbSBsb2FkaW5nIG5ldyBmcmFncy5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoZXZlbnRzXzEuZGVmYXVsdC5TVUJUSVRMRV9GUkFHX1BST0NFU1NFRCwgeyBzdWNjZXNzOiBmYWxzZSwgZnJhZzogZnJhZyB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBkZWNyeXB0RGF0YSA9IGZyYWcuZGVjcnlwdGRhdGE7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIHN1YnRpdGxlcyBhcmUgbm90IGVuY3J5cHRlZCwgcGFyc2UgVlRUcyBub3cuIE90aGVyd2lzZSwgd2UgbmVlZCB0byB3YWl0LlxuICAgICAgICAgICAgICAgIGlmICgoZGVjcnlwdERhdGEgPT0gbnVsbCkgfHwgKGRlY3J5cHREYXRhLmtleSA9PSBudWxsKSB8fCAoZGVjcnlwdERhdGEubWV0aG9kICE9PSAnQUVTLTEyOCcpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3BhcnNlVlRUcyhmcmFnLCBwYXlsb2FkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBJbiBjYXNlIHRoZXJlIGlzIG5vIHBheWxvYWQsIGZpbmlzaCB1bnN1Y2Nlc3NmdWxseS5cbiAgICAgICAgICAgICAgICB0aGlzLmhscy50cmlnZ2VyKGV2ZW50c18xLmRlZmF1bHQuU1VCVElUTEVfRlJBR19QUk9DRVNTRUQsIHsgc3VjY2VzczogZmFsc2UsIGZyYWc6IGZyYWcgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRpbWVsaW5lQ29udHJvbGxlci5wcm90b3R5cGUuX3BhcnNlVlRUcyA9IGZ1bmN0aW9uIChmcmFnLCBwYXlsb2FkKSB7XG4gICAgICAgIHZhciB2dHRDQ3MgPSB0aGlzLnZ0dENDcztcbiAgICAgICAgaWYgKCF2dHRDQ3NbZnJhZy5jY10pIHtcbiAgICAgICAgICAgIHZ0dENDc1tmcmFnLmNjXSA9IHsgc3RhcnQ6IGZyYWcuc3RhcnQsIHByZXZDQzogdGhpcy5wcmV2Q0MsIG5ldzogdHJ1ZSB9O1xuICAgICAgICAgICAgdGhpcy5wcmV2Q0MgPSBmcmFnLmNjO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0ZXh0VHJhY2tzID0gdGhpcy50ZXh0VHJhY2tzLCBobHMgPSB0aGlzLmhscztcbiAgICAgICAgLy8gUGFyc2UgdGhlIFdlYlZUVCBmaWxlIGNvbnRlbnRzLlxuICAgICAgICB3ZWJ2dHRfcGFyc2VyXzEuZGVmYXVsdC5wYXJzZShwYXlsb2FkLCB0aGlzLmluaXRQVFNbZnJhZy5jY10sIHZ0dENDcywgZnJhZy5jYywgZnVuY3Rpb24gKGN1ZXMpIHtcbiAgICAgICAgICAgIHZhciBjdXJyZW50VHJhY2sgPSB0ZXh0VHJhY2tzW2ZyYWcubGV2ZWxdO1xuICAgICAgICAgICAgLy8gV2ViVlRUUGFyc2VyLnBhcnNlIGlzIGFuIGFzeW5jIG1ldGhvZCBhbmQgaWYgdGhlIGN1cnJlbnRseSBzZWxlY3RlZCB0ZXh0IHRyYWNrIG1vZGUgaXMgc2V0IHRvIFwiZGlzYWJsZWRcIlxuICAgICAgICAgICAgLy8gYmVmb3JlIHBhcnNpbmcgaXMgZG9uZSB0aGVuIGRvbid0IHRyeSB0byBhY2Nlc3MgY3VycmVudFRyYWNrLmN1ZXMuZ2V0Q3VlQnlJZCBhcyBjdWVzIHdpbGwgYmUgbnVsbFxuICAgICAgICAgICAgLy8gYW5kIHRyeWluZyB0byBhY2Nlc3MgZ2V0Q3VlQnlJZCBtZXRob2Qgb2YgY3VlcyB3aWxsIHRocm93IGFuIGV4Y2VwdGlvblxuICAgICAgICAgICAgaWYgKGN1cnJlbnRUcmFjay5tb2RlID09PSAnZGlzYWJsZWQnKSB7XG4gICAgICAgICAgICAgICAgaGxzLnRyaWdnZXIoZXZlbnRzXzEuZGVmYXVsdC5TVUJUSVRMRV9GUkFHX1BST0NFU1NFRCwgeyBzdWNjZXNzOiBmYWxzZSwgZnJhZzogZnJhZyB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBZGQgY3VlcyBhbmQgdHJpZ2dlciBldmVudCB3aXRoIHN1Y2Nlc3MgdHJ1ZS5cbiAgICAgICAgICAgIGN1ZXMuZm9yRWFjaChmdW5jdGlvbiAoY3VlKSB7XG4gICAgICAgICAgICAgICAgLy8gU29tZXRpbWVzIHRoZXJlIGFyZSBjdWUgb3ZlcmxhcHMgb24gc2VnbWVudGVkIHZ0dHMgc28gdGhlIHNhbWVcbiAgICAgICAgICAgICAgICAvLyBjdWUgY2FuIGFwcGVhciBtb3JlIHRoYW4gb25jZSBpbiBkaWZmZXJlbnQgdnR0IGZpbGVzLlxuICAgICAgICAgICAgICAgIC8vIFRoaXMgYXZvaWQgc2hvd2luZyBkdXBsaWNhdGVkIGN1ZXMgd2l0aCBzYW1lIHRpbWVjb2RlIGFuZCB0ZXh0LlxuICAgICAgICAgICAgICAgIGlmICghY3VycmVudFRyYWNrLmN1ZXMuZ2V0Q3VlQnlJZChjdWUuaWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50VHJhY2suYWRkQ3VlKGN1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRleHRUcmFja0N1ZSA9IG5ldyB3aW5kb3cuVGV4dFRyYWNrQ3VlKGN1ZS5zdGFydFRpbWUsIGN1ZS5lbmRUaW1lLCBjdWUudGV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0VHJhY2tDdWUuaWQgPSBjdWUuaWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50VHJhY2suYWRkQ3VlKHRleHRUcmFja0N1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGhscy50cmlnZ2VyKGV2ZW50c18xLmRlZmF1bHQuU1VCVElUTEVfRlJBR19QUk9DRVNTRUQsIHsgc3VjY2VzczogdHJ1ZSwgZnJhZzogZnJhZyB9KTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIC8vIFNvbWV0aGluZyB3ZW50IHdyb25nIHdoaWxlIHBhcnNpbmcuIFRyaWdnZXIgZXZlbnQgd2l0aCBzdWNjZXNzIGZhbHNlLlxuICAgICAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLmxvZyhcIkZhaWxlZCB0byBwYXJzZSBWVFQgY3VlOiBcIiArIGUpO1xuICAgICAgICAgICAgaGxzLnRyaWdnZXIoZXZlbnRzXzEuZGVmYXVsdC5TVUJUSVRMRV9GUkFHX1BST0NFU1NFRCwgeyBzdWNjZXNzOiBmYWxzZSwgZnJhZzogZnJhZyB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBUaW1lbGluZUNvbnRyb2xsZXIucHJvdG90eXBlLm9uRnJhZ0RlY3J5cHRlZCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHZhciBkZWNyeXB0ZWREYXRhID0gZGF0YS5wYXlsb2FkLCBmcmFnID0gZGF0YS5mcmFnO1xuICAgICAgICBpZiAoZnJhZy50eXBlID09PSAnc3VidGl0bGUnKSB7XG4gICAgICAgICAgICBpZiAoIU51bWJlci5pc0Zpbml0ZSh0aGlzLmluaXRQVFNbZnJhZy5jY10pKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51bnBhcnNlZFZ0dEZyYWdzLnB1c2goZGF0YSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fcGFyc2VWVFRzKGZyYWcsIGRlY3J5cHRlZERhdGEpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUaW1lbGluZUNvbnRyb2xsZXIucHJvdG90eXBlLm9uRnJhZ1BhcnNpbmdVc2VyZGF0YSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIC8vIHB1c2ggYWxsIG9mIHRoZSBDRUEtNzA4IG1lc3NhZ2VzIGludG8gdGhlIGludGVycHJldGVyXG4gICAgICAgIC8vIGltbWVkaWF0ZWx5LiBJdCB3aWxsIGNyZWF0ZSB0aGUgcHJvcGVyIHRpbWVzdGFtcHMgYmFzZWQgb24gb3VyIFBUUyB2YWx1ZVxuICAgICAgICBpZiAodGhpcy5lbmFibGVkICYmIHRoaXMuY29uZmlnLmVuYWJsZUNFQTcwOENhcHRpb25zKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEuc2FtcGxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBjY2RhdGFzID0gdGhpcy5leHRyYWN0Q2VhNjA4RGF0YShkYXRhLnNhbXBsZXNbaV0uYnl0ZXMpO1xuICAgICAgICAgICAgICAgIHRoaXMuY2VhNjA4UGFyc2VyLmFkZERhdGEoZGF0YS5zYW1wbGVzW2ldLnB0cywgY2NkYXRhcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRpbWVsaW5lQ29udHJvbGxlci5wcm90b3R5cGUuZXh0cmFjdENlYTYwOERhdGEgPSBmdW5jdGlvbiAoYnl0ZUFycmF5KSB7XG4gICAgICAgIHZhciBjb3VudCA9IGJ5dGVBcnJheVswXSAmIDMxO1xuICAgICAgICB2YXIgcG9zaXRpb24gPSAyO1xuICAgICAgICB2YXIgdG1wQnl0ZSwgY2NieXRlMSwgY2NieXRlMiwgY2NWYWxpZCwgY2NUeXBlO1xuICAgICAgICB2YXIgYWN0dWFsQ0NCeXRlcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGNvdW50OyBqKyspIHtcbiAgICAgICAgICAgIHRtcEJ5dGUgPSBieXRlQXJyYXlbcG9zaXRpb24rK107XG4gICAgICAgICAgICBjY2J5dGUxID0gMHg3RiAmIGJ5dGVBcnJheVtwb3NpdGlvbisrXTtcbiAgICAgICAgICAgIGNjYnl0ZTIgPSAweDdGICYgYnl0ZUFycmF5W3Bvc2l0aW9uKytdO1xuICAgICAgICAgICAgY2NWYWxpZCA9ICg0ICYgdG1wQnl0ZSkgIT09IDA7XG4gICAgICAgICAgICBjY1R5cGUgPSAzICYgdG1wQnl0ZTtcbiAgICAgICAgICAgIGlmIChjY2J5dGUxID09PSAwICYmIGNjYnl0ZTIgPT09IDApIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjY1ZhbGlkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNjVHlwZSA9PT0gMCkgeyAvLyB8fCBjY1R5cGUgPT09IDFcbiAgICAgICAgICAgICAgICAgICAgYWN0dWFsQ0NCeXRlcy5wdXNoKGNjYnl0ZTEpO1xuICAgICAgICAgICAgICAgICAgICBhY3R1YWxDQ0J5dGVzLnB1c2goY2NieXRlMik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhY3R1YWxDQ0J5dGVzO1xuICAgIH07XG4gICAgcmV0dXJuIFRpbWVsaW5lQ29udHJvbGxlcjtcbn0oZXZlbnRfaGFuZGxlcl8xLmRlZmF1bHQpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IFRpbWVsaW5lQ29udHJvbGxlcjtcblxuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovfS5jYWxsKHRoaXMsIF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vc3JjL3BvbHlmaWxscy9udW1iZXIgKi8gXCIuL3NyYy9wb2x5ZmlsbHMvbnVtYmVyLmpzXCIpW1wiTnVtYmVyXCJdKSlcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvY3J5cHQvYWVzLWNyeXB0by5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2NyeXB0L2Flcy1jcnlwdG8uanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIEFFU0NyeXB0byA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBRVNDcnlwdG8oc3VidGxlLCBpdikge1xuICAgICAgICB0aGlzLnN1YnRsZSA9IHN1YnRsZTtcbiAgICAgICAgdGhpcy5hZXNJViA9IGl2O1xuICAgIH1cbiAgICBBRVNDcnlwdG8ucHJvdG90eXBlLmRlY3J5cHQgPSBmdW5jdGlvbiAoZGF0YSwga2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN1YnRsZS5kZWNyeXB0KHsgbmFtZTogJ0FFUy1DQkMnLCBpdjogdGhpcy5hZXNJViB9LCBrZXksIGRhdGEpO1xuICAgIH07XG4gICAgcmV0dXJuIEFFU0NyeXB0bztcbn0oKSk7XG5leHBvcnRzLmRlZmF1bHQgPSBBRVNDcnlwdG87XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvY3J5cHQvYWVzLWRlY3J5cHRvci5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2NyeXB0L2Flcy1kZWNyeXB0b3IuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLy8gUEtDUzdcbmZ1bmN0aW9uIHJlbW92ZVBhZGRpbmcoYnVmZmVyKSB7XG4gICAgdmFyIG91dHB1dEJ5dGVzID0gYnVmZmVyLmJ5dGVMZW5ndGg7XG4gICAgdmFyIHBhZGRpbmdCeXRlcyA9IG91dHB1dEJ5dGVzICYmIChuZXcgRGF0YVZpZXcoYnVmZmVyKSkuZ2V0VWludDgob3V0cHV0Qnl0ZXMgLSAxKTtcbiAgICBpZiAocGFkZGluZ0J5dGVzKSB7XG4gICAgICAgIHJldHVybiBidWZmZXIuc2xpY2UoMCwgb3V0cHV0Qnl0ZXMgLSBwYWRkaW5nQnl0ZXMpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGJ1ZmZlcjtcbiAgICB9XG59XG5leHBvcnRzLnJlbW92ZVBhZGRpbmcgPSByZW1vdmVQYWRkaW5nO1xudmFyIEFFU0RlY3J5cHRvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBRVNEZWNyeXB0b3IoKSB7XG4gICAgICAgIC8vIFN0YXRpYyBhZnRlciBydW5uaW5nIGluaXRUYWJsZVxuICAgICAgICB0aGlzLnJjb24gPSBbMHgwLCAweDEsIDB4MiwgMHg0LCAweDgsIDB4MTAsIDB4MjAsIDB4NDAsIDB4ODAsIDB4MWIsIDB4MzZdO1xuICAgICAgICB0aGlzLnN1Yk1peCA9IFtuZXcgVWludDMyQXJyYXkoMjU2KSwgbmV3IFVpbnQzMkFycmF5KDI1NiksIG5ldyBVaW50MzJBcnJheSgyNTYpLCBuZXcgVWludDMyQXJyYXkoMjU2KV07XG4gICAgICAgIHRoaXMuaW52U3ViTWl4ID0gW25ldyBVaW50MzJBcnJheSgyNTYpLCBuZXcgVWludDMyQXJyYXkoMjU2KSwgbmV3IFVpbnQzMkFycmF5KDI1NiksIG5ldyBVaW50MzJBcnJheSgyNTYpXTtcbiAgICAgICAgdGhpcy5zQm94ID0gbmV3IFVpbnQzMkFycmF5KDI1Nik7XG4gICAgICAgIHRoaXMuaW52U0JveCA9IG5ldyBVaW50MzJBcnJheSgyNTYpO1xuICAgICAgICAvLyBDaGFuZ2VzIGR1cmluZyBydW50aW1lXG4gICAgICAgIHRoaXMua2V5ID0gbmV3IFVpbnQzMkFycmF5KDApO1xuICAgICAgICB0aGlzLmluaXRUYWJsZSgpO1xuICAgIH1cbiAgICAvLyBVc2luZyB2aWV3LmdldFVpbnQzMigpIGFsc28gc3dhcHMgdGhlIGJ5dGUgb3JkZXIuXG4gICAgQUVTRGVjcnlwdG9yLnByb3RvdHlwZS51aW50OEFycmF5VG9VaW50MzJBcnJheV8gPSBmdW5jdGlvbiAoYXJyYXlCdWZmZXIpIHtcbiAgICAgICAgdmFyIHZpZXcgPSBuZXcgRGF0YVZpZXcoYXJyYXlCdWZmZXIpO1xuICAgICAgICB2YXIgbmV3QXJyYXkgPSBuZXcgVWludDMyQXJyYXkoNCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgICAgICAgICBuZXdBcnJheVtpXSA9IHZpZXcuZ2V0VWludDMyKGkgKiA0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3QXJyYXk7XG4gICAgfTtcbiAgICBBRVNEZWNyeXB0b3IucHJvdG90eXBlLmluaXRUYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHNCb3ggPSB0aGlzLnNCb3g7XG4gICAgICAgIHZhciBpbnZTQm94ID0gdGhpcy5pbnZTQm94O1xuICAgICAgICB2YXIgc3ViTWl4ID0gdGhpcy5zdWJNaXg7XG4gICAgICAgIHZhciBzdWJNaXgwID0gc3ViTWl4WzBdO1xuICAgICAgICB2YXIgc3ViTWl4MSA9IHN1Yk1peFsxXTtcbiAgICAgICAgdmFyIHN1Yk1peDIgPSBzdWJNaXhbMl07XG4gICAgICAgIHZhciBzdWJNaXgzID0gc3ViTWl4WzNdO1xuICAgICAgICB2YXIgaW52U3ViTWl4ID0gdGhpcy5pbnZTdWJNaXg7XG4gICAgICAgIHZhciBpbnZTdWJNaXgwID0gaW52U3ViTWl4WzBdO1xuICAgICAgICB2YXIgaW52U3ViTWl4MSA9IGludlN1Yk1peFsxXTtcbiAgICAgICAgdmFyIGludlN1Yk1peDIgPSBpbnZTdWJNaXhbMl07XG4gICAgICAgIHZhciBpbnZTdWJNaXgzID0gaW52U3ViTWl4WzNdO1xuICAgICAgICB2YXIgZCA9IG5ldyBVaW50MzJBcnJheSgyNTYpO1xuICAgICAgICB2YXIgeCA9IDA7XG4gICAgICAgIHZhciB4aSA9IDA7XG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDI1NjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoaSA8IDEyOCkge1xuICAgICAgICAgICAgICAgIGRbaV0gPSBpIDw8IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkW2ldID0gKGkgPDwgMSkgXiAweDExYjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMjU2OyBpKyspIHtcbiAgICAgICAgICAgIHZhciBzeCA9IHhpIF4gKHhpIDw8IDEpIF4gKHhpIDw8IDIpIF4gKHhpIDw8IDMpIF4gKHhpIDw8IDQpO1xuICAgICAgICAgICAgc3ggPSAoc3ggPj4+IDgpIF4gKHN4ICYgMHhmZikgXiAweDYzO1xuICAgICAgICAgICAgc0JveFt4XSA9IHN4O1xuICAgICAgICAgICAgaW52U0JveFtzeF0gPSB4O1xuICAgICAgICAgICAgLy8gQ29tcHV0ZSBtdWx0aXBsaWNhdGlvblxuICAgICAgICAgICAgdmFyIHgyID0gZFt4XTtcbiAgICAgICAgICAgIHZhciB4NCA9IGRbeDJdO1xuICAgICAgICAgICAgdmFyIHg4ID0gZFt4NF07XG4gICAgICAgICAgICAvLyBDb21wdXRlIHN1Yi9pbnZTdWIgYnl0ZXMsIG1peCBjb2x1bW5zIHRhYmxlc1xuICAgICAgICAgICAgdmFyIHQgPSAoZFtzeF0gKiAweDEwMSkgXiAoc3ggKiAweDEwMTAxMDApO1xuICAgICAgICAgICAgc3ViTWl4MFt4XSA9ICh0IDw8IDI0KSB8ICh0ID4+PiA4KTtcbiAgICAgICAgICAgIHN1Yk1peDFbeF0gPSAodCA8PCAxNikgfCAodCA+Pj4gMTYpO1xuICAgICAgICAgICAgc3ViTWl4Mlt4XSA9ICh0IDw8IDgpIHwgKHQgPj4+IDI0KTtcbiAgICAgICAgICAgIHN1Yk1peDNbeF0gPSB0O1xuICAgICAgICAgICAgLy8gQ29tcHV0ZSBpbnYgc3ViIGJ5dGVzLCBpbnYgbWl4IGNvbHVtbnMgdGFibGVzXG4gICAgICAgICAgICB0ID0gKHg4ICogMHgxMDEwMTAxKSBeICh4NCAqIDB4MTAwMDEpIF4gKHgyICogMHgxMDEpIF4gKHggKiAweDEwMTAxMDApO1xuICAgICAgICAgICAgaW52U3ViTWl4MFtzeF0gPSAodCA8PCAyNCkgfCAodCA+Pj4gOCk7XG4gICAgICAgICAgICBpbnZTdWJNaXgxW3N4XSA9ICh0IDw8IDE2KSB8ICh0ID4+PiAxNik7XG4gICAgICAgICAgICBpbnZTdWJNaXgyW3N4XSA9ICh0IDw8IDgpIHwgKHQgPj4+IDI0KTtcbiAgICAgICAgICAgIGludlN1Yk1peDNbc3hdID0gdDtcbiAgICAgICAgICAgIC8vIENvbXB1dGUgbmV4dCBjb3VudGVyXG4gICAgICAgICAgICBpZiAoIXgpIHtcbiAgICAgICAgICAgICAgICB4ID0geGkgPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgeCA9IHgyIF4gZFtkW2RbeDggXiB4Ml1dXTtcbiAgICAgICAgICAgICAgICB4aSBePSBkW2RbeGldXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgQUVTRGVjcnlwdG9yLnByb3RvdHlwZS5leHBhbmRLZXkgPSBmdW5jdGlvbiAoa2V5QnVmZmVyKSB7XG4gICAgICAgIC8vIGNvbnZlcnQga2V5QnVmZmVyIHRvIFVpbnQzMkFycmF5XG4gICAgICAgIHZhciBrZXkgPSB0aGlzLnVpbnQ4QXJyYXlUb1VpbnQzMkFycmF5XyhrZXlCdWZmZXIpO1xuICAgICAgICB2YXIgc2FtZUtleSA9IHRydWU7XG4gICAgICAgIHZhciBvZmZzZXQgPSAwO1xuICAgICAgICB3aGlsZSAob2Zmc2V0IDwga2V5Lmxlbmd0aCAmJiBzYW1lS2V5KSB7XG4gICAgICAgICAgICBzYW1lS2V5ID0gKGtleVtvZmZzZXRdID09PSB0aGlzLmtleVtvZmZzZXRdKTtcbiAgICAgICAgICAgIG9mZnNldCsrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzYW1lS2V5KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgICAgIHZhciBrZXlTaXplID0gdGhpcy5rZXlTaXplID0ga2V5Lmxlbmd0aDtcbiAgICAgICAgaWYgKGtleVNpemUgIT09IDQgJiYga2V5U2l6ZSAhPT0gNiAmJiBrZXlTaXplICE9PSA4KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYWVzIGtleSBzaXplPScgKyBrZXlTaXplKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIga3NSb3dzID0gdGhpcy5rc1Jvd3MgPSAoa2V5U2l6ZSArIDYgKyAxKSAqIDQ7XG4gICAgICAgIHZhciBrc1JvdztcbiAgICAgICAgdmFyIGludktzUm93O1xuICAgICAgICB2YXIga2V5U2NoZWR1bGUgPSB0aGlzLmtleVNjaGVkdWxlID0gbmV3IFVpbnQzMkFycmF5KGtzUm93cyk7XG4gICAgICAgIHZhciBpbnZLZXlTY2hlZHVsZSA9IHRoaXMuaW52S2V5U2NoZWR1bGUgPSBuZXcgVWludDMyQXJyYXkoa3NSb3dzKTtcbiAgICAgICAgdmFyIHNib3ggPSB0aGlzLnNCb3g7XG4gICAgICAgIHZhciByY29uID0gdGhpcy5yY29uO1xuICAgICAgICB2YXIgaW52U3ViTWl4ID0gdGhpcy5pbnZTdWJNaXg7XG4gICAgICAgIHZhciBpbnZTdWJNaXgwID0gaW52U3ViTWl4WzBdO1xuICAgICAgICB2YXIgaW52U3ViTWl4MSA9IGludlN1Yk1peFsxXTtcbiAgICAgICAgdmFyIGludlN1Yk1peDIgPSBpbnZTdWJNaXhbMl07XG4gICAgICAgIHZhciBpbnZTdWJNaXgzID0gaW52U3ViTWl4WzNdO1xuICAgICAgICB2YXIgcHJldjtcbiAgICAgICAgdmFyIHQ7XG4gICAgICAgIGZvciAoa3NSb3cgPSAwOyBrc1JvdyA8IGtzUm93czsga3NSb3crKykge1xuICAgICAgICAgICAgaWYgKGtzUm93IDwga2V5U2l6ZSkge1xuICAgICAgICAgICAgICAgIHByZXYgPSBrZXlTY2hlZHVsZVtrc1Jvd10gPSBrZXlba3NSb3ddO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdCA9IHByZXY7XG4gICAgICAgICAgICBpZiAoa3NSb3cgJSBrZXlTaXplID09PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gUm90IHdvcmRcbiAgICAgICAgICAgICAgICB0ID0gKHQgPDwgOCkgfCAodCA+Pj4gMjQpO1xuICAgICAgICAgICAgICAgIC8vIFN1YiB3b3JkXG4gICAgICAgICAgICAgICAgdCA9IChzYm94W3QgPj4+IDI0XSA8PCAyNCkgfCAoc2JveFsodCA+Pj4gMTYpICYgMHhmZl0gPDwgMTYpIHwgKHNib3hbKHQgPj4+IDgpICYgMHhmZl0gPDwgOCkgfCBzYm94W3QgJiAweGZmXTtcbiAgICAgICAgICAgICAgICAvLyBNaXggUmNvblxuICAgICAgICAgICAgICAgIHQgXj0gcmNvblsoa3NSb3cgLyBrZXlTaXplKSB8IDBdIDw8IDI0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5U2l6ZSA+IDYgJiYga3NSb3cgJSBrZXlTaXplID09PSA0KSB7XG4gICAgICAgICAgICAgICAgLy8gU3ViIHdvcmRcbiAgICAgICAgICAgICAgICB0ID0gKHNib3hbdCA+Pj4gMjRdIDw8IDI0KSB8IChzYm94Wyh0ID4+PiAxNikgJiAweGZmXSA8PCAxNikgfCAoc2JveFsodCA+Pj4gOCkgJiAweGZmXSA8PCA4KSB8IHNib3hbdCAmIDB4ZmZdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAga2V5U2NoZWR1bGVba3NSb3ddID0gcHJldiA9IChrZXlTY2hlZHVsZVtrc1JvdyAtIGtleVNpemVdIF4gdCkgPj4+IDA7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpbnZLc1JvdyA9IDA7IGludktzUm93IDwga3NSb3dzOyBpbnZLc1JvdysrKSB7XG4gICAgICAgICAgICBrc1JvdyA9IGtzUm93cyAtIGludktzUm93O1xuICAgICAgICAgICAgaWYgKGludktzUm93ICYgMykge1xuICAgICAgICAgICAgICAgIHQgPSBrZXlTY2hlZHVsZVtrc1Jvd107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0ID0ga2V5U2NoZWR1bGVba3NSb3cgLSA0XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpbnZLc1JvdyA8IDQgfHwga3NSb3cgPD0gNCkge1xuICAgICAgICAgICAgICAgIGludktleVNjaGVkdWxlW2ludktzUm93XSA9IHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbnZLZXlTY2hlZHVsZVtpbnZLc1Jvd10gPSBpbnZTdWJNaXgwW3Nib3hbdCA+Pj4gMjRdXSBeIGludlN1Yk1peDFbc2JveFsodCA+Pj4gMTYpICYgMHhmZl1dIF4gaW52U3ViTWl4MltzYm94Wyh0ID4+PiA4KSAmIDB4ZmZdXSBeIGludlN1Yk1peDNbc2JveFt0ICYgMHhmZl1dO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW52S2V5U2NoZWR1bGVbaW52S3NSb3ddID0gaW52S2V5U2NoZWR1bGVbaW52S3NSb3ddID4+PiAwO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBBZGRpbmcgdGhpcyBhcyBhIG1ldGhvZCBncmVhdGx5IGltcHJvdmVzIHBlcmZvcm1hbmNlLlxuICAgIEFFU0RlY3J5cHRvci5wcm90b3R5cGUubmV0d29ya1RvSG9zdE9yZGVyU3dhcCA9IGZ1bmN0aW9uICh3b3JkKSB7XG4gICAgICAgIHJldHVybiAod29yZCA8PCAyNCkgfCAoKHdvcmQgJiAweGZmMDApIDw8IDgpIHwgKCh3b3JkICYgMHhmZjAwMDApID4+IDgpIHwgKHdvcmQgPj4+IDI0KTtcbiAgICB9O1xuICAgIEFFU0RlY3J5cHRvci5wcm90b3R5cGUuZGVjcnlwdCA9IGZ1bmN0aW9uIChpbnB1dEFycmF5QnVmZmVyLCBvZmZzZXQsIGFlc0lWLCByZW1vdmVQS0NTN1BhZGRpbmcpIHtcbiAgICAgICAgdmFyIG5Sb3VuZHMgPSB0aGlzLmtleVNpemUgKyA2O1xuICAgICAgICB2YXIgaW52S2V5U2NoZWR1bGUgPSB0aGlzLmludktleVNjaGVkdWxlO1xuICAgICAgICB2YXIgaW52U0JPWCA9IHRoaXMuaW52U0JveDtcbiAgICAgICAgdmFyIGludlN1Yk1peCA9IHRoaXMuaW52U3ViTWl4O1xuICAgICAgICB2YXIgaW52U3ViTWl4MCA9IGludlN1Yk1peFswXTtcbiAgICAgICAgdmFyIGludlN1Yk1peDEgPSBpbnZTdWJNaXhbMV07XG4gICAgICAgIHZhciBpbnZTdWJNaXgyID0gaW52U3ViTWl4WzJdO1xuICAgICAgICB2YXIgaW52U3ViTWl4MyA9IGludlN1Yk1peFszXTtcbiAgICAgICAgdmFyIGluaXRWZWN0b3IgPSB0aGlzLnVpbnQ4QXJyYXlUb1VpbnQzMkFycmF5XyhhZXNJVik7XG4gICAgICAgIHZhciBpbml0VmVjdG9yMCA9IGluaXRWZWN0b3JbMF07XG4gICAgICAgIHZhciBpbml0VmVjdG9yMSA9IGluaXRWZWN0b3JbMV07XG4gICAgICAgIHZhciBpbml0VmVjdG9yMiA9IGluaXRWZWN0b3JbMl07XG4gICAgICAgIHZhciBpbml0VmVjdG9yMyA9IGluaXRWZWN0b3JbM107XG4gICAgICAgIHZhciBpbnB1dEludDMyID0gbmV3IEludDMyQXJyYXkoaW5wdXRBcnJheUJ1ZmZlcik7XG4gICAgICAgIHZhciBvdXRwdXRJbnQzMiA9IG5ldyBJbnQzMkFycmF5KGlucHV0SW50MzIubGVuZ3RoKTtcbiAgICAgICAgdmFyIHQwLCB0MSwgdDIsIHQzO1xuICAgICAgICB2YXIgczAsIHMxLCBzMiwgczM7XG4gICAgICAgIHZhciBpbnB1dFdvcmRzMCwgaW5wdXRXb3JkczEsIGlucHV0V29yZHMyLCBpbnB1dFdvcmRzMztcbiAgICAgICAgdmFyIGtzUm93LCBpO1xuICAgICAgICB2YXIgc3dhcFdvcmQgPSB0aGlzLm5ldHdvcmtUb0hvc3RPcmRlclN3YXA7XG4gICAgICAgIHdoaWxlIChvZmZzZXQgPCBpbnB1dEludDMyLmxlbmd0aCkge1xuICAgICAgICAgICAgaW5wdXRXb3JkczAgPSBzd2FwV29yZChpbnB1dEludDMyW29mZnNldF0pO1xuICAgICAgICAgICAgaW5wdXRXb3JkczEgPSBzd2FwV29yZChpbnB1dEludDMyW29mZnNldCArIDFdKTtcbiAgICAgICAgICAgIGlucHV0V29yZHMyID0gc3dhcFdvcmQoaW5wdXRJbnQzMltvZmZzZXQgKyAyXSk7XG4gICAgICAgICAgICBpbnB1dFdvcmRzMyA9IHN3YXBXb3JkKGlucHV0SW50MzJbb2Zmc2V0ICsgM10pO1xuICAgICAgICAgICAgczAgPSBpbnB1dFdvcmRzMCBeIGludktleVNjaGVkdWxlWzBdO1xuICAgICAgICAgICAgczEgPSBpbnB1dFdvcmRzMyBeIGludktleVNjaGVkdWxlWzFdO1xuICAgICAgICAgICAgczIgPSBpbnB1dFdvcmRzMiBeIGludktleVNjaGVkdWxlWzJdO1xuICAgICAgICAgICAgczMgPSBpbnB1dFdvcmRzMSBeIGludktleVNjaGVkdWxlWzNdO1xuICAgICAgICAgICAga3NSb3cgPSA0O1xuICAgICAgICAgICAgLy8gSXRlcmF0ZSB0aHJvdWdoIHRoZSByb3VuZHMgb2YgZGVjcnlwdGlvblxuICAgICAgICAgICAgZm9yIChpID0gMTsgaSA8IG5Sb3VuZHM7IGkrKykge1xuICAgICAgICAgICAgICAgIHQwID0gaW52U3ViTWl4MFtzMCA+Pj4gMjRdIF4gaW52U3ViTWl4MVsoczEgPj4gMTYpICYgMHhmZl0gXiBpbnZTdWJNaXgyWyhzMiA+PiA4KSAmIDB4ZmZdIF4gaW52U3ViTWl4M1tzMyAmIDB4ZmZdIF4gaW52S2V5U2NoZWR1bGVba3NSb3ddO1xuICAgICAgICAgICAgICAgIHQxID0gaW52U3ViTWl4MFtzMSA+Pj4gMjRdIF4gaW52U3ViTWl4MVsoczIgPj4gMTYpICYgMHhmZl0gXiBpbnZTdWJNaXgyWyhzMyA+PiA4KSAmIDB4ZmZdIF4gaW52U3ViTWl4M1tzMCAmIDB4ZmZdIF4gaW52S2V5U2NoZWR1bGVba3NSb3cgKyAxXTtcbiAgICAgICAgICAgICAgICB0MiA9IGludlN1Yk1peDBbczIgPj4+IDI0XSBeIGludlN1Yk1peDFbKHMzID4+IDE2KSAmIDB4ZmZdIF4gaW52U3ViTWl4MlsoczAgPj4gOCkgJiAweGZmXSBeIGludlN1Yk1peDNbczEgJiAweGZmXSBeIGludktleVNjaGVkdWxlW2tzUm93ICsgMl07XG4gICAgICAgICAgICAgICAgdDMgPSBpbnZTdWJNaXgwW3MzID4+PiAyNF0gXiBpbnZTdWJNaXgxWyhzMCA+PiAxNikgJiAweGZmXSBeIGludlN1Yk1peDJbKHMxID4+IDgpICYgMHhmZl0gXiBpbnZTdWJNaXgzW3MyICYgMHhmZl0gXiBpbnZLZXlTY2hlZHVsZVtrc1JvdyArIDNdO1xuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBzdGF0ZVxuICAgICAgICAgICAgICAgIHMwID0gdDA7XG4gICAgICAgICAgICAgICAgczEgPSB0MTtcbiAgICAgICAgICAgICAgICBzMiA9IHQyO1xuICAgICAgICAgICAgICAgIHMzID0gdDM7XG4gICAgICAgICAgICAgICAga3NSb3cgPSBrc1JvdyArIDQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTaGlmdCByb3dzLCBzdWIgYnl0ZXMsIGFkZCByb3VuZCBrZXlcbiAgICAgICAgICAgIHQwID0gKChpbnZTQk9YW3MwID4+PiAyNF0gPDwgMjQpIF4gKGludlNCT1hbKHMxID4+IDE2KSAmIDB4ZmZdIDw8IDE2KSBeIChpbnZTQk9YWyhzMiA+PiA4KSAmIDB4ZmZdIDw8IDgpIF4gaW52U0JPWFtzMyAmIDB4ZmZdKSBeIGludktleVNjaGVkdWxlW2tzUm93XTtcbiAgICAgICAgICAgIHQxID0gKChpbnZTQk9YW3MxID4+PiAyNF0gPDwgMjQpIF4gKGludlNCT1hbKHMyID4+IDE2KSAmIDB4ZmZdIDw8IDE2KSBeIChpbnZTQk9YWyhzMyA+PiA4KSAmIDB4ZmZdIDw8IDgpIF4gaW52U0JPWFtzMCAmIDB4ZmZdKSBeIGludktleVNjaGVkdWxlW2tzUm93ICsgMV07XG4gICAgICAgICAgICB0MiA9ICgoaW52U0JPWFtzMiA+Pj4gMjRdIDw8IDI0KSBeIChpbnZTQk9YWyhzMyA+PiAxNikgJiAweGZmXSA8PCAxNikgXiAoaW52U0JPWFsoczAgPj4gOCkgJiAweGZmXSA8PCA4KSBeIGludlNCT1hbczEgJiAweGZmXSkgXiBpbnZLZXlTY2hlZHVsZVtrc1JvdyArIDJdO1xuICAgICAgICAgICAgdDMgPSAoKGludlNCT1hbczMgPj4+IDI0XSA8PCAyNCkgXiAoaW52U0JPWFsoczAgPj4gMTYpICYgMHhmZl0gPDwgMTYpIF4gKGludlNCT1hbKHMxID4+IDgpICYgMHhmZl0gPDwgOCkgXiBpbnZTQk9YW3MyICYgMHhmZl0pIF4gaW52S2V5U2NoZWR1bGVba3NSb3cgKyAzXTtcbiAgICAgICAgICAgIGtzUm93ID0ga3NSb3cgKyAzO1xuICAgICAgICAgICAgLy8gV3JpdGVcbiAgICAgICAgICAgIG91dHB1dEludDMyW29mZnNldF0gPSBzd2FwV29yZCh0MCBeIGluaXRWZWN0b3IwKTtcbiAgICAgICAgICAgIG91dHB1dEludDMyW29mZnNldCArIDFdID0gc3dhcFdvcmQodDMgXiBpbml0VmVjdG9yMSk7XG4gICAgICAgICAgICBvdXRwdXRJbnQzMltvZmZzZXQgKyAyXSA9IHN3YXBXb3JkKHQyIF4gaW5pdFZlY3RvcjIpO1xuICAgICAgICAgICAgb3V0cHV0SW50MzJbb2Zmc2V0ICsgM10gPSBzd2FwV29yZCh0MSBeIGluaXRWZWN0b3IzKTtcbiAgICAgICAgICAgIC8vIHJlc2V0IGluaXRWZWN0b3IgdG8gbGFzdCA0IHVuc2lnbmVkIGludFxuICAgICAgICAgICAgaW5pdFZlY3RvcjAgPSBpbnB1dFdvcmRzMDtcbiAgICAgICAgICAgIGluaXRWZWN0b3IxID0gaW5wdXRXb3JkczE7XG4gICAgICAgICAgICBpbml0VmVjdG9yMiA9IGlucHV0V29yZHMyO1xuICAgICAgICAgICAgaW5pdFZlY3RvcjMgPSBpbnB1dFdvcmRzMztcbiAgICAgICAgICAgIG9mZnNldCA9IG9mZnNldCArIDQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlbW92ZVBLQ1M3UGFkZGluZyA/IHJlbW92ZVBhZGRpbmcob3V0cHV0SW50MzIuYnVmZmVyKSA6IG91dHB1dEludDMyLmJ1ZmZlcjtcbiAgICB9O1xuICAgIEFFU0RlY3J5cHRvci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5rZXkgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMua2V5U2l6ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5rc1Jvd3MgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuc0JveCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5pbnZTQm94ID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnN1Yk1peCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5pbnZTdWJNaXggPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMua2V5U2NoZWR1bGUgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuaW52S2V5U2NoZWR1bGUgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMucmNvbiA9IHVuZGVmaW5lZDtcbiAgICB9O1xuICAgIHJldHVybiBBRVNEZWNyeXB0b3I7XG59KCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gQUVTRGVjcnlwdG9yO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2NyeXB0L2RlY3J5cHRlci5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvY3J5cHQvZGVjcnlwdGVyLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGFlc19jcnlwdG9fMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vYWVzLWNyeXB0byAqLyBcIi4vc3JjL2NyeXB0L2Flcy1jcnlwdG8uanNcIik7XG52YXIgZmFzdF9hZXNfa2V5XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2Zhc3QtYWVzLWtleSAqLyBcIi4vc3JjL2NyeXB0L2Zhc3QtYWVzLWtleS5qc1wiKTtcbnZhciBhZXNfZGVjcnlwdG9yXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2Flcy1kZWNyeXB0b3IgKi8gXCIuL3NyYy9jcnlwdC9hZXMtZGVjcnlwdG9yLmpzXCIpO1xudmFyIGVycm9yc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZXJyb3JzICovIFwiLi9zcmMvZXJyb3JzLmpzXCIpO1xudmFyIGxvZ2dlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvbG9nZ2VyICovIFwiLi9zcmMvdXRpbHMvbG9nZ2VyLmpzXCIpO1xudmFyIGV2ZW50c18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZXZlbnRzICovIFwiLi9zcmMvZXZlbnRzLmpzXCIpO1xudmFyIGdldF9zZWxmX3Njb3BlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy9nZXQtc2VsZi1zY29wZSAqLyBcIi4vc3JjL3V0aWxzL2dldC1zZWxmLXNjb3BlLmpzXCIpO1xuLy8gc2VlIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xMTIzNzI1OS81ODk0OTNcbnZhciBnbG9iYWwgPSBnZXRfc2VsZl9zY29wZV8xLmdldFNlbGZTY29wZSgpOyAvLyBzYWZlZ3VhcmQgZm9yIGNvZGUgdGhhdCBtaWdodCBydW4gYm90aCBvbiB3b3JrZXIgYW5kIG1haW4gdGhyZWFkXG52YXIgRGVjcnlwdGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIERlY3J5cHRlcihvYnNlcnZlciwgY29uZmlnLCBfYSkge1xuICAgICAgICB2YXIgX2IgPSAoX2EgPT09IHZvaWQgMCA/IHt9IDogX2EpLnJlbW92ZVBLQ1M3UGFkZGluZywgcmVtb3ZlUEtDUzdQYWRkaW5nID0gX2IgPT09IHZvaWQgMCA/IHRydWUgOiBfYjtcbiAgICAgICAgdGhpcy5sb2dFbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5vYnNlcnZlciA9IG9ic2VydmVyO1xuICAgICAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICAgICAgdGhpcy5yZW1vdmVQS0NTN1BhZGRpbmcgPSByZW1vdmVQS0NTN1BhZGRpbmc7XG4gICAgICAgIC8vIGJ1aWx0IGluIGRlY3J5cHRvciBleHBlY3RzIFBLQ1M3IHBhZGRpbmdcbiAgICAgICAgaWYgKHJlbW92ZVBLQ1M3UGFkZGluZykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB2YXIgYnJvd3NlckNyeXB0byA9IGdsb2JhbC5jcnlwdG87XG4gICAgICAgICAgICAgICAgaWYgKGJyb3dzZXJDcnlwdG8pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdWJ0bGUgPSBicm93c2VyQ3J5cHRvLnN1YnRsZSB8fCBicm93c2VyQ3J5cHRvLndlYmtpdFN1YnRsZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkgeyB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kaXNhYmxlV2ViQ3J5cHRvID0gIXRoaXMuc3VidGxlO1xuICAgIH1cbiAgICBEZWNyeXB0ZXIucHJvdG90eXBlLmlzU3luYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmRpc2FibGVXZWJDcnlwdG8gJiYgdGhpcy5jb25maWcuZW5hYmxlU29mdHdhcmVBRVMpO1xuICAgIH07XG4gICAgRGVjcnlwdGVyLnByb3RvdHlwZS5kZWNyeXB0ID0gZnVuY3Rpb24gKGRhdGEsIGtleSwgaXYsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLmRpc2FibGVXZWJDcnlwdG8gJiYgdGhpcy5jb25maWcuZW5hYmxlU29mdHdhcmVBRVMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmxvZ0VuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXJfMS5sb2dnZXIubG9nKCdKUyBBRVMgZGVjcnlwdCcpO1xuICAgICAgICAgICAgICAgIHRoaXMubG9nRW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGRlY3J5cHRvciA9IHRoaXMuZGVjcnlwdG9yO1xuICAgICAgICAgICAgaWYgKCFkZWNyeXB0b3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRlY3J5cHRvciA9IGRlY3J5cHRvciA9IG5ldyBhZXNfZGVjcnlwdG9yXzEuZGVmYXVsdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVjcnlwdG9yLmV4cGFuZEtleShrZXkpO1xuICAgICAgICAgICAgY2FsbGJhY2soZGVjcnlwdG9yLmRlY3J5cHQoZGF0YSwgMCwgaXYsIHRoaXMucmVtb3ZlUEtDUzdQYWRkaW5nKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5sb2dFbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLmxvZygnV2ViQ3J5cHRvIEFFUyBkZWNyeXB0Jyk7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2dFbmFibGVkID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgc3VidGxlXzEgPSB0aGlzLnN1YnRsZTtcbiAgICAgICAgICAgIGlmICh0aGlzLmtleSAhPT0ga2V5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgICAgICAgICAgICAgdGhpcy5mYXN0QWVzS2V5ID0gbmV3IGZhc3RfYWVzX2tleV8xLmRlZmF1bHQoc3VidGxlXzEsIGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmZhc3RBZXNLZXkuZXhwYW5kS2V5KClcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoYWVzS2V5KSB7XG4gICAgICAgICAgICAgICAgLy8gZGVjcnlwdCB1c2luZyB3ZWIgY3J5cHRvXG4gICAgICAgICAgICAgICAgdmFyIGNyeXB0byA9IG5ldyBhZXNfY3J5cHRvXzEuZGVmYXVsdChzdWJ0bGVfMSwgaXYpO1xuICAgICAgICAgICAgICAgIGNyeXB0by5kZWNyeXB0KGRhdGEsIGFlc0tleSlcbiAgICAgICAgICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMub25XZWJDcnlwdG9FcnJvcihlcnIsIGRhdGEsIGtleSwgaXYsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5jYXRjaChmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMub25XZWJDcnlwdG9FcnJvcihlcnIsIGRhdGEsIGtleSwgaXYsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBEZWNyeXB0ZXIucHJvdG90eXBlLm9uV2ViQ3J5cHRvRXJyb3IgPSBmdW5jdGlvbiAoZXJyLCBkYXRhLCBrZXksIGl2LCBjYWxsYmFjaykge1xuICAgICAgICBpZiAodGhpcy5jb25maWcuZW5hYmxlU29mdHdhcmVBRVMpIHtcbiAgICAgICAgICAgIGxvZ2dlcl8xLmxvZ2dlci5sb2coJ1dlYkNyeXB0byBFcnJvciwgZGlzYWJsZSBXZWJDcnlwdG8gQVBJJyk7XG4gICAgICAgICAgICB0aGlzLmRpc2FibGVXZWJDcnlwdG8gPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5sb2dFbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuZGVjcnlwdChkYXRhLCBrZXksIGl2LCBjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsb2dnZXJfMS5sb2dnZXIuZXJyb3IoXCJkZWNyeXB0aW5nIGVycm9yIDogXCIgKyBlcnIubWVzc2FnZSk7XG4gICAgICAgICAgICB0aGlzLm9ic2VydmVyLnRyaWdnZXIoZXZlbnRzXzEuZGVmYXVsdC5FUlJPUiwgeyB0eXBlOiBlcnJvcnNfMS5FcnJvclR5cGVzLk1FRElBX0VSUk9SLCBkZXRhaWxzOiBlcnJvcnNfMS5FcnJvckRldGFpbHMuRlJBR19ERUNSWVBUX0VSUk9SLCBmYXRhbDogdHJ1ZSwgcmVhc29uOiBlcnIubWVzc2FnZSB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRGVjcnlwdGVyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZGVjcnlwdG9yID0gdGhpcy5kZWNyeXB0b3I7XG4gICAgICAgIGlmIChkZWNyeXB0b3IpIHtcbiAgICAgICAgICAgIGRlY3J5cHRvci5kZXN0cm95KCk7XG4gICAgICAgICAgICB0aGlzLmRlY3J5cHRvciA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIERlY3J5cHRlcjtcbn0oKSk7XG5leHBvcnRzLmRlZmF1bHQgPSBEZWNyeXB0ZXI7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvY3J5cHQvZmFzdC1hZXMta2V5LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9jcnlwdC9mYXN0LWFlcy1rZXkuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgRmFzdEFFU0tleSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBGYXN0QUVTS2V5KHN1YnRsZSwga2V5KSB7XG4gICAgICAgIHRoaXMuc3VidGxlID0gc3VidGxlO1xuICAgICAgICB0aGlzLmtleSA9IGtleTtcbiAgICB9XG4gICAgRmFzdEFFU0tleS5wcm90b3R5cGUuZXhwYW5kS2V5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdWJ0bGUuaW1wb3J0S2V5KCdyYXcnLCB0aGlzLmtleSwgeyBuYW1lOiAnQUVTLUNCQycgfSwgZmFsc2UsIFsnZW5jcnlwdCcsICdkZWNyeXB0J10pO1xuICAgIH07XG4gICAgcmV0dXJuIEZhc3RBRVNLZXk7XG59KCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gRmFzdEFFU0tleTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9kZW11eC9hYWNkZW11eGVyLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvZGVtdXgvYWFjZGVtdXhlci5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovKGZ1bmN0aW9uKE51bWJlcikge1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBBQUMgZGVtdXhlclxuICovXG52YXIgQURUUyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vYWR0cyAqLyBcIi4vc3JjL2RlbXV4L2FkdHMuanNcIik7XG52YXIgbG9nZ2VyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy9sb2dnZXIgKi8gXCIuL3NyYy91dGlscy9sb2dnZXIuanNcIik7XG52YXIgaWQzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9kZW11eC9pZDMgKi8gXCIuL3NyYy9kZW11eC9pZDMuanNcIik7XG52YXIgQUFDRGVtdXhlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBQUNEZW11eGVyKG9ic2VydmVyLCByZW11eGVyLCBjb25maWcpIHtcbiAgICAgICAgdGhpcy5vYnNlcnZlciA9IG9ic2VydmVyO1xuICAgICAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICAgICAgdGhpcy5yZW11eGVyID0gcmVtdXhlcjtcbiAgICB9XG4gICAgQUFDRGVtdXhlci5wcm90b3R5cGUucmVzZXRJbml0U2VnbWVudCA9IGZ1bmN0aW9uIChpbml0U2VnbWVudCwgYXVkaW9Db2RlYywgdmlkZW9Db2RlYywgZHVyYXRpb24pIHtcbiAgICAgICAgdGhpcy5fYXVkaW9UcmFjayA9IHsgY29udGFpbmVyOiAnYXVkaW8vYWR0cycsIHR5cGU6ICdhdWRpbycsIGlkOiAwLCBzZXF1ZW5jZU51bWJlcjogMCwgaXNBQUM6IHRydWUsIHNhbXBsZXM6IFtdLCBsZW46IDAsIG1hbmlmZXN0Q29kZWM6IGF1ZGlvQ29kZWMsIGR1cmF0aW9uOiBkdXJhdGlvbiwgaW5wdXRUaW1lU2NhbGU6IDkwMDAwIH07XG4gICAgfTtcbiAgICBBQUNEZW11eGVyLnByb3RvdHlwZS5yZXNldFRpbWVTdGFtcCA9IGZ1bmN0aW9uICgpIHtcbiAgICB9O1xuICAgIEFBQ0RlbXV4ZXIucHJvYmUgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDaGVjayBmb3IgdGhlIEFEVFMgc3luYyB3b3JkXG4gICAgICAgIC8vIExvb2sgZm9yIEFEVFMgaGVhZGVyIHwgMTExMSAxMTExIHwgMTExMSBYMDBYIHwgd2hlcmUgWCBjYW4gYmUgZWl0aGVyIDAgb3IgMVxuICAgICAgICAvLyBMYXllciBiaXRzIChwb3NpdGlvbiAxNCBhbmQgMTUpIGluIGhlYWRlciBzaG91bGQgYmUgYWx3YXlzIDAgZm9yIEFEVFNcbiAgICAgICAgLy8gTW9yZSBpbmZvIGh0dHBzOi8vd2lraS5tdWx0aW1lZGlhLmN4L2luZGV4LnBocD90aXRsZT1BRFRTXG4gICAgICAgIHZhciBpZDNEYXRhID0gaWQzXzEuZGVmYXVsdC5nZXRJRDNEYXRhKGRhdGEsIDApIHx8IFtdO1xuICAgICAgICB2YXIgb2Zmc2V0ID0gaWQzRGF0YS5sZW5ndGg7XG4gICAgICAgIGZvciAodmFyIGxlbmd0aF8xID0gZGF0YS5sZW5ndGg7IG9mZnNldCA8IGxlbmd0aF8xOyBvZmZzZXQrKykge1xuICAgICAgICAgICAgaWYgKEFEVFMucHJvYmUoZGF0YSwgb2Zmc2V0KSkge1xuICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmxvZ2dlci5sb2coJ0FEVFMgc3luYyB3b3JkIGZvdW5kICEnKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICAvLyBmZWVkIGluY29taW5nIGRhdGEgdG8gdGhlIGZyb250IG9mIHRoZSBwYXJzaW5nIHBpcGVsaW5lXG4gICAgQUFDRGVtdXhlci5wcm90b3R5cGUuYXBwZW5kID0gZnVuY3Rpb24gKGRhdGEsIHRpbWVPZmZzZXQsIGNvbnRpZ3VvdXMsIGFjY3VyYXRlVGltZU9mZnNldCkge1xuICAgICAgICB2YXIgdHJhY2sgPSB0aGlzLl9hdWRpb1RyYWNrO1xuICAgICAgICB2YXIgaWQzRGF0YSA9IGlkM18xLmRlZmF1bHQuZ2V0SUQzRGF0YShkYXRhLCAwKSB8fCBbXTtcbiAgICAgICAgdmFyIHRpbWVzdGFtcCA9IGlkM18xLmRlZmF1bHQuZ2V0VGltZVN0YW1wKGlkM0RhdGEpO1xuICAgICAgICB2YXIgcHRzID0gTnVtYmVyLmlzRmluaXRlKHRpbWVzdGFtcCkgPyB0aW1lc3RhbXAgKiA5MCA6IHRpbWVPZmZzZXQgKiA5MDAwMDtcbiAgICAgICAgdmFyIGZyYW1lSW5kZXggPSAwO1xuICAgICAgICB2YXIgc3RhbXAgPSBwdHM7XG4gICAgICAgIHZhciBsZW5ndGggPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgdmFyIG9mZnNldCA9IGlkM0RhdGEubGVuZ3RoO1xuICAgICAgICB2YXIgaWQzU2FtcGxlcyA9IFt7IHB0czogc3RhbXAsIGR0czogc3RhbXAsIGRhdGE6IGlkM0RhdGEgfV07XG4gICAgICAgIHdoaWxlIChvZmZzZXQgPCBsZW5ndGggLSAxKSB7XG4gICAgICAgICAgICBpZiAoQURUUy5pc0hlYWRlcihkYXRhLCBvZmZzZXQpICYmIChvZmZzZXQgKyA1KSA8IGxlbmd0aCkge1xuICAgICAgICAgICAgICAgIEFEVFMuaW5pdFRyYWNrQ29uZmlnKHRyYWNrLCB0aGlzLm9ic2VydmVyLCBkYXRhLCBvZmZzZXQsIHRyYWNrLm1hbmlmZXN0Q29kZWMpO1xuICAgICAgICAgICAgICAgIHZhciBmcmFtZSA9IEFEVFMuYXBwZW5kRnJhbWUodHJhY2ssIGRhdGEsIG9mZnNldCwgcHRzLCBmcmFtZUluZGV4KTtcbiAgICAgICAgICAgICAgICBpZiAoZnJhbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ICs9IGZyYW1lLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgc3RhbXAgPSBmcmFtZS5zYW1wbGUucHRzO1xuICAgICAgICAgICAgICAgICAgICBmcmFtZUluZGV4Kys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXJfMS5sb2dnZXIubG9nKCdVbmFibGUgdG8gcGFyc2UgQUFDIGZyYW1lJyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlkM18xLmRlZmF1bHQuaXNIZWFkZXIoZGF0YSwgb2Zmc2V0KSkge1xuICAgICAgICAgICAgICAgIGlkM0RhdGEgPSBpZDNfMS5kZWZhdWx0LmdldElEM0RhdGEoZGF0YSwgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBpZDNTYW1wbGVzLnB1c2goeyBwdHM6IHN0YW1wLCBkdHM6IHN0YW1wLCBkYXRhOiBpZDNEYXRhIH0pO1xuICAgICAgICAgICAgICAgIG9mZnNldCArPSBpZDNEYXRhLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIG5vdGhpbmcgZm91bmQsIGtlZXAgbG9va2luZ1xuICAgICAgICAgICAgICAgIG9mZnNldCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVtdXhlci5yZW11eCh0cmFjaywgeyBzYW1wbGVzOiBbXSB9LCB7IHNhbXBsZXM6IGlkM1NhbXBsZXMsIGlucHV0VGltZVNjYWxlOiA5MDAwMCB9LCB7IHNhbXBsZXM6IFtdIH0sIHRpbWVPZmZzZXQsIGNvbnRpZ3VvdXMsIGFjY3VyYXRlVGltZU9mZnNldCk7XG4gICAgfTtcbiAgICBBQUNEZW11eGVyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgIH07XG4gICAgcmV0dXJuIEFBQ0RlbXV4ZXI7XG59KCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gQUFDRGVtdXhlcjtcblxuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovfS5jYWxsKHRoaXMsIF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vc3JjL3BvbHlmaWxscy9udW1iZXIgKi8gXCIuL3NyYy9wb2x5ZmlsbHMvbnVtYmVyLmpzXCIpW1wiTnVtYmVyXCJdKSlcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvZGVtdXgvYWR0cy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2RlbXV4L2FkdHMuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiAgQURUUyBwYXJzZXIgaGVscGVyXG4gKi9cbnZhciBsb2dnZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL2xvZ2dlciAqLyBcIi4vc3JjL3V0aWxzL2xvZ2dlci5qc1wiKTtcbnZhciBlcnJvcnNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2Vycm9ycyAqLyBcIi4vc3JjL2Vycm9ycy5qc1wiKTtcbnZhciBldmVudHNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2V2ZW50cyAqLyBcIi4vc3JjL2V2ZW50cy5qc1wiKTtcbmZ1bmN0aW9uIGdldEF1ZGlvQ29uZmlnKG9ic2VydmVyLCBkYXRhLCBvZmZzZXQsIGF1ZGlvQ29kZWMpIHtcbiAgICB2YXIgYWR0c09iamVjdFR5cGUsIC8vIDppbnRcbiAgICBhZHRzU2FtcGxlaW5nSW5kZXgsIC8vIDppbnRcbiAgICBhZHRzRXh0ZW5zaW9uU2FtcGxlaW5nSW5kZXgsIC8vIDppbnRcbiAgICBhZHRzQ2hhbmVsQ29uZmlnLCAvLyA6aW50XG4gICAgY29uZmlnLCB1c2VyQWdlbnQgPSBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCksIG1hbmlmZXN0Q29kZWMgPSBhdWRpb0NvZGVjLCBhZHRzU2FtcGxlaW5nUmF0ZXMgPSBbXG4gICAgICAgIDk2MDAwLCA4ODIwMCxcbiAgICAgICAgNjQwMDAsIDQ4MDAwLFxuICAgICAgICA0NDEwMCwgMzIwMDAsXG4gICAgICAgIDI0MDAwLCAyMjA1MCxcbiAgICAgICAgMTYwMDAsIDEyMDAwLFxuICAgICAgICAxMTAyNSwgODAwMCxcbiAgICAgICAgNzM1MFxuICAgIF07XG4gICAgLy8gYnl0ZSAyXG4gICAgYWR0c09iamVjdFR5cGUgPSAoKGRhdGFbb2Zmc2V0ICsgMl0gJiAweEMwKSA+Pj4gNikgKyAxO1xuICAgIGFkdHNTYW1wbGVpbmdJbmRleCA9ICgoZGF0YVtvZmZzZXQgKyAyXSAmIDB4M0MpID4+PiAyKTtcbiAgICBpZiAoYWR0c1NhbXBsZWluZ0luZGV4ID4gYWR0c1NhbXBsZWluZ1JhdGVzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgb2JzZXJ2ZXIudHJpZ2dlcihldmVudHNfMS5kZWZhdWx0LkVSUk9SLCB7IHR5cGU6IGVycm9yc18xLkVycm9yVHlwZXMuTUVESUFfRVJST1IsIGRldGFpbHM6IGVycm9yc18xLkVycm9yRGV0YWlscy5GUkFHX1BBUlNJTkdfRVJST1IsIGZhdGFsOiB0cnVlLCByZWFzb246IFwiaW52YWxpZCBBRFRTIHNhbXBsaW5nIGluZGV4OlwiICsgYWR0c1NhbXBsZWluZ0luZGV4IH0pO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGFkdHNDaGFuZWxDb25maWcgPSAoKGRhdGFbb2Zmc2V0ICsgMl0gJiAweDAxKSA8PCAyKTtcbiAgICAvLyBieXRlIDNcbiAgICBhZHRzQ2hhbmVsQ29uZmlnIHw9ICgoZGF0YVtvZmZzZXQgKyAzXSAmIDB4QzApID4+PiA2KTtcbiAgICBsb2dnZXJfMS5sb2dnZXIubG9nKFwibWFuaWZlc3QgY29kZWM6XCIgKyBhdWRpb0NvZGVjICsgXCIsQURUUyBkYXRhOnR5cGU6XCIgKyBhZHRzT2JqZWN0VHlwZSArIFwiLHNhbXBsZWluZ0luZGV4OlwiICsgYWR0c1NhbXBsZWluZ0luZGV4ICsgXCJbXCIgKyBhZHRzU2FtcGxlaW5nUmF0ZXNbYWR0c1NhbXBsZWluZ0luZGV4XSArIFwiSHpdLGNoYW5uZWxDb25maWc6XCIgKyBhZHRzQ2hhbmVsQ29uZmlnKTtcbiAgICAvLyBmaXJlZm94OiBmcmVxIGxlc3MgdGhhbiAyNGtIeiA9IEFBQyBTQlIgKEhFLUFBQylcbiAgICBpZiAoL2ZpcmVmb3gvaS50ZXN0KHVzZXJBZ2VudCkpIHtcbiAgICAgICAgaWYgKGFkdHNTYW1wbGVpbmdJbmRleCA+PSA2KSB7XG4gICAgICAgICAgICBhZHRzT2JqZWN0VHlwZSA9IDU7XG4gICAgICAgICAgICBjb25maWcgPSBuZXcgQXJyYXkoNCk7XG4gICAgICAgICAgICAvLyBIRS1BQUMgdXNlcyBTQlIgKFNwZWN0cmFsIEJhbmQgUmVwbGljYXRpb24pICwgaGlnaCBmcmVxdWVuY2llcyBhcmUgY29uc3RydWN0ZWQgZnJvbSBsb3cgZnJlcXVlbmNpZXNcbiAgICAgICAgICAgIC8vIHRoZXJlIGlzIGEgZmFjdG9yIDIgYmV0d2VlbiBmcmFtZSBzYW1wbGUgcmF0ZSBhbmQgb3V0cHV0IHNhbXBsZSByYXRlXG4gICAgICAgICAgICAvLyBtdWx0aXBseSBmcmVxdWVuY3kgYnkgMiAoc2VlIHRhYmxlIGJlbG93LCBlcXVpdmFsZW50IHRvIHN1YnN0cmFjdCAzKVxuICAgICAgICAgICAgYWR0c0V4dGVuc2lvblNhbXBsZWluZ0luZGV4ID0gYWR0c1NhbXBsZWluZ0luZGV4IC0gMztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGFkdHNPYmplY3RUeXBlID0gMjtcbiAgICAgICAgICAgIGNvbmZpZyA9IG5ldyBBcnJheSgyKTtcbiAgICAgICAgICAgIGFkdHNFeHRlbnNpb25TYW1wbGVpbmdJbmRleCA9IGFkdHNTYW1wbGVpbmdJbmRleDtcbiAgICAgICAgfVxuICAgICAgICAvLyBBbmRyb2lkIDogYWx3YXlzIHVzZSBBQUNcbiAgICB9XG4gICAgZWxzZSBpZiAodXNlckFnZW50LmluZGV4T2YoJ2FuZHJvaWQnKSAhPT0gLTEpIHtcbiAgICAgICAgYWR0c09iamVjdFR5cGUgPSAyO1xuICAgICAgICBjb25maWcgPSBuZXcgQXJyYXkoMik7XG4gICAgICAgIGFkdHNFeHRlbnNpb25TYW1wbGVpbmdJbmRleCA9IGFkdHNTYW1wbGVpbmdJbmRleDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8qICBmb3Igb3RoZXIgYnJvd3NlcnMgKENocm9tZS9WaXZhbGRpL09wZXJhIC4uLilcbiAgICAgICAgICAgIGFsd2F5cyBmb3JjZSBhdWRpbyB0eXBlIHRvIGJlIEhFLUFBQyBTQlIsIGFzIHNvbWUgYnJvd3NlcnMgZG8gbm90IHN1cHBvcnQgYXVkaW8gY29kZWMgc3dpdGNoIHByb3Blcmx5IChsaWtlIENocm9tZSAuLi4pXG4gICAgICAgICovXG4gICAgICAgIGFkdHNPYmplY3RUeXBlID0gNTtcbiAgICAgICAgY29uZmlnID0gbmV3IEFycmF5KDQpO1xuICAgICAgICAvLyBpZiAobWFuaWZlc3QgY29kZWMgaXMgSEUtQUFDIG9yIEhFLUFBQ3YyKSBPUiAobWFuaWZlc3QgY29kZWMgbm90IHNwZWNpZmllZCBBTkQgZnJlcXVlbmN5IGxlc3MgdGhhbiAyNGtIeilcbiAgICAgICAgaWYgKChhdWRpb0NvZGVjICYmICgoYXVkaW9Db2RlYy5pbmRleE9mKCdtcDRhLjQwLjI5JykgIT09IC0xKSB8fFxuICAgICAgICAgICAgKGF1ZGlvQ29kZWMuaW5kZXhPZignbXA0YS40MC41JykgIT09IC0xKSkpIHx8XG4gICAgICAgICAgICAoIWF1ZGlvQ29kZWMgJiYgYWR0c1NhbXBsZWluZ0luZGV4ID49IDYpKSB7XG4gICAgICAgICAgICAvLyBIRS1BQUMgdXNlcyBTQlIgKFNwZWN0cmFsIEJhbmQgUmVwbGljYXRpb24pICwgaGlnaCBmcmVxdWVuY2llcyBhcmUgY29uc3RydWN0ZWQgZnJvbSBsb3cgZnJlcXVlbmNpZXNcbiAgICAgICAgICAgIC8vIHRoZXJlIGlzIGEgZmFjdG9yIDIgYmV0d2VlbiBmcmFtZSBzYW1wbGUgcmF0ZSBhbmQgb3V0cHV0IHNhbXBsZSByYXRlXG4gICAgICAgICAgICAvLyBtdWx0aXBseSBmcmVxdWVuY3kgYnkgMiAoc2VlIHRhYmxlIGJlbG93LCBlcXVpdmFsZW50IHRvIHN1YnN0cmFjdCAzKVxuICAgICAgICAgICAgYWR0c0V4dGVuc2lvblNhbXBsZWluZ0luZGV4ID0gYWR0c1NhbXBsZWluZ0luZGV4IC0gMztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGlmIChtYW5pZmVzdCBjb2RlYyBpcyBBQUMpIEFORCAoZnJlcXVlbmN5IGxlc3MgdGhhbiAyNGtIeiBBTkQgbmIgY2hhbm5lbCBpcyAxKSBPUiAobWFuaWZlc3QgY29kZWMgbm90IHNwZWNpZmllZCBhbmQgbW9ubyBhdWRpbylcbiAgICAgICAgICAgIC8vIENocm9tZSBmYWlscyB0byBwbGF5IGJhY2sgd2l0aCBsb3cgZnJlcXVlbmN5IEFBQyBMQyBtb25vIHdoZW4gaW5pdGlhbGl6ZWQgd2l0aCBIRS1BQUMuICBUaGlzIGlzIG5vdCBhIHByb2JsZW0gd2l0aCBzdGVyZW8uXG4gICAgICAgICAgICBpZiAoYXVkaW9Db2RlYyAmJiBhdWRpb0NvZGVjLmluZGV4T2YoJ21wNGEuNDAuMicpICE9PSAtMSAmJiAoKGFkdHNTYW1wbGVpbmdJbmRleCA+PSA2ICYmIGFkdHNDaGFuZWxDb25maWcgPT09IDEpIHx8XG4gICAgICAgICAgICAgICAgL3ZpdmFsZGkvaS50ZXN0KHVzZXJBZ2VudCkpIHx8XG4gICAgICAgICAgICAgICAgKCFhdWRpb0NvZGVjICYmIGFkdHNDaGFuZWxDb25maWcgPT09IDEpKSB7XG4gICAgICAgICAgICAgICAgYWR0c09iamVjdFR5cGUgPSAyO1xuICAgICAgICAgICAgICAgIGNvbmZpZyA9IG5ldyBBcnJheSgyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFkdHNFeHRlbnNpb25TYW1wbGVpbmdJbmRleCA9IGFkdHNTYW1wbGVpbmdJbmRleDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiByZWZlciB0byBodHRwOi8vd2lraS5tdWx0aW1lZGlhLmN4L2luZGV4LnBocD90aXRsZT1NUEVHLTRfQXVkaW8jQXVkaW9fU3BlY2lmaWNfQ29uZmlnXG4gICAgICAgIElTTyAxNDQ5Ni0zIChBQUMpLnBkZiAtIFRhYmxlIDEuMTMg4oCUIFN5bnRheCBvZiBBdWRpb1NwZWNpZmljQ29uZmlnKClcbiAgICAgIEF1ZGlvIFByb2ZpbGUgLyBBdWRpbyBPYmplY3QgVHlwZVxuICAgICAgMDogTnVsbFxuICAgICAgMTogQUFDIE1haW5cbiAgICAgIDI6IEFBQyBMQyAoTG93IENvbXBsZXhpdHkpXG4gICAgICAzOiBBQUMgU1NSIChTY2FsYWJsZSBTYW1wbGUgUmF0ZSlcbiAgICAgIDQ6IEFBQyBMVFAgKExvbmcgVGVybSBQcmVkaWN0aW9uKVxuICAgICAgNTogU0JSIChTcGVjdHJhbCBCYW5kIFJlcGxpY2F0aW9uKVxuICAgICAgNjogQUFDIFNjYWxhYmxlXG4gICAgIHNhbXBsaW5nIGZyZXFcbiAgICAgIDA6IDk2MDAwIEh6XG4gICAgICAxOiA4ODIwMCBIelxuICAgICAgMjogNjQwMDAgSHpcbiAgICAgIDM6IDQ4MDAwIEh6XG4gICAgICA0OiA0NDEwMCBIelxuICAgICAgNTogMzIwMDAgSHpcbiAgICAgIDY6IDI0MDAwIEh6XG4gICAgICA3OiAyMjA1MCBIelxuICAgICAgODogMTYwMDAgSHpcbiAgICAgIDk6IDEyMDAwIEh6XG4gICAgICAxMDogMTEwMjUgSHpcbiAgICAgIDExOiA4MDAwIEh6XG4gICAgICAxMjogNzM1MCBIelxuICAgICAgMTM6IFJlc2VydmVkXG4gICAgICAxNDogUmVzZXJ2ZWRcbiAgICAgIDE1OiBmcmVxdWVuY3kgaXMgd3JpdHRlbiBleHBsaWN0bHlcbiAgICAgIENoYW5uZWwgQ29uZmlndXJhdGlvbnNcbiAgICAgIFRoZXNlIGFyZSB0aGUgY2hhbm5lbCBjb25maWd1cmF0aW9uczpcbiAgICAgIDA6IERlZmluZWQgaW4gQU9UIFNwZWNpZmMgQ29uZmlnXG4gICAgICAxOiAxIGNoYW5uZWw6IGZyb250LWNlbnRlclxuICAgICAgMjogMiBjaGFubmVsczogZnJvbnQtbGVmdCwgZnJvbnQtcmlnaHRcbiAgICAqL1xuICAgIC8vIGF1ZGlvT2JqZWN0VHlwZSA9IHByb2ZpbGUgPT4gcHJvZmlsZSwgdGhlIE1QRUctNCBBdWRpbyBPYmplY3QgVHlwZSBtaW51cyAxXG4gICAgY29uZmlnWzBdID0gYWR0c09iamVjdFR5cGUgPDwgMztcbiAgICAvLyBzYW1wbGluZ0ZyZXF1ZW5jeUluZGV4XG4gICAgY29uZmlnWzBdIHw9IChhZHRzU2FtcGxlaW5nSW5kZXggJiAweDBFKSA+PiAxO1xuICAgIGNvbmZpZ1sxXSB8PSAoYWR0c1NhbXBsZWluZ0luZGV4ICYgMHgwMSkgPDwgNztcbiAgICAvLyBjaGFubmVsQ29uZmlndXJhdGlvblxuICAgIGNvbmZpZ1sxXSB8PSBhZHRzQ2hhbmVsQ29uZmlnIDw8IDM7XG4gICAgaWYgKGFkdHNPYmplY3RUeXBlID09PSA1KSB7XG4gICAgICAgIC8vIGFkdHNFeHRlbnNpb25TYW1wbGVpbmdJbmRleFxuICAgICAgICBjb25maWdbMV0gfD0gKGFkdHNFeHRlbnNpb25TYW1wbGVpbmdJbmRleCAmIDB4MEUpID4+IDE7XG4gICAgICAgIGNvbmZpZ1syXSA9IChhZHRzRXh0ZW5zaW9uU2FtcGxlaW5nSW5kZXggJiAweDAxKSA8PCA3O1xuICAgICAgICAvLyBhZHRzT2JqZWN0VHlwZSAoZm9yY2UgdG8gMiwgY2hyb21lIGlzIGNoZWNraW5nIHRoYXQgb2JqZWN0IHR5cGUgaXMgbGVzcyB0aGFuIDUgPz8/XG4gICAgICAgIC8vICAgIGh0dHBzOi8vY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMuZ2l0LysvbWFzdGVyL21lZGlhL2Zvcm1hdHMvbXA0L2FhYy5jY1xuICAgICAgICBjb25maWdbMl0gfD0gMiA8PCAyO1xuICAgICAgICBjb25maWdbM10gPSAwO1xuICAgIH1cbiAgICByZXR1cm4geyBjb25maWc6IGNvbmZpZywgc2FtcGxlcmF0ZTogYWR0c1NhbXBsZWluZ1JhdGVzW2FkdHNTYW1wbGVpbmdJbmRleF0sIGNoYW5uZWxDb3VudDogYWR0c0NoYW5lbENvbmZpZywgY29kZWM6ICgnbXA0YS40MC4nICsgYWR0c09iamVjdFR5cGUpLCBtYW5pZmVzdENvZGVjOiBtYW5pZmVzdENvZGVjIH07XG59XG5leHBvcnRzLmdldEF1ZGlvQ29uZmlnID0gZ2V0QXVkaW9Db25maWc7XG5mdW5jdGlvbiBpc0hlYWRlclBhdHRlcm4oZGF0YSwgb2Zmc2V0KSB7XG4gICAgcmV0dXJuIGRhdGFbb2Zmc2V0XSA9PT0gMHhmZiAmJiAoZGF0YVtvZmZzZXQgKyAxXSAmIDB4ZjYpID09PSAweGYwO1xufVxuZXhwb3J0cy5pc0hlYWRlclBhdHRlcm4gPSBpc0hlYWRlclBhdHRlcm47XG5mdW5jdGlvbiBnZXRIZWFkZXJMZW5ndGgoZGF0YSwgb2Zmc2V0KSB7XG4gICAgcmV0dXJuIChkYXRhW29mZnNldCArIDFdICYgMHgwMSA/IDcgOiA5KTtcbn1cbmV4cG9ydHMuZ2V0SGVhZGVyTGVuZ3RoID0gZ2V0SGVhZGVyTGVuZ3RoO1xuZnVuY3Rpb24gZ2V0RnVsbEZyYW1lTGVuZ3RoKGRhdGEsIG9mZnNldCkge1xuICAgIHJldHVybiAoKGRhdGFbb2Zmc2V0ICsgM10gJiAweDAzKSA8PCAxMSkgfFxuICAgICAgICAoZGF0YVtvZmZzZXQgKyA0XSA8PCAzKSB8XG4gICAgICAgICgoZGF0YVtvZmZzZXQgKyA1XSAmIDB4RTApID4+PiA1KTtcbn1cbmV4cG9ydHMuZ2V0RnVsbEZyYW1lTGVuZ3RoID0gZ2V0RnVsbEZyYW1lTGVuZ3RoO1xuZnVuY3Rpb24gaXNIZWFkZXIoZGF0YSwgb2Zmc2V0KSB7XG4gICAgLy8gTG9vayBmb3IgQURUUyBoZWFkZXIgfCAxMTExIDExMTEgfCAxMTExIFgwMFggfCB3aGVyZSBYIGNhbiBiZSBlaXRoZXIgMCBvciAxXG4gICAgLy8gTGF5ZXIgYml0cyAocG9zaXRpb24gMTQgYW5kIDE1KSBpbiBoZWFkZXIgc2hvdWxkIGJlIGFsd2F5cyAwIGZvciBBRFRTXG4gICAgLy8gTW9yZSBpbmZvIGh0dHBzOi8vd2lraS5tdWx0aW1lZGlhLmN4L2luZGV4LnBocD90aXRsZT1BRFRTXG4gICAgaWYgKG9mZnNldCArIDEgPCBkYXRhLmxlbmd0aCAmJiBpc0hlYWRlclBhdHRlcm4oZGF0YSwgb2Zmc2V0KSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZXhwb3J0cy5pc0hlYWRlciA9IGlzSGVhZGVyO1xuZnVuY3Rpb24gcHJvYmUoZGF0YSwgb2Zmc2V0KSB7XG4gICAgLy8gc2FtZSBhcyBpc0hlYWRlciBidXQgd2UgYWxzbyBjaGVjayB0aGF0IEFEVFMgZnJhbWUgZm9sbG93cyBsYXN0IEFEVFMgZnJhbWVcbiAgICAvLyBvciBlbmQgb2YgZGF0YSBpcyByZWFjaGVkXG4gICAgaWYgKG9mZnNldCArIDEgPCBkYXRhLmxlbmd0aCAmJiBpc0hlYWRlclBhdHRlcm4oZGF0YSwgb2Zmc2V0KSkge1xuICAgICAgICAvLyBBRFRTIGhlYWRlciBMZW5ndGhcbiAgICAgICAgdmFyIGhlYWRlckxlbmd0aCA9IGdldEhlYWRlckxlbmd0aChkYXRhLCBvZmZzZXQpO1xuICAgICAgICAvLyBBRFRTIGZyYW1lIExlbmd0aFxuICAgICAgICB2YXIgZnJhbWVMZW5ndGggPSBoZWFkZXJMZW5ndGg7XG4gICAgICAgIGlmIChvZmZzZXQgKyA1IDwgZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGZyYW1lTGVuZ3RoID0gZ2V0RnVsbEZyYW1lTGVuZ3RoKGRhdGEsIG9mZnNldCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5ld09mZnNldCA9IG9mZnNldCArIGZyYW1lTGVuZ3RoO1xuICAgICAgICBpZiAobmV3T2Zmc2V0ID09PSBkYXRhLmxlbmd0aCB8fCAobmV3T2Zmc2V0ICsgMSA8IGRhdGEubGVuZ3RoICYmIGlzSGVhZGVyUGF0dGVybihkYXRhLCBuZXdPZmZzZXQpKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZXhwb3J0cy5wcm9iZSA9IHByb2JlO1xuZnVuY3Rpb24gaW5pdFRyYWNrQ29uZmlnKHRyYWNrLCBvYnNlcnZlciwgZGF0YSwgb2Zmc2V0LCBhdWRpb0NvZGVjKSB7XG4gICAgaWYgKCF0cmFjay5zYW1wbGVyYXRlKSB7XG4gICAgICAgIHZhciBjb25maWcgPSBnZXRBdWRpb0NvbmZpZyhvYnNlcnZlciwgZGF0YSwgb2Zmc2V0LCBhdWRpb0NvZGVjKTtcbiAgICAgICAgdHJhY2suY29uZmlnID0gY29uZmlnLmNvbmZpZztcbiAgICAgICAgdHJhY2suc2FtcGxlcmF0ZSA9IGNvbmZpZy5zYW1wbGVyYXRlO1xuICAgICAgICB0cmFjay5jaGFubmVsQ291bnQgPSBjb25maWcuY2hhbm5lbENvdW50O1xuICAgICAgICB0cmFjay5jb2RlYyA9IGNvbmZpZy5jb2RlYztcbiAgICAgICAgdHJhY2subWFuaWZlc3RDb2RlYyA9IGNvbmZpZy5tYW5pZmVzdENvZGVjO1xuICAgICAgICBsb2dnZXJfMS5sb2dnZXIubG9nKFwicGFyc2VkIGNvZGVjOlwiICsgdHJhY2suY29kZWMgKyBcIixyYXRlOlwiICsgY29uZmlnLnNhbXBsZXJhdGUgKyBcIixuYiBjaGFubmVsOlwiICsgY29uZmlnLmNoYW5uZWxDb3VudCk7XG4gICAgfVxufVxuZXhwb3J0cy5pbml0VHJhY2tDb25maWcgPSBpbml0VHJhY2tDb25maWc7XG5mdW5jdGlvbiBnZXRGcmFtZUR1cmF0aW9uKHNhbXBsZXJhdGUpIHtcbiAgICByZXR1cm4gMTAyNCAqIDkwMDAwIC8gc2FtcGxlcmF0ZTtcbn1cbmV4cG9ydHMuZ2V0RnJhbWVEdXJhdGlvbiA9IGdldEZyYW1lRHVyYXRpb247XG5mdW5jdGlvbiBwYXJzZUZyYW1lSGVhZGVyKGRhdGEsIG9mZnNldCwgcHRzLCBmcmFtZUluZGV4LCBmcmFtZUR1cmF0aW9uKSB7XG4gICAgdmFyIGhlYWRlckxlbmd0aCwgZnJhbWVMZW5ndGgsIHN0YW1wO1xuICAgIHZhciBsZW5ndGggPSBkYXRhLmxlbmd0aDtcbiAgICAvLyBUaGUgcHJvdGVjdGlvbiBza2lwIGJpdCB0ZWxscyB1cyBpZiB3ZSBoYXZlIDIgYnl0ZXMgb2YgQ1JDIGRhdGEgYXQgdGhlIGVuZCBvZiB0aGUgQURUUyBoZWFkZXJcbiAgICBoZWFkZXJMZW5ndGggPSBnZXRIZWFkZXJMZW5ndGgoZGF0YSwgb2Zmc2V0KTtcbiAgICAvLyByZXRyaWV2ZSBmcmFtZSBzaXplXG4gICAgZnJhbWVMZW5ndGggPSBnZXRGdWxsRnJhbWVMZW5ndGgoZGF0YSwgb2Zmc2V0KTtcbiAgICBmcmFtZUxlbmd0aCAtPSBoZWFkZXJMZW5ndGg7XG4gICAgaWYgKChmcmFtZUxlbmd0aCA+IDApICYmICgob2Zmc2V0ICsgaGVhZGVyTGVuZ3RoICsgZnJhbWVMZW5ndGgpIDw9IGxlbmd0aCkpIHtcbiAgICAgICAgc3RhbXAgPSBwdHMgKyBmcmFtZUluZGV4ICogZnJhbWVEdXJhdGlvbjtcbiAgICAgICAgLy8gbG9nZ2VyLmxvZyhgQUFDIGZyYW1lLCBvZmZzZXQvbGVuZ3RoL3RvdGFsL3B0czoke29mZnNldCtoZWFkZXJMZW5ndGh9LyR7ZnJhbWVMZW5ndGh9LyR7ZGF0YS5ieXRlTGVuZ3RofS8keyhzdGFtcC85MCkudG9GaXhlZCgwKX1gKTtcbiAgICAgICAgcmV0dXJuIHsgaGVhZGVyTGVuZ3RoOiBoZWFkZXJMZW5ndGgsIGZyYW1lTGVuZ3RoOiBmcmFtZUxlbmd0aCwgc3RhbXA6IHN0YW1wIH07XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG5leHBvcnRzLnBhcnNlRnJhbWVIZWFkZXIgPSBwYXJzZUZyYW1lSGVhZGVyO1xuZnVuY3Rpb24gYXBwZW5kRnJhbWUodHJhY2ssIGRhdGEsIG9mZnNldCwgcHRzLCBmcmFtZUluZGV4KSB7XG4gICAgdmFyIGZyYW1lRHVyYXRpb24gPSBnZXRGcmFtZUR1cmF0aW9uKHRyYWNrLnNhbXBsZXJhdGUpO1xuICAgIHZhciBoZWFkZXIgPSBwYXJzZUZyYW1lSGVhZGVyKGRhdGEsIG9mZnNldCwgcHRzLCBmcmFtZUluZGV4LCBmcmFtZUR1cmF0aW9uKTtcbiAgICBpZiAoaGVhZGVyKSB7XG4gICAgICAgIHZhciBzdGFtcCA9IGhlYWRlci5zdGFtcDtcbiAgICAgICAgdmFyIGhlYWRlckxlbmd0aCA9IGhlYWRlci5oZWFkZXJMZW5ndGg7XG4gICAgICAgIHZhciBmcmFtZUxlbmd0aCA9IGhlYWRlci5mcmFtZUxlbmd0aDtcbiAgICAgICAgLy8gbG9nZ2VyLmxvZyhgQUFDIGZyYW1lLCBvZmZzZXQvbGVuZ3RoL3RvdGFsL3B0czoke29mZnNldCtoZWFkZXJMZW5ndGh9LyR7ZnJhbWVMZW5ndGh9LyR7ZGF0YS5ieXRlTGVuZ3RofS8keyhzdGFtcC85MCkudG9GaXhlZCgwKX1gKTtcbiAgICAgICAgdmFyIGFhY1NhbXBsZSA9IHtcbiAgICAgICAgICAgIHVuaXQ6IGRhdGEuc3ViYXJyYXkob2Zmc2V0ICsgaGVhZGVyTGVuZ3RoLCBvZmZzZXQgKyBoZWFkZXJMZW5ndGggKyBmcmFtZUxlbmd0aCksXG4gICAgICAgICAgICBwdHM6IHN0YW1wLFxuICAgICAgICAgICAgZHRzOiBzdGFtcFxuICAgICAgICB9O1xuICAgICAgICB0cmFjay5zYW1wbGVzLnB1c2goYWFjU2FtcGxlKTtcbiAgICAgICAgdHJhY2subGVuICs9IGZyYW1lTGVuZ3RoO1xuICAgICAgICByZXR1cm4geyBzYW1wbGU6IGFhY1NhbXBsZSwgbGVuZ3RoOiBmcmFtZUxlbmd0aCArIGhlYWRlckxlbmd0aCB9O1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuZXhwb3J0cy5hcHBlbmRGcmFtZSA9IGFwcGVuZEZyYW1lO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2RlbXV4L2RlbXV4ZXItaW5saW5lLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2RlbXV4L2RlbXV4ZXItaW5saW5lLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKipcbiAqXG4gKiBpbmxpbmUgZGVtdXhlcjogcHJvYmUgZnJhZ21lbnRzIGFuZCBpbnN0YW50aWF0ZVxuICogYXBwcm9wcmlhdGUgZGVtdXhlciBkZXBlbmRpbmcgb24gY29udGVudCB0eXBlIChUU0RlbXV4ZXIsIEFBQ0RlbXV4ZXIsIC4uLilcbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBldmVudHNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2V2ZW50cyAqLyBcIi4vc3JjL2V2ZW50cy5qc1wiKTtcbnZhciBlcnJvcnNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2Vycm9ycyAqLyBcIi4vc3JjL2Vycm9ycy5qc1wiKTtcbnZhciBkZWNyeXB0ZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2NyeXB0L2RlY3J5cHRlciAqLyBcIi4vc3JjL2NyeXB0L2RlY3J5cHRlci5qc1wiKTtcbnZhciBhYWNkZW11eGVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9kZW11eC9hYWNkZW11eGVyICovIFwiLi9zcmMvZGVtdXgvYWFjZGVtdXhlci5qc1wiKTtcbnZhciBtcDRkZW11eGVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9kZW11eC9tcDRkZW11eGVyICovIFwiLi9zcmMvZGVtdXgvbXA0ZGVtdXhlci5qc1wiKTtcbnZhciB0c2RlbXV4ZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2RlbXV4L3RzZGVtdXhlciAqLyBcIi4vc3JjL2RlbXV4L3RzZGVtdXhlci5qc1wiKTtcbnZhciBtcDNkZW11eGVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9kZW11eC9tcDNkZW11eGVyICovIFwiLi9zcmMvZGVtdXgvbXAzZGVtdXhlci5qc1wiKTtcbnZhciBtcDRfcmVtdXhlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vcmVtdXgvbXA0LXJlbXV4ZXIgKi8gXCIuL3NyYy9yZW11eC9tcDQtcmVtdXhlci5qc1wiKTtcbnZhciBwYXNzdGhyb3VnaF9yZW11eGVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9yZW11eC9wYXNzdGhyb3VnaC1yZW11eGVyICovIFwiLi9zcmMvcmVtdXgvcGFzc3Rocm91Z2gtcmVtdXhlci5qc1wiKTtcbnZhciBnZXRfc2VsZl9zY29wZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvZ2V0LXNlbGYtc2NvcGUgKi8gXCIuL3NyYy91dGlscy9nZXQtc2VsZi1zY29wZS5qc1wiKTtcbnZhciBsb2dnZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL2xvZ2dlciAqLyBcIi4vc3JjL3V0aWxzL2xvZ2dlci5qc1wiKTtcbi8vIHNlZSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTEyMzcyNTkvNTg5NDkzXG52YXIgZ2xvYmFsID0gZ2V0X3NlbGZfc2NvcGVfMS5nZXRTZWxmU2NvcGUoKTsgLy8gc2FmZWd1YXJkIGZvciBjb2RlIHRoYXQgbWlnaHQgcnVuIGJvdGggb24gd29ya2VyIGFuZCBtYWluIHRocmVhZFxudmFyIG5vdztcbi8vIHBlcmZvcm1hbmNlLm5vdygpIG5vdCBhdmFpbGFibGUgb24gV2ViV29ya2VyLCBhdCBsZWFzdCBvbiBTYWZhcmkgRGVza3RvcFxudHJ5IHtcbiAgICBub3cgPSBnbG9iYWwucGVyZm9ybWFuY2Uubm93LmJpbmQoZ2xvYmFsLnBlcmZvcm1hbmNlKTtcbn1cbmNhdGNoIChlcnIpIHtcbiAgICBsb2dnZXJfMS5sb2dnZXIuZGVidWcoJ1VuYWJsZSB0byB1c2UgUGVyZm9ybWFuY2UgQVBJIG9uIHRoaXMgZW52aXJvbm1lbnQnKTtcbiAgICBub3cgPSBnbG9iYWwuRGF0ZS5ub3c7XG59XG52YXIgRGVtdXhlcklubGluZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEZW11eGVySW5saW5lKG9ic2VydmVyLCB0eXBlU3VwcG9ydGVkLCBjb25maWcsIHZlbmRvcikge1xuICAgICAgICB0aGlzLm9ic2VydmVyID0gb2JzZXJ2ZXI7XG4gICAgICAgIHRoaXMudHlwZVN1cHBvcnRlZCA9IHR5cGVTdXBwb3J0ZWQ7XG4gICAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgICAgICB0aGlzLnZlbmRvciA9IHZlbmRvcjtcbiAgICB9XG4gICAgRGVtdXhlcklubGluZS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGRlbXV4ZXIgPSB0aGlzLmRlbXV4ZXI7XG4gICAgICAgIGlmIChkZW11eGVyKSB7XG4gICAgICAgICAgICBkZW11eGVyLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRGVtdXhlcklubGluZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChkYXRhLCBkZWNyeXB0ZGF0YSwgaW5pdFNlZ21lbnQsIGF1ZGlvQ29kZWMsIHZpZGVvQ29kZWMsIHRpbWVPZmZzZXQsIGRpc2NvbnRpbnVpdHksIHRyYWNrU3dpdGNoLCBjb250aWd1b3VzLCBkdXJhdGlvbiwgYWNjdXJhdGVUaW1lT2Zmc2V0LCBkZWZhdWx0SW5pdFBUUykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoKGRhdGEuYnl0ZUxlbmd0aCA+IDApICYmIChkZWNyeXB0ZGF0YSAhPSBudWxsKSAmJiAoZGVjcnlwdGRhdGEua2V5ICE9IG51bGwpICYmIChkZWNyeXB0ZGF0YS5tZXRob2QgPT09ICdBRVMtMTI4JykpIHtcbiAgICAgICAgICAgIHZhciBkZWNyeXB0ZXIgPSB0aGlzLmRlY3J5cHRlcjtcbiAgICAgICAgICAgIGlmIChkZWNyeXB0ZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGRlY3J5cHRlciA9IHRoaXMuZGVjcnlwdGVyID0gbmV3IGRlY3J5cHRlcl8xLmRlZmF1bHQodGhpcy5vYnNlcnZlciwgdGhpcy5jb25maWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHN0YXJ0VGltZV8xID0gbm93KCk7XG4gICAgICAgICAgICBkZWNyeXB0ZXIuZGVjcnlwdChkYXRhLCBkZWNyeXB0ZGF0YS5rZXkuYnVmZmVyLCBkZWNyeXB0ZGF0YS5pdi5idWZmZXIsIGZ1bmN0aW9uIChkZWNyeXB0ZWREYXRhKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVuZFRpbWUgPSBub3coKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5vYnNlcnZlci50cmlnZ2VyKGV2ZW50c18xLmRlZmF1bHQuRlJBR19ERUNSWVBURUQsIHsgc3RhdHM6IHsgdHN0YXJ0OiBzdGFydFRpbWVfMSwgdGRlY3J5cHQ6IGVuZFRpbWUgfSB9KTtcbiAgICAgICAgICAgICAgICBfdGhpcy5wdXNoRGVjcnlwdGVkKG5ldyBVaW50OEFycmF5KGRlY3J5cHRlZERhdGEpLCBkZWNyeXB0ZGF0YSwgbmV3IFVpbnQ4QXJyYXkoaW5pdFNlZ21lbnQpLCBhdWRpb0NvZGVjLCB2aWRlb0NvZGVjLCB0aW1lT2Zmc2V0LCBkaXNjb250aW51aXR5LCB0cmFja1N3aXRjaCwgY29udGlndW91cywgZHVyYXRpb24sIGFjY3VyYXRlVGltZU9mZnNldCwgZGVmYXVsdEluaXRQVFMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnB1c2hEZWNyeXB0ZWQobmV3IFVpbnQ4QXJyYXkoZGF0YSksIGRlY3J5cHRkYXRhLCBuZXcgVWludDhBcnJheShpbml0U2VnbWVudCksIGF1ZGlvQ29kZWMsIHZpZGVvQ29kZWMsIHRpbWVPZmZzZXQsIGRpc2NvbnRpbnVpdHksIHRyYWNrU3dpdGNoLCBjb250aWd1b3VzLCBkdXJhdGlvbiwgYWNjdXJhdGVUaW1lT2Zmc2V0LCBkZWZhdWx0SW5pdFBUUyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIERlbXV4ZXJJbmxpbmUucHJvdG90eXBlLnB1c2hEZWNyeXB0ZWQgPSBmdW5jdGlvbiAoZGF0YSwgZGVjcnlwdGRhdGEsIGluaXRTZWdtZW50LCBhdWRpb0NvZGVjLCB2aWRlb0NvZGVjLCB0aW1lT2Zmc2V0LCBkaXNjb250aW51aXR5LCB0cmFja1N3aXRjaCwgY29udGlndW91cywgZHVyYXRpb24sIGFjY3VyYXRlVGltZU9mZnNldCwgZGVmYXVsdEluaXRQVFMpIHtcbiAgICAgICAgdmFyIGRlbXV4ZXIgPSB0aGlzLmRlbXV4ZXI7XG4gICAgICAgIGlmICghZGVtdXhlciB8fFxuICAgICAgICAgICAgLy8gaW4gY2FzZSBvZiBjb250aW51aXR5IGNoYW5nZSwgb3IgdHJhY2sgc3dpdGNoXG4gICAgICAgICAgICAvLyB3ZSBtaWdodCBzd2l0Y2ggZnJvbSBjb250ZW50IHR5cGUgKEFBQyBjb250YWluZXIgdG8gVFMgY29udGFpbmVyLCBvciBUUyB0byBmbXA0IGZvciBleGFtcGxlKVxuICAgICAgICAgICAgLy8gc28gbGV0J3MgY2hlY2sgdGhhdCBjdXJyZW50IGRlbXV4ZXIgaXMgc3RpbGwgdmFsaWRcbiAgICAgICAgICAgICgoZGlzY29udGludWl0eSB8fCB0cmFja1N3aXRjaCkgJiYgIXRoaXMucHJvYmUoZGF0YSkpKSB7XG4gICAgICAgICAgICB2YXIgb2JzZXJ2ZXIgPSB0aGlzLm9ic2VydmVyO1xuICAgICAgICAgICAgdmFyIHR5cGVTdXBwb3J0ZWQgPSB0aGlzLnR5cGVTdXBwb3J0ZWQ7XG4gICAgICAgICAgICB2YXIgY29uZmlnID0gdGhpcy5jb25maWc7XG4gICAgICAgICAgICAvLyBwcm9iaW5nIG9yZGVyIGlzIFRTL0FBQy9NUDMvTVA0XG4gICAgICAgICAgICB2YXIgbXV4Q29uZmlnID0gW1xuICAgICAgICAgICAgICAgIHsgZGVtdXg6IHRzZGVtdXhlcl8xLmRlZmF1bHQsIHJlbXV4OiBtcDRfcmVtdXhlcl8xLmRlZmF1bHQgfSxcbiAgICAgICAgICAgICAgICB7IGRlbXV4OiBtcDRkZW11eGVyXzEuZGVmYXVsdCwgcmVtdXg6IHBhc3N0aHJvdWdoX3JlbXV4ZXJfMS5kZWZhdWx0IH0sXG4gICAgICAgICAgICAgICAgeyBkZW11eDogYWFjZGVtdXhlcl8xLmRlZmF1bHQsIHJlbXV4OiBtcDRfcmVtdXhlcl8xLmRlZmF1bHQgfSxcbiAgICAgICAgICAgICAgICB7IGRlbXV4OiBtcDNkZW11eGVyXzEuZGVmYXVsdCwgcmVtdXg6IG1wNF9yZW11eGVyXzEuZGVmYXVsdCB9XG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgLy8gcHJvYmUgZm9yIGNvbnRlbnQgdHlwZVxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IG11eENvbmZpZy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBtdXggPSBtdXhDb25maWdbaV07XG4gICAgICAgICAgICAgICAgdmFyIHByb2JlID0gbXV4LmRlbXV4LnByb2JlO1xuICAgICAgICAgICAgICAgIGlmIChwcm9iZShkYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVtdXhlcl8xID0gdGhpcy5yZW11eGVyID0gbmV3IG11eC5yZW11eChvYnNlcnZlciwgY29uZmlnLCB0eXBlU3VwcG9ydGVkLCB0aGlzLnZlbmRvcik7XG4gICAgICAgICAgICAgICAgICAgIGRlbXV4ZXIgPSBuZXcgbXV4LmRlbXV4KG9ic2VydmVyLCByZW11eGVyXzEsIGNvbmZpZywgdHlwZVN1cHBvcnRlZCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHJvYmUgPSBwcm9iZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFkZW11eGVyKSB7XG4gICAgICAgICAgICAgICAgb2JzZXJ2ZXIudHJpZ2dlcihldmVudHNfMS5kZWZhdWx0LkVSUk9SLCB7IHR5cGU6IGVycm9yc18xLkVycm9yVHlwZXMuTUVESUFfRVJST1IsIGRldGFpbHM6IGVycm9yc18xLkVycm9yRGV0YWlscy5GUkFHX1BBUlNJTkdfRVJST1IsIGZhdGFsOiB0cnVlLCByZWFzb246ICdubyBkZW11eCBtYXRjaGluZyB3aXRoIGNvbnRlbnQgZm91bmQnIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZGVtdXhlciA9IGRlbXV4ZXI7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlbXV4ZXIgPSB0aGlzLnJlbXV4ZXI7XG4gICAgICAgIGlmIChkaXNjb250aW51aXR5IHx8IHRyYWNrU3dpdGNoKSB7XG4gICAgICAgICAgICBkZW11eGVyLnJlc2V0SW5pdFNlZ21lbnQoaW5pdFNlZ21lbnQsIGF1ZGlvQ29kZWMsIHZpZGVvQ29kZWMsIGR1cmF0aW9uKTtcbiAgICAgICAgICAgIHJlbXV4ZXIucmVzZXRJbml0U2VnbWVudCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkaXNjb250aW51aXR5KSB7XG4gICAgICAgICAgICBkZW11eGVyLnJlc2V0VGltZVN0YW1wKGRlZmF1bHRJbml0UFRTKTtcbiAgICAgICAgICAgIHJlbXV4ZXIucmVzZXRUaW1lU3RhbXAoZGVmYXVsdEluaXRQVFMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZGVtdXhlci5zZXREZWNyeXB0RGF0YSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgZGVtdXhlci5zZXREZWNyeXB0RGF0YShkZWNyeXB0ZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgZGVtdXhlci5hcHBlbmQoZGF0YSwgdGltZU9mZnNldCwgY29udGlndW91cywgYWNjdXJhdGVUaW1lT2Zmc2V0KTtcbiAgICB9O1xuICAgIHJldHVybiBEZW11eGVySW5saW5lO1xufSgpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IERlbXV4ZXJJbmxpbmU7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvZGVtdXgvZGVtdXhlci13b3JrZXIuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvZGVtdXgvZGVtdXhlci13b3JrZXIuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qISBNb2R1bGVDb25jYXRlbmF0aW9uIGJhaWxvdXQ6IE1vZHVsZSBpcyBub3QgYW4gRUNNQVNjcmlwdCBtb2R1bGUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIGRlbXV4ZXIgd2ViIHdvcmtlci5cbiAqICAtIGxpc3RlbiB0byB3b3JrZXIgbWVzc2FnZSwgYW5kIHRyaWdnZXIgRGVtdXhlcklubGluZSB1cG9uIHJlY2VwdGlvbiBvZiBGcmFnbWVudHMuXG4gKiAgLSBwcm92aWRlcyBNUDQgQm94ZXMgYmFjayB0byBtYWluIHRocmVhZCB1c2luZyBbdHJhbnNmZXJhYmxlIG9iamVjdHNdKGh0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL3dlYi91cGRhdGVzLzIwMTEvMTIvVHJhbnNmZXJhYmxlLU9iamVjdHMtTGlnaHRuaW5nLUZhc3QpIGluIG9yZGVyIHRvIG1pbmltaXplIG1lc3NhZ2UgcGFzc2luZyBvdmVyaGVhZC5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGRlbXV4ZXJfaW5saW5lXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9kZW11eC9kZW11eGVyLWlubGluZSAqLyBcIi4vc3JjL2RlbXV4L2RlbXV4ZXItaW5saW5lLmpzXCIpO1xudmFyIGV2ZW50c18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZXZlbnRzICovIFwiLi9zcmMvZXZlbnRzLmpzXCIpO1xudmFyIGxvZ2dlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvbG9nZ2VyICovIFwiLi9zcmMvdXRpbHMvbG9nZ2VyLmpzXCIpO1xudmFyIGV2ZW50c18yID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgZXZlbnRzICovIFwiLi9ub2RlX21vZHVsZXMvbm9kZS1saWJzLWJyb3dzZXIvbm9kZV9tb2R1bGVzL2V2ZW50cy9ldmVudHMuanNcIik7XG52YXIgRGVtdXhlcldvcmtlciA9IGZ1bmN0aW9uIChzZWxmKSB7XG4gICAgLy8gb2JzZXJ2ZXIgc2V0dXBcbiAgICB2YXIgb2JzZXJ2ZXIgPSBuZXcgZXZlbnRzXzIuRXZlbnRFbWl0dGVyKCk7XG4gICAgb2JzZXJ2ZXIudHJpZ2dlciA9IGZ1bmN0aW9uIHRyaWdnZXIoZXZlbnQpIHtcbiAgICAgICAgdmFyIGRhdGEgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGRhdGFbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgb2JzZXJ2ZXIuZW1pdC5hcHBseShvYnNlcnZlciwgW2V2ZW50LCBldmVudF0uY29uY2F0KGRhdGEpKTtcbiAgICB9O1xuICAgIG9ic2VydmVyLm9mZiA9IGZ1bmN0aW9uIG9mZihldmVudCkge1xuICAgICAgICB2YXIgZGF0YSA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgZGF0YVtfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICBvYnNlcnZlci5yZW1vdmVMaXN0ZW5lci5hcHBseShvYnNlcnZlciwgW2V2ZW50XS5jb25jYXQoZGF0YSkpO1xuICAgIH07XG4gICAgdmFyIGZvcndhcmRNZXNzYWdlID0gZnVuY3Rpb24gKGV2LCBkYXRhKSB7XG4gICAgICAgIHNlbGYucG9zdE1lc3NhZ2UoeyBldmVudDogZXYsIGRhdGE6IGRhdGEgfSk7XG4gICAgfTtcbiAgICBzZWxmLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgdmFyIGRhdGEgPSBldi5kYXRhO1xuICAgICAgICAvLyBjb25zb2xlLmxvZygnZGVtdXhlciBjbWQ6JyArIGRhdGEuY21kKTtcbiAgICAgICAgc3dpdGNoIChkYXRhLmNtZCkge1xuICAgICAgICAgICAgY2FzZSAnaW5pdCc6XG4gICAgICAgICAgICAgICAgdmFyIGNvbmZpZyA9IEpTT04ucGFyc2UoZGF0YS5jb25maWcpO1xuICAgICAgICAgICAgICAgIHNlbGYuZGVtdXhlciA9IG5ldyBkZW11eGVyX2lubGluZV8xLmRlZmF1bHQob2JzZXJ2ZXIsIGRhdGEudHlwZVN1cHBvcnRlZCwgY29uZmlnLCBkYXRhLnZlbmRvcik7XG4gICAgICAgICAgICAgICAgbG9nZ2VyXzEuZW5hYmxlTG9ncyhjb25maWcuZGVidWcpO1xuICAgICAgICAgICAgICAgIC8vIHNpZ25hbCBlbmQgb2Ygd29ya2VyIGluaXRcbiAgICAgICAgICAgICAgICBmb3J3YXJkTWVzc2FnZSgnaW5pdCcsIG51bGwpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnZGVtdXgnOlxuICAgICAgICAgICAgICAgIHNlbGYuZGVtdXhlci5wdXNoKGRhdGEuZGF0YSwgZGF0YS5kZWNyeXB0ZGF0YSwgZGF0YS5pbml0U2VnbWVudCwgZGF0YS5hdWRpb0NvZGVjLCBkYXRhLnZpZGVvQ29kZWMsIGRhdGEudGltZU9mZnNldCwgZGF0YS5kaXNjb250aW51aXR5LCBkYXRhLnRyYWNrU3dpdGNoLCBkYXRhLmNvbnRpZ3VvdXMsIGRhdGEuZHVyYXRpb24sIGRhdGEuYWNjdXJhdGVUaW1lT2Zmc2V0LCBkYXRhLmRlZmF1bHRJbml0UFRTKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICAvLyBmb3J3YXJkIGV2ZW50cyB0byBtYWluIHRocmVhZFxuICAgIG9ic2VydmVyLm9uKGV2ZW50c18xLmRlZmF1bHQuRlJBR19ERUNSWVBURUQsIGZvcndhcmRNZXNzYWdlKTtcbiAgICBvYnNlcnZlci5vbihldmVudHNfMS5kZWZhdWx0LkZSQUdfUEFSU0lOR19JTklUX1NFR01FTlQsIGZvcndhcmRNZXNzYWdlKTtcbiAgICBvYnNlcnZlci5vbihldmVudHNfMS5kZWZhdWx0LkZSQUdfUEFSU0VELCBmb3J3YXJkTWVzc2FnZSk7XG4gICAgb2JzZXJ2ZXIub24oZXZlbnRzXzEuZGVmYXVsdC5FUlJPUiwgZm9yd2FyZE1lc3NhZ2UpO1xuICAgIG9ic2VydmVyLm9uKGV2ZW50c18xLmRlZmF1bHQuRlJBR19QQVJTSU5HX01FVEFEQVRBLCBmb3J3YXJkTWVzc2FnZSk7XG4gICAgb2JzZXJ2ZXIub24oZXZlbnRzXzEuZGVmYXVsdC5GUkFHX1BBUlNJTkdfVVNFUkRBVEEsIGZvcndhcmRNZXNzYWdlKTtcbiAgICBvYnNlcnZlci5vbihldmVudHNfMS5kZWZhdWx0LklOSVRfUFRTX0ZPVU5ELCBmb3J3YXJkTWVzc2FnZSk7XG4gICAgLy8gc3BlY2lhbCBjYXNlIGZvciBGUkFHX1BBUlNJTkdfREFUQTogcGFzcyBkYXRhMS9kYXRhMiBhcyB0cmFuc2ZlcmFibGUgb2JqZWN0IChubyBjb3B5KVxuICAgIG9ic2VydmVyLm9uKGV2ZW50c18xLmRlZmF1bHQuRlJBR19QQVJTSU5HX0RBVEEsIGZ1bmN0aW9uIChldiwgZGF0YSkge1xuICAgICAgICB2YXIgdHJhbnNmZXJhYmxlID0gW107XG4gICAgICAgIHZhciBtZXNzYWdlID0geyBldmVudDogZXYsIGRhdGE6IGRhdGEgfTtcbiAgICAgICAgaWYgKGRhdGEuZGF0YTEpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UuZGF0YTEgPSBkYXRhLmRhdGExLmJ1ZmZlcjtcbiAgICAgICAgICAgIHRyYW5zZmVyYWJsZS5wdXNoKGRhdGEuZGF0YTEuYnVmZmVyKTtcbiAgICAgICAgICAgIGRlbGV0ZSBkYXRhLmRhdGExO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLmRhdGEyKSB7XG4gICAgICAgICAgICBtZXNzYWdlLmRhdGEyID0gZGF0YS5kYXRhMi5idWZmZXI7XG4gICAgICAgICAgICB0cmFuc2ZlcmFibGUucHVzaChkYXRhLmRhdGEyLmJ1ZmZlcik7XG4gICAgICAgICAgICBkZWxldGUgZGF0YS5kYXRhMjtcbiAgICAgICAgfVxuICAgICAgICBzZWxmLnBvc3RNZXNzYWdlKG1lc3NhZ2UsIHRyYW5zZmVyYWJsZSk7XG4gICAgfSk7XG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gRGVtdXhlcldvcmtlcjtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9kZW11eC9kZW11eGVyLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvZGVtdXgvZGVtdXhlci5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovKGZ1bmN0aW9uKE51bWJlcikge1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHdvcmsgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISB3ZWJ3b3JraWZ5LXdlYnBhY2sgKi8gXCIuL25vZGVfbW9kdWxlcy93ZWJ3b3JraWZ5LXdlYnBhY2svaW5kZXguanNcIik7XG52YXIgZXZlbnRzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9ldmVudHMgKi8gXCIuL3NyYy9ldmVudHMuanNcIik7XG52YXIgZGVtdXhlcl9pbmxpbmVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2RlbXV4L2RlbXV4ZXItaW5saW5lICovIFwiLi9zcmMvZGVtdXgvZGVtdXhlci1pbmxpbmUuanNcIik7XG52YXIgbG9nZ2VyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy9sb2dnZXIgKi8gXCIuL3NyYy91dGlscy9sb2dnZXIuanNcIik7XG52YXIgZXJyb3JzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9lcnJvcnMgKi8gXCIuL3NyYy9lcnJvcnMuanNcIik7XG52YXIgbWVkaWFzb3VyY2VfaGVscGVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy9tZWRpYXNvdXJjZS1oZWxwZXIgKi8gXCIuL3NyYy91dGlscy9tZWRpYXNvdXJjZS1oZWxwZXIuanNcIik7XG52YXIgZ2V0X3NlbGZfc2NvcGVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL2dldC1zZWxmLXNjb3BlICovIFwiLi9zcmMvdXRpbHMvZ2V0LXNlbGYtc2NvcGUuanNcIik7XG52YXIgb2JzZXJ2ZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL29ic2VydmVyICovIFwiLi9zcmMvb2JzZXJ2ZXIuanNcIik7XG4vLyBzZWUgaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzExMjM3MjU5LzU4OTQ5M1xudmFyIGdsb2JhbCA9IGdldF9zZWxmX3Njb3BlXzEuZ2V0U2VsZlNjb3BlKCk7IC8vIHNhZmVndWFyZCBmb3IgY29kZSB0aGF0IG1pZ2h0IHJ1biBib3RoIG9uIHdvcmtlciBhbmQgbWFpbiB0aHJlYWRcbnZhciBNZWRpYVNvdXJjZSA9IG1lZGlhc291cmNlX2hlbHBlcl8xLmdldE1lZGlhU291cmNlKCk7XG52YXIgRGVtdXhlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEZW11eGVyKGhscywgaWQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5obHMgPSBobHM7XG4gICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICAgICAgdmFyIG9ic2VydmVyID0gdGhpcy5vYnNlcnZlciA9IG5ldyBvYnNlcnZlcl8xLk9ic2VydmVyKCk7XG4gICAgICAgIHZhciBjb25maWcgPSBobHMuY29uZmlnO1xuICAgICAgICB2YXIgZm9yd2FyZE1lc3NhZ2UgPSBmdW5jdGlvbiAoZXYsIGRhdGEpIHtcbiAgICAgICAgICAgIGRhdGEgPSBkYXRhIHx8IHt9O1xuICAgICAgICAgICAgZGF0YS5mcmFnID0gX3RoaXMuZnJhZztcbiAgICAgICAgICAgIGRhdGEuaWQgPSBfdGhpcy5pZDtcbiAgICAgICAgICAgIGhscy50cmlnZ2VyKGV2LCBkYXRhKTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gZm9yd2FyZCBldmVudHMgdG8gbWFpbiB0aHJlYWRcbiAgICAgICAgb2JzZXJ2ZXIub24oZXZlbnRzXzEuZGVmYXVsdC5GUkFHX0RFQ1JZUFRFRCwgZm9yd2FyZE1lc3NhZ2UpO1xuICAgICAgICBvYnNlcnZlci5vbihldmVudHNfMS5kZWZhdWx0LkZSQUdfUEFSU0lOR19JTklUX1NFR01FTlQsIGZvcndhcmRNZXNzYWdlKTtcbiAgICAgICAgb2JzZXJ2ZXIub24oZXZlbnRzXzEuZGVmYXVsdC5GUkFHX1BBUlNJTkdfREFUQSwgZm9yd2FyZE1lc3NhZ2UpO1xuICAgICAgICBvYnNlcnZlci5vbihldmVudHNfMS5kZWZhdWx0LkZSQUdfUEFSU0VELCBmb3J3YXJkTWVzc2FnZSk7XG4gICAgICAgIG9ic2VydmVyLm9uKGV2ZW50c18xLmRlZmF1bHQuRVJST1IsIGZvcndhcmRNZXNzYWdlKTtcbiAgICAgICAgb2JzZXJ2ZXIub24oZXZlbnRzXzEuZGVmYXVsdC5GUkFHX1BBUlNJTkdfTUVUQURBVEEsIGZvcndhcmRNZXNzYWdlKTtcbiAgICAgICAgb2JzZXJ2ZXIub24oZXZlbnRzXzEuZGVmYXVsdC5GUkFHX1BBUlNJTkdfVVNFUkRBVEEsIGZvcndhcmRNZXNzYWdlKTtcbiAgICAgICAgb2JzZXJ2ZXIub24oZXZlbnRzXzEuZGVmYXVsdC5JTklUX1BUU19GT1VORCwgZm9yd2FyZE1lc3NhZ2UpO1xuICAgICAgICB2YXIgdHlwZVN1cHBvcnRlZCA9IHtcbiAgICAgICAgICAgIG1wNDogTWVkaWFTb3VyY2UuaXNUeXBlU3VwcG9ydGVkKCd2aWRlby9tcDQnKSxcbiAgICAgICAgICAgIG1wZWc6IE1lZGlhU291cmNlLmlzVHlwZVN1cHBvcnRlZCgnYXVkaW8vbXBlZycpLFxuICAgICAgICAgICAgbXAzOiBNZWRpYVNvdXJjZS5pc1R5cGVTdXBwb3J0ZWQoJ2F1ZGlvL21wNDsgY29kZWNzPVwibXAzXCInKVxuICAgICAgICB9O1xuICAgICAgICAvLyBuYXZpZ2F0b3IudmVuZG9yIGlzIG5vdCBhbHdheXMgYXZhaWxhYmxlIGluIFdlYiBXb3JrZXJcbiAgICAgICAgLy8gcmVmZXIgdG8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1dvcmtlckdsb2JhbFNjb3BlL25hdmlnYXRvclxuICAgICAgICB2YXIgdmVuZG9yID0gbmF2aWdhdG9yLnZlbmRvcjtcbiAgICAgICAgaWYgKGNvbmZpZy5lbmFibGVXb3JrZXIgJiYgKHR5cGVvZiAoV29ya2VyKSAhPT0gJ3VuZGVmaW5lZCcpKSB7XG4gICAgICAgICAgICBsb2dnZXJfMS5sb2dnZXIubG9nKCdkZW11eGluZyBpbiB3ZWJ3b3JrZXInKTtcbiAgICAgICAgICAgIHZhciB3ID0gdm9pZCAwO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB3ID0gdGhpcy53ID0gd29yaygvKnJlcXVpcmUucmVzb2x2ZSovKC8qISAuLi9kZW11eC9kZW11eGVyLXdvcmtlci5qcyAqLyBcIi4vc3JjL2RlbXV4L2RlbXV4ZXItd29ya2VyLmpzXCIpKTtcbiAgICAgICAgICAgICAgICB0aGlzLm9ud21zZyA9IHRoaXMub25Xb3JrZXJNZXNzYWdlLmJpbmQodGhpcyk7XG4gICAgICAgICAgICAgICAgdy5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgdGhpcy5vbndtc2cpO1xuICAgICAgICAgICAgICAgIHcub25lcnJvciA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgICAgICAgICBobHMudHJpZ2dlcihldmVudHNfMS5kZWZhdWx0LkVSUk9SLCB7IHR5cGU6IGVycm9yc18xLkVycm9yVHlwZXMuT1RIRVJfRVJST1IsIGRldGFpbHM6IGVycm9yc18xLkVycm9yRGV0YWlscy5JTlRFUk5BTF9FWENFUFRJT04sIGZhdGFsOiB0cnVlLCBldmVudDogJ2RlbXV4ZXJXb3JrZXInLCBlcnI6IHsgbWVzc2FnZTogZXZlbnQubWVzc2FnZSArICcgKCcgKyBldmVudC5maWxlbmFtZSArICc6JyArIGV2ZW50LmxpbmVubyArICcpJyB9IH0pO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdy5wb3N0TWVzc2FnZSh7IGNtZDogJ2luaXQnLCB0eXBlU3VwcG9ydGVkOiB0eXBlU3VwcG9ydGVkLCB2ZW5kb3I6IHZlbmRvciwgaWQ6IGlkLCBjb25maWc6IEpTT04uc3RyaW5naWZ5KGNvbmZpZykgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLndhcm4oJ0Vycm9yIGluIHdvcmtlcjonLCBlcnIpO1xuICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmxvZ2dlci5lcnJvcignRXJyb3Igd2hpbGUgaW5pdGlhbGl6aW5nIERlbXV4ZXJXb3JrZXIsIGZhbGxiYWNrIG9uIERlbXV4ZXJJbmxpbmUnKTtcbiAgICAgICAgICAgICAgICBpZiAodykge1xuICAgICAgICAgICAgICAgICAgICAvLyByZXZva2UgdGhlIE9iamVjdCBVUkwgdGhhdCB3YXMgdXNlZCB0byBjcmVhdGUgZGVtdXhlciB3b3JrZXIsIHNvIGFzIG5vdCB0byBsZWFrIGl0XG4gICAgICAgICAgICAgICAgICAgIGdsb2JhbC5VUkwucmV2b2tlT2JqZWN0VVJMKHcub2JqZWN0VVJMKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5kZW11eGVyID0gbmV3IGRlbXV4ZXJfaW5saW5lXzEuZGVmYXVsdChvYnNlcnZlciwgdHlwZVN1cHBvcnRlZCwgY29uZmlnLCB2ZW5kb3IpO1xuICAgICAgICAgICAgICAgIHRoaXMudyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZGVtdXhlciA9IG5ldyBkZW11eGVyX2lubGluZV8xLmRlZmF1bHQob2JzZXJ2ZXIsIHR5cGVTdXBwb3J0ZWQsIGNvbmZpZywgdmVuZG9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBEZW11eGVyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgICAgaWYgKHcpIHtcbiAgICAgICAgICAgIHcucmVtb3ZlRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIHRoaXMub253bXNnKTtcbiAgICAgICAgICAgIHcudGVybWluYXRlKCk7XG4gICAgICAgICAgICB0aGlzLncgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGRlbXV4ZXIgPSB0aGlzLmRlbXV4ZXI7XG4gICAgICAgICAgICBpZiAoZGVtdXhlcikge1xuICAgICAgICAgICAgICAgIGRlbXV4ZXIuZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuZGVtdXhlciA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG9ic2VydmVyID0gdGhpcy5vYnNlcnZlcjtcbiAgICAgICAgaWYgKG9ic2VydmVyKSB7XG4gICAgICAgICAgICBvYnNlcnZlci5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICAgICAgICAgIHRoaXMub2JzZXJ2ZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBEZW11eGVyLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGRhdGEsIGluaXRTZWdtZW50LCBhdWRpb0NvZGVjLCB2aWRlb0NvZGVjLCBmcmFnLCBkdXJhdGlvbiwgYWNjdXJhdGVUaW1lT2Zmc2V0LCBkZWZhdWx0SW5pdFBUUykge1xuICAgICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgICAgdmFyIHRpbWVPZmZzZXQgPSBOdW1iZXIuaXNGaW5pdGUoZnJhZy5zdGFydFBUUykgPyBmcmFnLnN0YXJ0UFRTIDogZnJhZy5zdGFydDtcbiAgICAgICAgdmFyIGRlY3J5cHRkYXRhID0gZnJhZy5kZWNyeXB0ZGF0YTtcbiAgICAgICAgdmFyIGxhc3RGcmFnID0gdGhpcy5mcmFnO1xuICAgICAgICB2YXIgZGlzY29udGludWl0eSA9ICEobGFzdEZyYWcgJiYgKGZyYWcuY2MgPT09IGxhc3RGcmFnLmNjKSk7XG4gICAgICAgIHZhciB0cmFja1N3aXRjaCA9ICEobGFzdEZyYWcgJiYgKGZyYWcubGV2ZWwgPT09IGxhc3RGcmFnLmxldmVsKSk7XG4gICAgICAgIHZhciBuZXh0U04gPSBsYXN0RnJhZyAmJiAoZnJhZy5zbiA9PT0gKGxhc3RGcmFnLnNuICsgMSkpO1xuICAgICAgICB2YXIgY29udGlndW91cyA9ICF0cmFja1N3aXRjaCAmJiBuZXh0U047XG4gICAgICAgIGlmIChkaXNjb250aW51aXR5KSB7XG4gICAgICAgICAgICBsb2dnZXJfMS5sb2dnZXIubG9nKHRoaXMuaWQgKyBcIjpkaXNjb250aW51aXR5IGRldGVjdGVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0cmFja1N3aXRjaCkge1xuICAgICAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLmxvZyh0aGlzLmlkICsgXCI6c3dpdGNoIGRldGVjdGVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZnJhZyA9IGZyYWc7XG4gICAgICAgIGlmICh3KSB7XG4gICAgICAgICAgICAvLyBwb3N0IGZyYWdtZW50IHBheWxvYWQgYXMgdHJhbnNmZXJhYmxlIG9iamVjdHMgZm9yIEFycmF5QnVmZmVyIChubyBjb3B5KVxuICAgICAgICAgICAgdy5wb3N0TWVzc2FnZSh7IGNtZDogJ2RlbXV4JywgZGF0YTogZGF0YSwgZGVjcnlwdGRhdGE6IGRlY3J5cHRkYXRhLCBpbml0U2VnbWVudDogaW5pdFNlZ21lbnQsIGF1ZGlvQ29kZWM6IGF1ZGlvQ29kZWMsIHZpZGVvQ29kZWM6IHZpZGVvQ29kZWMsIHRpbWVPZmZzZXQ6IHRpbWVPZmZzZXQsIGRpc2NvbnRpbnVpdHk6IGRpc2NvbnRpbnVpdHksIHRyYWNrU3dpdGNoOiB0cmFja1N3aXRjaCwgY29udGlndW91czogY29udGlndW91cywgZHVyYXRpb246IGR1cmF0aW9uLCBhY2N1cmF0ZVRpbWVPZmZzZXQ6IGFjY3VyYXRlVGltZU9mZnNldCwgZGVmYXVsdEluaXRQVFM6IGRlZmF1bHRJbml0UFRTIH0sIGRhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciA/IFtkYXRhXSA6IFtdKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBkZW11eGVyID0gdGhpcy5kZW11eGVyO1xuICAgICAgICAgICAgaWYgKGRlbXV4ZXIpIHtcbiAgICAgICAgICAgICAgICBkZW11eGVyLnB1c2goZGF0YSwgZGVjcnlwdGRhdGEsIGluaXRTZWdtZW50LCBhdWRpb0NvZGVjLCB2aWRlb0NvZGVjLCB0aW1lT2Zmc2V0LCBkaXNjb250aW51aXR5LCB0cmFja1N3aXRjaCwgY29udGlndW91cywgZHVyYXRpb24sIGFjY3VyYXRlVGltZU9mZnNldCwgZGVmYXVsdEluaXRQVFMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBEZW11eGVyLnByb3RvdHlwZS5vbldvcmtlck1lc3NhZ2UgPSBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgdmFyIGRhdGEgPSBldi5kYXRhLCBobHMgPSB0aGlzLmhscztcbiAgICAgICAgc3dpdGNoIChkYXRhLmV2ZW50KSB7XG4gICAgICAgICAgICBjYXNlICdpbml0JzpcbiAgICAgICAgICAgICAgICAvLyByZXZva2UgdGhlIE9iamVjdCBVUkwgdGhhdCB3YXMgdXNlZCB0byBjcmVhdGUgZGVtdXhlciB3b3JrZXIsIHNvIGFzIG5vdCB0byBsZWFrIGl0XG4gICAgICAgICAgICAgICAgZ2xvYmFsLlVSTC5yZXZva2VPYmplY3RVUkwodGhpcy53Lm9iamVjdFVSTCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAvLyBzcGVjaWFsIGNhc2UgZm9yIEZSQUdfUEFSU0lOR19EQVRBOiBkYXRhMSBhbmQgZGF0YTIgYXJlIHRyYW5zZmVyYWJsZSBvYmplY3RzXG4gICAgICAgICAgICBjYXNlIGV2ZW50c18xLmRlZmF1bHQuRlJBR19QQVJTSU5HX0RBVEE6XG4gICAgICAgICAgICAgICAgZGF0YS5kYXRhLmRhdGExID0gbmV3IFVpbnQ4QXJyYXkoZGF0YS5kYXRhMSk7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGEuZGF0YTIpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5kYXRhLmRhdGEyID0gbmV3IFVpbnQ4QXJyYXkoZGF0YS5kYXRhMik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBkYXRhLmRhdGEgPSBkYXRhLmRhdGEgfHwge307XG4gICAgICAgICAgICAgICAgZGF0YS5kYXRhLmZyYWcgPSB0aGlzLmZyYWc7XG4gICAgICAgICAgICAgICAgZGF0YS5kYXRhLmlkID0gdGhpcy5pZDtcbiAgICAgICAgICAgICAgICBobHMudHJpZ2dlcihkYXRhLmV2ZW50LCBkYXRhLmRhdGEpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gRGVtdXhlcjtcbn0oKSk7XG5leHBvcnRzLmRlZmF1bHQgPSBEZW11eGVyO1xuXG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwodGhpcywgX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9zcmMvcG9seWZpbGxzL251bWJlciAqLyBcIi4vc3JjL3BvbHlmaWxscy9udW1iZXIuanNcIilbXCJOdW1iZXJcIl0pKVxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9kZW11eC9leHAtZ29sb21iLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvZGVtdXgvZXhwLWdvbG9tYi5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKipcbiAqIFBhcnNlciBmb3IgZXhwb25lbnRpYWwgR29sb21iIGNvZGVzLCBhIHZhcmlhYmxlLWJpdHdpZHRoIG51bWJlciBlbmNvZGluZyBzY2hlbWUgdXNlZCBieSBoMjY0LlxuKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBsb2dnZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL2xvZ2dlciAqLyBcIi4vc3JjL3V0aWxzL2xvZ2dlci5qc1wiKTtcbnZhciBFeHBHb2xvbWIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRXhwR29sb21iKGRhdGEpIHtcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICAgICAgLy8gdGhlIG51bWJlciBvZiBieXRlcyBsZWZ0IHRvIGV4YW1pbmUgaW4gdGhpcy5kYXRhXG4gICAgICAgIHRoaXMuYnl0ZXNBdmFpbGFibGUgPSBkYXRhLmJ5dGVMZW5ndGg7XG4gICAgICAgIC8vIHRoZSBjdXJyZW50IHdvcmQgYmVpbmcgZXhhbWluZWRcbiAgICAgICAgdGhpcy53b3JkID0gMDsgLy8gOnVpbnRcbiAgICAgICAgLy8gdGhlIG51bWJlciBvZiBiaXRzIGxlZnQgdG8gZXhhbWluZSBpbiB0aGUgY3VycmVudCB3b3JkXG4gICAgICAgIHRoaXMuYml0c0F2YWlsYWJsZSA9IDA7IC8vIDp1aW50XG4gICAgfVxuICAgIC8vICgpOnZvaWRcbiAgICBFeHBHb2xvbWIucHJvdG90eXBlLmxvYWRXb3JkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YSwgYnl0ZXNBdmFpbGFibGUgPSB0aGlzLmJ5dGVzQXZhaWxhYmxlLCBwb3NpdGlvbiA9IGRhdGEuYnl0ZUxlbmd0aCAtIGJ5dGVzQXZhaWxhYmxlLCB3b3JraW5nQnl0ZXMgPSBuZXcgVWludDhBcnJheSg0KSwgYXZhaWxhYmxlQnl0ZXMgPSBNYXRoLm1pbig0LCBieXRlc0F2YWlsYWJsZSk7XG4gICAgICAgIGlmIChhdmFpbGFibGVCeXRlcyA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdubyBieXRlcyBhdmFpbGFibGUnKTtcbiAgICAgICAgfVxuICAgICAgICB3b3JraW5nQnl0ZXMuc2V0KGRhdGEuc3ViYXJyYXkocG9zaXRpb24sIHBvc2l0aW9uICsgYXZhaWxhYmxlQnl0ZXMpKTtcbiAgICAgICAgdGhpcy53b3JkID0gbmV3IERhdGFWaWV3KHdvcmtpbmdCeXRlcy5idWZmZXIpLmdldFVpbnQzMigwKTtcbiAgICAgICAgLy8gdHJhY2sgdGhlIGFtb3VudCBvZiB0aGlzLmRhdGEgdGhhdCBoYXMgYmVlbiBwcm9jZXNzZWRcbiAgICAgICAgdGhpcy5iaXRzQXZhaWxhYmxlID0gYXZhaWxhYmxlQnl0ZXMgKiA4O1xuICAgICAgICB0aGlzLmJ5dGVzQXZhaWxhYmxlIC09IGF2YWlsYWJsZUJ5dGVzO1xuICAgIH07XG4gICAgLy8gKGNvdW50OmludCk6dm9pZFxuICAgIEV4cEdvbG9tYi5wcm90b3R5cGUuc2tpcEJpdHMgPSBmdW5jdGlvbiAoY291bnQpIHtcbiAgICAgICAgdmFyIHNraXBCeXRlczsgLy8gOmludFxuICAgICAgICBpZiAodGhpcy5iaXRzQXZhaWxhYmxlID4gY291bnQpIHtcbiAgICAgICAgICAgIHRoaXMud29yZCA8PD0gY291bnQ7XG4gICAgICAgICAgICB0aGlzLmJpdHNBdmFpbGFibGUgLT0gY291bnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb3VudCAtPSB0aGlzLmJpdHNBdmFpbGFibGU7XG4gICAgICAgICAgICBza2lwQnl0ZXMgPSBjb3VudCA+PiAzO1xuICAgICAgICAgICAgY291bnQgLT0gKHNraXBCeXRlcyA+PiAzKTtcbiAgICAgICAgICAgIHRoaXMuYnl0ZXNBdmFpbGFibGUgLT0gc2tpcEJ5dGVzO1xuICAgICAgICAgICAgdGhpcy5sb2FkV29yZCgpO1xuICAgICAgICAgICAgdGhpcy53b3JkIDw8PSBjb3VudDtcbiAgICAgICAgICAgIHRoaXMuYml0c0F2YWlsYWJsZSAtPSBjb3VudDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gKHNpemU6aW50KTp1aW50XG4gICAgRXhwR29sb21iLnByb3RvdHlwZS5yZWFkQml0cyA9IGZ1bmN0aW9uIChzaXplKSB7XG4gICAgICAgIHZhciBiaXRzID0gTWF0aC5taW4odGhpcy5iaXRzQXZhaWxhYmxlLCBzaXplKSwgLy8gOnVpbnRcbiAgICAgICAgdmFsdSA9IHRoaXMud29yZCA+Pj4gKDMyIC0gYml0cyk7IC8vIDp1aW50XG4gICAgICAgIGlmIChzaXplID4gMzIpIHtcbiAgICAgICAgICAgIGxvZ2dlcl8xLmxvZ2dlci5lcnJvcignQ2Fubm90IHJlYWQgbW9yZSB0aGFuIDMyIGJpdHMgYXQgYSB0aW1lJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5iaXRzQXZhaWxhYmxlIC09IGJpdHM7XG4gICAgICAgIGlmICh0aGlzLmJpdHNBdmFpbGFibGUgPiAwKSB7XG4gICAgICAgICAgICB0aGlzLndvcmQgPDw9IGJpdHM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5ieXRlc0F2YWlsYWJsZSA+IDApIHtcbiAgICAgICAgICAgIHRoaXMubG9hZFdvcmQoKTtcbiAgICAgICAgfVxuICAgICAgICBiaXRzID0gc2l6ZSAtIGJpdHM7XG4gICAgICAgIGlmIChiaXRzID4gMCAmJiB0aGlzLmJpdHNBdmFpbGFibGUpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1IDw8IGJpdHMgfCB0aGlzLnJlYWRCaXRzKGJpdHMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHU7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vICgpOnVpbnRcbiAgICBFeHBHb2xvbWIucHJvdG90eXBlLnNraXBMWiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGxlYWRpbmdaZXJvQ291bnQ7IC8vIDp1aW50XG4gICAgICAgIGZvciAobGVhZGluZ1plcm9Db3VudCA9IDA7IGxlYWRpbmdaZXJvQ291bnQgPCB0aGlzLmJpdHNBdmFpbGFibGU7ICsrbGVhZGluZ1plcm9Db3VudCkge1xuICAgICAgICAgICAgaWYgKCh0aGlzLndvcmQgJiAoMHg4MDAwMDAwMCA+Pj4gbGVhZGluZ1plcm9Db3VudCkpICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gdGhlIGZpcnN0IGJpdCBvZiB3b3JraW5nIHdvcmQgaXMgMVxuICAgICAgICAgICAgICAgIHRoaXMud29yZCA8PD0gbGVhZGluZ1plcm9Db3VudDtcbiAgICAgICAgICAgICAgICB0aGlzLmJpdHNBdmFpbGFibGUgLT0gbGVhZGluZ1plcm9Db3VudDtcbiAgICAgICAgICAgICAgICByZXR1cm4gbGVhZGluZ1plcm9Db3VudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyB3ZSBleGhhdXN0ZWQgd29yZCBhbmQgc3RpbGwgaGF2ZSBub3QgZm91bmQgYSAxXG4gICAgICAgIHRoaXMubG9hZFdvcmQoKTtcbiAgICAgICAgcmV0dXJuIGxlYWRpbmdaZXJvQ291bnQgKyB0aGlzLnNraXBMWigpO1xuICAgIH07XG4gICAgLy8gKCk6dm9pZFxuICAgIEV4cEdvbG9tYi5wcm90b3R5cGUuc2tpcFVFRyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5za2lwQml0cygxICsgdGhpcy5za2lwTFooKSk7XG4gICAgfTtcbiAgICAvLyAoKTp2b2lkXG4gICAgRXhwR29sb21iLnByb3RvdHlwZS5za2lwRUcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuc2tpcEJpdHMoMSArIHRoaXMuc2tpcExaKCkpO1xuICAgIH07XG4gICAgLy8gKCk6dWludFxuICAgIEV4cEdvbG9tYi5wcm90b3R5cGUucmVhZFVFRyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNseiA9IHRoaXMuc2tpcExaKCk7IC8vIDp1aW50XG4gICAgICAgIHJldHVybiB0aGlzLnJlYWRCaXRzKGNseiArIDEpIC0gMTtcbiAgICB9O1xuICAgIC8vICgpOmludFxuICAgIEV4cEdvbG9tYi5wcm90b3R5cGUucmVhZEVHID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdmFsdSA9IHRoaXMucmVhZFVFRygpOyAvLyA6aW50XG4gICAgICAgIGlmICgweDAxICYgdmFsdSkge1xuICAgICAgICAgICAgLy8gdGhlIG51bWJlciBpcyBvZGQgaWYgdGhlIGxvdyBvcmRlciBiaXQgaXMgc2V0XG4gICAgICAgICAgICByZXR1cm4gKDEgKyB2YWx1KSA+Pj4gMTsgLy8gYWRkIDEgdG8gbWFrZSBpdCBldmVuLCBhbmQgZGl2aWRlIGJ5IDJcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAtMSAqICh2YWx1ID4+PiAxKTsgLy8gZGl2aWRlIGJ5IHR3byB0aGVuIG1ha2UgaXQgbmVnYXRpdmVcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gU29tZSBjb252ZW5pZW5jZSBmdW5jdGlvbnNcbiAgICAvLyA6Qm9vbGVhblxuICAgIEV4cEdvbG9tYi5wcm90b3R5cGUucmVhZEJvb2xlYW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlYWRCaXRzKDEpID09PSAxO1xuICAgIH07XG4gICAgLy8gKCk6aW50XG4gICAgRXhwR29sb21iLnByb3RvdHlwZS5yZWFkVUJ5dGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlYWRCaXRzKDgpO1xuICAgIH07XG4gICAgLy8gKCk6aW50XG4gICAgRXhwR29sb21iLnByb3RvdHlwZS5yZWFkVVNob3J0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZWFkQml0cygxNik7XG4gICAgfTtcbiAgICAvLyAoKTppbnRcbiAgICBFeHBHb2xvbWIucHJvdG90eXBlLnJlYWRVSW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZWFkQml0cygzMik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBZHZhbmNlIHRoZSBFeHBHb2xvbWIgZGVjb2RlciBwYXN0IGEgc2NhbGluZyBsaXN0LiBUaGUgc2NhbGluZ1xuICAgICAqIGxpc3QgaXMgb3B0aW9uYWxseSB0cmFuc21pdHRlZCBhcyBwYXJ0IG9mIGEgc2VxdWVuY2UgcGFyYW1ldGVyXG4gICAgICogc2V0IGFuZCBpcyBub3QgcmVsZXZhbnQgdG8gdHJhbnNtdXhpbmcuXG4gICAgICogQHBhcmFtIGNvdW50IHtudW1iZXJ9IHRoZSBudW1iZXIgb2YgZW50cmllcyBpbiB0aGlzIHNjYWxpbmcgbGlzdFxuICAgICAqIEBzZWUgUmVjb21tZW5kYXRpb24gSVRVLVQgSC4yNjQsIFNlY3Rpb24gNy4zLjIuMS4xLjFcbiAgICAgKi9cbiAgICBFeHBHb2xvbWIucHJvdG90eXBlLnNraXBTY2FsaW5nTGlzdCA9IGZ1bmN0aW9uIChjb3VudCkge1xuICAgICAgICB2YXIgbGFzdFNjYWxlID0gOCwgbmV4dFNjYWxlID0gOCwgaiwgZGVsdGFTY2FsZTtcbiAgICAgICAgZm9yIChqID0gMDsgaiA8IGNvdW50OyBqKyspIHtcbiAgICAgICAgICAgIGlmIChuZXh0U2NhbGUgIT09IDApIHtcbiAgICAgICAgICAgICAgICBkZWx0YVNjYWxlID0gdGhpcy5yZWFkRUcoKTtcbiAgICAgICAgICAgICAgICBuZXh0U2NhbGUgPSAobGFzdFNjYWxlICsgZGVsdGFTY2FsZSArIDI1NikgJSAyNTY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsYXN0U2NhbGUgPSAobmV4dFNjYWxlID09PSAwKSA/IGxhc3RTY2FsZSA6IG5leHRTY2FsZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVhZCBhIHNlcXVlbmNlIHBhcmFtZXRlciBzZXQgYW5kIHJldHVybiBzb21lIGludGVyZXN0aW5nIHZpZGVvXG4gICAgICogcHJvcGVydGllcy4gQSBzZXF1ZW5jZSBwYXJhbWV0ZXIgc2V0IGlzIHRoZSBIMjY0IG1ldGFkYXRhIHRoYXRcbiAgICAgKiBkZXNjcmliZXMgdGhlIHByb3BlcnRpZXMgb2YgdXBjb21pbmcgdmlkZW8gZnJhbWVzLlxuICAgICAqIEBwYXJhbSBkYXRhIHtVaW50OEFycmF5fSB0aGUgYnl0ZXMgb2YgYSBzZXF1ZW5jZSBwYXJhbWV0ZXIgc2V0XG4gICAgICogQHJldHVybiB7b2JqZWN0fSBhbiBvYmplY3Qgd2l0aCBjb25maWd1cmF0aW9uIHBhcnNlZCBmcm9tIHRoZVxuICAgICAqIHNlcXVlbmNlIHBhcmFtZXRlciBzZXQsIGluY2x1ZGluZyB0aGUgZGltZW5zaW9ucyBvZiB0aGVcbiAgICAgKiBhc3NvY2lhdGVkIHZpZGVvIGZyYW1lcy5cbiAgICAgKi9cbiAgICBFeHBHb2xvbWIucHJvdG90eXBlLnJlYWRTUFMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBmcmFtZUNyb3BMZWZ0T2Zmc2V0ID0gMCwgZnJhbWVDcm9wUmlnaHRPZmZzZXQgPSAwLCBmcmFtZUNyb3BUb3BPZmZzZXQgPSAwLCBmcmFtZUNyb3BCb3R0b21PZmZzZXQgPSAwLCBwcm9maWxlSWRjLCBwcm9maWxlQ29tcGF0LCBsZXZlbElkYywgbnVtUmVmRnJhbWVzSW5QaWNPcmRlckNudEN5Y2xlLCBwaWNXaWR0aEluTWJzTWludXMxLCBwaWNIZWlnaHRJbk1hcFVuaXRzTWludXMxLCBmcmFtZU1ic09ubHlGbGFnLCBzY2FsaW5nTGlzdENvdW50LCBpLCByZWFkVUJ5dGUgPSB0aGlzLnJlYWRVQnl0ZS5iaW5kKHRoaXMpLCByZWFkQml0cyA9IHRoaXMucmVhZEJpdHMuYmluZCh0aGlzKSwgcmVhZFVFRyA9IHRoaXMucmVhZFVFRy5iaW5kKHRoaXMpLCByZWFkQm9vbGVhbiA9IHRoaXMucmVhZEJvb2xlYW4uYmluZCh0aGlzKSwgc2tpcEJpdHMgPSB0aGlzLnNraXBCaXRzLmJpbmQodGhpcyksIHNraXBFRyA9IHRoaXMuc2tpcEVHLmJpbmQodGhpcyksIHNraXBVRUcgPSB0aGlzLnNraXBVRUcuYmluZCh0aGlzKSwgc2tpcFNjYWxpbmdMaXN0ID0gdGhpcy5za2lwU2NhbGluZ0xpc3QuYmluZCh0aGlzKTtcbiAgICAgICAgcmVhZFVCeXRlKCk7XG4gICAgICAgIHByb2ZpbGVJZGMgPSByZWFkVUJ5dGUoKTsgLy8gcHJvZmlsZV9pZGNcbiAgICAgICAgcHJvZmlsZUNvbXBhdCA9IHJlYWRCaXRzKDUpOyAvLyBjb25zdHJhaW50X3NldFswLTRdX2ZsYWcsIHUoNSlcbiAgICAgICAgc2tpcEJpdHMoMyk7IC8vIHJlc2VydmVkX3plcm9fM2JpdHMgdSgzKSxcbiAgICAgICAgbGV2ZWxJZGMgPSByZWFkVUJ5dGUoKTsgLy8gbGV2ZWxfaWRjIHUoOClcbiAgICAgICAgc2tpcFVFRygpOyAvLyBzZXFfcGFyYW1ldGVyX3NldF9pZFxuICAgICAgICAvLyBzb21lIHByb2ZpbGVzIGhhdmUgbW9yZSBvcHRpb25hbCBkYXRhIHdlIGRvbid0IG5lZWRcbiAgICAgICAgaWYgKHByb2ZpbGVJZGMgPT09IDEwMCB8fFxuICAgICAgICAgICAgcHJvZmlsZUlkYyA9PT0gMTEwIHx8XG4gICAgICAgICAgICBwcm9maWxlSWRjID09PSAxMjIgfHxcbiAgICAgICAgICAgIHByb2ZpbGVJZGMgPT09IDI0NCB8fFxuICAgICAgICAgICAgcHJvZmlsZUlkYyA9PT0gNDQgfHxcbiAgICAgICAgICAgIHByb2ZpbGVJZGMgPT09IDgzIHx8XG4gICAgICAgICAgICBwcm9maWxlSWRjID09PSA4NiB8fFxuICAgICAgICAgICAgcHJvZmlsZUlkYyA9PT0gMTE4IHx8XG4gICAgICAgICAgICBwcm9maWxlSWRjID09PSAxMjgpIHtcbiAgICAgICAgICAgIHZhciBjaHJvbWFGb3JtYXRJZGMgPSByZWFkVUVHKCk7XG4gICAgICAgICAgICBpZiAoY2hyb21hRm9ybWF0SWRjID09PSAzKSB7XG4gICAgICAgICAgICAgICAgc2tpcEJpdHMoMSk7XG4gICAgICAgICAgICB9IC8vIHNlcGFyYXRlX2NvbG91cl9wbGFuZV9mbGFnXG4gICAgICAgICAgICBza2lwVUVHKCk7IC8vIGJpdF9kZXB0aF9sdW1hX21pbnVzOFxuICAgICAgICAgICAgc2tpcFVFRygpOyAvLyBiaXRfZGVwdGhfY2hyb21hX21pbnVzOFxuICAgICAgICAgICAgc2tpcEJpdHMoMSk7IC8vIHFwcHJpbWVfeV96ZXJvX3RyYW5zZm9ybV9ieXBhc3NfZmxhZ1xuICAgICAgICAgICAgaWYgKHJlYWRCb29sZWFuKCkpIHsgLy8gc2VxX3NjYWxpbmdfbWF0cml4X3ByZXNlbnRfZmxhZ1xuICAgICAgICAgICAgICAgIHNjYWxpbmdMaXN0Q291bnQgPSAoY2hyb21hRm9ybWF0SWRjICE9PSAzKSA/IDggOiAxMjtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc2NhbGluZ0xpc3RDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWFkQm9vbGVhbigpKSB7IC8vIHNlcV9zY2FsaW5nX2xpc3RfcHJlc2VudF9mbGFnWyBpIF1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpIDwgNikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNraXBTY2FsaW5nTGlzdCgxNik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBza2lwU2NhbGluZ0xpc3QoNjQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHNraXBVRUcoKTsgLy8gbG9nMl9tYXhfZnJhbWVfbnVtX21pbnVzNFxuICAgICAgICB2YXIgcGljT3JkZXJDbnRUeXBlID0gcmVhZFVFRygpO1xuICAgICAgICBpZiAocGljT3JkZXJDbnRUeXBlID09PSAwKSB7XG4gICAgICAgICAgICByZWFkVUVHKCk7IC8vIGxvZzJfbWF4X3BpY19vcmRlcl9jbnRfbHNiX21pbnVzNFxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHBpY09yZGVyQ250VHlwZSA9PT0gMSkge1xuICAgICAgICAgICAgc2tpcEJpdHMoMSk7IC8vIGRlbHRhX3BpY19vcmRlcl9hbHdheXNfemVyb19mbGFnXG4gICAgICAgICAgICBza2lwRUcoKTsgLy8gb2Zmc2V0X2Zvcl9ub25fcmVmX3BpY1xuICAgICAgICAgICAgc2tpcEVHKCk7IC8vIG9mZnNldF9mb3JfdG9wX3RvX2JvdHRvbV9maWVsZFxuICAgICAgICAgICAgbnVtUmVmRnJhbWVzSW5QaWNPcmRlckNudEN5Y2xlID0gcmVhZFVFRygpO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG51bVJlZkZyYW1lc0luUGljT3JkZXJDbnRDeWNsZTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgc2tpcEVHKCk7XG4gICAgICAgICAgICB9IC8vIG9mZnNldF9mb3JfcmVmX2ZyYW1lWyBpIF1cbiAgICAgICAgfVxuICAgICAgICBza2lwVUVHKCk7IC8vIG1heF9udW1fcmVmX2ZyYW1lc1xuICAgICAgICBza2lwQml0cygxKTsgLy8gZ2Fwc19pbl9mcmFtZV9udW1fdmFsdWVfYWxsb3dlZF9mbGFnXG4gICAgICAgIHBpY1dpZHRoSW5NYnNNaW51czEgPSByZWFkVUVHKCk7XG4gICAgICAgIHBpY0hlaWdodEluTWFwVW5pdHNNaW51czEgPSByZWFkVUVHKCk7XG4gICAgICAgIGZyYW1lTWJzT25seUZsYWcgPSByZWFkQml0cygxKTtcbiAgICAgICAgaWYgKGZyYW1lTWJzT25seUZsYWcgPT09IDApIHtcbiAgICAgICAgICAgIHNraXBCaXRzKDEpO1xuICAgICAgICB9IC8vIG1iX2FkYXB0aXZlX2ZyYW1lX2ZpZWxkX2ZsYWdcbiAgICAgICAgc2tpcEJpdHMoMSk7IC8vIGRpcmVjdF84eDhfaW5mZXJlbmNlX2ZsYWdcbiAgICAgICAgaWYgKHJlYWRCb29sZWFuKCkpIHsgLy8gZnJhbWVfY3JvcHBpbmdfZmxhZ1xuICAgICAgICAgICAgZnJhbWVDcm9wTGVmdE9mZnNldCA9IHJlYWRVRUcoKTtcbiAgICAgICAgICAgIGZyYW1lQ3JvcFJpZ2h0T2Zmc2V0ID0gcmVhZFVFRygpO1xuICAgICAgICAgICAgZnJhbWVDcm9wVG9wT2Zmc2V0ID0gcmVhZFVFRygpO1xuICAgICAgICAgICAgZnJhbWVDcm9wQm90dG9tT2Zmc2V0ID0gcmVhZFVFRygpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwaXhlbFJhdGlvID0gWzEsIDFdO1xuICAgICAgICBpZiAocmVhZEJvb2xlYW4oKSkge1xuICAgICAgICAgICAgLy8gdnVpX3BhcmFtZXRlcnNfcHJlc2VudF9mbGFnXG4gICAgICAgICAgICBpZiAocmVhZEJvb2xlYW4oKSkge1xuICAgICAgICAgICAgICAgIC8vIGFzcGVjdF9yYXRpb19pbmZvX3ByZXNlbnRfZmxhZ1xuICAgICAgICAgICAgICAgIHZhciBhc3BlY3RSYXRpb0lkYyA9IHJlYWRVQnl0ZSgpO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoYXNwZWN0UmF0aW9JZGMpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgcGl4ZWxSYXRpbyA9IFsxLCAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICBwaXhlbFJhdGlvID0gWzEyLCAxMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgcGl4ZWxSYXRpbyA9IFsxMCwgMTFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHBpeGVsUmF0aW8gPSBbMTYsIDExXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgICAgICBwaXhlbFJhdGlvID0gWzQwLCAzM107XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICAgICAgcGl4ZWxSYXRpbyA9IFsyNCwgMTFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHBpeGVsUmF0aW8gPSBbMjAsIDExXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgICAgICAgICBwaXhlbFJhdGlvID0gWzMyLCAxMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICAgICAgICAgICAgcGl4ZWxSYXRpbyA9IFs4MCwgMzNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICAgICAgICAgICAgICBwaXhlbFJhdGlvID0gWzE4LCAxMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHBpeGVsUmF0aW8gPSBbMTUsIDExXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgICAgICAgICAgICAgcGl4ZWxSYXRpbyA9IFs2NCwgMzNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgICAgICAgICAgICAgICBwaXhlbFJhdGlvID0gWzE2MCwgOTldO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBwaXhlbFJhdGlvID0gWzQsIDNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgICAgICAgICAgICAgICBwaXhlbFJhdGlvID0gWzMsIDJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTY6XG4gICAgICAgICAgICAgICAgICAgICAgICBwaXhlbFJhdGlvID0gWzIsIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjU1OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwaXhlbFJhdGlvID0gW3JlYWRVQnl0ZSgpIDw8IDggfCByZWFkVUJ5dGUoKSwgcmVhZFVCeXRlKCkgPDwgOCB8IHJlYWRVQnl0ZSgpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB3aWR0aDogTWF0aC5jZWlsKCgoKHBpY1dpZHRoSW5NYnNNaW51czEgKyAxKSAqIDE2KSAtIGZyYW1lQ3JvcExlZnRPZmZzZXQgKiAyIC0gZnJhbWVDcm9wUmlnaHRPZmZzZXQgKiAyKSksXG4gICAgICAgICAgICBoZWlnaHQ6ICgoMiAtIGZyYW1lTWJzT25seUZsYWcpICogKHBpY0hlaWdodEluTWFwVW5pdHNNaW51czEgKyAxKSAqIDE2KSAtICgoZnJhbWVNYnNPbmx5RmxhZyA/IDIgOiA0KSAqIChmcmFtZUNyb3BUb3BPZmZzZXQgKyBmcmFtZUNyb3BCb3R0b21PZmZzZXQpKSxcbiAgICAgICAgICAgIHBpeGVsUmF0aW86IHBpeGVsUmF0aW9cbiAgICAgICAgfTtcbiAgICB9O1xuICAgIEV4cEdvbG9tYi5wcm90b3R5cGUucmVhZFNsaWNlVHlwZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gc2tpcCBOQUx1IHR5cGVcbiAgICAgICAgdGhpcy5yZWFkVUJ5dGUoKTtcbiAgICAgICAgLy8gZGlzY2FyZCBmaXJzdF9tYl9pbl9zbGljZVxuICAgICAgICB0aGlzLnJlYWRVRUcoKTtcbiAgICAgICAgLy8gcmV0dXJuIHNsaWNlX3R5cGVcbiAgICAgICAgcmV0dXJuIHRoaXMucmVhZFVFRygpO1xuICAgIH07XG4gICAgcmV0dXJuIEV4cEdvbG9tYjtcbn0oKSk7XG5leHBvcnRzLmRlZmF1bHQgPSBFeHBHb2xvbWI7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvZGVtdXgvaWQzLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9kZW11eC9pZDMuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIElEMyBwYXJzZXJcbiAqL1xudmFyIElEMyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBJRDMoKSB7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiBhbiBJRDMgaGVhZGVyIGNhbiBiZSBmb3VuZCBhdCBvZmZzZXQgaW4gZGF0YVxuICAgICAqIEBwYXJhbSB7VWludDhBcnJheX0gZGF0YSAtIFRoZSBkYXRhIHRvIHNlYXJjaCBpblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgLSBUaGUgb2Zmc2V0IGF0IHdoaWNoIHRvIHN0YXJ0IHNlYXJjaGluZ1xuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IC0gVHJ1ZSBpZiBhbiBJRDMgaGVhZGVyIGlzIGZvdW5kXG4gICAgICovXG4gICAgSUQzLmlzSGVhZGVyID0gZnVuY3Rpb24gKGRhdGEsIG9mZnNldCkge1xuICAgICAgICAvKlxuICAgICAgICAqIGh0dHA6Ly9pZDMub3JnL2lkM3YyLjMuMFxuICAgICAgICAqIFswXSAgICAgPSAnSSdcbiAgICAgICAgKiBbMV0gICAgID0gJ0QnXG4gICAgICAgICogWzJdICAgICA9ICczJ1xuICAgICAgICAqIFszLDRdICAgPSB7VmVyc2lvbn1cbiAgICAgICAgKiBbNV0gICAgID0ge0ZsYWdzfVxuICAgICAgICAqIFs2LTldICAgPSB7SUQzIFNpemV9XG4gICAgICAgICpcbiAgICAgICAgKiBBbiBJRDN2MiB0YWcgY2FuIGJlIGRldGVjdGVkIHdpdGggdGhlIGZvbGxvd2luZyBwYXR0ZXJuOlxuICAgICAgICAqICAkNDkgNDQgMzMgeXkgeXkgeHggenogenogenogenpcbiAgICAgICAgKiBXaGVyZSB5eSBpcyBsZXNzIHRoYW4gJEZGLCB4eCBpcyB0aGUgJ2ZsYWdzJyBieXRlIGFuZCB6eiBpcyBsZXNzIHRoYW4gJDgwXG4gICAgICAgICovXG4gICAgICAgIGlmIChvZmZzZXQgKyAxMCA8PSBkYXRhLmxlbmd0aCkge1xuICAgICAgICAgICAgLy8gbG9vayBmb3IgJ0lEMycgaWRlbnRpZmllclxuICAgICAgICAgICAgaWYgKGRhdGFbb2Zmc2V0XSA9PT0gMHg0OSAmJiBkYXRhW29mZnNldCArIDFdID09PSAweDQ0ICYmIGRhdGFbb2Zmc2V0ICsgMl0gPT09IDB4MzMpIHtcbiAgICAgICAgICAgICAgICAvLyBjaGVjayB2ZXJzaW9uIGlzIHdpdGhpbiByYW5nZVxuICAgICAgICAgICAgICAgIGlmIChkYXRhW29mZnNldCArIDNdIDwgMHhGRiAmJiBkYXRhW29mZnNldCArIDRdIDwgMHhGRikge1xuICAgICAgICAgICAgICAgICAgICAvLyBjaGVjayBzaXplIGlzIHdpdGhpbiByYW5nZVxuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YVtvZmZzZXQgKyA2XSA8IDB4ODAgJiYgZGF0YVtvZmZzZXQgKyA3XSA8IDB4ODAgJiYgZGF0YVtvZmZzZXQgKyA4XSA8IDB4ODAgJiYgZGF0YVtvZmZzZXQgKyA5XSA8IDB4ODApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiBhbiBJRDMgZm9vdGVyIGNhbiBiZSBmb3VuZCBhdCBvZmZzZXQgaW4gZGF0YVxuICAgICAqIEBwYXJhbSB7VWludDhBcnJheX0gZGF0YSAtIFRoZSBkYXRhIHRvIHNlYXJjaCBpblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgLSBUaGUgb2Zmc2V0IGF0IHdoaWNoIHRvIHN0YXJ0IHNlYXJjaGluZ1xuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IC0gVHJ1ZSBpZiBhbiBJRDMgZm9vdGVyIGlzIGZvdW5kXG4gICAgICovXG4gICAgSUQzLmlzRm9vdGVyID0gZnVuY3Rpb24gKGRhdGEsIG9mZnNldCkge1xuICAgICAgICAvKlxuICAgICAgICAqIFRoZSBmb290ZXIgaXMgYSBjb3B5IG9mIHRoZSBoZWFkZXIsIGJ1dCB3aXRoIGEgZGlmZmVyZW50IGlkZW50aWZpZXJcbiAgICAgICAgKi9cbiAgICAgICAgaWYgKG9mZnNldCArIDEwIDw9IGRhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyBsb29rIGZvciAnM0RJJyBpZGVudGlmaWVyXG4gICAgICAgICAgICBpZiAoZGF0YVtvZmZzZXRdID09PSAweDMzICYmIGRhdGFbb2Zmc2V0ICsgMV0gPT09IDB4NDQgJiYgZGF0YVtvZmZzZXQgKyAyXSA9PT0gMHg0OSkge1xuICAgICAgICAgICAgICAgIC8vIGNoZWNrIHZlcnNpb24gaXMgd2l0aGluIHJhbmdlXG4gICAgICAgICAgICAgICAgaWYgKGRhdGFbb2Zmc2V0ICsgM10gPCAweEZGICYmIGRhdGFbb2Zmc2V0ICsgNF0gPCAweEZGKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrIHNpemUgaXMgd2l0aGluIHJhbmdlXG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXRhW29mZnNldCArIDZdIDwgMHg4MCAmJiBkYXRhW29mZnNldCArIDddIDwgMHg4MCAmJiBkYXRhW29mZnNldCArIDhdIDwgMHg4MCAmJiBkYXRhW29mZnNldCArIDldIDwgMHg4MCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbnkgYWRqYWNlbnQgSUQzIHRhZ3MgZm91bmQgaW4gZGF0YSBzdGFydGluZyBhdCBvZmZzZXQsIGFzIG9uZSBibG9jayBvZiBkYXRhXG4gICAgICogQHBhcmFtIHtVaW50OEFycmF5fSBkYXRhIC0gVGhlIGRhdGEgdG8gc2VhcmNoIGluXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCAtIFRoZSBvZmZzZXQgYXQgd2hpY2ggdG8gc3RhcnQgc2VhcmNoaW5nXG4gICAgICogQHJldHVybiB7VWludDhBcnJheX0gLSBUaGUgYmxvY2sgb2YgZGF0YSBjb250YWluaW5nIGFueSBJRDMgdGFncyBmb3VuZFxuICAgICAqL1xuICAgIElEMy5nZXRJRDNEYXRhID0gZnVuY3Rpb24gKGRhdGEsIG9mZnNldCkge1xuICAgICAgICB2YXIgZnJvbnQgPSBvZmZzZXQ7XG4gICAgICAgIHZhciBsZW5ndGggPSAwO1xuICAgICAgICB3aGlsZSAoSUQzLmlzSGVhZGVyKGRhdGEsIG9mZnNldCkpIHtcbiAgICAgICAgICAgIC8vIElEMyBoZWFkZXIgaXMgMTAgYnl0ZXNcbiAgICAgICAgICAgIGxlbmd0aCArPSAxMDtcbiAgICAgICAgICAgIHZhciBzaXplID0gSUQzLl9yZWFkU2l6ZShkYXRhLCBvZmZzZXQgKyA2KTtcbiAgICAgICAgICAgIGxlbmd0aCArPSBzaXplO1xuICAgICAgICAgICAgaWYgKElEMy5pc0Zvb3RlcihkYXRhLCBvZmZzZXQgKyAxMCkpIHtcbiAgICAgICAgICAgICAgICAvLyBJRDMgZm9vdGVyIGlzIDEwIGJ5dGVzXG4gICAgICAgICAgICAgICAgbGVuZ3RoICs9IDEwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2Zmc2V0ICs9IGxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGEuc3ViYXJyYXkoZnJvbnQsIGZyb250ICsgbGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH07XG4gICAgSUQzLl9yZWFkU2l6ZSA9IGZ1bmN0aW9uIChkYXRhLCBvZmZzZXQpIHtcbiAgICAgICAgdmFyIHNpemUgPSAwO1xuICAgICAgICBzaXplID0gKChkYXRhW29mZnNldF0gJiAweDdmKSA8PCAyMSk7XG4gICAgICAgIHNpemUgfD0gKChkYXRhW29mZnNldCArIDFdICYgMHg3ZikgPDwgMTQpO1xuICAgICAgICBzaXplIHw9ICgoZGF0YVtvZmZzZXQgKyAyXSAmIDB4N2YpIDw8IDcpO1xuICAgICAgICBzaXplIHw9IChkYXRhW29mZnNldCArIDNdICYgMHg3Zik7XG4gICAgICAgIHJldHVybiBzaXplO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2VhcmNoZXMgZm9yIHRoZSBFbGVtZW50YXJ5IFN0cmVhbSB0aW1lc3RhbXAgZm91bmQgaW4gdGhlIElEMyBkYXRhIGNodW5rXG4gICAgICogQHBhcmFtIHtVaW50OEFycmF5fSBkYXRhIC0gQmxvY2sgb2YgZGF0YSBjb250YWluaW5nIG9uZSBvciBtb3JlIElEMyB0YWdzXG4gICAgICogQHJldHVybiB7bnVtYmVyfSAtIFRoZSB0aW1lc3RhbXBcbiAgICAgKi9cbiAgICBJRDMuZ2V0VGltZVN0YW1wID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdmFyIGZyYW1lcyA9IElEMy5nZXRJRDNGcmFtZXMoZGF0YSk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZnJhbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgZnJhbWUgPSBmcmFtZXNbaV07XG4gICAgICAgICAgICBpZiAoSUQzLmlzVGltZVN0YW1wRnJhbWUoZnJhbWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIElEMy5fcmVhZFRpbWVTdGFtcChmcmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgSUQzIGZyYW1lIGlzIGFuIEVsZW1lbnRhcnkgU3RyZWFtIHRpbWVzdGFtcCBmcmFtZVxuICAgICAqIEBwYXJhbSB7SUQzIGZyYW1lfSBmcmFtZVxuICAgICAqL1xuICAgIElEMy5pc1RpbWVTdGFtcEZyYW1lID0gZnVuY3Rpb24gKGZyYW1lKSB7XG4gICAgICAgIHJldHVybiAoZnJhbWUgJiYgZnJhbWUua2V5ID09PSAnUFJJVicgJiYgZnJhbWUuaW5mbyA9PT0gJ2NvbS5hcHBsZS5zdHJlYW1pbmcudHJhbnNwb3J0U3RyZWFtVGltZXN0YW1wJyk7XG4gICAgfTtcbiAgICBJRDMuX2dldEZyYW1lRGF0YSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIC8qXG4gICAgICAgIEZyYW1lIElEICAgICAgICR4eCB4eCB4eCB4eCAoZm91ciBjaGFyYWN0ZXJzKVxuICAgICAgICBTaXplICAgICAgICAgICAkeHggeHggeHggeHhcbiAgICAgICAgRmxhZ3MgICAgICAgICAgJHh4IHh4XG4gICAgICAgICovXG4gICAgICAgIHZhciB0eXBlID0gU3RyaW5nLmZyb21DaGFyQ29kZShkYXRhWzBdLCBkYXRhWzFdLCBkYXRhWzJdLCBkYXRhWzNdKTtcbiAgICAgICAgdmFyIHNpemUgPSBJRDMuX3JlYWRTaXplKGRhdGEsIDQpO1xuICAgICAgICAvLyBza2lwIGZyYW1lIGlkLCBzaXplLCBhbmQgZmxhZ3NcbiAgICAgICAgdmFyIG9mZnNldCA9IDEwO1xuICAgICAgICByZXR1cm4geyB0eXBlOiB0eXBlLCBzaXplOiBzaXplLCBkYXRhOiBkYXRhLnN1YmFycmF5KG9mZnNldCwgb2Zmc2V0ICsgc2l6ZSkgfTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gYXJyYXkgb2YgSUQzIGZyYW1lcyBmb3VuZCBpbiBhbGwgdGhlIElEMyB0YWdzIGluIHRoZSBpZDNEYXRhXG4gICAgICogQHBhcmFtIHtVaW50OEFycmF5fSBpZDNEYXRhIC0gVGhlIElEMyBkYXRhIGNvbnRhaW5pbmcgb25lIG9yIG1vcmUgSUQzIHRhZ3NcbiAgICAgKiBAcmV0dXJuIHtJRDMgZnJhbWVbXX0gLSBBcnJheSBvZiBJRDMgZnJhbWUgb2JqZWN0c1xuICAgICAqL1xuICAgIElEMy5nZXRJRDNGcmFtZXMgPSBmdW5jdGlvbiAoaWQzRGF0YSkge1xuICAgICAgICB2YXIgb2Zmc2V0ID0gMDtcbiAgICAgICAgdmFyIGZyYW1lcyA9IFtdO1xuICAgICAgICB3aGlsZSAoSUQzLmlzSGVhZGVyKGlkM0RhdGEsIG9mZnNldCkpIHtcbiAgICAgICAgICAgIHZhciBzaXplID0gSUQzLl9yZWFkU2l6ZShpZDNEYXRhLCBvZmZzZXQgKyA2KTtcbiAgICAgICAgICAgIC8vIHNraXAgcGFzdCBJRDMgaGVhZGVyXG4gICAgICAgICAgICBvZmZzZXQgKz0gMTA7XG4gICAgICAgICAgICB2YXIgZW5kID0gb2Zmc2V0ICsgc2l6ZTtcbiAgICAgICAgICAgIC8vIGxvb3AgdGhyb3VnaCBmcmFtZXMgaW4gdGhlIElEMyB0YWdcbiAgICAgICAgICAgIHdoaWxlIChvZmZzZXQgKyA4IDwgZW5kKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZyYW1lRGF0YSA9IElEMy5fZ2V0RnJhbWVEYXRhKGlkM0RhdGEuc3ViYXJyYXkob2Zmc2V0KSk7XG4gICAgICAgICAgICAgICAgdmFyIGZyYW1lID0gSUQzLl9kZWNvZGVGcmFtZShmcmFtZURhdGEpO1xuICAgICAgICAgICAgICAgIGlmIChmcmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBmcmFtZXMucHVzaChmcmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHNraXAgZnJhbWUgaGVhZGVyIGFuZCBmcmFtZSBkYXRhXG4gICAgICAgICAgICAgICAgb2Zmc2V0ICs9IGZyYW1lRGF0YS5zaXplICsgMTA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoSUQzLmlzRm9vdGVyKGlkM0RhdGEsIG9mZnNldCkpIHtcbiAgICAgICAgICAgICAgICBvZmZzZXQgKz0gMTA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZyYW1lcztcbiAgICB9O1xuICAgIElEMy5fZGVjb2RlRnJhbWUgPSBmdW5jdGlvbiAoZnJhbWUpIHtcbiAgICAgICAgaWYgKGZyYW1lLnR5cGUgPT09ICdQUklWJykge1xuICAgICAgICAgICAgcmV0dXJuIElEMy5fZGVjb2RlUHJpdkZyYW1lKGZyYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChmcmFtZS50eXBlWzBdID09PSAnVCcpIHtcbiAgICAgICAgICAgIHJldHVybiBJRDMuX2RlY29kZVRleHRGcmFtZShmcmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZnJhbWUudHlwZVswXSA9PT0gJ1cnKSB7XG4gICAgICAgICAgICByZXR1cm4gSUQzLl9kZWNvZGVVUkxGcmFtZShmcmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9O1xuICAgIElEMy5fcmVhZFRpbWVTdGFtcCA9IGZ1bmN0aW9uICh0aW1lU3RhbXBGcmFtZSkge1xuICAgICAgICBpZiAodGltZVN0YW1wRnJhbWUuZGF0YS5ieXRlTGVuZ3RoID09PSA4KSB7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IG5ldyBVaW50OEFycmF5KHRpbWVTdGFtcEZyYW1lLmRhdGEpO1xuICAgICAgICAgICAgLy8gdGltZXN0YW1wIGlzIDMzIGJpdCBleHByZXNzZWQgYXMgYSBiaWctZW5kaWFuIGVpZ2h0LW9jdGV0IG51bWJlcixcbiAgICAgICAgICAgIC8vIHdpdGggdGhlIHVwcGVyIDMxIGJpdHMgc2V0IHRvIHplcm8uXG4gICAgICAgICAgICB2YXIgcHRzMzNCaXQgPSBkYXRhWzNdICYgMHgxO1xuICAgICAgICAgICAgdmFyIHRpbWVzdGFtcCA9IChkYXRhWzRdIDw8IDIzKSArXG4gICAgICAgICAgICAgICAgKGRhdGFbNV0gPDwgMTUpICtcbiAgICAgICAgICAgICAgICAoZGF0YVs2XSA8PCA3KSArXG4gICAgICAgICAgICAgICAgZGF0YVs3XTtcbiAgICAgICAgICAgIHRpbWVzdGFtcCAvPSA0NTtcbiAgICAgICAgICAgIGlmIChwdHMzM0JpdCkge1xuICAgICAgICAgICAgICAgIHRpbWVzdGFtcCArPSA0NzcyMTg1OC44NDtcbiAgICAgICAgICAgIH0gLy8gMl4zMiAvIDkwXG4gICAgICAgICAgICByZXR1cm4gTWF0aC5yb3VuZCh0aW1lc3RhbXApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfTtcbiAgICBJRDMuX2RlY29kZVByaXZGcmFtZSA9IGZ1bmN0aW9uIChmcmFtZSkge1xuICAgICAgICAvKlxuICAgICAgICBGb3JtYXQ6IDx0ZXh0IHN0cmluZz5cXDA8YmluYXJ5IGRhdGE+XG4gICAgICAgICovXG4gICAgICAgIGlmIChmcmFtZS5zaXplIDwgMikge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb3duZXIgPSBJRDMuX3V0ZjhBcnJheVRvU3RyKGZyYW1lLmRhdGEsIHRydWUpO1xuICAgICAgICB2YXIgcHJpdmF0ZURhdGEgPSBuZXcgVWludDhBcnJheShmcmFtZS5kYXRhLnN1YmFycmF5KG93bmVyLmxlbmd0aCArIDEpKTtcbiAgICAgICAgcmV0dXJuIHsga2V5OiBmcmFtZS50eXBlLCBpbmZvOiBvd25lciwgZGF0YTogcHJpdmF0ZURhdGEuYnVmZmVyIH07XG4gICAgfTtcbiAgICBJRDMuX2RlY29kZVRleHRGcmFtZSA9IGZ1bmN0aW9uIChmcmFtZSkge1xuICAgICAgICBpZiAoZnJhbWUuc2l6ZSA8IDIpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZyYW1lLnR5cGUgPT09ICdUWFhYJykge1xuICAgICAgICAgICAgLypcbiAgICAgICAgICAgIEZvcm1hdDpcbiAgICAgICAgICAgIFswXSAgID0ge1RleHQgRW5jb2Rpbmd9XG4gICAgICAgICAgICBbMS0/XSA9IHtEZXNjcmlwdGlvbn1cXDB7VmFsdWV9XG4gICAgICAgICAgICAqL1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gMTtcbiAgICAgICAgICAgIHZhciBkZXNjcmlwdGlvbiA9IElEMy5fdXRmOEFycmF5VG9TdHIoZnJhbWUuZGF0YS5zdWJhcnJheShpbmRleCkpO1xuICAgICAgICAgICAgaW5kZXggKz0gZGVzY3JpcHRpb24ubGVuZ3RoICsgMTtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IElEMy5fdXRmOEFycmF5VG9TdHIoZnJhbWUuZGF0YS5zdWJhcnJheShpbmRleCkpO1xuICAgICAgICAgICAgcmV0dXJuIHsga2V5OiBmcmFtZS50eXBlLCBpbmZvOiBkZXNjcmlwdGlvbiwgZGF0YTogdmFsdWUgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICBGb3JtYXQ6XG4gICAgICAgICAgICBbMF0gICA9IHtUZXh0IEVuY29kaW5nfVxuICAgICAgICAgICAgWzEtP10gPSB7VmFsdWV9XG4gICAgICAgICAgICAqL1xuICAgICAgICAgICAgdmFyIHRleHQgPSBJRDMuX3V0ZjhBcnJheVRvU3RyKGZyYW1lLmRhdGEuc3ViYXJyYXkoMSkpO1xuICAgICAgICAgICAgcmV0dXJuIHsga2V5OiBmcmFtZS50eXBlLCBkYXRhOiB0ZXh0IH07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIElEMy5fZGVjb2RlVVJMRnJhbWUgPSBmdW5jdGlvbiAoZnJhbWUpIHtcbiAgICAgICAgaWYgKGZyYW1lLnR5cGUgPT09ICdXWFhYJykge1xuICAgICAgICAgICAgLypcbiAgICAgICAgICAgIEZvcm1hdDpcbiAgICAgICAgICAgIFswXSAgID0ge1RleHQgRW5jb2Rpbmd9XG4gICAgICAgICAgICBbMS0/XSA9IHtEZXNjcmlwdGlvbn1cXDB7VVJMfVxuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmIChmcmFtZS5zaXplIDwgMikge1xuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgaW5kZXggPSAxO1xuICAgICAgICAgICAgdmFyIGRlc2NyaXB0aW9uID0gSUQzLl91dGY4QXJyYXlUb1N0cihmcmFtZS5kYXRhLnN1YmFycmF5KGluZGV4KSk7XG4gICAgICAgICAgICBpbmRleCArPSBkZXNjcmlwdGlvbi5sZW5ndGggKyAxO1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gSUQzLl91dGY4QXJyYXlUb1N0cihmcmFtZS5kYXRhLnN1YmFycmF5KGluZGV4KSk7XG4gICAgICAgICAgICByZXR1cm4geyBrZXk6IGZyYW1lLnR5cGUsIGluZm86IGRlc2NyaXB0aW9uLCBkYXRhOiB2YWx1ZSB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLypcbiAgICAgICAgICAgIEZvcm1hdDpcbiAgICAgICAgICAgIFswLT9dID0ge1VSTH1cbiAgICAgICAgICAgICovXG4gICAgICAgICAgICB2YXIgdXJsID0gSUQzLl91dGY4QXJyYXlUb1N0cihmcmFtZS5kYXRhKTtcbiAgICAgICAgICAgIHJldHVybiB7IGtleTogZnJhbWUudHlwZSwgZGF0YTogdXJsIH07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvODkzNjk4NC91aW50OGFycmF5LXRvLXN0cmluZy1pbi1qYXZhc2NyaXB0LzIyMzczMTk3XG4gICAgLy8gaHR0cDovL3d3dy5vbmljb3MuY29tL3N0YWZmL2l6L2FtdXNlL2phdmFzY3JpcHQvZXhwZXJ0L3V0Zi50eHRcbiAgICAvKiB1dGYuanMgLSBVVEYtOCA8PT4gVVRGLTE2IGNvbnZlcnRpb25cbiAgICAgKlxuICAgICAqIENvcHlyaWdodCAoQykgMTk5OSBNYXNhbmFvIEl6dW1vIDxpekBvbmljb3MuY28uanA+XG4gICAgICogVmVyc2lvbjogMS4wXG4gICAgICogTGFzdE1vZGlmaWVkOiBEZWMgMjUgMTk5OVxuICAgICAqIFRoaXMgbGlicmFyeSBpcyBmcmVlLiAgWW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeSBpdC5cbiAgICAgKi9cbiAgICBJRDMuX3V0ZjhBcnJheVRvU3RyID0gZnVuY3Rpb24gKGFycmF5LCBleGl0T25OdWxsKSB7XG4gICAgICAgIGlmIChleGl0T25OdWxsID09PSB2b2lkIDApIHsgZXhpdE9uTnVsbCA9IGZhbHNlOyB9XG4gICAgICAgIHZhciBsZW4gPSBhcnJheS5sZW5ndGg7XG4gICAgICAgIHZhciBjO1xuICAgICAgICB2YXIgY2hhcjI7XG4gICAgICAgIHZhciBjaGFyMztcbiAgICAgICAgdmFyIG91dCA9ICcnO1xuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgICAgICAgICBjID0gYXJyYXlbaSsrXTtcbiAgICAgICAgICAgIGlmIChjID09PSAweDAwICYmIGV4aXRPbk51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYyA9PT0gMHgwMCB8fCBjID09PSAweDAzKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIGNoYXJhY3RlciBpcyAzIChFTkRfT0ZfVEVYVCkgb3IgMCAoTlVMTCkgdGhlbiBza2lwIGl0XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzd2l0Y2ggKGMgPj4gNCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgICAgIC8vIDB4eHh4eHh4XG4gICAgICAgICAgICAgICAgICAgIG91dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgICAgICAgICAgIC8vIDExMHggeHh4eCAgIDEweHggeHh4eFxuICAgICAgICAgICAgICAgICAgICBjaGFyMiA9IGFycmF5W2krK107XG4gICAgICAgICAgICAgICAgICAgIG91dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCgoYyAmIDB4MUYpIDw8IDYpIHwgKGNoYXIyICYgMHgzRikpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDE0OlxuICAgICAgICAgICAgICAgICAgICAvLyAxMTEwIHh4eHggIDEweHggeHh4eCAgMTB4eCB4eHh4XG4gICAgICAgICAgICAgICAgICAgIGNoYXIyID0gYXJyYXlbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgY2hhcjMgPSBhcnJheVtpKytdO1xuICAgICAgICAgICAgICAgICAgICBvdXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoKGMgJiAweDBGKSA8PCAxMikgfFxuICAgICAgICAgICAgICAgICAgICAgICAgKChjaGFyMiAmIDB4M0YpIDw8IDYpIHxcbiAgICAgICAgICAgICAgICAgICAgICAgICgoY2hhcjMgJiAweDNGKSA8PCAwKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9O1xuICAgIHJldHVybiBJRDM7XG59KCkpO1xudmFyIHV0ZjhBcnJheVRvU3RyID0gSUQzLl91dGY4QXJyYXlUb1N0cjtcbmV4cG9ydHMudXRmOEFycmF5VG9TdHIgPSB1dGY4QXJyYXlUb1N0cjtcbmV4cG9ydHMuZGVmYXVsdCA9IElEMztcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9kZW11eC9tcDNkZW11eGVyLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvZGVtdXgvbXAzZGVtdXhlci5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIE1QMyBkZW11eGVyXG4gKi9cbnZhciBpZDNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2RlbXV4L2lkMyAqLyBcIi4vc3JjL2RlbXV4L2lkMy5qc1wiKTtcbnZhciBsb2dnZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL2xvZ2dlciAqLyBcIi4vc3JjL3V0aWxzL2xvZ2dlci5qc1wiKTtcbnZhciBtcGVnYXVkaW9fMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vbXBlZ2F1ZGlvICovIFwiLi9zcmMvZGVtdXgvbXBlZ2F1ZGlvLmpzXCIpO1xudmFyIE1QM0RlbXV4ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTVAzRGVtdXhlcihvYnNlcnZlciwgcmVtdXhlciwgY29uZmlnKSB7XG4gICAgICAgIHRoaXMub2JzZXJ2ZXIgPSBvYnNlcnZlcjtcbiAgICAgICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgICAgIHRoaXMucmVtdXhlciA9IHJlbXV4ZXI7XG4gICAgfVxuICAgIE1QM0RlbXV4ZXIucHJvdG90eXBlLnJlc2V0SW5pdFNlZ21lbnQgPSBmdW5jdGlvbiAoaW5pdFNlZ21lbnQsIGF1ZGlvQ29kZWMsIHZpZGVvQ29kZWMsIGR1cmF0aW9uKSB7XG4gICAgICAgIHRoaXMuX2F1ZGlvVHJhY2sgPSB7IGNvbnRhaW5lcjogJ2F1ZGlvL21wZWcnLCB0eXBlOiAnYXVkaW8nLCBpZDogLTEsIHNlcXVlbmNlTnVtYmVyOiAwLCBpc0FBQzogZmFsc2UsIHNhbXBsZXM6IFtdLCBsZW46IDAsIG1hbmlmZXN0Q29kZWM6IGF1ZGlvQ29kZWMsIGR1cmF0aW9uOiBkdXJhdGlvbiwgaW5wdXRUaW1lU2NhbGU6IDkwMDAwIH07XG4gICAgfTtcbiAgICBNUDNEZW11eGVyLnByb3RvdHlwZS5yZXNldFRpbWVTdGFtcCA9IGZ1bmN0aW9uICgpIHtcbiAgICB9O1xuICAgIE1QM0RlbXV4ZXIucHJvYmUgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAvLyBjaGVjayBpZiBkYXRhIGNvbnRhaW5zIElEMyB0aW1lc3RhbXAgYW5kIE1QRUcgc3luYyB3b3JkXG4gICAgICAgIHZhciBvZmZzZXQsIGxlbmd0aDtcbiAgICAgICAgdmFyIGlkM0RhdGEgPSBpZDNfMS5kZWZhdWx0LmdldElEM0RhdGEoZGF0YSwgMCk7XG4gICAgICAgIGlmIChpZDNEYXRhICYmIGlkM18xLmRlZmF1bHQuZ2V0VGltZVN0YW1wKGlkM0RhdGEpICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIExvb2sgZm9yIE1QRUcgaGVhZGVyIHwgMTExMSAxMTExIHwgMTExWCBYWVpYIHwgd2hlcmUgWCBjYW4gYmUgZWl0aGVyIDAgb3IgMSBhbmQgWSBvciBaIHNob3VsZCBiZSAxXG4gICAgICAgICAgICAvLyBMYXllciBiaXRzIChwb3NpdGlvbiAxNCBhbmQgMTUpIGluIGhlYWRlciBzaG91bGQgYmUgYWx3YXlzIGRpZmZlcmVudCBmcm9tIDAgKExheWVyIEkgb3IgTGF5ZXIgSUkgb3IgTGF5ZXIgSUlJKVxuICAgICAgICAgICAgLy8gTW9yZSBpbmZvIGh0dHA6Ly93d3cubXAzLXRlY2gub3JnL3Byb2dyYW1tZXIvZnJhbWVfaGVhZGVyLmh0bWxcbiAgICAgICAgICAgIGZvciAob2Zmc2V0ID0gaWQzRGF0YS5sZW5ndGgsIGxlbmd0aCA9IE1hdGgubWluKGRhdGEubGVuZ3RoIC0gMSwgb2Zmc2V0ICsgMTAwKTsgb2Zmc2V0IDwgbGVuZ3RoOyBvZmZzZXQrKykge1xuICAgICAgICAgICAgICAgIGlmIChtcGVnYXVkaW9fMS5kZWZhdWx0LnByb2JlKGRhdGEsIG9mZnNldCkpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLmxvZygnTVBFRyBBdWRpbyBzeW5jIHdvcmQgZm91bmQgIScpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgLy8gZmVlZCBpbmNvbWluZyBkYXRhIHRvIHRoZSBmcm9udCBvZiB0aGUgcGFyc2luZyBwaXBlbGluZVxuICAgIE1QM0RlbXV4ZXIucHJvdG90eXBlLmFwcGVuZCA9IGZ1bmN0aW9uIChkYXRhLCB0aW1lT2Zmc2V0LCBjb250aWd1b3VzLCBhY2N1cmF0ZVRpbWVPZmZzZXQpIHtcbiAgICAgICAgdmFyIGlkM0RhdGEgPSBpZDNfMS5kZWZhdWx0LmdldElEM0RhdGEoZGF0YSwgMCk7XG4gICAgICAgIHZhciB0aW1lc3RhbXAgPSBpZDNfMS5kZWZhdWx0LmdldFRpbWVTdGFtcChpZDNEYXRhKTtcbiAgICAgICAgdmFyIHB0cyA9IHRpbWVzdGFtcCA/IDkwICogdGltZXN0YW1wIDogdGltZU9mZnNldCAqIDkwMDAwO1xuICAgICAgICB2YXIgb2Zmc2V0ID0gaWQzRGF0YS5sZW5ndGg7XG4gICAgICAgIHZhciBsZW5ndGggPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgdmFyIGZyYW1lSW5kZXggPSAwLCBzdGFtcCA9IDA7XG4gICAgICAgIHZhciB0cmFjayA9IHRoaXMuX2F1ZGlvVHJhY2s7XG4gICAgICAgIHZhciBpZDNTYW1wbGVzID0gW3sgcHRzOiBwdHMsIGR0czogcHRzLCBkYXRhOiBpZDNEYXRhIH1dO1xuICAgICAgICB3aGlsZSAob2Zmc2V0IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAobXBlZ2F1ZGlvXzEuZGVmYXVsdC5pc0hlYWRlcihkYXRhLCBvZmZzZXQpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZyYW1lID0gbXBlZ2F1ZGlvXzEuZGVmYXVsdC5hcHBlbmRGcmFtZSh0cmFjaywgZGF0YSwgb2Zmc2V0LCBwdHMsIGZyYW1lSW5kZXgpO1xuICAgICAgICAgICAgICAgIGlmIChmcmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBvZmZzZXQgKz0gZnJhbWUubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBzdGFtcCA9IGZyYW1lLnNhbXBsZS5wdHM7XG4gICAgICAgICAgICAgICAgICAgIGZyYW1lSW5kZXgrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGxvZ2dlci5sb2coJ1VuYWJsZSB0byBwYXJzZSBNcGVnIGF1ZGlvIGZyYW1lJyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlkM18xLmRlZmF1bHQuaXNIZWFkZXIoZGF0YSwgb2Zmc2V0KSkge1xuICAgICAgICAgICAgICAgIGlkM0RhdGEgPSBpZDNfMS5kZWZhdWx0LmdldElEM0RhdGEoZGF0YSwgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBpZDNTYW1wbGVzLnB1c2goeyBwdHM6IHN0YW1wLCBkdHM6IHN0YW1wLCBkYXRhOiBpZDNEYXRhIH0pO1xuICAgICAgICAgICAgICAgIG9mZnNldCArPSBpZDNEYXRhLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIG5vdGhpbmcgZm91bmQsIGtlZXAgbG9va2luZ1xuICAgICAgICAgICAgICAgIG9mZnNldCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVtdXhlci5yZW11eCh0cmFjaywgeyBzYW1wbGVzOiBbXSB9LCB7IHNhbXBsZXM6IGlkM1NhbXBsZXMsIGlucHV0VGltZVNjYWxlOiA5MDAwMCB9LCB7IHNhbXBsZXM6IFtdIH0sIHRpbWVPZmZzZXQsIGNvbnRpZ3VvdXMsIGFjY3VyYXRlVGltZU9mZnNldCk7XG4gICAgfTtcbiAgICBNUDNEZW11eGVyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgIH07XG4gICAgcmV0dXJuIE1QM0RlbXV4ZXI7XG59KCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gTVAzRGVtdXhlcjtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9kZW11eC9tcDRkZW11eGVyLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvZGVtdXgvbXA0ZGVtdXhlci5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIE1QNCBkZW11eGVyXG4gKi9cbnZhciBsb2dnZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL2xvZ2dlciAqLyBcIi4vc3JjL3V0aWxzL2xvZ2dlci5qc1wiKTtcbnZhciBldmVudHNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2V2ZW50cyAqLyBcIi4vc3JjL2V2ZW50cy5qc1wiKTtcbnZhciBVSU5UMzJfTUFYID0gTWF0aC5wb3coMiwgMzIpIC0gMTtcbnZhciBNUDREZW11eGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1QNERlbXV4ZXIob2JzZXJ2ZXIsIHJlbXV4ZXIpIHtcbiAgICAgICAgdGhpcy5vYnNlcnZlciA9IG9ic2VydmVyO1xuICAgICAgICB0aGlzLnJlbXV4ZXIgPSByZW11eGVyO1xuICAgIH1cbiAgICBNUDREZW11eGVyLnByb3RvdHlwZS5yZXNldFRpbWVTdGFtcCA9IGZ1bmN0aW9uIChpbml0UFRTKSB7XG4gICAgICAgIHRoaXMuaW5pdFBUUyA9IGluaXRQVFM7XG4gICAgfTtcbiAgICBNUDREZW11eGVyLnByb3RvdHlwZS5yZXNldEluaXRTZWdtZW50ID0gZnVuY3Rpb24gKGluaXRTZWdtZW50LCBhdWRpb0NvZGVjLCB2aWRlb0NvZGVjLCBkdXJhdGlvbikge1xuICAgICAgICAvLyBqc2hpbnQgdW51c2VkOmZhbHNlXG4gICAgICAgIGlmIChpbml0U2VnbWVudCAmJiBpbml0U2VnbWVudC5ieXRlTGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgaW5pdERhdGEgPSB0aGlzLmluaXREYXRhID0gTVA0RGVtdXhlci5wYXJzZUluaXRTZWdtZW50KGluaXRTZWdtZW50KTtcbiAgICAgICAgICAgIC8vIGRlZmF1bHQgYXVkaW8gY29kZWMgaWYgbm90aGluZyBzcGVjaWZpZWRcbiAgICAgICAgICAgIC8vIFRPRE8gOiBleHRyYWN0IHRoYXQgZnJvbSBpbml0c2VnbWVudFxuICAgICAgICAgICAgaWYgKGF1ZGlvQ29kZWMgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGF1ZGlvQ29kZWMgPSAnbXA0YS40MC41JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2aWRlb0NvZGVjID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB2aWRlb0NvZGVjID0gJ2F2YzEuNDJlMDFlJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB0cmFja3MgPSB7fTtcbiAgICAgICAgICAgIGlmIChpbml0RGF0YS5hdWRpbyAmJiBpbml0RGF0YS52aWRlbykge1xuICAgICAgICAgICAgICAgIHRyYWNrcy5hdWRpb3ZpZGVvID0geyBjb250YWluZXI6ICd2aWRlby9tcDQnLCBjb2RlYzogYXVkaW9Db2RlYyArICcsJyArIHZpZGVvQ29kZWMsIGluaXRTZWdtZW50OiBkdXJhdGlvbiA/IGluaXRTZWdtZW50IDogbnVsbCB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGluaXREYXRhLmF1ZGlvKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyYWNrcy5hdWRpbyA9IHsgY29udGFpbmVyOiAnYXVkaW8vbXA0JywgY29kZWM6IGF1ZGlvQ29kZWMsIGluaXRTZWdtZW50OiBkdXJhdGlvbiA/IGluaXRTZWdtZW50IDogbnVsbCB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaW5pdERhdGEudmlkZW8pIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhY2tzLnZpZGVvID0geyBjb250YWluZXI6ICd2aWRlby9tcDQnLCBjb2RlYzogdmlkZW9Db2RlYywgaW5pdFNlZ21lbnQ6IGR1cmF0aW9uID8gaW5pdFNlZ21lbnQgOiBudWxsIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5vYnNlcnZlci50cmlnZ2VyKGV2ZW50c18xLmRlZmF1bHQuRlJBR19QQVJTSU5HX0lOSVRfU0VHTUVOVCwgeyB0cmFja3M6IHRyYWNrcyB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChhdWRpb0NvZGVjKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hdWRpb0NvZGVjID0gYXVkaW9Db2RlYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2aWRlb0NvZGVjKSB7XG4gICAgICAgICAgICAgICAgdGhpcy52aWRlb0NvZGVjID0gdmlkZW9Db2RlYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgTVA0RGVtdXhlci5wcm9iZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIC8vIGVuc3VyZSB3ZSBmaW5kIGEgbW9vZiBib3ggaW4gdGhlIGZpcnN0IDE2IGtCXG4gICAgICAgIHJldHVybiBNUDREZW11eGVyLmZpbmRCb3goeyBkYXRhOiBkYXRhLCBzdGFydDogMCwgZW5kOiBNYXRoLm1pbihkYXRhLmxlbmd0aCwgMTYzODQpIH0sIFsnbW9vZiddKS5sZW5ndGggPiAwO1xuICAgIH07XG4gICAgTVA0RGVtdXhlci5iaW4yc3RyID0gZnVuY3Rpb24gKGJ1ZmZlcikge1xuICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBidWZmZXIpO1xuICAgIH07XG4gICAgTVA0RGVtdXhlci5yZWFkVWludDE2ID0gZnVuY3Rpb24gKGJ1ZmZlciwgb2Zmc2V0KSB7XG4gICAgICAgIGlmIChidWZmZXIuZGF0YSkge1xuICAgICAgICAgICAgb2Zmc2V0ICs9IGJ1ZmZlci5zdGFydDtcbiAgICAgICAgICAgIGJ1ZmZlciA9IGJ1ZmZlci5kYXRhO1xuICAgICAgICB9XG4gICAgICAgIHZhciB2YWwgPSBidWZmZXJbb2Zmc2V0XSA8PCA4IHxcbiAgICAgICAgICAgIGJ1ZmZlcltvZmZzZXQgKyAxXTtcbiAgICAgICAgcmV0dXJuIHZhbCA8IDAgPyA2NTUzNiArIHZhbCA6IHZhbDtcbiAgICB9O1xuICAgIE1QNERlbXV4ZXIucmVhZFVpbnQzMiA9IGZ1bmN0aW9uIChidWZmZXIsIG9mZnNldCkge1xuICAgICAgICBpZiAoYnVmZmVyLmRhdGEpIHtcbiAgICAgICAgICAgIG9mZnNldCArPSBidWZmZXIuc3RhcnQ7XG4gICAgICAgICAgICBidWZmZXIgPSBidWZmZXIuZGF0YTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdmFsID0gYnVmZmVyW29mZnNldF0gPDwgMjQgfFxuICAgICAgICAgICAgYnVmZmVyW29mZnNldCArIDFdIDw8IDE2IHxcbiAgICAgICAgICAgIGJ1ZmZlcltvZmZzZXQgKyAyXSA8PCA4IHxcbiAgICAgICAgICAgIGJ1ZmZlcltvZmZzZXQgKyAzXTtcbiAgICAgICAgcmV0dXJuIHZhbCA8IDAgPyA0Mjk0OTY3Mjk2ICsgdmFsIDogdmFsO1xuICAgIH07XG4gICAgTVA0RGVtdXhlci53cml0ZVVpbnQzMiA9IGZ1bmN0aW9uIChidWZmZXIsIG9mZnNldCwgdmFsdWUpIHtcbiAgICAgICAgaWYgKGJ1ZmZlci5kYXRhKSB7XG4gICAgICAgICAgICBvZmZzZXQgKz0gYnVmZmVyLnN0YXJ0O1xuICAgICAgICAgICAgYnVmZmVyID0gYnVmZmVyLmRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgYnVmZmVyW29mZnNldF0gPSB2YWx1ZSA+PiAyNDtcbiAgICAgICAgYnVmZmVyW29mZnNldCArIDFdID0gKHZhbHVlID4+IDE2KSAmIDB4ZmY7XG4gICAgICAgIGJ1ZmZlcltvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+PiA4KSAmIDB4ZmY7XG4gICAgICAgIGJ1ZmZlcltvZmZzZXQgKyAzXSA9IHZhbHVlICYgMHhmZjtcbiAgICB9O1xuICAgIC8vIEZpbmQgdGhlIGRhdGEgZm9yIGEgYm94IHNwZWNpZmllZCBieSBpdHMgcGF0aFxuICAgIE1QNERlbXV4ZXIuZmluZEJveCA9IGZ1bmN0aW9uIChkYXRhLCBwYXRoKSB7XG4gICAgICAgIHZhciByZXN1bHRzID0gW10sIGksIHNpemUsIHR5cGUsIGVuZCwgc3VicmVzdWx0cywgc3RhcnQsIGVuZGJveDtcbiAgICAgICAgaWYgKGRhdGEuZGF0YSkge1xuICAgICAgICAgICAgc3RhcnQgPSBkYXRhLnN0YXJ0O1xuICAgICAgICAgICAgZW5kID0gZGF0YS5lbmQ7XG4gICAgICAgICAgICBkYXRhID0gZGF0YS5kYXRhO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RhcnQgPSAwO1xuICAgICAgICAgICAgZW5kID0gZGF0YS5ieXRlTGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcGF0aC5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIHNob3J0LWNpcmN1aXQgdGhlIHNlYXJjaCBmb3IgZW1wdHkgcGF0aHNcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOykge1xuICAgICAgICAgICAgc2l6ZSA9IE1QNERlbXV4ZXIucmVhZFVpbnQzMihkYXRhLCBpKTtcbiAgICAgICAgICAgIHR5cGUgPSBNUDREZW11eGVyLmJpbjJzdHIoZGF0YS5zdWJhcnJheShpICsgNCwgaSArIDgpKTtcbiAgICAgICAgICAgIGVuZGJveCA9IHNpemUgPiAxID8gaSArIHNpemUgOiBlbmQ7XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gcGF0aFswXSkge1xuICAgICAgICAgICAgICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIGlzIHRoZSBlbmQgb2YgdGhlIHBhdGggYW5kIHdlJ3ZlIGZvdW5kIHRoZSBib3ggd2Ugd2VyZVxuICAgICAgICAgICAgICAgICAgICAvLyBsb29raW5nIGZvclxuICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goeyBkYXRhOiBkYXRhLCBzdGFydDogaSArIDgsIGVuZDogZW5kYm94IH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVjdXJzaXZlbHkgc2VhcmNoIGZvciB0aGUgbmV4dCBib3ggYWxvbmcgdGhlIHBhdGhcbiAgICAgICAgICAgICAgICAgICAgc3VicmVzdWx0cyA9IE1QNERlbXV4ZXIuZmluZEJveCh7IGRhdGE6IGRhdGEsIHN0YXJ0OiBpICsgOCwgZW5kOiBlbmRib3ggfSwgcGF0aC5zbGljZSgxKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdWJyZXN1bHRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0cyA9IHJlc3VsdHMuY29uY2F0KHN1YnJlc3VsdHMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaSA9IGVuZGJveDtcbiAgICAgICAgfVxuICAgICAgICAvLyB3ZSd2ZSBmaW5pc2hlZCBzZWFyY2hpbmcgYWxsIG9mIGRhdGFcbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfTtcbiAgICBNUDREZW11eGVyLnBhcnNlU2VnbWVudEluZGV4ID0gZnVuY3Rpb24gKGluaXRTZWdtZW50KSB7XG4gICAgICAgIHZhciBtb292ID0gTVA0RGVtdXhlci5maW5kQm94KGluaXRTZWdtZW50LCBbJ21vb3YnXSlbMF07XG4gICAgICAgIHZhciBtb292RW5kT2Zmc2V0ID0gbW9vdiA/IG1vb3YuZW5kIDogbnVsbDsgLy8gd2UgbmVlZCB0aGlzIGluIGNhc2Ugd2UgbmVlZCB0byBjaG9wIG9mIGdhcmJhZ2Ugb2YgdGhlIGVuZCBvZiBjdXJyZW50IGRhdGFcbiAgICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgICAgdmFyIHNpZHggPSBNUDREZW11eGVyLmZpbmRCb3goaW5pdFNlZ21lbnQsIFsnc2lkeCddKTtcbiAgICAgICAgdmFyIHJlZmVyZW5jZXM7XG4gICAgICAgIGlmICghc2lkeCB8fCAhc2lkeFswXSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmVmZXJlbmNlcyA9IFtdO1xuICAgICAgICBzaWR4ID0gc2lkeFswXTtcbiAgICAgICAgdmFyIHZlcnNpb24gPSBzaWR4LmRhdGFbMF07XG4gICAgICAgIC8vIHNldCBpbml0aWFsIG9mZnNldCwgd2Ugc2tpcCB0aGUgcmVmZXJlbmNlIElEIChub3QgbmVlZGVkKVxuICAgICAgICBpbmRleCA9IHZlcnNpb24gPT09IDAgPyA4IDogMTY7XG4gICAgICAgIHZhciB0aW1lc2NhbGUgPSBNUDREZW11eGVyLnJlYWRVaW50MzIoc2lkeCwgaW5kZXgpO1xuICAgICAgICBpbmRleCArPSA0O1xuICAgICAgICAvLyBUT0RPOiBwYXJzZSBlYXJsaWVzdFByZXNlbnRhdGlvblRpbWUgYW5kIGZpcnN0T2Zmc2V0XG4gICAgICAgIC8vIHVzdWFsbHkgemVybyBpbiBvdXIgY2FzZVxuICAgICAgICB2YXIgZWFybGllc3RQcmVzZW50YXRpb25UaW1lID0gMDtcbiAgICAgICAgdmFyIGZpcnN0T2Zmc2V0ID0gMDtcbiAgICAgICAgaWYgKHZlcnNpb24gPT09IDApIHtcbiAgICAgICAgICAgIGluZGV4ICs9IDg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpbmRleCArPSAxNjtcbiAgICAgICAgfVxuICAgICAgICAvLyBza2lwIHJlc2VydmVkXG4gICAgICAgIGluZGV4ICs9IDI7XG4gICAgICAgIHZhciBzdGFydEJ5dGUgPSBzaWR4LmVuZCArIGZpcnN0T2Zmc2V0O1xuICAgICAgICB2YXIgcmVmZXJlbmNlc0NvdW50ID0gTVA0RGVtdXhlci5yZWFkVWludDE2KHNpZHgsIGluZGV4KTtcbiAgICAgICAgaW5kZXggKz0gMjtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZWZlcmVuY2VzQ291bnQ7IGkrKykge1xuICAgICAgICAgICAgdmFyIHJlZmVyZW5jZUluZGV4ID0gaW5kZXg7XG4gICAgICAgICAgICB2YXIgcmVmZXJlbmNlSW5mbyA9IE1QNERlbXV4ZXIucmVhZFVpbnQzMihzaWR4LCByZWZlcmVuY2VJbmRleCk7XG4gICAgICAgICAgICByZWZlcmVuY2VJbmRleCArPSA0O1xuICAgICAgICAgICAgdmFyIHJlZmVyZW5jZVNpemUgPSByZWZlcmVuY2VJbmZvICYgMHg3RkZGRkZGRjtcbiAgICAgICAgICAgIHZhciByZWZlcmVuY2VUeXBlID0gKHJlZmVyZW5jZUluZm8gJiAweDgwMDAwMDAwKSA+Pj4gMzE7XG4gICAgICAgICAgICBpZiAocmVmZXJlbmNlVHlwZSA9PT0gMSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignU0lEWCBoYXMgaGllcmFyY2hpY2FsIHJlZmVyZW5jZXMgKG5vdCBzdXBwb3J0ZWQpJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHN1YnNlZ21lbnREdXJhdGlvbiA9IE1QNERlbXV4ZXIucmVhZFVpbnQzMihzaWR4LCByZWZlcmVuY2VJbmRleCk7XG4gICAgICAgICAgICByZWZlcmVuY2VJbmRleCArPSA0O1xuICAgICAgICAgICAgcmVmZXJlbmNlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICByZWZlcmVuY2VTaXplOiByZWZlcmVuY2VTaXplLFxuICAgICAgICAgICAgICAgIHN1YnNlZ21lbnREdXJhdGlvbjogc3Vic2VnbWVudER1cmF0aW9uLFxuICAgICAgICAgICAgICAgIGluZm86IHtcbiAgICAgICAgICAgICAgICAgICAgZHVyYXRpb246IHN1YnNlZ21lbnREdXJhdGlvbiAvIHRpbWVzY2FsZSxcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0Qnl0ZSxcbiAgICAgICAgICAgICAgICAgICAgZW5kOiBzdGFydEJ5dGUgKyByZWZlcmVuY2VTaXplIC0gMVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc3RhcnRCeXRlICs9IHJlZmVyZW5jZVNpemU7XG4gICAgICAgICAgICAvLyBTa2lwcGluZyAxIGJpdCBmb3IgfHN0YXJ0c1dpdGhTYXB8LCAzIGJpdHMgZm9yIHxzYXBUeXBlfCwgYW5kIDI4IGJpdHNcbiAgICAgICAgICAgIC8vIGZvciB8c2FwRGVsdGF8LlxuICAgICAgICAgICAgcmVmZXJlbmNlSW5kZXggKz0gNDtcbiAgICAgICAgICAgIC8vIHNraXAgdG8gbmV4dCByZWZcbiAgICAgICAgICAgIGluZGV4ID0gcmVmZXJlbmNlSW5kZXg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGVhcmxpZXN0UHJlc2VudGF0aW9uVGltZTogZWFybGllc3RQcmVzZW50YXRpb25UaW1lLFxuICAgICAgICAgICAgdGltZXNjYWxlOiB0aW1lc2NhbGUsXG4gICAgICAgICAgICB2ZXJzaW9uOiB2ZXJzaW9uLFxuICAgICAgICAgICAgcmVmZXJlbmNlc0NvdW50OiByZWZlcmVuY2VzQ291bnQsXG4gICAgICAgICAgICByZWZlcmVuY2VzOiByZWZlcmVuY2VzLFxuICAgICAgICAgICAgbW9vdkVuZE9mZnNldDogbW9vdkVuZE9mZnNldFxuICAgICAgICB9O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUGFyc2VzIGFuIE1QNCBpbml0aWFsaXphdGlvbiBzZWdtZW50IGFuZCBleHRyYWN0cyBzdHJlYW0gdHlwZSBhbmRcbiAgICAgKiB0aW1lc2NhbGUgdmFsdWVzIGZvciBhbnkgZGVjbGFyZWQgdHJhY2tzLiBUaW1lc2NhbGUgdmFsdWVzIGluZGljYXRlIHRoZVxuICAgICAqIG51bWJlciBvZiBjbG9jayB0aWNrcyBwZXIgc2Vjb25kIHRvIGFzc3VtZSBmb3IgdGltZS1iYXNlZCB2YWx1ZXNcbiAgICAgKiBlbHNld2hlcmUgaW4gdGhlIE1QNC5cbiAgICAgKlxuICAgICAqIFRvIGRldGVybWluZSB0aGUgc3RhcnQgdGltZSBvZiBhbiBNUDQsIHlvdSBuZWVkIHR3byBwaWVjZXMgb2ZcbiAgICAgKiBpbmZvcm1hdGlvbjogdGhlIHRpbWVzY2FsZSB1bml0IGFuZCB0aGUgZWFybGllc3QgYmFzZSBtZWRpYSBkZWNvZGVcbiAgICAgKiB0aW1lLiBNdWx0aXBsZSB0aW1lc2NhbGVzIGNhbiBiZSBzcGVjaWZpZWQgd2l0aGluIGFuIE1QNCBidXQgdGhlXG4gICAgICogYmFzZSBtZWRpYSBkZWNvZGUgdGltZSBpcyBhbHdheXMgZXhwcmVzc2VkIGluIHRoZSB0aW1lc2NhbGUgZnJvbVxuICAgICAqIHRoZSBtZWRpYSBoZWFkZXIgYm94IGZvciB0aGUgdHJhY2s6XG4gICAgICogYGBgXG4gICAgICogbW9vdiA+IHRyYWsgPiBtZGlhID4gbWRoZC50aW1lc2NhbGVcbiAgICAgKiBtb292ID4gdHJhayA+IG1kaWEgPiBoZGxyXG4gICAgICogYGBgXG4gICAgICogQHBhcmFtIGluaXQge1VpbnQ4QXJyYXl9IHRoZSBieXRlcyBvZiB0aGUgaW5pdCBzZWdtZW50XG4gICAgICogQHJldHVybiB7b2JqZWN0fSBhIGhhc2ggb2YgdHJhY2sgdHlwZSB0byB0aW1lc2NhbGUgdmFsdWVzIG9yIG51bGwgaWZcbiAgICAgKiB0aGUgaW5pdCBzZWdtZW50IGlzIG1hbGZvcm1lZC5cbiAgICAgKi9cbiAgICBNUDREZW11eGVyLnBhcnNlSW5pdFNlZ21lbnQgPSBmdW5jdGlvbiAoaW5pdFNlZ21lbnQpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICB2YXIgdHJha3MgPSBNUDREZW11eGVyLmZpbmRCb3goaW5pdFNlZ21lbnQsIFsnbW9vdicsICd0cmFrJ10pO1xuICAgICAgICB0cmFrcy5mb3JFYWNoKGZ1bmN0aW9uICh0cmFrKSB7XG4gICAgICAgICAgICB2YXIgdGtoZCA9IE1QNERlbXV4ZXIuZmluZEJveCh0cmFrLCBbJ3RraGQnXSlbMF07XG4gICAgICAgICAgICBpZiAodGtoZCkge1xuICAgICAgICAgICAgICAgIHZhciB2ZXJzaW9uID0gdGtoZC5kYXRhW3RraGQuc3RhcnRdO1xuICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IHZlcnNpb24gPT09IDAgPyAxMiA6IDIwO1xuICAgICAgICAgICAgICAgIHZhciB0cmFja0lkID0gTVA0RGVtdXhlci5yZWFkVWludDMyKHRraGQsIGluZGV4KTtcbiAgICAgICAgICAgICAgICB2YXIgbWRoZCA9IE1QNERlbXV4ZXIuZmluZEJveCh0cmFrLCBbJ21kaWEnLCAnbWRoZCddKVswXTtcbiAgICAgICAgICAgICAgICBpZiAobWRoZCkge1xuICAgICAgICAgICAgICAgICAgICB2ZXJzaW9uID0gbWRoZC5kYXRhW21kaGQuc3RhcnRdO1xuICAgICAgICAgICAgICAgICAgICBpbmRleCA9IHZlcnNpb24gPT09IDAgPyAxMiA6IDIwO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGltZXNjYWxlID0gTVA0RGVtdXhlci5yZWFkVWludDMyKG1kaGQsIGluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGhkbHIgPSBNUDREZW11eGVyLmZpbmRCb3godHJhaywgWydtZGlhJywgJ2hkbHInXSlbMF07XG4gICAgICAgICAgICAgICAgICAgIGlmIChoZGxyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaGRsclR5cGUgPSBNUDREZW11eGVyLmJpbjJzdHIoaGRsci5kYXRhLnN1YmFycmF5KGhkbHIuc3RhcnQgKyA4LCBoZGxyLnN0YXJ0ICsgMTIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0eXBlID0geyAnc291bic6ICdhdWRpbycsICd2aWRlJzogJ3ZpZGVvJyB9W2hkbHJUeXBlXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXh0cmFjdCBjb2RlYyBpbmZvLiBUT0RPIDogcGFyc2UgY29kZWMgZGV0YWlscyB0byBiZSBhYmxlIHRvIGJ1aWxkIE1JTUUgdHlwZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb2RlY0JveCA9IE1QNERlbXV4ZXIuZmluZEJveCh0cmFrLCBbJ21kaWEnLCAnbWluZicsICdzdGJsJywgJ3N0c2QnXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvZGVjQm94Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlY0JveCA9IGNvZGVjQm94WzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29kZWNUeXBlID0gTVA0RGVtdXhlci5iaW4yc3RyKGNvZGVjQm94LmRhdGEuc3ViYXJyYXkoY29kZWNCb3guc3RhcnQgKyAxMiwgY29kZWNCb3guc3RhcnQgKyAxNikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXJfMS5sb2dnZXIubG9nKFwiTVA0RGVtdXhlcjpcIiArIHR5cGUgKyBcIjpcIiArIGNvZGVjVHlwZSArIFwiIGZvdW5kXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRbdHJhY2tJZF0gPSB7IHRpbWVzY2FsZTogdGltZXNjYWxlLCB0eXBlOiB0eXBlIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0W3R5cGVdID0geyB0aW1lc2NhbGU6IHRpbWVzY2FsZSwgaWQ6IHRyYWNrSWQgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICAvKipcbiAgICogRGV0ZXJtaW5lIHRoZSBiYXNlIG1lZGlhIGRlY29kZSBzdGFydCB0aW1lLCBpbiBzZWNvbmRzLCBmb3IgYW4gTVA0XG4gICAqIGZyYWdtZW50LiBJZiBtdWx0aXBsZSBmcmFnbWVudHMgYXJlIHNwZWNpZmllZCwgdGhlIGVhcmxpZXN0IHRpbWUgaXNcbiAgICogcmV0dXJuZWQuXG4gICAqXG4gICAqIFRoZSBiYXNlIG1lZGlhIGRlY29kZSB0aW1lIGNhbiBiZSBwYXJzZWQgZnJvbSB0cmFjayBmcmFnbWVudFxuICAgKiBtZXRhZGF0YTpcbiAgICogYGBgXG4gICAqIG1vb2YgPiB0cmFmID4gdGZkdC5iYXNlTWVkaWFEZWNvZGVUaW1lXG4gICAqIGBgYFxuICAgKiBJdCByZXF1aXJlcyB0aGUgdGltZXNjYWxlIHZhbHVlIGZyb20gdGhlIG1kaGQgdG8gaW50ZXJwcmV0LlxuICAgKlxuICAgKiBAcGFyYW0gdGltZXNjYWxlIHtvYmplY3R9IGEgaGFzaCBvZiB0cmFjayBpZHMgdG8gdGltZXNjYWxlIHZhbHVlcy5cbiAgICogQHJldHVybiB7bnVtYmVyfSB0aGUgZWFybGllc3QgYmFzZSBtZWRpYSBkZWNvZGUgc3RhcnQgdGltZSBmb3IgdGhlXG4gICAqIGZyYWdtZW50LCBpbiBzZWNvbmRzXG4gICAqL1xuICAgIE1QNERlbXV4ZXIuZ2V0U3RhcnREVFMgPSBmdW5jdGlvbiAoaW5pdERhdGEsIGZyYWdtZW50KSB7XG4gICAgICAgIHZhciB0cmFmcywgYmFzZVRpbWVzLCByZXN1bHQ7XG4gICAgICAgIC8vIHdlIG5lZWQgaW5mbyBmcm9tIHR3byBjaGlsZHJlbmQgb2YgZWFjaCB0cmFjayBmcmFnbWVudCBib3hcbiAgICAgICAgdHJhZnMgPSBNUDREZW11eGVyLmZpbmRCb3goZnJhZ21lbnQsIFsnbW9vZicsICd0cmFmJ10pO1xuICAgICAgICAvLyBkZXRlcm1pbmUgdGhlIHN0YXJ0IHRpbWVzIGZvciBlYWNoIHRyYWNrXG4gICAgICAgIGJhc2VUaW1lcyA9IFtdLmNvbmNhdC5hcHBseShbXSwgdHJhZnMubWFwKGZ1bmN0aW9uICh0cmFmKSB7XG4gICAgICAgICAgICByZXR1cm4gTVA0RGVtdXhlci5maW5kQm94KHRyYWYsIFsndGZoZCddKS5tYXAoZnVuY3Rpb24gKHRmaGQpIHtcbiAgICAgICAgICAgICAgICB2YXIgaWQsIHNjYWxlLCBiYXNlVGltZTtcbiAgICAgICAgICAgICAgICAvLyBnZXQgdGhlIHRyYWNrIGlkIGZyb20gdGhlIHRmaGRcbiAgICAgICAgICAgICAgICBpZCA9IE1QNERlbXV4ZXIucmVhZFVpbnQzMih0ZmhkLCA0KTtcbiAgICAgICAgICAgICAgICAvLyBhc3N1bWUgYSA5MGtIeiBjbG9jayBpZiBubyB0aW1lc2NhbGUgd2FzIHNwZWNpZmllZFxuICAgICAgICAgICAgICAgIHNjYWxlID0gaW5pdERhdGFbaWRdLnRpbWVzY2FsZSB8fCA5MGUzO1xuICAgICAgICAgICAgICAgIC8vIGdldCB0aGUgYmFzZSBtZWRpYSBkZWNvZGUgdGltZSBmcm9tIHRoZSB0ZmR0XG4gICAgICAgICAgICAgICAgYmFzZVRpbWUgPSBNUDREZW11eGVyLmZpbmRCb3godHJhZiwgWyd0ZmR0J10pLm1hcChmdW5jdGlvbiAodGZkdCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmVyc2lvbiwgcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICB2ZXJzaW9uID0gdGZkdC5kYXRhW3RmZHQuc3RhcnRdO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBNUDREZW11eGVyLnJlYWRVaW50MzIodGZkdCwgNCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2ZXJzaW9uID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKj0gTWF0aC5wb3coMiwgMzIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IE1QNERlbXV4ZXIucmVhZFVpbnQzMih0ZmR0LCA4KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH0pWzBdO1xuICAgICAgICAgICAgICAgIC8vIGNvbnZlcnQgYmFzZSB0aW1lIHRvIHNlY29uZHNcbiAgICAgICAgICAgICAgICByZXR1cm4gYmFzZVRpbWUgLyBzY2FsZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KSk7XG4gICAgICAgIC8vIHJldHVybiB0aGUgbWluaW11bVxuICAgICAgICByZXN1bHQgPSBNYXRoLm1pbi5hcHBseShudWxsLCBiYXNlVGltZXMpO1xuICAgICAgICByZXR1cm4gaXNGaW5pdGUocmVzdWx0KSA/IHJlc3VsdCA6IDA7XG4gICAgfTtcbiAgICBNUDREZW11eGVyLm9mZnNldFN0YXJ0RFRTID0gZnVuY3Rpb24gKGluaXREYXRhLCBmcmFnbWVudCwgdGltZU9mZnNldCkge1xuICAgICAgICBNUDREZW11eGVyLmZpbmRCb3goZnJhZ21lbnQsIFsnbW9vZicsICd0cmFmJ10pLm1hcChmdW5jdGlvbiAodHJhZikge1xuICAgICAgICAgICAgcmV0dXJuIE1QNERlbXV4ZXIuZmluZEJveCh0cmFmLCBbJ3RmaGQnXSkubWFwKGZ1bmN0aW9uICh0ZmhkKSB7XG4gICAgICAgICAgICAgICAgLy8gZ2V0IHRoZSB0cmFjayBpZCBmcm9tIHRoZSB0ZmhkXG4gICAgICAgICAgICAgICAgdmFyIGlkID0gTVA0RGVtdXhlci5yZWFkVWludDMyKHRmaGQsIDQpO1xuICAgICAgICAgICAgICAgIC8vIGFzc3VtZSBhIDkwa0h6IGNsb2NrIGlmIG5vIHRpbWVzY2FsZSB3YXMgc3BlY2lmaWVkXG4gICAgICAgICAgICAgICAgdmFyIHRpbWVzY2FsZSA9IGluaXREYXRhW2lkXS50aW1lc2NhbGUgfHwgOTBlMztcbiAgICAgICAgICAgICAgICAvLyBnZXQgdGhlIGJhc2UgbWVkaWEgZGVjb2RlIHRpbWUgZnJvbSB0aGUgdGZkdFxuICAgICAgICAgICAgICAgIE1QNERlbXV4ZXIuZmluZEJveCh0cmFmLCBbJ3RmZHQnXSkubWFwKGZ1bmN0aW9uICh0ZmR0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2ZXJzaW9uID0gdGZkdC5kYXRhW3RmZHQuc3RhcnRdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYmFzZU1lZGlhRGVjb2RlVGltZSA9IE1QNERlbXV4ZXIucmVhZFVpbnQzMih0ZmR0LCA0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZlcnNpb24gPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIE1QNERlbXV4ZXIud3JpdGVVaW50MzIodGZkdCwgNCwgYmFzZU1lZGlhRGVjb2RlVGltZSAtIHRpbWVPZmZzZXQgKiB0aW1lc2NhbGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYmFzZU1lZGlhRGVjb2RlVGltZSAqPSBNYXRoLnBvdygyLCAzMik7XG4gICAgICAgICAgICAgICAgICAgICAgICBiYXNlTWVkaWFEZWNvZGVUaW1lICs9IE1QNERlbXV4ZXIucmVhZFVpbnQzMih0ZmR0LCA4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhc2VNZWRpYURlY29kZVRpbWUgLT0gdGltZU9mZnNldCAqIHRpbWVzY2FsZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhc2VNZWRpYURlY29kZVRpbWUgPSBNYXRoLm1heChiYXNlTWVkaWFEZWNvZGVUaW1lLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB1cHBlciA9IE1hdGguZmxvb3IoYmFzZU1lZGlhRGVjb2RlVGltZSAvIChVSU5UMzJfTUFYICsgMSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxvd2VyID0gTWF0aC5mbG9vcihiYXNlTWVkaWFEZWNvZGVUaW1lICUgKFVJTlQzMl9NQVggKyAxKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBNUDREZW11eGVyLndyaXRlVWludDMyKHRmZHQsIDQsIHVwcGVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIE1QNERlbXV4ZXIud3JpdGVVaW50MzIodGZkdCwgOCwgbG93ZXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvLyBmZWVkIGluY29taW5nIGRhdGEgdG8gdGhlIGZyb250IG9mIHRoZSBwYXJzaW5nIHBpcGVsaW5lXG4gICAgTVA0RGVtdXhlci5wcm90b3R5cGUuYXBwZW5kID0gZnVuY3Rpb24gKGRhdGEsIHRpbWVPZmZzZXQsIGNvbnRpZ3VvdXMsIGFjY3VyYXRlVGltZU9mZnNldCkge1xuICAgICAgICB2YXIgaW5pdERhdGEgPSB0aGlzLmluaXREYXRhO1xuICAgICAgICBpZiAoIWluaXREYXRhKSB7XG4gICAgICAgICAgICB0aGlzLnJlc2V0SW5pdFNlZ21lbnQoZGF0YSwgdGhpcy5hdWRpb0NvZGVjLCB0aGlzLnZpZGVvQ29kZWMsIGZhbHNlKTtcbiAgICAgICAgICAgIGluaXREYXRhID0gdGhpcy5pbml0RGF0YTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3RhcnREVFMsIGluaXRQVFMgPSB0aGlzLmluaXRQVFM7XG4gICAgICAgIGlmIChpbml0UFRTID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHZhciBzdGFydERUU18xID0gTVA0RGVtdXhlci5nZXRTdGFydERUUyhpbml0RGF0YSwgZGF0YSk7XG4gICAgICAgICAgICB0aGlzLmluaXRQVFMgPSBpbml0UFRTID0gc3RhcnREVFNfMSAtIHRpbWVPZmZzZXQ7XG4gICAgICAgICAgICB0aGlzLm9ic2VydmVyLnRyaWdnZXIoZXZlbnRzXzEuZGVmYXVsdC5JTklUX1BUU19GT1VORCwgeyBpbml0UFRTOiBpbml0UFRTIH0pO1xuICAgICAgICB9XG4gICAgICAgIE1QNERlbXV4ZXIub2Zmc2V0U3RhcnREVFMoaW5pdERhdGEsIGRhdGEsIGluaXRQVFMpO1xuICAgICAgICBzdGFydERUUyA9IE1QNERlbXV4ZXIuZ2V0U3RhcnREVFMoaW5pdERhdGEsIGRhdGEpO1xuICAgICAgICB0aGlzLnJlbXV4ZXIucmVtdXgoaW5pdERhdGEuYXVkaW8sIGluaXREYXRhLnZpZGVvLCBudWxsLCBudWxsLCBzdGFydERUUywgY29udGlndW91cywgYWNjdXJhdGVUaW1lT2Zmc2V0LCBkYXRhKTtcbiAgICB9O1xuICAgIE1QNERlbXV4ZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgcmV0dXJuIE1QNERlbXV4ZXI7XG59KCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gTVA0RGVtdXhlcjtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9kZW11eC9tcGVnYXVkaW8uanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2RlbXV4L21wZWdhdWRpby5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qISBNb2R1bGVDb25jYXRlbmF0aW9uIGJhaWxvdXQ6IE1vZHVsZSBpcyBub3QgYW4gRUNNQVNjcmlwdCBtb2R1bGUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogIE1QRUcgcGFyc2VyIGhlbHBlclxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgTXBlZ0F1ZGlvID0ge1xuICAgIEJpdHJhdGVzTWFwOiBbXG4gICAgICAgIDMyLCA2NCwgOTYsIDEyOCwgMTYwLCAxOTIsIDIyNCwgMjU2LCAyODgsIDMyMCwgMzUyLCAzODQsIDQxNiwgNDQ4LFxuICAgICAgICAzMiwgNDgsIDU2LCA2NCwgODAsIDk2LCAxMTIsIDEyOCwgMTYwLCAxOTIsIDIyNCwgMjU2LCAzMjAsIDM4NCxcbiAgICAgICAgMzIsIDQwLCA0OCwgNTYsIDY0LCA4MCwgOTYsIDExMiwgMTI4LCAxNjAsIDE5MiwgMjI0LCAyNTYsIDMyMCxcbiAgICAgICAgMzIsIDQ4LCA1NiwgNjQsIDgwLCA5NiwgMTEyLCAxMjgsIDE0NCwgMTYwLCAxNzYsIDE5MiwgMjI0LCAyNTYsXG4gICAgICAgIDgsIDE2LCAyNCwgMzIsIDQwLCA0OCwgNTYsIDY0LCA4MCwgOTYsIDExMiwgMTI4LCAxNDQsIDE2MFxuICAgIF0sXG4gICAgU2FtcGxpbmdSYXRlTWFwOiBbNDQxMDAsIDQ4MDAwLCAzMjAwMCwgMjIwNTAsIDI0MDAwLCAxNjAwMCwgMTEwMjUsIDEyMDAwLCA4MDAwXSxcbiAgICBTYW1wbGVzQ29lZmZpY2llbnRzOiBbXG4gICAgICAgIC8vIE1QRUcgMi41XG4gICAgICAgIFtcbiAgICAgICAgICAgIDAsXG4gICAgICAgICAgICA3MixcbiAgICAgICAgICAgIDE0NCxcbiAgICAgICAgICAgIDEyIC8vIExheWVyMVxuICAgICAgICBdLFxuICAgICAgICAvLyBSZXNlcnZlZFxuICAgICAgICBbXG4gICAgICAgICAgICAwLFxuICAgICAgICAgICAgMCxcbiAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAwIC8vIExheWVyMVxuICAgICAgICBdLFxuICAgICAgICAvLyBNUEVHIDJcbiAgICAgICAgW1xuICAgICAgICAgICAgMCxcbiAgICAgICAgICAgIDcyLFxuICAgICAgICAgICAgMTQ0LFxuICAgICAgICAgICAgMTIgLy8gTGF5ZXIxXG4gICAgICAgIF0sXG4gICAgICAgIC8vIE1QRUcgMVxuICAgICAgICBbXG4gICAgICAgICAgICAwLFxuICAgICAgICAgICAgMTQ0LFxuICAgICAgICAgICAgMTQ0LFxuICAgICAgICAgICAgMTIgLy8gTGF5ZXIxXG4gICAgICAgIF1cbiAgICBdLFxuICAgIEJ5dGVzSW5TbG90OiBbXG4gICAgICAgIDAsXG4gICAgICAgIDEsXG4gICAgICAgIDEsXG4gICAgICAgIDQgLy8gTGF5ZXIxXG4gICAgXSxcbiAgICBhcHBlbmRGcmFtZTogZnVuY3Rpb24gKHRyYWNrLCBkYXRhLCBvZmZzZXQsIHB0cywgZnJhbWVJbmRleCkge1xuICAgICAgICAvLyBVc2luZyBodHRwOi8vd3d3LmRhdGF2b3lhZ2UuY29tL21wZ3NjcmlwdC9tcGVnaGRyLmh0bSBhcyBhIHJlZmVyZW5jZVxuICAgICAgICBpZiAob2Zmc2V0ICsgMjQgPiBkYXRhLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaGVhZGVyID0gdGhpcy5wYXJzZUhlYWRlcihkYXRhLCBvZmZzZXQpO1xuICAgICAgICBpZiAoaGVhZGVyICYmIG9mZnNldCArIGhlYWRlci5mcmFtZUxlbmd0aCA8PSBkYXRhLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIGZyYW1lRHVyYXRpb24gPSBoZWFkZXIuc2FtcGxlc1BlckZyYW1lICogOTAwMDAgLyBoZWFkZXIuc2FtcGxlUmF0ZTtcbiAgICAgICAgICAgIHZhciBzdGFtcCA9IHB0cyArIGZyYW1lSW5kZXggKiBmcmFtZUR1cmF0aW9uO1xuICAgICAgICAgICAgdmFyIHNhbXBsZSA9IHsgdW5pdDogZGF0YS5zdWJhcnJheShvZmZzZXQsIG9mZnNldCArIGhlYWRlci5mcmFtZUxlbmd0aCksIHB0czogc3RhbXAsIGR0czogc3RhbXAgfTtcbiAgICAgICAgICAgIHRyYWNrLmNvbmZpZyA9IFtdO1xuICAgICAgICAgICAgdHJhY2suY2hhbm5lbENvdW50ID0gaGVhZGVyLmNoYW5uZWxDb3VudDtcbiAgICAgICAgICAgIHRyYWNrLnNhbXBsZXJhdGUgPSBoZWFkZXIuc2FtcGxlUmF0ZTtcbiAgICAgICAgICAgIHRyYWNrLnNhbXBsZXMucHVzaChzYW1wbGUpO1xuICAgICAgICAgICAgdHJhY2subGVuICs9IGhlYWRlci5mcmFtZUxlbmd0aDtcbiAgICAgICAgICAgIHJldHVybiB7IHNhbXBsZTogc2FtcGxlLCBsZW5ndGg6IGhlYWRlci5mcmFtZUxlbmd0aCB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfSxcbiAgICBwYXJzZUhlYWRlcjogZnVuY3Rpb24gKGRhdGEsIG9mZnNldCkge1xuICAgICAgICB2YXIgaGVhZGVyQiA9IChkYXRhW29mZnNldCArIDFdID4+IDMpICYgMztcbiAgICAgICAgdmFyIGhlYWRlckMgPSAoZGF0YVtvZmZzZXQgKyAxXSA+PiAxKSAmIDM7XG4gICAgICAgIHZhciBoZWFkZXJFID0gKGRhdGFbb2Zmc2V0ICsgMl0gPj4gNCkgJiAxNTtcbiAgICAgICAgdmFyIGhlYWRlckYgPSAoZGF0YVtvZmZzZXQgKyAyXSA+PiAyKSAmIDM7XG4gICAgICAgIHZhciBoZWFkZXJHID0gKGRhdGFbb2Zmc2V0ICsgMl0gPj4gMSkgJiAxO1xuICAgICAgICBpZiAoaGVhZGVyQiAhPT0gMSAmJiBoZWFkZXJFICE9PSAwICYmIGhlYWRlckUgIT09IDE1ICYmIGhlYWRlckYgIT09IDMpIHtcbiAgICAgICAgICAgIHZhciBjb2x1bW5JbkJpdHJhdGVzID0gaGVhZGVyQiA9PT0gMyA/ICgzIC0gaGVhZGVyQykgOiAoaGVhZGVyQyA9PT0gMyA/IDMgOiA0KTtcbiAgICAgICAgICAgIHZhciBiaXRSYXRlID0gTXBlZ0F1ZGlvLkJpdHJhdGVzTWFwW2NvbHVtbkluQml0cmF0ZXMgKiAxNCArIGhlYWRlckUgLSAxXSAqIDEwMDA7XG4gICAgICAgICAgICB2YXIgY29sdW1uSW5TYW1wbGVSYXRlcyA9IGhlYWRlckIgPT09IDMgPyAwIDogaGVhZGVyQiA9PT0gMiA/IDEgOiAyO1xuICAgICAgICAgICAgdmFyIHNhbXBsZVJhdGUgPSBNcGVnQXVkaW8uU2FtcGxpbmdSYXRlTWFwW2NvbHVtbkluU2FtcGxlUmF0ZXMgKiAzICsgaGVhZGVyRl07XG4gICAgICAgICAgICB2YXIgY2hhbm5lbENvdW50ID0gZGF0YVtvZmZzZXQgKyAzXSA+PiA2ID09PSAzID8gMSA6IDI7IC8vIElmIGJpdHMgb2YgY2hhbm5lbCBtb2RlIGFyZSBgMTFgIHRoZW4gaXQgaXMgYSBzaW5nbGUgY2hhbm5lbCAoTW9ubylcbiAgICAgICAgICAgIHZhciBzYW1wbGVDb2VmZmljaWVudCA9IE1wZWdBdWRpby5TYW1wbGVzQ29lZmZpY2llbnRzW2hlYWRlckJdW2hlYWRlckNdO1xuICAgICAgICAgICAgdmFyIGJ5dGVzSW5TbG90ID0gTXBlZ0F1ZGlvLkJ5dGVzSW5TbG90W2hlYWRlckNdO1xuICAgICAgICAgICAgdmFyIHNhbXBsZXNQZXJGcmFtZSA9IHNhbXBsZUNvZWZmaWNpZW50ICogOCAqIGJ5dGVzSW5TbG90O1xuICAgICAgICAgICAgdmFyIGZyYW1lTGVuZ3RoID0gcGFyc2VJbnQoc2FtcGxlQ29lZmZpY2llbnQgKiBiaXRSYXRlIC8gc2FtcGxlUmF0ZSArIGhlYWRlckcsIDEwKSAqIGJ5dGVzSW5TbG90O1xuICAgICAgICAgICAgcmV0dXJuIHsgc2FtcGxlUmF0ZTogc2FtcGxlUmF0ZSwgY2hhbm5lbENvdW50OiBjaGFubmVsQ291bnQsIGZyYW1lTGVuZ3RoOiBmcmFtZUxlbmd0aCwgc2FtcGxlc1BlckZyYW1lOiBzYW1wbGVzUGVyRnJhbWUgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0sXG4gICAgaXNIZWFkZXJQYXR0ZXJuOiBmdW5jdGlvbiAoZGF0YSwgb2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiBkYXRhW29mZnNldF0gPT09IDB4ZmYgJiYgKGRhdGFbb2Zmc2V0ICsgMV0gJiAweGUwKSA9PT0gMHhlMCAmJiAoZGF0YVtvZmZzZXQgKyAxXSAmIDB4MDYpICE9PSAweDAwO1xuICAgIH0sXG4gICAgaXNIZWFkZXI6IGZ1bmN0aW9uIChkYXRhLCBvZmZzZXQpIHtcbiAgICAgICAgLy8gTG9vayBmb3IgTVBFRyBoZWFkZXIgfCAxMTExIDExMTEgfCAxMTFYIFhZWlggfCB3aGVyZSBYIGNhbiBiZSBlaXRoZXIgMCBvciAxIGFuZCBZIG9yIFogc2hvdWxkIGJlIDFcbiAgICAgICAgLy8gTGF5ZXIgYml0cyAocG9zaXRpb24gMTQgYW5kIDE1KSBpbiBoZWFkZXIgc2hvdWxkIGJlIGFsd2F5cyBkaWZmZXJlbnQgZnJvbSAwIChMYXllciBJIG9yIExheWVyIElJIG9yIExheWVyIElJSSlcbiAgICAgICAgLy8gTW9yZSBpbmZvIGh0dHA6Ly93d3cubXAzLXRlY2gub3JnL3Byb2dyYW1tZXIvZnJhbWVfaGVhZGVyLmh0bWxcbiAgICAgICAgaWYgKG9mZnNldCArIDEgPCBkYXRhLmxlbmd0aCAmJiB0aGlzLmlzSGVhZGVyUGF0dGVybihkYXRhLCBvZmZzZXQpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcbiAgICBwcm9iZTogZnVuY3Rpb24gKGRhdGEsIG9mZnNldCkge1xuICAgICAgICAvLyBzYW1lIGFzIGlzSGVhZGVyIGJ1dCB3ZSBhbHNvIGNoZWNrIHRoYXQgTVBFRyBmcmFtZSBmb2xsb3dzIGxhc3QgTVBFRyBmcmFtZVxuICAgICAgICAvLyBvciBlbmQgb2YgZGF0YSBpcyByZWFjaGVkXG4gICAgICAgIGlmIChvZmZzZXQgKyAxIDwgZGF0YS5sZW5ndGggJiYgdGhpcy5pc0hlYWRlclBhdHRlcm4oZGF0YSwgb2Zmc2V0KSkge1xuICAgICAgICAgICAgLy8gTVBFRyBoZWFkZXIgTGVuZ3RoXG4gICAgICAgICAgICB2YXIgaGVhZGVyTGVuZ3RoID0gNDtcbiAgICAgICAgICAgIC8vIE1QRUcgZnJhbWUgTGVuZ3RoXG4gICAgICAgICAgICB2YXIgaGVhZGVyID0gdGhpcy5wYXJzZUhlYWRlcihkYXRhLCBvZmZzZXQpO1xuICAgICAgICAgICAgdmFyIGZyYW1lTGVuZ3RoID0gaGVhZGVyTGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGhlYWRlciAmJiBoZWFkZXIuZnJhbWVMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBmcmFtZUxlbmd0aCA9IGhlYWRlci5mcmFtZUxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBuZXdPZmZzZXQgPSBvZmZzZXQgKyBmcmFtZUxlbmd0aDtcbiAgICAgICAgICAgIGlmIChuZXdPZmZzZXQgPT09IGRhdGEubGVuZ3RoIHx8IChuZXdPZmZzZXQgKyAxIDwgZGF0YS5sZW5ndGggJiYgdGhpcy5pc0hlYWRlclBhdHRlcm4oZGF0YSwgbmV3T2Zmc2V0KSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IE1wZWdBdWRpbztcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9kZW11eC9zYW1wbGUtYWVzLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvZGVtdXgvc2FtcGxlLWFlcy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKipcbiAqIFNBTVBMRS1BRVMgZGVjcnlwdGVyXG4qL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGRlY3J5cHRlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vY3J5cHQvZGVjcnlwdGVyICovIFwiLi9zcmMvY3J5cHQvZGVjcnlwdGVyLmpzXCIpO1xudmFyIFNhbXBsZUFlc0RlY3J5cHRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTYW1wbGVBZXNEZWNyeXB0ZXIob2JzZXJ2ZXIsIGNvbmZpZywgZGVjcnlwdGRhdGEsIGRpc2NhcmRFUEIpIHtcbiAgICAgICAgdGhpcy5kZWNyeXB0ZGF0YSA9IGRlY3J5cHRkYXRhO1xuICAgICAgICB0aGlzLmRpc2NhcmRFUEIgPSBkaXNjYXJkRVBCO1xuICAgICAgICB0aGlzLmRlY3J5cHRlciA9IG5ldyBkZWNyeXB0ZXJfMS5kZWZhdWx0KG9ic2VydmVyLCBjb25maWcsIHsgcmVtb3ZlUEtDUzdQYWRkaW5nOiBmYWxzZSB9KTtcbiAgICB9XG4gICAgU2FtcGxlQWVzRGVjcnlwdGVyLnByb3RvdHlwZS5kZWNyeXB0QnVmZmVyID0gZnVuY3Rpb24gKGVuY3J5cHRlZERhdGEsIGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuZGVjcnlwdGVyLmRlY3J5cHQoZW5jcnlwdGVkRGF0YSwgdGhpcy5kZWNyeXB0ZGF0YS5rZXkuYnVmZmVyLCB0aGlzLmRlY3J5cHRkYXRhLml2LmJ1ZmZlciwgY2FsbGJhY2spO1xuICAgIH07XG4gICAgLy8gQUFDIC0gZW5jcnlwdCBhbGwgZnVsbCAxNiBieXRlcyBibG9ja3Mgc3RhcnRpbmcgZnJvbSBvZmZzZXQgMTZcbiAgICBTYW1wbGVBZXNEZWNyeXB0ZXIucHJvdG90eXBlLmRlY3J5cHRBYWNTYW1wbGUgPSBmdW5jdGlvbiAoc2FtcGxlcywgc2FtcGxlSW5kZXgsIGNhbGxiYWNrLCBzeW5jKSB7XG4gICAgICAgIHZhciBjdXJVbml0ID0gc2FtcGxlc1tzYW1wbGVJbmRleF0udW5pdDtcbiAgICAgICAgdmFyIGVuY3J5cHRlZERhdGEgPSBjdXJVbml0LnN1YmFycmF5KDE2LCBjdXJVbml0Lmxlbmd0aCAtIGN1clVuaXQubGVuZ3RoICUgMTYpO1xuICAgICAgICB2YXIgZW5jcnlwdGVkQnVmZmVyID0gZW5jcnlwdGVkRGF0YS5idWZmZXIuc2xpY2UoZW5jcnlwdGVkRGF0YS5ieXRlT2Zmc2V0LCBlbmNyeXB0ZWREYXRhLmJ5dGVPZmZzZXQgKyBlbmNyeXB0ZWREYXRhLmxlbmd0aCk7XG4gICAgICAgIHZhciBsb2NhbHRoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLmRlY3J5cHRCdWZmZXIoZW5jcnlwdGVkQnVmZmVyLCBmdW5jdGlvbiAoZGVjcnlwdGVkRGF0YSkge1xuICAgICAgICAgICAgZGVjcnlwdGVkRGF0YSA9IG5ldyBVaW50OEFycmF5KGRlY3J5cHRlZERhdGEpO1xuICAgICAgICAgICAgY3VyVW5pdC5zZXQoZGVjcnlwdGVkRGF0YSwgMTYpO1xuICAgICAgICAgICAgaWYgKCFzeW5jKSB7XG4gICAgICAgICAgICAgICAgbG9jYWx0aGlzLmRlY3J5cHRBYWNTYW1wbGVzKHNhbXBsZXMsIHNhbXBsZUluZGV4ICsgMSwgY2FsbGJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFNhbXBsZUFlc0RlY3J5cHRlci5wcm90b3R5cGUuZGVjcnlwdEFhY1NhbXBsZXMgPSBmdW5jdGlvbiAoc2FtcGxlcywgc2FtcGxlSW5kZXgsIGNhbGxiYWNrKSB7XG4gICAgICAgIGZvciAoOzsgc2FtcGxlSW5kZXgrKykge1xuICAgICAgICAgICAgaWYgKHNhbXBsZUluZGV4ID49IHNhbXBsZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2FtcGxlc1tzYW1wbGVJbmRleF0udW5pdC5sZW5ndGggPCAzMikge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHN5bmMgPSB0aGlzLmRlY3J5cHRlci5pc1N5bmMoKTtcbiAgICAgICAgICAgIHRoaXMuZGVjcnlwdEFhY1NhbXBsZShzYW1wbGVzLCBzYW1wbGVJbmRleCwgY2FsbGJhY2ssIHN5bmMpO1xuICAgICAgICAgICAgaWYgKCFzeW5jKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBBVkMgLSBlbmNyeXB0IG9uZSAxNiBieXRlcyBibG9jayBvdXQgb2YgdGVuLCBzdGFydGluZyBmcm9tIG9mZnNldCAzMlxuICAgIFNhbXBsZUFlc0RlY3J5cHRlci5wcm90b3R5cGUuZ2V0QXZjRW5jcnlwdGVkRGF0YSA9IGZ1bmN0aW9uIChkZWNvZGVkRGF0YSkge1xuICAgICAgICB2YXIgZW5jcnlwdGVkRGF0YUxlbiA9IE1hdGguZmxvb3IoKGRlY29kZWREYXRhLmxlbmd0aCAtIDQ4KSAvIDE2MCkgKiAxNiArIDE2O1xuICAgICAgICB2YXIgZW5jcnlwdGVkRGF0YSA9IG5ldyBJbnQ4QXJyYXkoZW5jcnlwdGVkRGF0YUxlbik7XG4gICAgICAgIHZhciBvdXRwdXRQb3MgPSAwO1xuICAgICAgICBmb3IgKHZhciBpbnB1dFBvcyA9IDMyOyBpbnB1dFBvcyA8PSBkZWNvZGVkRGF0YS5sZW5ndGggLSAxNjsgaW5wdXRQb3MgKz0gMTYwLCBvdXRwdXRQb3MgKz0gMTYpIHtcbiAgICAgICAgICAgIGVuY3J5cHRlZERhdGEuc2V0KGRlY29kZWREYXRhLnN1YmFycmF5KGlucHV0UG9zLCBpbnB1dFBvcyArIDE2KSwgb3V0cHV0UG9zKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZW5jcnlwdGVkRGF0YTtcbiAgICB9O1xuICAgIFNhbXBsZUFlc0RlY3J5cHRlci5wcm90b3R5cGUuZ2V0QXZjRGVjcnlwdGVkVW5pdCA9IGZ1bmN0aW9uIChkZWNvZGVkRGF0YSwgZGVjcnlwdGVkRGF0YSkge1xuICAgICAgICBkZWNyeXB0ZWREYXRhID0gbmV3IFVpbnQ4QXJyYXkoZGVjcnlwdGVkRGF0YSk7XG4gICAgICAgIHZhciBpbnB1dFBvcyA9IDA7XG4gICAgICAgIGZvciAodmFyIG91dHB1dFBvcyA9IDMyOyBvdXRwdXRQb3MgPD0gZGVjb2RlZERhdGEubGVuZ3RoIC0gMTY7IG91dHB1dFBvcyArPSAxNjAsIGlucHV0UG9zICs9IDE2KSB7XG4gICAgICAgICAgICBkZWNvZGVkRGF0YS5zZXQoZGVjcnlwdGVkRGF0YS5zdWJhcnJheShpbnB1dFBvcywgaW5wdXRQb3MgKyAxNiksIG91dHB1dFBvcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlY29kZWREYXRhO1xuICAgIH07XG4gICAgU2FtcGxlQWVzRGVjcnlwdGVyLnByb3RvdHlwZS5kZWNyeXB0QXZjU2FtcGxlID0gZnVuY3Rpb24gKHNhbXBsZXMsIHNhbXBsZUluZGV4LCB1bml0SW5kZXgsIGNhbGxiYWNrLCBjdXJVbml0LCBzeW5jKSB7XG4gICAgICAgIHZhciBkZWNvZGVkRGF0YSA9IHRoaXMuZGlzY2FyZEVQQihjdXJVbml0LmRhdGEpO1xuICAgICAgICB2YXIgZW5jcnlwdGVkRGF0YSA9IHRoaXMuZ2V0QXZjRW5jcnlwdGVkRGF0YShkZWNvZGVkRGF0YSk7XG4gICAgICAgIHZhciBsb2NhbHRoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLmRlY3J5cHRCdWZmZXIoZW5jcnlwdGVkRGF0YS5idWZmZXIsIGZ1bmN0aW9uIChkZWNyeXB0ZWREYXRhKSB7XG4gICAgICAgICAgICBjdXJVbml0LmRhdGEgPSBsb2NhbHRoaXMuZ2V0QXZjRGVjcnlwdGVkVW5pdChkZWNvZGVkRGF0YSwgZGVjcnlwdGVkRGF0YSk7XG4gICAgICAgICAgICBpZiAoIXN5bmMpIHtcbiAgICAgICAgICAgICAgICBsb2NhbHRoaXMuZGVjcnlwdEF2Y1NhbXBsZXMoc2FtcGxlcywgc2FtcGxlSW5kZXgsIHVuaXRJbmRleCArIDEsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBTYW1wbGVBZXNEZWNyeXB0ZXIucHJvdG90eXBlLmRlY3J5cHRBdmNTYW1wbGVzID0gZnVuY3Rpb24gKHNhbXBsZXMsIHNhbXBsZUluZGV4LCB1bml0SW5kZXgsIGNhbGxiYWNrKSB7XG4gICAgICAgIGZvciAoOzsgc2FtcGxlSW5kZXgrKywgdW5pdEluZGV4ID0gMCkge1xuICAgICAgICAgICAgaWYgKHNhbXBsZUluZGV4ID49IHNhbXBsZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgY3VyVW5pdHMgPSBzYW1wbGVzW3NhbXBsZUluZGV4XS51bml0cztcbiAgICAgICAgICAgIGZvciAoOzsgdW5pdEluZGV4KyspIHtcbiAgICAgICAgICAgICAgICBpZiAodW5pdEluZGV4ID49IGN1clVuaXRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGN1clVuaXQgPSBjdXJVbml0c1t1bml0SW5kZXhdO1xuICAgICAgICAgICAgICAgIGlmIChjdXJVbml0Lmxlbmd0aCA8PSA0OCB8fCAoY3VyVW5pdC50eXBlICE9PSAxICYmIGN1clVuaXQudHlwZSAhPT0gNSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBzeW5jID0gdGhpcy5kZWNyeXB0ZXIuaXNTeW5jKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWNyeXB0QXZjU2FtcGxlKHNhbXBsZXMsIHNhbXBsZUluZGV4LCB1bml0SW5kZXgsIGNhbGxiYWNrLCBjdXJVbml0LCBzeW5jKTtcbiAgICAgICAgICAgICAgICBpZiAoIXN5bmMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFNhbXBsZUFlc0RlY3J5cHRlcjtcbn0oKSk7XG5leHBvcnRzLmRlZmF1bHQgPSBTYW1wbGVBZXNEZWNyeXB0ZXI7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvZGVtdXgvdHNkZW11eGVyLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9kZW11eC90c2RlbXV4ZXIuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKipcbiAqIGhpZ2hseSBvcHRpbWl6ZWQgVFMgZGVtdXhlcjpcbiAqIHBhcnNlIFBBVCwgUE1UXG4gKiBleHRyYWN0IFBFUyBwYWNrZXQgZnJvbSBhdWRpbyBhbmQgdmlkZW8gUElEc1xuICogZXh0cmFjdCBBVkMvSDI2NCBOQUwgdW5pdHMgYW5kIEFBQy9BRFRTIHNhbXBsZXMgZnJvbSBQRVMgcGFja2V0XG4gKiB0cmlnZ2VyIHRoZSByZW11eGVyIHVwb24gcGFyc2luZyBjb21wbGV0aW9uXG4gKiBpdCBhbHNvIHRyaWVzIHRvIHdvcmthcm91bmQgYXMgYmVzdCBhcyBpdCBjYW4gYXVkaW8gY29kZWMgc3dpdGNoIChIRS1BQUMgdG8gQUFDIGFuZCB2aWNlIHZlcnNhKSwgd2l0aG91dCBoYXZpbmcgdG8gcmVzdGFydCB0aGUgTWVkaWFTb3VyY2UuXG4gKiBpdCBhbHNvIGNvbnRyb2xzIHRoZSByZW11eGluZyBwcm9jZXNzIDpcbiAqIHVwb24gZGlzY29udGludWl0eSBvciBsZXZlbCBzd2l0Y2ggZGV0ZWN0aW9uLCBpdCB3aWxsIGFsc28gbm90aWZpZXMgdGhlIHJlbXV4ZXIgc28gdGhhdCBpdCBjYW4gcmVzZXQgaXRzIHN0YXRlLlxuKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBBRFRTID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9hZHRzICovIFwiLi9zcmMvZGVtdXgvYWR0cy5qc1wiKTtcbnZhciBtcGVnYXVkaW9fMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vbXBlZ2F1ZGlvICovIFwiLi9zcmMvZGVtdXgvbXBlZ2F1ZGlvLmpzXCIpO1xudmFyIGV2ZW50c18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZXZlbnRzICovIFwiLi9zcmMvZXZlbnRzLmpzXCIpO1xudmFyIGV4cF9nb2xvbWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZXhwLWdvbG9tYiAqLyBcIi4vc3JjL2RlbXV4L2V4cC1nb2xvbWIuanNcIik7XG52YXIgc2FtcGxlX2Flc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9zYW1wbGUtYWVzICovIFwiLi9zcmMvZGVtdXgvc2FtcGxlLWFlcy5qc1wiKTtcbi8vIGltcG9ydCBIZXggZnJvbSAnLi4vdXRpbHMvaGV4JztcbnZhciBsb2dnZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL2xvZ2dlciAqLyBcIi4vc3JjL3V0aWxzL2xvZ2dlci5qc1wiKTtcbnZhciBlcnJvcnNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2Vycm9ycyAqLyBcIi4vc3JjL2Vycm9ycy5qc1wiKTtcbi8vIFdlIGFyZSB1c2luZyBmaXhlZCB0cmFjayBJRHMgZm9yIGRyaXZpbmcgdGhlIE1QNCByZW11eGVyXG4vLyBpbnN0ZWFkIG9mIGZvbGxvd2luZyB0aGUgVFMgUElEcy5cbi8vIFRoZXJlIGlzIG5vIHJlYXNvbiBub3QgdG8gZG8gdGhpcyBhbmQgc29tZSBicm93c2Vycy9Tb3VyY2VCdWZmZXItZGVtdXhlcnNcbi8vIG1heSBub3QgbGlrZSBpZiB0aGVyZSBhcmUgVHJhY2tJRCBcInN3aXRjaGVzXCJcbi8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vdmlkZW8tZGV2L2hscy5qcy9pc3N1ZXMvMTMzMVxuLy8gSGVyZSB3ZSBhcmUgbWFwcGluZyBvdXIgaW50ZXJuYWwgdHJhY2sgdHlwZXMgdG8gY29uc3RhbnQgTVA0IHRyYWNrIElEc1xuLy8gV2l0aCBNU0UgY3VycmVudGx5IG9uZSBjYW4gb25seSBoYXZlIG9uZSB0cmFjayBvZiBlYWNoLCBhbmQgd2UgYXJlIG11eGluZ1xuLy8gd2hhdGV2ZXIgdmlkZW8vYXVkaW8gcmVuZGl0aW9uIGluIHRoZW0uXG52YXIgUmVtdXhlclRyYWNrSWRDb25maWcgPSB7XG4gICAgdmlkZW86IDEsXG4gICAgYXVkaW86IDIsXG4gICAgaWQzOiAzLFxuICAgIHRleHQ6IDRcbn07XG52YXIgVFNEZW11eGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRTRGVtdXhlcihvYnNlcnZlciwgcmVtdXhlciwgY29uZmlnLCB0eXBlU3VwcG9ydGVkKSB7XG4gICAgICAgIHRoaXMub2JzZXJ2ZXIgPSBvYnNlcnZlcjtcbiAgICAgICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgICAgIHRoaXMudHlwZVN1cHBvcnRlZCA9IHR5cGVTdXBwb3J0ZWQ7XG4gICAgICAgIHRoaXMucmVtdXhlciA9IHJlbXV4ZXI7XG4gICAgICAgIHRoaXMuc2FtcGxlQWVzID0gbnVsbDtcbiAgICB9XG4gICAgVFNEZW11eGVyLnByb3RvdHlwZS5zZXREZWNyeXB0RGF0YSA9IGZ1bmN0aW9uIChkZWNyeXB0ZGF0YSkge1xuICAgICAgICBpZiAoKGRlY3J5cHRkYXRhICE9IG51bGwpICYmIChkZWNyeXB0ZGF0YS5rZXkgIT0gbnVsbCkgJiYgKGRlY3J5cHRkYXRhLm1ldGhvZCA9PT0gJ1NBTVBMRS1BRVMnKSkge1xuICAgICAgICAgICAgdGhpcy5zYW1wbGVBZXMgPSBuZXcgc2FtcGxlX2Flc18xLmRlZmF1bHQodGhpcy5vYnNlcnZlciwgdGhpcy5jb25maWcsIGRlY3J5cHRkYXRhLCB0aGlzLmRpc2NhcmRFUEIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zYW1wbGVBZXMgPSBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUU0RlbXV4ZXIucHJvYmUgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB2YXIgc3luY09mZnNldCA9IFRTRGVtdXhlci5fc3luY09mZnNldChkYXRhKTtcbiAgICAgICAgaWYgKHN5bmNPZmZzZXQgPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoc3luY09mZnNldCkge1xuICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmxvZ2dlci53YXJuKFwiTVBFRzItVFMgZGV0ZWN0ZWQgYnV0IGZpcnN0IHN5bmMgd29yZCBmb3VuZCBAIG9mZnNldCBcIiArIHN5bmNPZmZzZXQgKyBcIiwganVuayBhaGVhZCA/XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRTRGVtdXhlci5fc3luY09mZnNldCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIC8vIHNjYW4gMTAwMCBmaXJzdCBieXRlc1xuICAgICAgICB2YXIgc2NhbndpbmRvdyA9IE1hdGgubWluKDEwMDAsIGRhdGEubGVuZ3RoIC0gMyAqIDE4OCk7XG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgd2hpbGUgKGkgPCBzY2Fud2luZG93KSB7XG4gICAgICAgICAgICAvLyBhIFRTIGZyYWdtZW50IHNob3VsZCBjb250YWluIGF0IGxlYXN0IDMgVFMgcGFja2V0cywgYSBQQVQsIGEgUE1ULCBhbmQgb25lIFBJRCwgZWFjaCBzdGFydGluZyB3aXRoIDB4NDdcbiAgICAgICAgICAgIGlmIChkYXRhW2ldID09PSAweDQ3ICYmIGRhdGFbaSArIDE4OF0gPT09IDB4NDcgJiYgZGF0YVtpICsgMiAqIDE4OF0gPT09IDB4NDcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgdHJhY2sgbW9kZWwgaW50ZXJuYWwgdG8gZGVtdXhlciB1c2VkIHRvIGRyaXZlIHJlbXV4aW5nIGlucHV0XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSAnYXVkaW8nIHwgJ3ZpZGVvJyB8ICdpZDMnIHwgJ3RleHQnXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGR1cmF0aW9uXG4gICAgICogQHJldHVybiB7b2JqZWN0fSBUU0RlbXV4ZXIncyBpbnRlcm5hbCB0cmFjayBtb2RlbFxuICAgICAqL1xuICAgIFRTRGVtdXhlci5jcmVhdGVUcmFjayA9IGZ1bmN0aW9uICh0eXBlLCBkdXJhdGlvbikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY29udGFpbmVyOiB0eXBlID09PSAndmlkZW8nIHx8IHR5cGUgPT09ICdhdWRpbycgPyAndmlkZW8vbXAydCcgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgICAgaWQ6IFJlbXV4ZXJUcmFja0lkQ29uZmlnW3R5cGVdLFxuICAgICAgICAgICAgcGlkOiAtMSxcbiAgICAgICAgICAgIGlucHV0VGltZVNjYWxlOiA5MDAwMCxcbiAgICAgICAgICAgIHNlcXVlbmNlTnVtYmVyOiAwLFxuICAgICAgICAgICAgc2FtcGxlczogW10sXG4gICAgICAgICAgICBsZW46IDAsXG4gICAgICAgICAgICBkcm9wcGVkOiB0eXBlID09PSAndmlkZW8nID8gMCA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGlzQUFDOiB0eXBlID09PSAnYXVkaW8nID8gdHJ1ZSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGR1cmF0aW9uOiB0eXBlID09PSAnYXVkaW8nID8gZHVyYXRpb24gOiB1bmRlZmluZWRcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIGEgbmV3IGluaXQgc2VnbWVudCBvbiB0aGUgZGVtdXhlci9yZW11eGVyIGludGVyZmFjZS4gTmVlZGVkIGZvciBkaXNjb250aW51aXRpZXMvdHJhY2stc3dpdGNoZXMgKG9yIGF0IHN0cmVhbSBzdGFydClcbiAgICAgKiBSZXNldHMgYWxsIGludGVybmFsIHRyYWNrIGluc3RhbmNlcyBvZiB0aGUgZGVtdXhlci5cbiAgICAgKlxuICAgICAqIEBvdmVycmlkZSBJbXBsZW1lbnRzIGdlbmVyaWMgZGVtdXhpbmcvcmVtdXhpbmcgaW50ZXJmYWNlIChzZWUgRGVtdXhlcklubGluZSlcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gaW5pdFNlZ21lbnRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYXVkaW9Db2RlY1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2aWRlb0NvZGVjXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGR1cmF0aW9uIChpbiBUUyB0aW1lc2NhbGUgPSA5MGtIeilcbiAgICAgKi9cbiAgICBUU0RlbXV4ZXIucHJvdG90eXBlLnJlc2V0SW5pdFNlZ21lbnQgPSBmdW5jdGlvbiAoaW5pdFNlZ21lbnQsIGF1ZGlvQ29kZWMsIHZpZGVvQ29kZWMsIGR1cmF0aW9uKSB7XG4gICAgICAgIHRoaXMucG10UGFyc2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3BtdElkID0gLTE7XG4gICAgICAgIHRoaXMuX2F2Y1RyYWNrID0gVFNEZW11eGVyLmNyZWF0ZVRyYWNrKCd2aWRlbycsIGR1cmF0aW9uKTtcbiAgICAgICAgdGhpcy5fYXVkaW9UcmFjayA9IFRTRGVtdXhlci5jcmVhdGVUcmFjaygnYXVkaW8nLCBkdXJhdGlvbik7XG4gICAgICAgIHRoaXMuX2lkM1RyYWNrID0gVFNEZW11eGVyLmNyZWF0ZVRyYWNrKCdpZDMnLCBkdXJhdGlvbik7XG4gICAgICAgIHRoaXMuX3R4dFRyYWNrID0gVFNEZW11eGVyLmNyZWF0ZVRyYWNrKCd0ZXh0JywgZHVyYXRpb24pO1xuICAgICAgICAvLyBmbHVzaCBhbnkgcGFydGlhbCBjb250ZW50XG4gICAgICAgIHRoaXMuYWFjT3ZlckZsb3cgPSBudWxsO1xuICAgICAgICB0aGlzLmFhY0xhc3RQVFMgPSBudWxsO1xuICAgICAgICB0aGlzLmF2Y1NhbXBsZSA9IG51bGw7XG4gICAgICAgIHRoaXMuYXVkaW9Db2RlYyA9IGF1ZGlvQ29kZWM7XG4gICAgICAgIHRoaXMudmlkZW9Db2RlYyA9IHZpZGVvQ29kZWM7XG4gICAgICAgIHRoaXMuX2R1cmF0aW9uID0gZHVyYXRpb247XG4gICAgfTtcbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICAgIFRTRGVtdXhlci5wcm90b3R5cGUucmVzZXRUaW1lU3RhbXAgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgLy8gZmVlZCBpbmNvbWluZyBkYXRhIHRvIHRoZSBmcm9udCBvZiB0aGUgcGFyc2luZyBwaXBlbGluZVxuICAgIFRTRGVtdXhlci5wcm90b3R5cGUuYXBwZW5kID0gZnVuY3Rpb24gKGRhdGEsIHRpbWVPZmZzZXQsIGNvbnRpZ3VvdXMsIGFjY3VyYXRlVGltZU9mZnNldCkge1xuICAgICAgICB2YXIgc3RhcnQsIGxlbiA9IGRhdGEubGVuZ3RoLCBzdHQsIHBpZCwgYXRmLCBvZmZzZXQsIHBlcywgdW5rbm93blBJRHMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jb250aWd1b3VzID0gY29udGlndW91cztcbiAgICAgICAgdmFyIHBtdFBhcnNlZCA9IHRoaXMucG10UGFyc2VkLCBhdmNUcmFjayA9IHRoaXMuX2F2Y1RyYWNrLCBhdWRpb1RyYWNrID0gdGhpcy5fYXVkaW9UcmFjaywgaWQzVHJhY2sgPSB0aGlzLl9pZDNUcmFjaywgYXZjSWQgPSBhdmNUcmFjay5waWQsIGF1ZGlvSWQgPSBhdWRpb1RyYWNrLnBpZCwgaWQzSWQgPSBpZDNUcmFjay5waWQsIHBtdElkID0gdGhpcy5fcG10SWQsIGF2Y0RhdGEgPSBhdmNUcmFjay5wZXNEYXRhLCBhdWRpb0RhdGEgPSBhdWRpb1RyYWNrLnBlc0RhdGEsIGlkM0RhdGEgPSBpZDNUcmFjay5wZXNEYXRhLCBwYXJzZVBBVCA9IHRoaXMuX3BhcnNlUEFULCBwYXJzZVBNVCA9IHRoaXMuX3BhcnNlUE1ULCBwYXJzZVBFUyA9IHRoaXMuX3BhcnNlUEVTLCBwYXJzZUFWQ1BFUyA9IHRoaXMuX3BhcnNlQVZDUEVTLmJpbmQodGhpcyksIHBhcnNlQUFDUEVTID0gdGhpcy5fcGFyc2VBQUNQRVMuYmluZCh0aGlzKSwgcGFyc2VNUEVHUEVTID0gdGhpcy5fcGFyc2VNUEVHUEVTLmJpbmQodGhpcyksIHBhcnNlSUQzUEVTID0gdGhpcy5fcGFyc2VJRDNQRVMuYmluZCh0aGlzKTtcbiAgICAgICAgdmFyIHN5bmNPZmZzZXQgPSBUU0RlbXV4ZXIuX3N5bmNPZmZzZXQoZGF0YSk7XG4gICAgICAgIC8vIGRvbid0IHBhcnNlIGxhc3QgVFMgcGFja2V0IGlmIGluY29tcGxldGVcbiAgICAgICAgbGVuIC09IChsZW4gKyBzeW5jT2Zmc2V0KSAlIDE4ODtcbiAgICAgICAgLy8gbG9vcCB0aHJvdWdoIFRTIHBhY2tldHNcbiAgICAgICAgZm9yIChzdGFydCA9IHN5bmNPZmZzZXQ7IHN0YXJ0IDwgbGVuOyBzdGFydCArPSAxODgpIHtcbiAgICAgICAgICAgIGlmIChkYXRhW3N0YXJ0XSA9PT0gMHg0Nykge1xuICAgICAgICAgICAgICAgIHN0dCA9ICEhKGRhdGFbc3RhcnQgKyAxXSAmIDB4NDApO1xuICAgICAgICAgICAgICAgIC8vIHBpZCBpcyBhIDEzLWJpdCBmaWVsZCBzdGFydGluZyBhdCB0aGUgbGFzdCBiaXQgb2YgVFNbMV1cbiAgICAgICAgICAgICAgICBwaWQgPSAoKGRhdGFbc3RhcnQgKyAxXSAmIDB4MWYpIDw8IDgpICsgZGF0YVtzdGFydCArIDJdO1xuICAgICAgICAgICAgICAgIGF0ZiA9IChkYXRhW3N0YXJ0ICsgM10gJiAweDMwKSA+PiA0O1xuICAgICAgICAgICAgICAgIC8vIGlmIGFuIGFkYXB0aW9uIGZpZWxkIGlzIHByZXNlbnQsIGl0cyBsZW5ndGggaXMgc3BlY2lmaWVkIGJ5IHRoZSBmaWZ0aCBieXRlIG9mIHRoZSBUUyBwYWNrZXQgaGVhZGVyLlxuICAgICAgICAgICAgICAgIGlmIChhdGYgPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgIG9mZnNldCA9IHN0YXJ0ICsgNSArIGRhdGFbc3RhcnQgKyA0XTtcbiAgICAgICAgICAgICAgICAgICAgLy8gY29udGludWUgaWYgdGhlcmUgaXMgb25seSBhZGFwdGF0aW9uIGZpZWxkXG4gICAgICAgICAgICAgICAgICAgIGlmIChvZmZzZXQgPT09IChzdGFydCArIDE4OCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBvZmZzZXQgPSBzdGFydCArIDQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN3aXRjaCAocGlkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgYXZjSWQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3R0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGF2Y0RhdGEgJiYgKHBlcyA9IHBhcnNlUEVTKGF2Y0RhdGEpKSAmJiBwZXMucHRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VBVkNQRVMocGVzLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF2Y0RhdGEgPSB7IGRhdGE6IFtdLCBzaXplOiAwIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXZjRGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF2Y0RhdGEuZGF0YS5wdXNoKGRhdGEuc3ViYXJyYXkob2Zmc2V0LCBzdGFydCArIDE4OCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF2Y0RhdGEuc2l6ZSArPSBzdGFydCArIDE4OCAtIG9mZnNldDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIGF1ZGlvSWQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3R0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGF1ZGlvRGF0YSAmJiAocGVzID0gcGFyc2VQRVMoYXVkaW9EYXRhKSkgJiYgcGVzLnB0cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhdWRpb1RyYWNrLmlzQUFDKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJzZUFBQ1BFUyhwZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VNUEVHUEVTKHBlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXVkaW9EYXRhID0geyBkYXRhOiBbXSwgc2l6ZTogMCB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGF1ZGlvRGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF1ZGlvRGF0YS5kYXRhLnB1c2goZGF0YS5zdWJhcnJheShvZmZzZXQsIHN0YXJ0ICsgMTg4KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXVkaW9EYXRhLnNpemUgKz0gc3RhcnQgKyAxODggLSBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBpZDNJZDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaWQzRGF0YSAmJiAocGVzID0gcGFyc2VQRVMoaWQzRGF0YSkpICYmIHBlcy5wdHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJzZUlEM1BFUyhwZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDNEYXRhID0geyBkYXRhOiBbXSwgc2l6ZTogMCB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlkM0RhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDNEYXRhLmRhdGEucHVzaChkYXRhLnN1YmFycmF5KG9mZnNldCwgc3RhcnQgKyAxODgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDNEYXRhLnNpemUgKz0gc3RhcnQgKyAxODggLSBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldCArPSBkYXRhW29mZnNldF0gKyAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcG10SWQgPSB0aGlzLl9wbXRJZCA9IHBhcnNlUEFUKGRhdGEsIG9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBwbXRJZDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQgKz0gZGF0YVtvZmZzZXRdICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXJzZWRQSURzID0gcGFyc2VQTVQoZGF0YSwgb2Zmc2V0LCB0aGlzLnR5cGVTdXBwb3J0ZWQubXBlZyA9PT0gdHJ1ZSB8fCB0aGlzLnR5cGVTdXBwb3J0ZWQubXAzID09PSB0cnVlLCB0aGlzLnNhbXBsZUFlcyAhPSBudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9ubHkgdXBkYXRlIHRyYWNrIGlkIGlmIHRyYWNrIFBJRCBmb3VuZCB3aGlsZSBwYXJzaW5nIFBNVFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyBpcyB0byBhdm9pZCByZXNldHRpbmcgdGhlIFBJRCB0byAtMSBpbiBjYXNlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0cmFjayBQSUQgdHJhbnNpZW50bHkgZGlzYXBwZWFycyBmcm9tIHRoZSBzdHJlYW1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgY291bGQgaGFwcGVuIGluIGNhc2Ugb2YgdHJhbnNpZW50IG1pc3NpbmcgYXVkaW8gc2FtcGxlcyBmb3IgZXhhbXBsZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTk9URSB0aGlzIGlzIG9ubHkgdGhlIFBJRCBvZiB0aGUgdHJhY2sgYXMgZm91bmQgaW4gVFMsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBidXQgd2UgYXJlIG5vdCB1c2luZyB0aGlzIGZvciBNUDQgdHJhY2sgSURzLlxuICAgICAgICAgICAgICAgICAgICAgICAgYXZjSWQgPSBwYXJzZWRQSURzLmF2YztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhdmNJZCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdmNUcmFjay5waWQgPSBhdmNJZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGF1ZGlvSWQgPSBwYXJzZWRQSURzLmF1ZGlvO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGF1ZGlvSWQgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXVkaW9UcmFjay5waWQgPSBhdWRpb0lkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF1ZGlvVHJhY2suaXNBQUMgPSBwYXJzZWRQSURzLmlzQUFDO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWQzSWQgPSBwYXJzZWRQSURzLmlkMztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpZDNJZCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDNUcmFjay5waWQgPSBpZDNJZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1bmtub3duUElEcyAmJiAhcG10UGFyc2VkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLmxvZygncmVwYXJzZSBmcm9tIGJlZ2lubmluZycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVua25vd25QSURzID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2Ugc2V0IGl0IHRvIC0xODgsIHRoZSArPSAxODggaW4gdGhlIGZvciBsb29wIHdpbGwgcmVzZXQgc3RhcnQgdG8gMFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gc3luY09mZnNldCAtIDE4ODtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHBtdFBhcnNlZCA9IHRoaXMucG10UGFyc2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE3OlxuICAgICAgICAgICAgICAgICAgICBjYXNlIDB4MWZmZjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgdW5rbm93blBJRHMgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vYnNlcnZlci50cmlnZ2VyKGV2ZW50c18xLmRlZmF1bHQuRVJST1IsIHsgdHlwZTogZXJyb3JzXzEuRXJyb3JUeXBlcy5NRURJQV9FUlJPUiwgZGV0YWlsczogZXJyb3JzXzEuRXJyb3JEZXRhaWxzLkZSQUdfUEFSU0lOR19FUlJPUiwgZmF0YWw6IGZhbHNlLCByZWFzb246ICdUUyBwYWNrZXQgZGlkIG5vdCBzdGFydCB3aXRoIDB4NDcnIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHRyeSB0byBwYXJzZSBsYXN0IFBFUyBwYWNrZXRzXG4gICAgICAgIGlmIChhdmNEYXRhICYmIChwZXMgPSBwYXJzZVBFUyhhdmNEYXRhKSkgJiYgcGVzLnB0cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwYXJzZUFWQ1BFUyhwZXMsIHRydWUpO1xuICAgICAgICAgICAgYXZjVHJhY2sucGVzRGF0YSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBlaXRoZXIgYXZjRGF0YSBudWxsIG9yIFBFUyB0cnVuY2F0ZWQsIGtlZXAgaXQgZm9yIG5leHQgZnJhZyBwYXJzaW5nXG4gICAgICAgICAgICBhdmNUcmFjay5wZXNEYXRhID0gYXZjRGF0YTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXVkaW9EYXRhICYmIChwZXMgPSBwYXJzZVBFUyhhdWRpb0RhdGEpKSAmJiBwZXMucHRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmIChhdWRpb1RyYWNrLmlzQUFDKSB7XG4gICAgICAgICAgICAgICAgcGFyc2VBQUNQRVMocGVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhcnNlTVBFR1BFUyhwZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXVkaW9UcmFjay5wZXNEYXRhID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChhdWRpb0RhdGEgJiYgYXVkaW9EYXRhLnNpemUpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXJfMS5sb2dnZXIubG9nKCdsYXN0IEFBQyBQRVMgcGFja2V0IHRydW5jYXRlZCxtaWdodCBvdmVybGFwIGJldHdlZW4gZnJhZ21lbnRzJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBlaXRoZXIgYXVkaW9EYXRhIG51bGwgb3IgUEVTIHRydW5jYXRlZCwga2VlcCBpdCBmb3IgbmV4dCBmcmFnIHBhcnNpbmdcbiAgICAgICAgICAgIGF1ZGlvVHJhY2sucGVzRGF0YSA9IGF1ZGlvRGF0YTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaWQzRGF0YSAmJiAocGVzID0gcGFyc2VQRVMoaWQzRGF0YSkpICYmIHBlcy5wdHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcGFyc2VJRDNQRVMocGVzKTtcbiAgICAgICAgICAgIGlkM1RyYWNrLnBlc0RhdGEgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gZWl0aGVyIGlkM0RhdGEgbnVsbCBvciBQRVMgdHJ1bmNhdGVkLCBrZWVwIGl0IGZvciBuZXh0IGZyYWcgcGFyc2luZ1xuICAgICAgICAgICAgaWQzVHJhY2sucGVzRGF0YSA9IGlkM0RhdGE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc2FtcGxlQWVzID09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMucmVtdXhlci5yZW11eChhdWRpb1RyYWNrLCBhdmNUcmFjaywgaWQzVHJhY2ssIHRoaXMuX3R4dFRyYWNrLCB0aW1lT2Zmc2V0LCBjb250aWd1b3VzLCBhY2N1cmF0ZVRpbWVPZmZzZXQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kZWNyeXB0QW5kUmVtdXgoYXVkaW9UcmFjaywgYXZjVHJhY2ssIGlkM1RyYWNrLCB0aGlzLl90eHRUcmFjaywgdGltZU9mZnNldCwgY29udGlndW91cywgYWNjdXJhdGVUaW1lT2Zmc2V0KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVFNEZW11eGVyLnByb3RvdHlwZS5kZWNyeXB0QW5kUmVtdXggPSBmdW5jdGlvbiAoYXVkaW9UcmFjaywgdmlkZW9UcmFjaywgaWQzVHJhY2ssIHRleHRUcmFjaywgdGltZU9mZnNldCwgY29udGlndW91cywgYWNjdXJhdGVUaW1lT2Zmc2V0KSB7XG4gICAgICAgIGlmIChhdWRpb1RyYWNrLnNhbXBsZXMgJiYgYXVkaW9UcmFjay5pc0FBQykge1xuICAgICAgICAgICAgdmFyIGxvY2FsdGhpc18xID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMuc2FtcGxlQWVzLmRlY3J5cHRBYWNTYW1wbGVzKGF1ZGlvVHJhY2suc2FtcGxlcywgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGxvY2FsdGhpc18xLmRlY3J5cHRBbmRSZW11eEF2YyhhdWRpb1RyYWNrLCB2aWRlb1RyYWNrLCBpZDNUcmFjaywgdGV4dFRyYWNrLCB0aW1lT2Zmc2V0LCBjb250aWd1b3VzLCBhY2N1cmF0ZVRpbWVPZmZzZXQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRlY3J5cHRBbmRSZW11eEF2YyhhdWRpb1RyYWNrLCB2aWRlb1RyYWNrLCBpZDNUcmFjaywgdGV4dFRyYWNrLCB0aW1lT2Zmc2V0LCBjb250aWd1b3VzLCBhY2N1cmF0ZVRpbWVPZmZzZXQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUU0RlbXV4ZXIucHJvdG90eXBlLmRlY3J5cHRBbmRSZW11eEF2YyA9IGZ1bmN0aW9uIChhdWRpb1RyYWNrLCB2aWRlb1RyYWNrLCBpZDNUcmFjaywgdGV4dFRyYWNrLCB0aW1lT2Zmc2V0LCBjb250aWd1b3VzLCBhY2N1cmF0ZVRpbWVPZmZzZXQpIHtcbiAgICAgICAgaWYgKHZpZGVvVHJhY2suc2FtcGxlcykge1xuICAgICAgICAgICAgdmFyIGxvY2FsdGhpc18yID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMuc2FtcGxlQWVzLmRlY3J5cHRBdmNTYW1wbGVzKHZpZGVvVHJhY2suc2FtcGxlcywgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGxvY2FsdGhpc18yLnJlbXV4ZXIucmVtdXgoYXVkaW9UcmFjaywgdmlkZW9UcmFjaywgaWQzVHJhY2ssIHRleHRUcmFjaywgdGltZU9mZnNldCwgY29udGlndW91cywgYWNjdXJhdGVUaW1lT2Zmc2V0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5yZW11eGVyLnJlbXV4KGF1ZGlvVHJhY2ssIHZpZGVvVHJhY2ssIGlkM1RyYWNrLCB0ZXh0VHJhY2ssIHRpbWVPZmZzZXQsIGNvbnRpZ3VvdXMsIGFjY3VyYXRlVGltZU9mZnNldCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRTRGVtdXhlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5faW5pdFBUUyA9IHRoaXMuX2luaXREVFMgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuX2R1cmF0aW9uID0gMDtcbiAgICB9O1xuICAgIFRTRGVtdXhlci5wcm90b3R5cGUuX3BhcnNlUEFUID0gZnVuY3Rpb24gKGRhdGEsIG9mZnNldCkge1xuICAgICAgICAvLyBza2lwIHRoZSBQU0kgaGVhZGVyIGFuZCBwYXJzZSB0aGUgZmlyc3QgUE1UIGVudHJ5XG4gICAgICAgIHJldHVybiAoZGF0YVtvZmZzZXQgKyAxMF0gJiAweDFGKSA8PCA4IHwgZGF0YVtvZmZzZXQgKyAxMV07XG4gICAgICAgIC8vIGxvZ2dlci5sb2coJ1BNVCBQSUQ6JyAgKyB0aGlzLl9wbXRJZCk7XG4gICAgfTtcbiAgICBUU0RlbXV4ZXIucHJvdG90eXBlLl9wYXJzZVBNVCA9IGZ1bmN0aW9uIChkYXRhLCBvZmZzZXQsIG1wZWdTdXBwb3J0ZWQsIGlzU2FtcGxlQWVzKSB7XG4gICAgICAgIHZhciBzZWN0aW9uTGVuZ3RoLCB0YWJsZUVuZCwgcHJvZ3JhbUluZm9MZW5ndGgsIHBpZCwgcmVzdWx0ID0geyBhdWRpbzogLTEsIGF2YzogLTEsIGlkMzogLTEsIGlzQUFDOiB0cnVlIH07XG4gICAgICAgIHNlY3Rpb25MZW5ndGggPSAoZGF0YVtvZmZzZXQgKyAxXSAmIDB4MGYpIDw8IDggfCBkYXRhW29mZnNldCArIDJdO1xuICAgICAgICB0YWJsZUVuZCA9IG9mZnNldCArIDMgKyBzZWN0aW9uTGVuZ3RoIC0gNDtcbiAgICAgICAgLy8gdG8gZGV0ZXJtaW5lIHdoZXJlIHRoZSB0YWJsZSBpcywgd2UgaGF2ZSB0byBmaWd1cmUgb3V0IGhvd1xuICAgICAgICAvLyBsb25nIHRoZSBwcm9ncmFtIGluZm8gZGVzY3JpcHRvcnMgYXJlXG4gICAgICAgIHByb2dyYW1JbmZvTGVuZ3RoID0gKGRhdGFbb2Zmc2V0ICsgMTBdICYgMHgwZikgPDwgOCB8IGRhdGFbb2Zmc2V0ICsgMTFdO1xuICAgICAgICAvLyBhZHZhbmNlIHRoZSBvZmZzZXQgdG8gdGhlIGZpcnN0IGVudHJ5IGluIHRoZSBtYXBwaW5nIHRhYmxlXG4gICAgICAgIG9mZnNldCArPSAxMiArIHByb2dyYW1JbmZvTGVuZ3RoO1xuICAgICAgICB3aGlsZSAob2Zmc2V0IDwgdGFibGVFbmQpIHtcbiAgICAgICAgICAgIHBpZCA9IChkYXRhW29mZnNldCArIDFdICYgMHgxRikgPDwgOCB8IGRhdGFbb2Zmc2V0ICsgMl07XG4gICAgICAgICAgICBzd2l0Y2ggKGRhdGFbb2Zmc2V0XSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMHhjZjogLy8gU0FNUExFLUFFUyBBQUNcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1NhbXBsZUFlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLmxvZygndW5rb3duIHN0cmVhbSB0eXBlOicgKyBkYXRhW29mZnNldF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICAgICAgICAgICAgLy8gSVNPL0lFQyAxMzgxOC03IEFEVFMgQUFDIChNUEVHLTIgbG93ZXIgYml0LXJhdGUgYXVkaW8pXG4gICAgICAgICAgICAgICAgY2FzZSAweDBmOlxuICAgICAgICAgICAgICAgICAgICAvLyBsb2dnZXIubG9nKCdBQUMgUElEOicgICsgcGlkKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5hdWRpbyA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hdWRpbyA9IHBpZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAvLyBQYWNrZXRpemVkIG1ldGFkYXRhIChJRDMpXG4gICAgICAgICAgICAgICAgY2FzZSAweDE1OlxuICAgICAgICAgICAgICAgICAgICAvLyBsb2dnZXIubG9nKCdJRDMgUElEOicgICsgcGlkKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5pZDMgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuaWQzID0gcGlkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMHhkYjogLy8gU0FNUExFLUFFUyBBVkNcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1NhbXBsZUFlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLmxvZygndW5rb3duIHN0cmVhbSB0eXBlOicgKyBkYXRhW29mZnNldF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICAgICAgICAgICAgLy8gSVRVLVQgUmVjLiBILjI2NCBhbmQgSVNPL0lFQyAxNDQ5Ni0xMCAobG93ZXIgYml0LXJhdGUgdmlkZW8pXG4gICAgICAgICAgICAgICAgY2FzZSAweDFiOlxuICAgICAgICAgICAgICAgICAgICAvLyBsb2dnZXIubG9nKCdBVkMgUElEOicgICsgcGlkKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5hdmMgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuYXZjID0gcGlkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIC8vIElTTy9JRUMgMTExNzItMyAoTVBFRy0xIGF1ZGlvKVxuICAgICAgICAgICAgICAgIC8vIG9yIElTTy9JRUMgMTM4MTgtMyAoTVBFRy0yIGhhbHZlZCBzYW1wbGUgcmF0ZSBhdWRpbylcbiAgICAgICAgICAgICAgICBjYXNlIDB4MDM6XG4gICAgICAgICAgICAgICAgY2FzZSAweDA0OlxuICAgICAgICAgICAgICAgICAgICAvLyBsb2dnZXIubG9nKCdNUEVHIFBJRDonICArIHBpZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbXBlZ1N1cHBvcnRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLmxvZygnTVBFRyBhdWRpbyBmb3VuZCwgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJyb3dzZXIgZm9yIG5vdycpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJlc3VsdC5hdWRpbyA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hdWRpbyA9IHBpZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5pc0FBQyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMHgyNDpcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLndhcm4oJ0hFVkMgc3RyZWFtIHR5cGUgZm91bmQsIG5vdCBzdXBwb3J0ZWQgZm9yIG5vdycpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBsb2dnZXJfMS5sb2dnZXIubG9nKCd1bmtvd24gc3RyZWFtIHR5cGU6JyArIGRhdGFbb2Zmc2V0XSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gbW92ZSB0byB0aGUgbmV4dCB0YWJsZSBlbnRyeVxuICAgICAgICAgICAgLy8gc2tpcCBwYXN0IHRoZSBlbGVtZW50YXJ5IHN0cmVhbSBkZXNjcmlwdG9ycywgaWYgcHJlc2VudFxuICAgICAgICAgICAgb2Zmc2V0ICs9ICgoZGF0YVtvZmZzZXQgKyAzXSAmIDB4MEYpIDw8IDggfCBkYXRhW29mZnNldCArIDRdKSArIDU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIFRTRGVtdXhlci5wcm90b3R5cGUuX3BhcnNlUEVTID0gZnVuY3Rpb24gKHN0cmVhbSkge1xuICAgICAgICB2YXIgaSA9IDAsIGZyYWcsIHBlc0ZsYWdzLCBwZXNQcmVmaXgsIHBlc0xlbiwgcGVzSGRyTGVuLCBwZXNEYXRhLCBwZXNQdHMsIHBlc0R0cywgcGF5bG9hZFN0YXJ0T2Zmc2V0LCBkYXRhID0gc3RyZWFtLmRhdGE7XG4gICAgICAgIC8vIHNhZmV0eSBjaGVja1xuICAgICAgICBpZiAoIXN0cmVhbSB8fCBzdHJlYW0uc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gd2UgbWlnaHQgbmVlZCB1cCB0byAxOSBieXRlcyB0byByZWFkIFBFUyBoZWFkZXJcbiAgICAgICAgLy8gaWYgZmlyc3QgY2h1bmsgb2YgZGF0YSBpcyBsZXNzIHRoYW4gMTkgYnl0ZXMsIGxldCdzIG1lcmdlIGl0IHdpdGggZm9sbG93aW5nIG9uZXMgdW50aWwgd2UgZ2V0IDE5IGJ5dGVzXG4gICAgICAgIC8vIHVzdWFsbHkgb25seSBvbmUgbWVyZ2UgaXMgbmVlZGVkIChhbmQgdGhpcyBpcyByYXJlIC4uLilcbiAgICAgICAgd2hpbGUgKGRhdGFbMF0ubGVuZ3RoIDwgMTkgJiYgZGF0YS5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICB2YXIgbmV3RGF0YSA9IG5ldyBVaW50OEFycmF5KGRhdGFbMF0ubGVuZ3RoICsgZGF0YVsxXS5sZW5ndGgpO1xuICAgICAgICAgICAgbmV3RGF0YS5zZXQoZGF0YVswXSk7XG4gICAgICAgICAgICBuZXdEYXRhLnNldChkYXRhWzFdLCBkYXRhWzBdLmxlbmd0aCk7XG4gICAgICAgICAgICBkYXRhWzBdID0gbmV3RGF0YTtcbiAgICAgICAgICAgIGRhdGEuc3BsaWNlKDEsIDEpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJldHJpZXZlIFBUUy9EVFMgZnJvbSBmaXJzdCBmcmFnbWVudFxuICAgICAgICBmcmFnID0gZGF0YVswXTtcbiAgICAgICAgcGVzUHJlZml4ID0gKGZyYWdbMF0gPDwgMTYpICsgKGZyYWdbMV0gPDwgOCkgKyBmcmFnWzJdO1xuICAgICAgICBpZiAocGVzUHJlZml4ID09PSAxKSB7XG4gICAgICAgICAgICBwZXNMZW4gPSAoZnJhZ1s0XSA8PCA4KSArIGZyYWdbNV07XG4gICAgICAgICAgICAvLyBpZiBQRVMgcGFyc2VkIGxlbmd0aCBpcyBub3QgemVybyBhbmQgZ3JlYXRlciB0aGFuIHRvdGFsIHJlY2VpdmVkIGxlbmd0aCwgc3RvcCBwYXJzaW5nLiBQRVMgbWlnaHQgYmUgdHJ1bmNhdGVkXG4gICAgICAgICAgICAvLyBtaW51cyA2IDogUEVTIGhlYWRlciBzaXplXG4gICAgICAgICAgICBpZiAocGVzTGVuICYmIHBlc0xlbiA+IHN0cmVhbS5zaXplIC0gNikge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGVzRmxhZ3MgPSBmcmFnWzddO1xuICAgICAgICAgICAgaWYgKHBlc0ZsYWdzICYgMHhDMCkge1xuICAgICAgICAgICAgICAgIC8qIFBFUyBoZWFkZXIgZGVzY3JpYmVkIGhlcmUgOiBodHRwOi8vZHZkLnNvdXJjZWZvcmdlLm5ldC9kdmRpbmZvL3Blcy1oZHIuaHRtbFxuICAgICAgICAgICAgICAgICAgICBhcyBQVFMgLyBEVFMgaXMgMzMgYml0IHdlIGNhbm5vdCB1c2UgYml0d2lzZSBvcGVyYXRvciBpbiBKUyxcbiAgICAgICAgICAgICAgICAgICAgYXMgQml0d2lzZSBvcGVyYXRvcnMgdHJlYXQgdGhlaXIgb3BlcmFuZHMgYXMgYSBzZXF1ZW5jZSBvZiAzMiBiaXRzICovXG4gICAgICAgICAgICAgICAgcGVzUHRzID0gKGZyYWdbOV0gJiAweDBFKSAqIDUzNjg3MDkxMiArIC8vIDEgPDwgMjlcbiAgICAgICAgICAgICAgICAgICAgKGZyYWdbMTBdICYgMHhGRikgKiA0MTk0MzA0ICsgLy8gMSA8PCAyMlxuICAgICAgICAgICAgICAgICAgICAoZnJhZ1sxMV0gJiAweEZFKSAqIDE2Mzg0ICsgLy8gMSA8PCAxNFxuICAgICAgICAgICAgICAgICAgICAoZnJhZ1sxMl0gJiAweEZGKSAqIDEyOCArIC8vIDEgPDwgN1xuICAgICAgICAgICAgICAgICAgICAoZnJhZ1sxM10gJiAweEZFKSAvIDI7XG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgaWYgZ3JlYXRlciB0aGFuIDJeMzIgLTFcbiAgICAgICAgICAgICAgICBpZiAocGVzUHRzID4gNDI5NDk2NzI5NSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBkZWNyZW1lbnQgMl4zM1xuICAgICAgICAgICAgICAgICAgICBwZXNQdHMgLT0gODU4OTkzNDU5MjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHBlc0ZsYWdzICYgMHg0MCkge1xuICAgICAgICAgICAgICAgICAgICBwZXNEdHMgPSAoZnJhZ1sxNF0gJiAweDBFKSAqIDUzNjg3MDkxMiArIC8vIDEgPDwgMjlcbiAgICAgICAgICAgICAgICAgICAgICAgIChmcmFnWzE1XSAmIDB4RkYpICogNDE5NDMwNCArIC8vIDEgPDwgMjJcbiAgICAgICAgICAgICAgICAgICAgICAgIChmcmFnWzE2XSAmIDB4RkUpICogMTYzODQgKyAvLyAxIDw8IDE0XG4gICAgICAgICAgICAgICAgICAgICAgICAoZnJhZ1sxN10gJiAweEZGKSAqIDEyOCArIC8vIDEgPDwgN1xuICAgICAgICAgICAgICAgICAgICAgICAgKGZyYWdbMThdICYgMHhGRSkgLyAyO1xuICAgICAgICAgICAgICAgICAgICAvLyBjaGVjayBpZiBncmVhdGVyIHRoYW4gMl4zMiAtMVxuICAgICAgICAgICAgICAgICAgICBpZiAocGVzRHRzID4gNDI5NDk2NzI5NSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZGVjcmVtZW50IDJeMzNcbiAgICAgICAgICAgICAgICAgICAgICAgIHBlc0R0cyAtPSA4NTg5OTM0NTkyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChwZXNQdHMgLSBwZXNEdHMgPiA2MCAqIDkwMDAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXJfMS5sb2dnZXIud2FybihNYXRoLnJvdW5kKChwZXNQdHMgLSBwZXNEdHMpIC8gOTAwMDApICsgXCJzIGRlbHRhIGJldHdlZW4gUFRTIGFuZCBEVFMsIGFsaWduIHRoZW1cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBwZXNQdHMgPSBwZXNEdHM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHBlc0R0cyA9IHBlc1B0cztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwZXNIZHJMZW4gPSBmcmFnWzhdO1xuICAgICAgICAgICAgLy8gOSBieXRlcyA6IDYgYnl0ZXMgZm9yIFBFUyBoZWFkZXIgKyAzIGJ5dGVzIGZvciBQRVMgZXh0ZW5zaW9uXG4gICAgICAgICAgICBwYXlsb2FkU3RhcnRPZmZzZXQgPSBwZXNIZHJMZW4gKyA5O1xuICAgICAgICAgICAgc3RyZWFtLnNpemUgLT0gcGF5bG9hZFN0YXJ0T2Zmc2V0O1xuICAgICAgICAgICAgLy8gcmVhc3NlbWJsZSBQRVMgcGFja2V0XG4gICAgICAgICAgICBwZXNEYXRhID0gbmV3IFVpbnQ4QXJyYXkoc3RyZWFtLnNpemUpO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDAsIGRhdGFMZW4gPSBkYXRhLmxlbmd0aDsgaiA8IGRhdGFMZW47IGorKykge1xuICAgICAgICAgICAgICAgIGZyYWcgPSBkYXRhW2pdO1xuICAgICAgICAgICAgICAgIHZhciBsZW4gPSBmcmFnLmJ5dGVMZW5ndGg7XG4gICAgICAgICAgICAgICAgaWYgKHBheWxvYWRTdGFydE9mZnNldCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocGF5bG9hZFN0YXJ0T2Zmc2V0ID4gbGVuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0cmltIGZ1bGwgZnJhZyBpZiBQRVMgaGVhZGVyIGJpZ2dlciB0aGFuIGZyYWdcbiAgICAgICAgICAgICAgICAgICAgICAgIHBheWxvYWRTdGFydE9mZnNldCAtPSBsZW47XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRyaW0gcGFydGlhbCBmcmFnIGlmIFBFUyBoZWFkZXIgc21hbGxlciB0aGFuIGZyYWdcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyYWcgPSBmcmFnLnN1YmFycmF5KHBheWxvYWRTdGFydE9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZW4gLT0gcGF5bG9hZFN0YXJ0T2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF5bG9hZFN0YXJ0T2Zmc2V0ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwZXNEYXRhLnNldChmcmFnLCBpKTtcbiAgICAgICAgICAgICAgICBpICs9IGxlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwZXNMZW4pIHtcbiAgICAgICAgICAgICAgICAvLyBwYXlsb2FkIHNpemUgOiByZW1vdmUgUEVTIGhlYWRlciArIFBFUyBleHRlbnNpb25cbiAgICAgICAgICAgICAgICBwZXNMZW4gLT0gcGVzSGRyTGVuICsgMztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IHBlc0RhdGEsIHB0czogcGVzUHRzLCBkdHM6IHBlc0R0cywgbGVuOiBwZXNMZW4gfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUU0RlbXV4ZXIucHJvdG90eXBlLnB1c2hBY2Nlc1VuaXQgPSBmdW5jdGlvbiAoYXZjU2FtcGxlLCBhdmNUcmFjaykge1xuICAgICAgICBpZiAoYXZjU2FtcGxlLnVuaXRzLmxlbmd0aCAmJiBhdmNTYW1wbGUuZnJhbWUpIHtcbiAgICAgICAgICAgIHZhciBzYW1wbGVzID0gYXZjVHJhY2suc2FtcGxlcztcbiAgICAgICAgICAgIHZhciBuYlNhbXBsZXMgPSBzYW1wbGVzLmxlbmd0aDtcbiAgICAgICAgICAgIC8vIG9ubHkgcHVzaCBBVkMgc2FtcGxlIGlmIHN0YXJ0aW5nIHdpdGggYSBrZXlmcmFtZSBpcyBub3QgbWFuZGF0b3J5IE9SXG4gICAgICAgICAgICAvLyAgICBpZiBrZXlmcmFtZSBhbHJlYWR5IGZvdW5kIGluIHRoaXMgZnJhZ21lbnQgT1JcbiAgICAgICAgICAgIC8vICAgICAgIGtleWZyYW1lIGZvdW5kIGluIGxhc3QgZnJhZ21lbnQgKHRyYWNrLnNwcykgQU5EXG4gICAgICAgICAgICAvLyAgICAgICAgICBzYW1wbGVzIGFscmVhZHkgYXBwZW5kZWQgKHdlIGFscmVhZHkgZm91bmQgYSBrZXlmcmFtZSBpbiB0aGlzIGZyYWdtZW50KSBPUiBmcmFnbWVudCBpcyBjb250aWd1b3VzXG4gICAgICAgICAgICBpZiAoIXRoaXMuY29uZmlnLmZvcmNlS2V5RnJhbWVPbkRpc2NvbnRpbnVpdHkgfHxcbiAgICAgICAgICAgICAgICBhdmNTYW1wbGUua2V5ID09PSB0cnVlIHx8XG4gICAgICAgICAgICAgICAgKGF2Y1RyYWNrLnNwcyAmJiAobmJTYW1wbGVzIHx8IHRoaXMuY29udGlndW91cykpKSB7XG4gICAgICAgICAgICAgICAgYXZjU2FtcGxlLmlkID0gbmJTYW1wbGVzO1xuICAgICAgICAgICAgICAgIHNhbXBsZXMucHVzaChhdmNTYW1wbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gZHJvcHBlZCBzYW1wbGVzLCB0cmFjayBpdFxuICAgICAgICAgICAgICAgIGF2Y1RyYWNrLmRyb3BwZWQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYXZjU2FtcGxlLmRlYnVnLmxlbmd0aCkge1xuICAgICAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLmxvZyhhdmNTYW1wbGUucHRzICsgJy8nICsgYXZjU2FtcGxlLmR0cyArICc6JyArIGF2Y1NhbXBsZS5kZWJ1Zyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRTRGVtdXhlci5wcm90b3R5cGUuX3BhcnNlQVZDUEVTID0gZnVuY3Rpb24gKHBlcywgbGFzdCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvLyBsb2dnZXIubG9nKCdwYXJzZSBuZXcgUEVTJyk7XG4gICAgICAgIHZhciB0cmFjayA9IHRoaXMuX2F2Y1RyYWNrLCB1bml0cyA9IHRoaXMuX3BhcnNlQVZDTkFMdShwZXMuZGF0YSksIGRlYnVnID0gZmFsc2UsIGV4cEdvbG9tYkRlY29kZXIsIGF2Y1NhbXBsZSA9IHRoaXMuYXZjU2FtcGxlLCBwdXNoLCBzcHNmb3VuZCA9IGZhbHNlLCBpLCBwdXNoQWNjZXNVbml0ID0gdGhpcy5wdXNoQWNjZXNVbml0LmJpbmQodGhpcyksIGNyZWF0ZUFWQ1NhbXBsZSA9IGZ1bmN0aW9uIChrZXksIHB0cywgZHRzLCBkZWJ1Zykge1xuICAgICAgICAgICAgcmV0dXJuIHsga2V5OiBrZXksIHB0czogcHRzLCBkdHM6IGR0cywgdW5pdHM6IFtdLCBkZWJ1ZzogZGVidWcgfTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gZnJlZSBwZXMuZGF0YSB0byBzYXZlIHVwIHNvbWUgbWVtb3J5XG4gICAgICAgIHBlcy5kYXRhID0gbnVsbDtcbiAgICAgICAgLy8gaWYgbmV3IE5BTCB1bml0cyBmb3VuZCBhbmQgbGFzdCBzYW1wbGUgc3RpbGwgdGhlcmUsIGxldCdzIHB1c2ggLi4uXG4gICAgICAgIC8vIHRoaXMgaGVscHMgcGFyc2luZyBzdHJlYW1zIHdpdGggbWlzc2luZyBBVUQgKG9ubHkgZG8gdGhpcyBpZiBBVUQgbmV2ZXIgZm91bmQpXG4gICAgICAgIGlmIChhdmNTYW1wbGUgJiYgdW5pdHMubGVuZ3RoICYmICF0cmFjay5hdWRGb3VuZCkge1xuICAgICAgICAgICAgcHVzaEFjY2VzVW5pdChhdmNTYW1wbGUsIHRyYWNrKTtcbiAgICAgICAgICAgIGF2Y1NhbXBsZSA9IHRoaXMuYXZjU2FtcGxlID0gY3JlYXRlQVZDU2FtcGxlKGZhbHNlLCBwZXMucHRzLCBwZXMuZHRzLCAnJyk7XG4gICAgICAgIH1cbiAgICAgICAgdW5pdHMuZm9yRWFjaChmdW5jdGlvbiAodW5pdCkge1xuICAgICAgICAgICAgc3dpdGNoICh1bml0LnR5cGUpIHtcbiAgICAgICAgICAgICAgICAvLyBORFJcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIHB1c2ggPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWF2Y1NhbXBsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXZjU2FtcGxlID0gX3RoaXMuYXZjU2FtcGxlID0gY3JlYXRlQVZDU2FtcGxlKHRydWUsIHBlcy5wdHMsIHBlcy5kdHMsICcnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZGVidWcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF2Y1NhbXBsZS5kZWJ1ZyArPSAnTkRSICc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYXZjU2FtcGxlLmZyYW1lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRhdGEgPSB1bml0LmRhdGE7XG4gICAgICAgICAgICAgICAgICAgIC8vIG9ubHkgY2hlY2sgc2xpY2UgdHlwZSB0byBkZXRlY3QgS0YgaW4gY2FzZSBTUFMgZm91bmQgaW4gc2FtZSBwYWNrZXQgKGFueSBrZXlmcmFtZSBpcyBwcmVjZWRlZCBieSBTUFMgLi4uKVxuICAgICAgICAgICAgICAgICAgICBpZiAoc3BzZm91bmQgJiYgZGF0YS5sZW5ndGggPiA0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByZXRyaWV2ZSBzbGljZSB0eXBlIGJ5IHBhcnNpbmcgYmVnaW5uaW5nIG9mIE5BTCB1bml0IChmb2xsb3cgSDI2NCBzcGVjLCBzbGljZV9oZWFkZXIgZGVmaW5pdGlvbikgdG8gZGV0ZWN0IGtleWZyYW1lIGVtYmVkZGVkIGluIE5EUlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNsaWNlVHlwZSA9IG5ldyBleHBfZ29sb21iXzEuZGVmYXVsdChkYXRhKS5yZWFkU2xpY2VUeXBlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAyIDogSSBzbGljZSwgNCA6IFNJIHNsaWNlLCA3IDogSSBzbGljZSwgOTogU0kgc2xpY2VcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNJIHNsaWNlIDogQSBzbGljZSB0aGF0IGlzIGNvZGVkIHVzaW5nIGludHJhIHByZWRpY3Rpb24gb25seSBhbmQgdXNpbmcgcXVhbnRpc2F0aW9uIG9mIHRoZSBwcmVkaWN0aW9uIHNhbXBsZXMuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBbiBTSSBzbGljZSBjYW4gYmUgY29kZWQgc3VjaCB0aGF0IGl0cyBkZWNvZGVkIHNhbXBsZXMgY2FuIGJlIGNvbnN0cnVjdGVkIGlkZW50aWNhbGx5IHRvIGFuIFNQIHNsaWNlLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSSBzbGljZTogQSBzbGljZSB0aGF0IGlzIG5vdCBhbiBTSSBzbGljZSB0aGF0IGlzIGRlY29kZWQgdXNpbmcgaW50cmEgcHJlZGljdGlvbiBvbmx5LlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgKHNsaWNlVHlwZSA9PT0gMiB8fCBzbGljZVR5cGUgPT09IDcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzbGljZVR5cGUgPT09IDIgfHwgc2xpY2VUeXBlID09PSA0IHx8IHNsaWNlVHlwZSA9PT0gNyB8fCBzbGljZVR5cGUgPT09IDkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdmNTYW1wbGUua2V5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAvLyBJRFJcbiAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgIHB1c2ggPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAvLyBoYW5kbGUgUEVTIG5vdCBzdGFydGluZyB3aXRoIEFVRFxuICAgICAgICAgICAgICAgICAgICBpZiAoIWF2Y1NhbXBsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXZjU2FtcGxlID0gX3RoaXMuYXZjU2FtcGxlID0gY3JlYXRlQVZDU2FtcGxlKHRydWUsIHBlcy5wdHMsIHBlcy5kdHMsICcnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZGVidWcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF2Y1NhbXBsZS5kZWJ1ZyArPSAnSURSICc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYXZjU2FtcGxlLmtleSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGF2Y1NhbXBsZS5mcmFtZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIC8vIFNFSVxuICAgICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICAgICAgcHVzaCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkZWJ1ZyAmJiBhdmNTYW1wbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF2Y1NhbXBsZS5kZWJ1ZyArPSAnU0VJICc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZXhwR29sb21iRGVjb2RlciA9IG5ldyBleHBfZ29sb21iXzEuZGVmYXVsdChfdGhpcy5kaXNjYXJkRVBCKHVuaXQuZGF0YSkpO1xuICAgICAgICAgICAgICAgICAgICAvLyBza2lwIGZyYW1lVHlwZVxuICAgICAgICAgICAgICAgICAgICBleHBHb2xvbWJEZWNvZGVyLnJlYWRVQnl0ZSgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGF5bG9hZFR5cGUgPSAwO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGF5bG9hZFNpemUgPSAwO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZW5kT2ZDYXB0aW9ucyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYiA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICghZW5kT2ZDYXB0aW9ucyAmJiBleHBHb2xvbWJEZWNvZGVyLmJ5dGVzQXZhaWxhYmxlID4gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF5bG9hZFR5cGUgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGIgPSBleHBHb2xvbWJEZWNvZGVyLnJlYWRVQnl0ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBheWxvYWRUeXBlICs9IGI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IHdoaWxlIChiID09PSAweEZGKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFBhcnNlIHBheWxvYWQgc2l6ZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIHBheWxvYWRTaXplID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiID0gZXhwR29sb21iRGVjb2Rlci5yZWFkVUJ5dGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXlsb2FkU2l6ZSArPSBiO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoYiA9PT0gMHhGRik7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiB0aGVyZSBjYW4gYmUgbW9yZSB0aGFuIG9uZSBwYXlsb2FkIGluIGFuIFNFSSBwYWNrZXQuLi5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IG5lZWQgdG8gcmVhZCB0eXBlIGFuZCBzaXplIGluIGEgd2hpbGUgbG9vcCB0byBnZXQgdGhlbSBhbGxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXlsb2FkVHlwZSA9PT0gNCAmJiBleHBHb2xvbWJEZWNvZGVyLmJ5dGVzQXZhaWxhYmxlICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kT2ZDYXB0aW9ucyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvdW50cnlDb2RlID0gZXhwR29sb21iRGVjb2Rlci5yZWFkVUJ5dGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY291bnRyeUNvZGUgPT09IDE4MSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHJvdmlkZXJDb2RlID0gZXhwR29sb21iRGVjb2Rlci5yZWFkVVNob3J0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcm92aWRlckNvZGUgPT09IDQ5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdXNlclN0cnVjdHVyZSA9IGV4cEdvbG9tYkRlY29kZXIucmVhZFVJbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1c2VyU3RydWN0dXJlID09PSAweDQ3NDEzOTM0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHVzZXJEYXRhVHlwZSA9IGV4cEdvbG9tYkRlY29kZXIucmVhZFVCeXRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmF3IENFQS02MDggYnl0ZXMgd3JhcHBlZCBpbiBDRUEtNzA4IHBhY2tldFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1c2VyRGF0YVR5cGUgPT09IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZpcnN0Qnl0ZSA9IGV4cEdvbG9tYkRlY29kZXIucmVhZFVCeXRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzZWNvbmRCeXRlID0gZXhwR29sb21iRGVjb2Rlci5yZWFkVUJ5dGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRvdGFsQ0NzID0gMzEgJiBmaXJzdEJ5dGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBieXRlQXJyYXkgPSBbZmlyc3RCeXRlLCBzZWNvbmRCeXRlXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHRvdGFsQ0NzOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDMgYnl0ZXMgcGVyIENDXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBieXRlQXJyYXkucHVzaChleHBHb2xvbWJEZWNvZGVyLnJlYWRVQnl0ZSgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ5dGVBcnJheS5wdXNoKGV4cEdvbG9tYkRlY29kZXIucmVhZFVCeXRlKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnl0ZUFycmF5LnB1c2goZXhwR29sb21iRGVjb2Rlci5yZWFkVUJ5dGUoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2luc2VydFNhbXBsZUluT3JkZXIoX3RoaXMuX3R4dFRyYWNrLnNhbXBsZXMsIHsgdHlwZTogMywgcHRzOiBwZXMucHRzLCBieXRlczogYnl0ZUFycmF5IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHBheWxvYWRTaXplIDwgZXhwR29sb21iRGVjb2Rlci5ieXRlc0F2YWlsYWJsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBwYXlsb2FkU2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cEdvbG9tYkRlY29kZXIucmVhZFVCeXRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIC8vIFNQU1xuICAgICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICAgICAgcHVzaCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHNwc2ZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlYnVnICYmIGF2Y1NhbXBsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXZjU2FtcGxlLmRlYnVnICs9ICdTUFMgJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIXRyYWNrLnNwcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXhwR29sb21iRGVjb2RlciA9IG5ldyBleHBfZ29sb21iXzEuZGVmYXVsdCh1bml0LmRhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbmZpZyA9IGV4cEdvbG9tYkRlY29kZXIucmVhZFNQUygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJhY2sud2lkdGggPSBjb25maWcud2lkdGg7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFjay5oZWlnaHQgPSBjb25maWcuaGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJhY2sucGl4ZWxSYXRpbyA9IGNvbmZpZy5waXhlbFJhdGlvO1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJhY2suc3BzID0gW3VuaXQuZGF0YV07XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFjay5kdXJhdGlvbiA9IF90aGlzLl9kdXJhdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb2RlY2FycmF5ID0gdW5pdC5kYXRhLnN1YmFycmF5KDEsIDQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvZGVjc3RyaW5nID0gJ2F2YzEuJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaCA9IGNvZGVjYXJyYXlbaV0udG9TdHJpbmcoMTYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaCA9ICcwJyArIGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVjc3RyaW5nICs9IGg7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFjay5jb2RlYyA9IGNvZGVjc3RyaW5nO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIC8vIFBQU1xuICAgICAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICAgICAgcHVzaCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkZWJ1ZyAmJiBhdmNTYW1wbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF2Y1NhbXBsZS5kZWJ1ZyArPSAnUFBTICc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0cmFjay5wcHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYWNrLnBwcyA9IFt1bml0LmRhdGFdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIC8vIEFVRFxuICAgICAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgICAgICAgcHVzaCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB0cmFjay5hdWRGb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhdmNTYW1wbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHB1c2hBY2Nlc1VuaXQoYXZjU2FtcGxlLCB0cmFjayk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYXZjU2FtcGxlID0gX3RoaXMuYXZjU2FtcGxlID0gY3JlYXRlQVZDU2FtcGxlKGZhbHNlLCBwZXMucHRzLCBwZXMuZHRzLCBkZWJ1ZyA/ICdBVUQgJyA6ICcnKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgLy8gRmlsbGVyIERhdGFcbiAgICAgICAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgICAgICAgICBwdXNoID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHB1c2ggPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGF2Y1NhbXBsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXZjU2FtcGxlLmRlYnVnICs9ICd1bmtub3duIE5BTCAnICsgdW5pdC50eXBlICsgJyAnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGF2Y1NhbXBsZSAmJiBwdXNoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHVuaXRzXzEgPSBhdmNTYW1wbGUudW5pdHM7XG4gICAgICAgICAgICAgICAgdW5pdHNfMS5wdXNoKHVuaXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gaWYgbGFzdCBQRVMgcGFja2V0LCBwdXNoIHNhbXBsZXNcbiAgICAgICAgaWYgKGxhc3QgJiYgYXZjU2FtcGxlKSB7XG4gICAgICAgICAgICBwdXNoQWNjZXNVbml0KGF2Y1NhbXBsZSwgdHJhY2spO1xuICAgICAgICAgICAgdGhpcy5hdmNTYW1wbGUgPSBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUU0RlbXV4ZXIucHJvdG90eXBlLl9pbnNlcnRTYW1wbGVJbk9yZGVyID0gZnVuY3Rpb24gKGFyciwgZGF0YSkge1xuICAgICAgICB2YXIgbGVuID0gYXJyLmxlbmd0aDtcbiAgICAgICAgaWYgKGxlbiA+IDApIHtcbiAgICAgICAgICAgIGlmIChkYXRhLnB0cyA+PSBhcnJbbGVuIC0gMV0ucHRzKSB7XG4gICAgICAgICAgICAgICAgYXJyLnB1c2goZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBwb3MgPSBsZW4gLSAxOyBwb3MgPj0gMDsgcG9zLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEucHRzIDwgYXJyW3Bvc10ucHRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcnIuc3BsaWNlKHBvcywgMCwgZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGFyci5wdXNoKGRhdGEpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUU0RlbXV4ZXIucHJvdG90eXBlLl9nZXRMYXN0TmFsVW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGF2Y1NhbXBsZSA9IHRoaXMuYXZjU2FtcGxlLCBsYXN0VW5pdDtcbiAgICAgICAgLy8gdHJ5IHRvIGZhbGxiYWNrIHRvIHByZXZpb3VzIHNhbXBsZSBpZiBjdXJyZW50IG9uZSBpcyBlbXB0eVxuICAgICAgICBpZiAoIWF2Y1NhbXBsZSB8fCBhdmNTYW1wbGUudW5pdHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB2YXIgdHJhY2sgPSB0aGlzLl9hdmNUcmFjaywgc2FtcGxlcyA9IHRyYWNrLnNhbXBsZXM7XG4gICAgICAgICAgICBhdmNTYW1wbGUgPSBzYW1wbGVzW3NhbXBsZXMubGVuZ3RoIC0gMV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGF2Y1NhbXBsZSkge1xuICAgICAgICAgICAgdmFyIHVuaXRzID0gYXZjU2FtcGxlLnVuaXRzO1xuICAgICAgICAgICAgbGFzdFVuaXQgPSB1bml0c1t1bml0cy5sZW5ndGggLSAxXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGFzdFVuaXQ7XG4gICAgfTtcbiAgICBUU0RlbXV4ZXIucHJvdG90eXBlLl9wYXJzZUFWQ05BTHUgPSBmdW5jdGlvbiAoYXJyYXkpIHtcbiAgICAgICAgdmFyIGkgPSAwLCBsZW4gPSBhcnJheS5ieXRlTGVuZ3RoLCB2YWx1ZSwgb3ZlcmZsb3csIHRyYWNrID0gdGhpcy5fYXZjVHJhY2ssIHN0YXRlID0gdHJhY2submFsdVN0YXRlIHx8IDAsIGxhc3RTdGF0ZSA9IHN0YXRlO1xuICAgICAgICB2YXIgdW5pdHMgPSBbXSwgdW5pdCwgdW5pdFR5cGUsIGxhc3RVbml0U3RhcnQgPSAtMSwgbGFzdFVuaXRUeXBlO1xuICAgICAgICAvLyBsb2dnZXIubG9nKCdQRVM6JyArIEhleC5oZXhEdW1wKGFycmF5KSk7XG4gICAgICAgIGlmIChzdGF0ZSA9PT0gLTEpIHtcbiAgICAgICAgICAgIC8vIHNwZWNpYWwgdXNlIGNhc2Ugd2hlcmUgd2UgZm91bmQgMyBvciA0LWJ5dGUgc3RhcnQgY29kZXMgZXhhY3RseSBhdCB0aGUgZW5kIG9mIHByZXZpb3VzIFBFUyBwYWNrZXRcbiAgICAgICAgICAgIGxhc3RVbml0U3RhcnQgPSAwO1xuICAgICAgICAgICAgLy8gTkFMdSB0eXBlIGlzIHZhbHVlIHJlYWQgZnJvbSBvZmZzZXQgMFxuICAgICAgICAgICAgbGFzdFVuaXRUeXBlID0gYXJyYXlbMF0gJiAweDFmO1xuICAgICAgICAgICAgc3RhdGUgPSAwO1xuICAgICAgICAgICAgaSA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICAgICAgICAgIHZhbHVlID0gYXJyYXlbaSsrXTtcbiAgICAgICAgICAgIC8vIG9wdGltaXphdGlvbi4gc3RhdGUgMCBhbmQgMSBhcmUgdGhlIHByZWRvbWluYW50IGNhc2UuIGxldCdzIGhhbmRsZSB0aGVtIG91dHNpZGUgb2YgdGhlIHN3aXRjaC9jYXNlXG4gICAgICAgICAgICBpZiAoIXN0YXRlKSB7XG4gICAgICAgICAgICAgICAgc3RhdGUgPSB2YWx1ZSA/IDAgOiAxO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0YXRlID09PSAxKSB7XG4gICAgICAgICAgICAgICAgc3RhdGUgPSB2YWx1ZSA/IDAgOiAyO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaGVyZSB3ZSBoYXZlIHN0YXRlIGVpdGhlciBlcXVhbCB0byAyIG9yIDNcbiAgICAgICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZSA9IDM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZSA9PT0gMSkge1xuICAgICAgICAgICAgICAgIGlmIChsYXN0VW5pdFN0YXJ0ID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdW5pdCA9IHsgZGF0YTogYXJyYXkuc3ViYXJyYXkobGFzdFVuaXRTdGFydCwgaSAtIHN0YXRlIC0gMSksIHR5cGU6IGxhc3RVbml0VHlwZSB9O1xuICAgICAgICAgICAgICAgICAgICAvLyBsb2dnZXIubG9nKCdwdXNoaW5nIE5BTFUsIHR5cGUvc2l6ZTonICsgdW5pdC50eXBlICsgJy8nICsgdW5pdC5kYXRhLmJ5dGVMZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICB1bml0cy5wdXNoKHVuaXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbGFzdFVuaXRTdGFydCBpcyB1bmRlZmluZWQgPT4gdGhpcyBpcyB0aGUgZmlyc3Qgc3RhcnQgY29kZSBmb3VuZCBpbiB0aGlzIFBFUyBwYWNrZXRcbiAgICAgICAgICAgICAgICAgICAgLy8gZmlyc3QgY2hlY2sgaWYgc3RhcnQgY29kZSBkZWxpbWl0ZXIgaXMgb3ZlcmxhcHBpbmcgYmV0d2VlbiAyIFBFUyBwYWNrZXRzLFxuICAgICAgICAgICAgICAgICAgICAvLyBpZSBpdCBzdGFydGVkIGluIGxhc3QgcGFja2V0IChsYXN0U3RhdGUgbm90IHplcm8pXG4gICAgICAgICAgICAgICAgICAgIC8vIGFuZCBlbmRlZCBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoaXMgUEVTIHBhY2tldCAoaSA8PSA0IC0gbGFzdFN0YXRlKVxuICAgICAgICAgICAgICAgICAgICB2YXIgbGFzdFVuaXQgPSB0aGlzLl9nZXRMYXN0TmFsVW5pdCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobGFzdFVuaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsYXN0U3RhdGUgJiYgKGkgPD0gNCAtIGxhc3RTdGF0ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzdGFydCBkZWxpbWl0ZXIgb3ZlcmxhcHBpbmcgYmV0d2VlbiBQRVMgcGFja2V0c1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHN0cmlwIHN0YXJ0IGRlbGltaXRlciBieXRlcyBmcm9tIHRoZSBlbmQgb2YgbGFzdCBOQUwgdW5pdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrIGlmIGxhc3RVbml0IGhhZCBhIHN0YXRlIGRpZmZlcmVudCBmcm9tIHplcm9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobGFzdFVuaXQuc3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3RyaXAgbGFzdCBieXRlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0VW5pdC5kYXRhID0gbGFzdFVuaXQuZGF0YS5zdWJhcnJheSgwLCBsYXN0VW5pdC5kYXRhLmJ5dGVMZW5ndGggLSBsYXN0U3RhdGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIE5BTCB1bml0cyBhcmUgbm90IHN0YXJ0aW5nIHJpZ2h0IGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIFBFUyBwYWNrZXQsIHB1c2ggcHJlY2VkaW5nIGRhdGEgaW50byBwcmV2aW91cyBOQUwgdW5pdC5cbiAgICAgICAgICAgICAgICAgICAgICAgIG92ZXJmbG93ID0gaSAtIHN0YXRlIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvdmVyZmxvdyA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBsb2dnZXIubG9nKCdmaXJzdCBOQUxVIGZvdW5kIHdpdGggb3ZlcmZsb3c6JyArIG92ZXJmbG93KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdG1wID0gbmV3IFVpbnQ4QXJyYXkobGFzdFVuaXQuZGF0YS5ieXRlTGVuZ3RoICsgb3ZlcmZsb3cpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRtcC5zZXQobGFzdFVuaXQuZGF0YSwgMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG1wLnNldChhcnJheS5zdWJhcnJheSgwLCBvdmVyZmxvdyksIGxhc3RVbml0LmRhdGEuYnl0ZUxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdFVuaXQuZGF0YSA9IHRtcDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBjaGVjayBpZiB3ZSBjYW4gcmVhZCB1bml0IHR5cGVcbiAgICAgICAgICAgICAgICBpZiAoaSA8IGxlbikge1xuICAgICAgICAgICAgICAgICAgICB1bml0VHlwZSA9IGFycmF5W2ldICYgMHgxZjtcbiAgICAgICAgICAgICAgICAgICAgLy8gbG9nZ2VyLmxvZygnZmluZCBOQUxVIEAgb2Zmc2V0OicgKyBpICsgJyx0eXBlOicgKyB1bml0VHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RVbml0U3RhcnQgPSBpO1xuICAgICAgICAgICAgICAgICAgICBsYXN0VW5pdFR5cGUgPSB1bml0VHlwZTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbm90IGVub3VnaCBieXRlIHRvIHJlYWQgdW5pdCB0eXBlLiBsZXQncyByZWFkIGl0IG9uIG5leHQgUEVTIHBhcnNpbmdcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSAtMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdGF0ZSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxhc3RVbml0U3RhcnQgPj0gMCAmJiBzdGF0ZSA+PSAwKSB7XG4gICAgICAgICAgICB1bml0ID0geyBkYXRhOiBhcnJheS5zdWJhcnJheShsYXN0VW5pdFN0YXJ0LCBsZW4pLCB0eXBlOiBsYXN0VW5pdFR5cGUsIHN0YXRlOiBzdGF0ZSB9O1xuICAgICAgICAgICAgdW5pdHMucHVzaCh1bml0KTtcbiAgICAgICAgICAgIC8vIGxvZ2dlci5sb2coJ3B1c2hpbmcgTkFMVSwgdHlwZS9zaXplL3N0YXRlOicgKyB1bml0LnR5cGUgKyAnLycgKyB1bml0LmRhdGEuYnl0ZUxlbmd0aCArICcvJyArIHN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBubyBOQUx1IGZvdW5kXG4gICAgICAgIGlmICh1bml0cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIC8vIGFwcGVuZCBwZXMuZGF0YSB0byBwcmV2aW91cyBOQUwgdW5pdFxuICAgICAgICAgICAgdmFyIGxhc3RVbml0ID0gdGhpcy5fZ2V0TGFzdE5hbFVuaXQoKTtcbiAgICAgICAgICAgIGlmIChsYXN0VW5pdCkge1xuICAgICAgICAgICAgICAgIHZhciB0bXAgPSBuZXcgVWludDhBcnJheShsYXN0VW5pdC5kYXRhLmJ5dGVMZW5ndGggKyBhcnJheS5ieXRlTGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB0bXAuc2V0KGxhc3RVbml0LmRhdGEsIDApO1xuICAgICAgICAgICAgICAgIHRtcC5zZXQoYXJyYXksIGxhc3RVbml0LmRhdGEuYnl0ZUxlbmd0aCk7XG4gICAgICAgICAgICAgICAgbGFzdFVuaXQuZGF0YSA9IHRtcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0cmFjay5uYWx1U3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgcmV0dXJuIHVuaXRzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogcmVtb3ZlIEVtdWxhdGlvbiBQcmV2ZW50aW9uIGJ5dGVzIGZyb20gYSBSQlNQXG4gICAgICovXG4gICAgVFNEZW11eGVyLnByb3RvdHlwZS5kaXNjYXJkRVBCID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdmFyIGxlbmd0aCA9IGRhdGEuYnl0ZUxlbmd0aCwgRVBCUG9zaXRpb25zID0gW10sIGkgPSAxLCBuZXdMZW5ndGgsIG5ld0RhdGE7XG4gICAgICAgIC8vIEZpbmQgYWxsIGBFbXVsYXRpb24gUHJldmVudGlvbiBCeXRlc2BcbiAgICAgICAgd2hpbGUgKGkgPCBsZW5ndGggLSAyKSB7XG4gICAgICAgICAgICBpZiAoZGF0YVtpXSA9PT0gMCAmJlxuICAgICAgICAgICAgICAgIGRhdGFbaSArIDFdID09PSAwICYmXG4gICAgICAgICAgICAgICAgZGF0YVtpICsgMl0gPT09IDB4MDMpIHtcbiAgICAgICAgICAgICAgICBFUEJQb3NpdGlvbnMucHVzaChpICsgMik7XG4gICAgICAgICAgICAgICAgaSArPSAyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIElmIG5vIEVtdWxhdGlvbiBQcmV2ZW50aW9uIEJ5dGVzIHdlcmUgZm91bmQganVzdCByZXR1cm4gdGhlIG9yaWdpbmFsXG4gICAgICAgIC8vIGFycmF5XG4gICAgICAgIGlmIChFUEJQb3NpdGlvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDcmVhdGUgYSBuZXcgYXJyYXkgdG8gaG9sZCB0aGUgTkFMIHVuaXQgZGF0YVxuICAgICAgICBuZXdMZW5ndGggPSBsZW5ndGggLSBFUEJQb3NpdGlvbnMubGVuZ3RoO1xuICAgICAgICBuZXdEYXRhID0gbmV3IFVpbnQ4QXJyYXkobmV3TGVuZ3RoKTtcbiAgICAgICAgdmFyIHNvdXJjZUluZGV4ID0gMDtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG5ld0xlbmd0aDsgc291cmNlSW5kZXgrKywgaSsrKSB7XG4gICAgICAgICAgICBpZiAoc291cmNlSW5kZXggPT09IEVQQlBvc2l0aW9uc1swXSkge1xuICAgICAgICAgICAgICAgIC8vIFNraXAgdGhpcyBieXRlXG4gICAgICAgICAgICAgICAgc291cmNlSW5kZXgrKztcbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgdGhpcyBwb3NpdGlvbiBpbmRleFxuICAgICAgICAgICAgICAgIEVQQlBvc2l0aW9ucy5zaGlmdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV3RGF0YVtpXSA9IGRhdGFbc291cmNlSW5kZXhdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdEYXRhO1xuICAgIH07XG4gICAgVFNEZW11eGVyLnByb3RvdHlwZS5fcGFyc2VBQUNQRVMgPSBmdW5jdGlvbiAocGVzKSB7XG4gICAgICAgIHZhciB0cmFjayA9IHRoaXMuX2F1ZGlvVHJhY2ssIGRhdGEgPSBwZXMuZGF0YSwgcHRzID0gcGVzLnB0cywgc3RhcnRPZmZzZXQgPSAwLCBhYWNPdmVyRmxvdyA9IHRoaXMuYWFjT3ZlckZsb3csIGFhY0xhc3RQVFMgPSB0aGlzLmFhY0xhc3RQVFMsIGZyYW1lRHVyYXRpb24sIGZyYW1lSW5kZXgsIG9mZnNldCwgc3RhbXAsIGxlbjtcbiAgICAgICAgaWYgKGFhY092ZXJGbG93KSB7XG4gICAgICAgICAgICB2YXIgdG1wID0gbmV3IFVpbnQ4QXJyYXkoYWFjT3ZlckZsb3cuYnl0ZUxlbmd0aCArIGRhdGEuYnl0ZUxlbmd0aCk7XG4gICAgICAgICAgICB0bXAuc2V0KGFhY092ZXJGbG93LCAwKTtcbiAgICAgICAgICAgIHRtcC5zZXQoZGF0YSwgYWFjT3ZlckZsb3cuYnl0ZUxlbmd0aCk7XG4gICAgICAgICAgICAvLyBsb2dnZXIubG9nKGBBQUM6IGFwcGVuZCBvdmVyZmxvd2luZyAke2FhY092ZXJGbG93LmJ5dGVMZW5ndGh9IGJ5dGVzIHRvIGJlZ2lubmluZyBvZiBuZXcgUEVTYCk7XG4gICAgICAgICAgICBkYXRhID0gdG1wO1xuICAgICAgICB9XG4gICAgICAgIC8vIGxvb2sgZm9yIEFEVFMgaGVhZGVyICgweEZGRngpXG4gICAgICAgIGZvciAob2Zmc2V0ID0gc3RhcnRPZmZzZXQsIGxlbiA9IGRhdGEubGVuZ3RoOyBvZmZzZXQgPCBsZW4gLSAxOyBvZmZzZXQrKykge1xuICAgICAgICAgICAgaWYgKEFEVFMuaXNIZWFkZXIoZGF0YSwgb2Zmc2V0KSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGlmIEFEVFMgaGVhZGVyIGRvZXMgbm90IHN0YXJ0IHN0cmFpZ2h0IGZyb20gdGhlIGJlZ2lubmluZyBvZiB0aGUgUEVTIHBheWxvYWQsIHJhaXNlIGFuIGVycm9yXG4gICAgICAgIGlmIChvZmZzZXQpIHtcbiAgICAgICAgICAgIHZhciByZWFzb24gPSB2b2lkIDAsIGZhdGFsID0gdm9pZCAwO1xuICAgICAgICAgICAgaWYgKG9mZnNldCA8IGxlbiAtIDEpIHtcbiAgICAgICAgICAgICAgICByZWFzb24gPSBcIkFBQyBQRVMgZGlkIG5vdCBzdGFydCB3aXRoIEFEVFMgaGVhZGVyLG9mZnNldDpcIiArIG9mZnNldDtcbiAgICAgICAgICAgICAgICBmYXRhbCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVhc29uID0gJ25vIEFEVFMgaGVhZGVyIGZvdW5kIGluIEFBQyBQRVMnO1xuICAgICAgICAgICAgICAgIGZhdGFsID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvZ2dlcl8xLmxvZ2dlci53YXJuKFwicGFyc2luZyBlcnJvcjpcIiArIHJlYXNvbik7XG4gICAgICAgICAgICB0aGlzLm9ic2VydmVyLnRyaWdnZXIoZXZlbnRzXzEuZGVmYXVsdC5FUlJPUiwgeyB0eXBlOiBlcnJvcnNfMS5FcnJvclR5cGVzLk1FRElBX0VSUk9SLCBkZXRhaWxzOiBlcnJvcnNfMS5FcnJvckRldGFpbHMuRlJBR19QQVJTSU5HX0VSUk9SLCBmYXRhbDogZmF0YWwsIHJlYXNvbjogcmVhc29uIH0pO1xuICAgICAgICAgICAgaWYgKGZhdGFsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIEFEVFMuaW5pdFRyYWNrQ29uZmlnKHRyYWNrLCB0aGlzLm9ic2VydmVyLCBkYXRhLCBvZmZzZXQsIHRoaXMuYXVkaW9Db2RlYyk7XG4gICAgICAgIGZyYW1lSW5kZXggPSAwO1xuICAgICAgICBmcmFtZUR1cmF0aW9uID0gQURUUy5nZXRGcmFtZUR1cmF0aW9uKHRyYWNrLnNhbXBsZXJhdGUpO1xuICAgICAgICAvLyBpZiBsYXN0IEFBQyBmcmFtZSBpcyBvdmVyZmxvd2luZywgd2Ugc2hvdWxkIGVuc3VyZSB0aW1lc3RhbXBzIGFyZSBjb250aWd1b3VzOlxuICAgICAgICAvLyBmaXJzdCBzYW1wbGUgUFRTIHNob3VsZCBiZSBlcXVhbCB0byBsYXN0IHNhbXBsZSBQVFMgKyBmcmFtZUR1cmF0aW9uXG4gICAgICAgIGlmIChhYWNPdmVyRmxvdyAmJiBhYWNMYXN0UFRTKSB7XG4gICAgICAgICAgICB2YXIgbmV3UFRTID0gYWFjTGFzdFBUUyArIGZyYW1lRHVyYXRpb247XG4gICAgICAgICAgICBpZiAoTWF0aC5hYnMobmV3UFRTIC0gcHRzKSA+IDEpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXJfMS5sb2dnZXIubG9nKFwiQUFDOiBhbGlnbiBQVFMgZm9yIG92ZXJsYXBwaW5nIGZyYW1lcyBieSBcIiArIE1hdGgucm91bmQoKG5ld1BUUyAtIHB0cykgLyA5MCkpO1xuICAgICAgICAgICAgICAgIHB0cyA9IG5ld1BUUztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBzY2FuIGZvciBhYWMgc2FtcGxlc1xuICAgICAgICB3aGlsZSAob2Zmc2V0IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoQURUUy5pc0hlYWRlcihkYXRhLCBvZmZzZXQpICYmIChvZmZzZXQgKyA1KSA8IGxlbikge1xuICAgICAgICAgICAgICAgIHZhciBmcmFtZSA9IEFEVFMuYXBwZW5kRnJhbWUodHJhY2ssIGRhdGEsIG9mZnNldCwgcHRzLCBmcmFtZUluZGV4KTtcbiAgICAgICAgICAgICAgICBpZiAoZnJhbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbG9nZ2VyLmxvZyhgJHtNYXRoLnJvdW5kKGZyYW1lLnNhbXBsZS5wdHMpfSA6IEFBQ2ApO1xuICAgICAgICAgICAgICAgICAgICBvZmZzZXQgKz0gZnJhbWUubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBzdGFtcCA9IGZyYW1lLnNhbXBsZS5wdHM7XG4gICAgICAgICAgICAgICAgICAgIGZyYW1lSW5kZXgrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGxvZ2dlci5sb2coJ1VuYWJsZSB0byBwYXJzZSBBQUMgZnJhbWUnKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gbm90aGluZyBmb3VuZCwga2VlcCBsb29raW5nXG4gICAgICAgICAgICAgICAgb2Zmc2V0Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9mZnNldCA8IGxlbikge1xuICAgICAgICAgICAgYWFjT3ZlckZsb3cgPSBkYXRhLnN1YmFycmF5KG9mZnNldCwgbGVuKTtcbiAgICAgICAgICAgIC8vIGxvZ2dlci5sb2coYEFBQzogb3ZlcmZsb3cgZGV0ZWN0ZWQ6JHtsZW4tb2Zmc2V0fWApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYWFjT3ZlckZsb3cgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWFjT3ZlckZsb3cgPSBhYWNPdmVyRmxvdztcbiAgICAgICAgdGhpcy5hYWNMYXN0UFRTID0gc3RhbXA7XG4gICAgfTtcbiAgICBUU0RlbXV4ZXIucHJvdG90eXBlLl9wYXJzZU1QRUdQRVMgPSBmdW5jdGlvbiAocGVzKSB7XG4gICAgICAgIHZhciBkYXRhID0gcGVzLmRhdGE7XG4gICAgICAgIHZhciBsZW5ndGggPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgdmFyIGZyYW1lSW5kZXggPSAwO1xuICAgICAgICB2YXIgb2Zmc2V0ID0gMDtcbiAgICAgICAgdmFyIHB0cyA9IHBlcy5wdHM7XG4gICAgICAgIHdoaWxlIChvZmZzZXQgPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChtcGVnYXVkaW9fMS5kZWZhdWx0LmlzSGVhZGVyKGRhdGEsIG9mZnNldCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgZnJhbWUgPSBtcGVnYXVkaW9fMS5kZWZhdWx0LmFwcGVuZEZyYW1lKHRoaXMuX2F1ZGlvVHJhY2ssIGRhdGEsIG9mZnNldCwgcHRzLCBmcmFtZUluZGV4KTtcbiAgICAgICAgICAgICAgICBpZiAoZnJhbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ICs9IGZyYW1lLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgZnJhbWVJbmRleCsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbG9nZ2VyLmxvZygnVW5hYmxlIHRvIHBhcnNlIE1wZWcgYXVkaW8gZnJhbWUnKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gbm90aGluZyBmb3VuZCwga2VlcCBsb29raW5nXG4gICAgICAgICAgICAgICAgb2Zmc2V0Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRTRGVtdXhlci5wcm90b3R5cGUuX3BhcnNlSUQzUEVTID0gZnVuY3Rpb24gKHBlcykge1xuICAgICAgICB0aGlzLl9pZDNUcmFjay5zYW1wbGVzLnB1c2gocGVzKTtcbiAgICB9O1xuICAgIHJldHVybiBUU0RlbXV4ZXI7XG59KCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gVFNEZW11eGVyO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2Vycm9ycy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvZXJyb3JzLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5FcnJvclR5cGVzID0ge1xuICAgIC8vIElkZW50aWZpZXIgZm9yIGEgbmV0d29yayBlcnJvciAobG9hZGluZyBlcnJvciAvIHRpbWVvdXQgLi4uKVxuICAgIE5FVFdPUktfRVJST1I6ICduZXR3b3JrRXJyb3InLFxuICAgIC8vIElkZW50aWZpZXIgZm9yIGEgbWVkaWEgRXJyb3IgKHZpZGVvL3BhcnNpbmcvbWVkaWFzb3VyY2UgZXJyb3IpXG4gICAgTUVESUFfRVJST1I6ICdtZWRpYUVycm9yJyxcbiAgICAvLyBFTUUgKGVuY3J5cHRlZCBtZWRpYSBleHRlbnNpb25zKSBlcnJvcnNcbiAgICBLRVlfU1lTVEVNX0VSUk9SOiAna2V5U3lzdGVtRXJyb3InLFxuICAgIC8vIElkZW50aWZpZXIgZm9yIGEgbXV4IEVycm9yIChkZW11eGluZy9yZW11eGluZylcbiAgICBNVVhfRVJST1I6ICdtdXhFcnJvcicsXG4gICAgLy8gSWRlbnRpZmllciBmb3IgYWxsIG90aGVyIGVycm9yc1xuICAgIE9USEVSX0VSUk9SOiAnb3RoZXJFcnJvcidcbn07XG4vKipcbiAqIEBlbnVtIHtFcnJvckRldGFpbHN9XG4gKiBAdHlwZWRlZiB7c3RyaW5nfSBFcnJvckRldGFpbFxuICovXG5leHBvcnRzLkVycm9yRGV0YWlscyA9IHtcbiAgICBLRVlfU1lTVEVNX05PX0tFWVM6ICdrZXlTeXN0ZW1Ob0tleXMnLFxuICAgIEtFWV9TWVNURU1fTk9fQUNDRVNTOiAna2V5U3lzdGVtTm9BY2Nlc3MnLFxuICAgIEtFWV9TWVNURU1fTk9fU0VTU0lPTjogJ2tleVN5c3RlbU5vU2Vzc2lvbicsXG4gICAgS0VZX1NZU1RFTV9MSUNFTlNFX1JFUVVFU1RfRkFJTEVEOiAna2V5U3lzdGVtTGljZW5zZVJlcXVlc3RGYWlsZWQnLFxuICAgIC8vIElkZW50aWZpZXIgZm9yIGEgbWFuaWZlc3QgbG9hZCBlcnJvciAtIGRhdGE6IHsgdXJsIDogZmF1bHR5IFVSTCwgcmVzcG9uc2UgOiB7IGNvZGU6IGVycm9yIGNvZGUsIHRleHQ6IGVycm9yIHRleHQgfX1cbiAgICBNQU5JRkVTVF9MT0FEX0VSUk9SOiAnbWFuaWZlc3RMb2FkRXJyb3InLFxuICAgIC8vIElkZW50aWZpZXIgZm9yIGEgbWFuaWZlc3QgbG9hZCB0aW1lb3V0IC0gZGF0YTogeyB1cmwgOiBmYXVsdHkgVVJMLCByZXNwb25zZSA6IHsgY29kZTogZXJyb3IgY29kZSwgdGV4dDogZXJyb3IgdGV4dCB9fVxuICAgIE1BTklGRVNUX0xPQURfVElNRU9VVDogJ21hbmlmZXN0TG9hZFRpbWVPdXQnLFxuICAgIC8vIElkZW50aWZpZXIgZm9yIGEgbWFuaWZlc3QgcGFyc2luZyBlcnJvciAtIGRhdGE6IHsgdXJsIDogZmF1bHR5IFVSTCwgcmVhc29uIDogZXJyb3IgcmVhc29ufVxuICAgIE1BTklGRVNUX1BBUlNJTkdfRVJST1I6ICdtYW5pZmVzdFBhcnNpbmdFcnJvcicsXG4gICAgLy8gSWRlbnRpZmllciBmb3IgYSBtYW5pZmVzdCB3aXRoIG9ubHkgaW5jb21wYXRpYmxlIGNvZGVjcyBlcnJvciAtIGRhdGE6IHsgdXJsIDogZmF1bHR5IFVSTCwgcmVhc29uIDogZXJyb3IgcmVhc29ufVxuICAgIE1BTklGRVNUX0lOQ09NUEFUSUJMRV9DT0RFQ1NfRVJST1I6ICdtYW5pZmVzdEluY29tcGF0aWJsZUNvZGVjc0Vycm9yJyxcbiAgICAvLyBJZGVudGlmaWVyIGZvciBhIGxldmVsIGxvYWQgZXJyb3IgLSBkYXRhOiB7IHVybCA6IGZhdWx0eSBVUkwsIHJlc3BvbnNlIDogeyBjb2RlOiBlcnJvciBjb2RlLCB0ZXh0OiBlcnJvciB0ZXh0IH19XG4gICAgTEVWRUxfTE9BRF9FUlJPUjogJ2xldmVsTG9hZEVycm9yJyxcbiAgICAvLyBJZGVudGlmaWVyIGZvciBhIGxldmVsIGxvYWQgdGltZW91dCAtIGRhdGE6IHsgdXJsIDogZmF1bHR5IFVSTCwgcmVzcG9uc2UgOiB7IGNvZGU6IGVycm9yIGNvZGUsIHRleHQ6IGVycm9yIHRleHQgfX1cbiAgICBMRVZFTF9MT0FEX1RJTUVPVVQ6ICdsZXZlbExvYWRUaW1lT3V0JyxcbiAgICAvLyBJZGVudGlmaWVyIGZvciBhIGxldmVsIHN3aXRjaCBlcnJvciAtIGRhdGE6IHsgbGV2ZWwgOiBmYXVsdHkgbGV2ZWwgSWQsIGV2ZW50IDogZXJyb3IgZGVzY3JpcHRpb259XG4gICAgTEVWRUxfU1dJVENIX0VSUk9SOiAnbGV2ZWxTd2l0Y2hFcnJvcicsXG4gICAgLy8gSWRlbnRpZmllciBmb3IgYW4gYXVkaW8gdHJhY2sgbG9hZCBlcnJvciAtIGRhdGE6IHsgdXJsIDogZmF1bHR5IFVSTCwgcmVzcG9uc2UgOiB7IGNvZGU6IGVycm9yIGNvZGUsIHRleHQ6IGVycm9yIHRleHQgfX1cbiAgICBBVURJT19UUkFDS19MT0FEX0VSUk9SOiAnYXVkaW9UcmFja0xvYWRFcnJvcicsXG4gICAgLy8gSWRlbnRpZmllciBmb3IgYW4gYXVkaW8gdHJhY2sgbG9hZCB0aW1lb3V0IC0gZGF0YTogeyB1cmwgOiBmYXVsdHkgVVJMLCByZXNwb25zZSA6IHsgY29kZTogZXJyb3IgY29kZSwgdGV4dDogZXJyb3IgdGV4dCB9fVxuICAgIEFVRElPX1RSQUNLX0xPQURfVElNRU9VVDogJ2F1ZGlvVHJhY2tMb2FkVGltZU91dCcsXG4gICAgLy8gSWRlbnRpZmllciBmb3IgZnJhZ21lbnQgbG9hZCBlcnJvciAtIGRhdGE6IHsgZnJhZyA6IGZyYWdtZW50IG9iamVjdCwgcmVzcG9uc2UgOiB7IGNvZGU6IGVycm9yIGNvZGUsIHRleHQ6IGVycm9yIHRleHQgfX1cbiAgICBGUkFHX0xPQURfRVJST1I6ICdmcmFnTG9hZEVycm9yJyxcbiAgICAvLyBJZGVudGlmaWVyIGZvciBmcmFnbWVudCBsb2FkIHRpbWVvdXQgZXJyb3IgLSBkYXRhOiB7IGZyYWcgOiBmcmFnbWVudCBvYmplY3R9XG4gICAgRlJBR19MT0FEX1RJTUVPVVQ6ICdmcmFnTG9hZFRpbWVPdXQnLFxuICAgIC8vIElkZW50aWZpZXIgZm9yIGEgZnJhZ21lbnQgZGVjcnlwdGlvbiBlcnJvciBldmVudCAtIGRhdGE6IHtpZCA6IGRlbXV4ZXIgSWQsZnJhZzogZnJhZ21lbnQgb2JqZWN0LCByZWFzb24gOiBwYXJzaW5nIGVycm9yIGRlc2NyaXB0aW9uIH1cbiAgICBGUkFHX0RFQ1JZUFRfRVJST1I6ICdmcmFnRGVjcnlwdEVycm9yJyxcbiAgICAvLyBJZGVudGlmaWVyIGZvciBhIGZyYWdtZW50IHBhcnNpbmcgZXJyb3IgZXZlbnQgLSBkYXRhOiB7IGlkIDogZGVtdXhlciBJZCwgcmVhc29uIDogcGFyc2luZyBlcnJvciBkZXNjcmlwdGlvbiB9XG4gICAgLy8gd2lsbCBiZSByZW5hbWVkIERFTVVYX1BBUlNJTkdfRVJST1IgYW5kIHN3aXRjaGVkIHRvIE1VWF9FUlJPUiBpbiB0aGUgbmV4dCBtYWpvciByZWxlYXNlXG4gICAgRlJBR19QQVJTSU5HX0VSUk9SOiAnZnJhZ1BhcnNpbmdFcnJvcicsXG4gICAgLy8gSWRlbnRpZmllciBmb3IgYSByZW11eCBhbGxvYyBlcnJvciBldmVudCAtIGRhdGE6IHsgaWQgOiBkZW11eGVyIElkLCBmcmFnIDogZnJhZ21lbnQgb2JqZWN0LCBieXRlcyA6IG5iIG9mIGJ5dGVzIG9uIHdoaWNoIGFsbG9jYXRpb24gZmFpbGVkICwgcmVhc29uIDogZXJyb3IgdGV4dCB9XG4gICAgUkVNVVhfQUxMT0NfRVJST1I6ICdyZW11eEFsbG9jRXJyb3InLFxuICAgIC8vIElkZW50aWZpZXIgZm9yIGRlY3J5cHQga2V5IGxvYWQgZXJyb3IgLSBkYXRhOiB7IGZyYWcgOiBmcmFnbWVudCBvYmplY3QsIHJlc3BvbnNlIDogeyBjb2RlOiBlcnJvciBjb2RlLCB0ZXh0OiBlcnJvciB0ZXh0IH19XG4gICAgS0VZX0xPQURfRVJST1I6ICdrZXlMb2FkRXJyb3InLFxuICAgIC8vIElkZW50aWZpZXIgZm9yIGRlY3J5cHQga2V5IGxvYWQgdGltZW91dCBlcnJvciAtIGRhdGE6IHsgZnJhZyA6IGZyYWdtZW50IG9iamVjdH1cbiAgICBLRVlfTE9BRF9USU1FT1VUOiAna2V5TG9hZFRpbWVPdXQnLFxuICAgIC8vIFRyaWdnZXJlZCB3aGVuIGFuIGV4Y2VwdGlvbiBvY2N1cnMgd2hpbGUgYWRkaW5nIGEgc291cmNlQnVmZmVyIHRvIE1lZGlhU291cmNlIC0gZGF0YSA6IHsgIGVyciA6IGV4Y2VwdGlvbiAsIG1pbWVUeXBlIDogbWltZVR5cGUgfVxuICAgIEJVRkZFUl9BRERfQ09ERUNfRVJST1I6ICdidWZmZXJBZGRDb2RlY0Vycm9yJyxcbiAgICAvLyBJZGVudGlmaWVyIGZvciBhIGJ1ZmZlciBhcHBlbmQgZXJyb3IgLSBkYXRhOiBhcHBlbmQgZXJyb3IgZGVzY3JpcHRpb25cbiAgICBCVUZGRVJfQVBQRU5EX0VSUk9SOiAnYnVmZmVyQXBwZW5kRXJyb3InLFxuICAgIC8vIElkZW50aWZpZXIgZm9yIGEgYnVmZmVyIGFwcGVuZGluZyBlcnJvciBldmVudCAtIGRhdGE6IGFwcGVuZGluZyBlcnJvciBkZXNjcmlwdGlvblxuICAgIEJVRkZFUl9BUFBFTkRJTkdfRVJST1I6ICdidWZmZXJBcHBlbmRpbmdFcnJvcicsXG4gICAgLy8gSWRlbnRpZmllciBmb3IgYSBidWZmZXIgc3RhbGxlZCBlcnJvciBldmVudFxuICAgIEJVRkZFUl9TVEFMTEVEX0VSUk9SOiAnYnVmZmVyU3RhbGxlZEVycm9yJyxcbiAgICAvLyBJZGVudGlmaWVyIGZvciBhIGJ1ZmZlciBmdWxsIGV2ZW50XG4gICAgQlVGRkVSX0ZVTExfRVJST1I6ICdidWZmZXJGdWxsRXJyb3InLFxuICAgIC8vIElkZW50aWZpZXIgZm9yIGEgYnVmZmVyIHNlZWsgb3ZlciBob2xlIGV2ZW50XG4gICAgQlVGRkVSX1NFRUtfT1ZFUl9IT0xFOiAnYnVmZmVyU2Vla092ZXJIb2xlJyxcbiAgICAvLyBJZGVudGlmaWVyIGZvciBhIGJ1ZmZlciBudWRnZSBvbiBzdGFsbCAocGxheWJhY2sgaXMgc3R1Y2sgYWx0aG91Z2ggY3VycmVudFRpbWUgaXMgaW4gYSBidWZmZXJlZCBhcmVhKVxuICAgIEJVRkZFUl9OVURHRV9PTl9TVEFMTDogJ2J1ZmZlck51ZGdlT25TdGFsbCcsXG4gICAgLy8gSWRlbnRpZmllciBmb3IgYW4gaW50ZXJuYWwgZXhjZXB0aW9uIGhhcHBlbmluZyBpbnNpZGUgaGxzLmpzIHdoaWxlIGhhbmRsaW5nIGFuIGV2ZW50XG4gICAgSU5URVJOQUxfRVhDRVBUSU9OOiAnaW50ZXJuYWxFeGNlcHRpb24nXG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2V2ZW50LWhhbmRsZXIuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9ldmVudC1oYW5kbGVyLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qISBNb2R1bGVDb25jYXRlbmF0aW9uIGJhaWxvdXQ6IE1vZHVsZSBpcyBub3QgYW4gRUNNQVNjcmlwdCBtb2R1bGUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qXG4qXG4qIEFsbCBvYmplY3RzIGluIHRoZSBldmVudCBoYW5kbGluZyBjaGFpbiBzaG91bGQgaW5oZXJpdCBmcm9tIHRoaXMgY2xhc3NcbipcbiovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgbG9nZ2VyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3V0aWxzL2xvZ2dlciAqLyBcIi4vc3JjL3V0aWxzL2xvZ2dlci5qc1wiKTtcbnZhciBlcnJvcnNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZXJyb3JzICovIFwiLi9zcmMvZXJyb3JzLmpzXCIpO1xudmFyIGV2ZW50c18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9ldmVudHMgKi8gXCIuL3NyYy9ldmVudHMuanNcIik7XG52YXIgRk9SQklEREVOX0VWRU5UX05BTUVTID0ge1xuICAgICdobHNFdmVudEdlbmVyaWMnOiB0cnVlLFxuICAgICdobHNIYW5kbGVyRGVzdHJveWluZyc6IHRydWUsXG4gICAgJ2hsc0hhbmRsZXJEZXN0cm95ZWQnOiB0cnVlXG59O1xudmFyIEV2ZW50SGFuZGxlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBFdmVudEhhbmRsZXIoaGxzKSB7XG4gICAgICAgIHZhciBldmVudHMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGV2ZW50c1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmhscyA9IGhscztcbiAgICAgICAgdGhpcy5vbkV2ZW50ID0gdGhpcy5vbkV2ZW50LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuaGFuZGxlZEV2ZW50cyA9IGV2ZW50cztcbiAgICAgICAgdGhpcy51c2VHZW5lcmljSGFuZGxlciA9IHRydWU7XG4gICAgICAgIHRoaXMucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgICB9XG4gICAgRXZlbnRIYW5kbGVyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLm9uSGFuZGxlckRlc3Ryb3lpbmcoKTtcbiAgICAgICAgdGhpcy51bnJlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gICAgICAgIHRoaXMub25IYW5kbGVyRGVzdHJveWVkKCk7XG4gICAgfTtcbiAgICBFdmVudEhhbmRsZXIucHJvdG90eXBlLm9uSGFuZGxlckRlc3Ryb3lpbmcgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgRXZlbnRIYW5kbGVyLnByb3RvdHlwZS5vbkhhbmRsZXJEZXN0cm95ZWQgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgRXZlbnRIYW5kbGVyLnByb3RvdHlwZS5pc0V2ZW50SGFuZGxlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB0aGlzLmhhbmRsZWRFdmVudHMgPT09ICdvYmplY3QnICYmIHRoaXMuaGFuZGxlZEV2ZW50cy5sZW5ndGggJiYgdHlwZW9mIHRoaXMub25FdmVudCA9PT0gJ2Z1bmN0aW9uJztcbiAgICB9O1xuICAgIEV2ZW50SGFuZGxlci5wcm90b3R5cGUucmVnaXN0ZXJMaXN0ZW5lcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzRXZlbnRIYW5kbGVyKCkpIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlZEV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgICAgIGlmIChGT1JCSURERU5fRVZFTlRfTkFNRVNbZXZlbnRdKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRm9yYmlkZGVuIGV2ZW50LW5hbWU6ICcgKyBldmVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuaGxzLm9uKGV2ZW50LCB0aGlzLm9uRXZlbnQpO1xuICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEV2ZW50SGFuZGxlci5wcm90b3R5cGUudW5yZWdpc3Rlckxpc3RlbmVycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNFdmVudEhhbmRsZXIoKSkge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVkRXZlbnRzLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5obHMub2ZmKGV2ZW50LCB0aGlzLm9uRXZlbnQpO1xuICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIGFyZ3VtZW50czogZXZlbnQgKHN0cmluZyksIGRhdGEgKGFueSlcbiAgICAgKi9cbiAgICBFdmVudEhhbmRsZXIucHJvdG90eXBlLm9uRXZlbnQgPSBmdW5jdGlvbiAoZXZlbnQsIGRhdGEpIHtcbiAgICAgICAgdGhpcy5vbkV2ZW50R2VuZXJpYyhldmVudCwgZGF0YSk7XG4gICAgfTtcbiAgICBFdmVudEhhbmRsZXIucHJvdG90eXBlLm9uRXZlbnRHZW5lcmljID0gZnVuY3Rpb24gKGV2ZW50LCBkYXRhKSB7XG4gICAgICAgIHZhciBldmVudFRvRnVuY3Rpb24gPSBmdW5jdGlvbiAoZXZlbnQsIGRhdGEpIHtcbiAgICAgICAgICAgIHZhciBmdW5jTmFtZSA9ICdvbicgKyBldmVudC5yZXBsYWNlKCdobHMnLCAnJyk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRoaXNbZnVuY05hbWVdICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXZlbnQgXCIgKyBldmVudCArIFwiIGhhcyBubyBnZW5lcmljIGhhbmRsZXIgaW4gdGhpcyBcIiArIHRoaXMuY29uc3RydWN0b3IubmFtZSArIFwiIGNsYXNzICh0cmllZCBcIiArIGZ1bmNOYW1lICsgXCIpXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXNbZnVuY05hbWVdLmJpbmQodGhpcywgZGF0YSk7XG4gICAgICAgIH07XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBldmVudFRvRnVuY3Rpb24uY2FsbCh0aGlzLCBldmVudCwgZGF0YSkuY2FsbCgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGxvZ2dlcl8xLmxvZ2dlci5lcnJvcihcIkFuIGludGVybmFsIGVycm9yIGhhcHBlbmVkIHdoaWxlIGhhbmRsaW5nIGV2ZW50IFwiICsgZXZlbnQgKyBcIi4gRXJyb3IgbWVzc2FnZTogXFxcIlwiICsgZXJyLm1lc3NhZ2UgKyBcIlxcXCIuIEhlcmUgaXMgYSBzdGFja3RyYWNlOlwiLCBlcnIpO1xuICAgICAgICAgICAgdGhpcy5obHMudHJpZ2dlcihldmVudHNfMS5kZWZhdWx0LkVSUk9SLCB7IHR5cGU6IGVycm9yc18xLkVycm9yVHlwZXMuT1RIRVJfRVJST1IsIGRldGFpbHM6IGVycm9yc18xLkVycm9yRGV0YWlscy5JTlRFUk5BTF9FWENFUFRJT04sIGZhdGFsOiBmYWxzZSwgZXZlbnQ6IGV2ZW50LCBlcnI6IGVyciB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIEV2ZW50SGFuZGxlcjtcbn0oKSk7XG5leHBvcnRzLmRlZmF1bHQgPSBFdmVudEhhbmRsZXI7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvZXZlbnRzLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9ldmVudHMuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIEByZWFkb25seVxuICogQGVudW0ge3N0cmluZ31cbiAqL1xudmFyIEhsc0V2ZW50cyA9IHtcbiAgICAvLyBmaXJlZCBiZWZvcmUgTWVkaWFTb3VyY2UgaXMgYXR0YWNoaW5nIHRvIG1lZGlhIGVsZW1lbnQgLSBkYXRhOiB7IG1lZGlhIH1cbiAgICBNRURJQV9BVFRBQ0hJTkc6ICdobHNNZWRpYUF0dGFjaGluZycsXG4gICAgLy8gZmlyZWQgd2hlbiBNZWRpYVNvdXJjZSBoYXMgYmVlbiBzdWNjZXNmdWxseSBhdHRhY2hlZCB0byBtZWRpYSBlbGVtZW50IC0gZGF0YTogeyB9XG4gICAgTUVESUFfQVRUQUNIRUQ6ICdobHNNZWRpYUF0dGFjaGVkJyxcbiAgICAvLyBmaXJlZCBiZWZvcmUgZGV0YWNoaW5nIE1lZGlhU291cmNlIGZyb20gbWVkaWEgZWxlbWVudCAtIGRhdGE6IHsgfVxuICAgIE1FRElBX0RFVEFDSElORzogJ2hsc01lZGlhRGV0YWNoaW5nJyxcbiAgICAvLyBmaXJlZCB3aGVuIE1lZGlhU291cmNlIGhhcyBiZWVuIGRldGFjaGVkIGZyb20gbWVkaWEgZWxlbWVudCAtIGRhdGE6IHsgfVxuICAgIE1FRElBX0RFVEFDSEVEOiAnaGxzTWVkaWFEZXRhY2hlZCcsXG4gICAgLy8gZmlyZWQgd2hlbiB3ZSBidWZmZXIgaXMgZ29pbmcgdG8gYmUgcmVzZXQgLSBkYXRhOiB7IH1cbiAgICBCVUZGRVJfUkVTRVQ6ICdobHNCdWZmZXJSZXNldCcsXG4gICAgLy8gZmlyZWQgd2hlbiB3ZSBrbm93IGFib3V0IHRoZSBjb2RlY3MgdGhhdCB3ZSBuZWVkIGJ1ZmZlcnMgZm9yIHRvIHB1c2ggaW50byAtIGRhdGE6IHt0cmFja3MgOiB7IGNvbnRhaW5lciwgY29kZWMsIGxldmVsQ29kZWMsIGluaXRTZWdtZW50LCBtZXRhZGF0YSB9fVxuICAgIEJVRkZFUl9DT0RFQ1M6ICdobHNCdWZmZXJDb2RlY3MnLFxuICAgIC8vIGZpcmVkIHdoZW4gc291cmNlYnVmZmVycyBoYXZlIGJlZW4gY3JlYXRlZCAtIGRhdGE6IHsgdHJhY2tzIDogdHJhY2tzIH1cbiAgICBCVUZGRVJfQ1JFQVRFRDogJ2hsc0J1ZmZlckNyZWF0ZWQnLFxuICAgIC8vIGZpcmVkIHdoZW4gd2UgYXBwZW5kIGEgc2VnbWVudCB0byB0aGUgYnVmZmVyIC0gZGF0YTogeyBzZWdtZW50OiBzZWdtZW50IG9iamVjdCB9XG4gICAgQlVGRkVSX0FQUEVORElORzogJ2hsc0J1ZmZlckFwcGVuZGluZycsXG4gICAgLy8gZmlyZWQgd2hlbiB3ZSBhcmUgZG9uZSB3aXRoIGFwcGVuZGluZyBhIG1lZGlhIHNlZ21lbnQgdG8gdGhlIGJ1ZmZlciAtIGRhdGEgOiB7IHBhcmVudCA6IHNlZ21lbnQgcGFyZW50IHRoYXQgdHJpZ2dlcmVkIEJVRkZFUl9BUFBFTkRJTkcsIHBlbmRpbmcgOiBuYiBvZiBzZWdtZW50cyB3YWl0aW5nIGZvciBhcHBlbmRpbmcgZm9yIHRoaXMgc2VnbWVudCBwYXJlbnR9XG4gICAgQlVGRkVSX0FQUEVOREVEOiAnaGxzQnVmZmVyQXBwZW5kZWQnLFxuICAgIC8vIGZpcmVkIHdoZW4gdGhlIHN0cmVhbSBpcyBmaW5pc2hlZCBhbmQgd2Ugd2FudCB0byBub3RpZnkgdGhlIG1lZGlhIGJ1ZmZlciB0aGF0IHRoZXJlIHdpbGwgYmUgbm8gbW9yZSBkYXRhIC0gZGF0YTogeyB9XG4gICAgQlVGRkVSX0VPUzogJ2hsc0J1ZmZlckVvcycsXG4gICAgLy8gZmlyZWQgd2hlbiB0aGUgbWVkaWEgYnVmZmVyIHNob3VsZCBiZSBmbHVzaGVkIC0gZGF0YSB7IHN0YXJ0T2Zmc2V0LCBlbmRPZmZzZXQgfVxuICAgIEJVRkZFUl9GTFVTSElORzogJ2hsc0J1ZmZlckZsdXNoaW5nJyxcbiAgICAvLyBmaXJlZCB3aGVuIHRoZSBtZWRpYSBidWZmZXIgaGFzIGJlZW4gZmx1c2hlZCAtIGRhdGE6IHsgfVxuICAgIEJVRkZFUl9GTFVTSEVEOiAnaGxzQnVmZmVyRmx1c2hlZCcsXG4gICAgLy8gZmlyZWQgdG8gc2lnbmFsIHRoYXQgYSBtYW5pZmVzdCBsb2FkaW5nIHN0YXJ0cyAtIGRhdGE6IHsgdXJsIDogbWFuaWZlc3RVUkx9XG4gICAgTUFOSUZFU1RfTE9BRElORzogJ2hsc01hbmlmZXN0TG9hZGluZycsXG4gICAgLy8gZmlyZWQgYWZ0ZXIgbWFuaWZlc3QgaGFzIGJlZW4gbG9hZGVkIC0gZGF0YTogeyBsZXZlbHMgOiBbYXZhaWxhYmxlIHF1YWxpdHkgbGV2ZWxzXSwgYXVkaW9UcmFja3MgOiBbIGF2YWlsYWJsZSBhdWRpbyB0cmFja3NdLCB1cmwgOiBtYW5pZmVzdFVSTCwgc3RhdHMgOiB7IHRyZXF1ZXN0LCB0Zmlyc3QsIHRsb2FkLCBtdGltZX19XG4gICAgTUFOSUZFU1RfTE9BREVEOiAnaGxzTWFuaWZlc3RMb2FkZWQnLFxuICAgIC8vIGZpcmVkIGFmdGVyIG1hbmlmZXN0IGhhcyBiZWVuIHBhcnNlZCAtIGRhdGE6IHsgbGV2ZWxzIDogW2F2YWlsYWJsZSBxdWFsaXR5IGxldmVsc10sIGZpcnN0TGV2ZWwgOiBpbmRleCBvZiBmaXJzdCBxdWFsaXR5IGxldmVsIGFwcGVhcmluZyBpbiBNYW5pZmVzdH1cbiAgICBNQU5JRkVTVF9QQVJTRUQ6ICdobHNNYW5pZmVzdFBhcnNlZCcsXG4gICAgLy8gZmlyZWQgd2hlbiBhIGxldmVsIHN3aXRjaCBpcyByZXF1ZXN0ZWQgLSBkYXRhOiB7IGxldmVsIDogaWQgb2YgbmV3IGxldmVsIH1cbiAgICBMRVZFTF9TV0lUQ0hJTkc6ICdobHNMZXZlbFN3aXRjaGluZycsXG4gICAgLy8gZmlyZWQgd2hlbiBhIGxldmVsIHN3aXRjaCBpcyBlZmZlY3RpdmUgLSBkYXRhOiB7IGxldmVsIDogaWQgb2YgbmV3IGxldmVsIH1cbiAgICBMRVZFTF9TV0lUQ0hFRDogJ2hsc0xldmVsU3dpdGNoZWQnLFxuICAgIC8vIGZpcmVkIHdoZW4gYSBsZXZlbCBwbGF5bGlzdCBsb2FkaW5nIHN0YXJ0cyAtIGRhdGE6IHsgdXJsIDogbGV2ZWwgVVJMLCBsZXZlbCA6IGlkIG9mIGxldmVsIGJlaW5nIGxvYWRlZH1cbiAgICBMRVZFTF9MT0FESU5HOiAnaGxzTGV2ZWxMb2FkaW5nJyxcbiAgICAvLyBmaXJlZCB3aGVuIGEgbGV2ZWwgcGxheWxpc3QgbG9hZGluZyBmaW5pc2hlcyAtIGRhdGE6IHsgZGV0YWlscyA6IGxldmVsRGV0YWlscyBvYmplY3QsIGxldmVsIDogaWQgb2YgbG9hZGVkIGxldmVsLCBzdGF0cyA6IHsgdHJlcXVlc3QsIHRmaXJzdCwgdGxvYWQsIG10aW1lfSB9XG4gICAgTEVWRUxfTE9BREVEOiAnaGxzTGV2ZWxMb2FkZWQnLFxuICAgIC8vIGZpcmVkIHdoZW4gYSBsZXZlbCdzIGRldGFpbHMgaGF2ZSBiZWVuIHVwZGF0ZWQgYmFzZWQgb24gcHJldmlvdXMgZGV0YWlscywgYWZ0ZXIgaXQgaGFzIGJlZW4gbG9hZGVkIC0gZGF0YTogeyBkZXRhaWxzIDogbGV2ZWxEZXRhaWxzIG9iamVjdCwgbGV2ZWwgOiBpZCBvZiB1cGRhdGVkIGxldmVsIH1cbiAgICBMRVZFTF9VUERBVEVEOiAnaGxzTGV2ZWxVcGRhdGVkJyxcbiAgICAvLyBmaXJlZCB3aGVuIGEgbGV2ZWwncyBQVFMgaW5mb3JtYXRpb24gaGFzIGJlZW4gdXBkYXRlZCBhZnRlciBwYXJzaW5nIGEgZnJhZ21lbnQgLSBkYXRhOiB7IGRldGFpbHMgOiBsZXZlbERldGFpbHMgb2JqZWN0LCBsZXZlbCA6IGlkIG9mIHVwZGF0ZWQgbGV2ZWwsIGRyaWZ0OiBQVFMgZHJpZnQgb2JzZXJ2ZWQgd2hlbiBwYXJzaW5nIGxhc3QgZnJhZ21lbnQgfVxuICAgIExFVkVMX1BUU19VUERBVEVEOiAnaGxzTGV2ZWxQdHNVcGRhdGVkJyxcbiAgICAvLyBmaXJlZCB0byBub3RpZnkgdGhhdCBhdWRpbyB0cmFjayBsaXN0cyBoYXMgYmVlbiB1cGRhdGVkIC0gZGF0YTogeyBhdWRpb1RyYWNrcyA6IGF1ZGlvVHJhY2tzIH1cbiAgICBBVURJT19UUkFDS1NfVVBEQVRFRDogJ2hsc0F1ZGlvVHJhY2tzVXBkYXRlZCcsXG4gICAgLy8gZmlyZWQgd2hlbiBhbiBhdWRpbyB0cmFjayBzd2l0Y2hpbmcgaXMgcmVxdWVzdGVkIC0gZGF0YTogeyBpZCA6IGF1ZGlvIHRyYWNrIGlkIH1cbiAgICBBVURJT19UUkFDS19TV0lUQ0hJTkc6ICdobHNBdWRpb1RyYWNrU3dpdGNoaW5nJyxcbiAgICAvLyBmaXJlZCB3aGVuIGFuIGF1ZGlvIHRyYWNrIHN3aXRjaCBhY3R1YWxseSBvY2N1cnMgLSBkYXRhOiB7IGlkIDogYXVkaW8gdHJhY2sgaWQgfVxuICAgIEFVRElPX1RSQUNLX1NXSVRDSEVEOiAnaGxzQXVkaW9UcmFja1N3aXRjaGVkJyxcbiAgICAvLyBmaXJlZCB3aGVuIGFuIGF1ZGlvIHRyYWNrIGxvYWRpbmcgc3RhcnRzIC0gZGF0YTogeyB1cmwgOiBhdWRpbyB0cmFjayBVUkwsIGlkIDogYXVkaW8gdHJhY2sgaWQgfVxuICAgIEFVRElPX1RSQUNLX0xPQURJTkc6ICdobHNBdWRpb1RyYWNrTG9hZGluZycsXG4gICAgLy8gZmlyZWQgd2hlbiBhbiBhdWRpbyB0cmFjayBsb2FkaW5nIGZpbmlzaGVzIC0gZGF0YTogeyBkZXRhaWxzIDogbGV2ZWxEZXRhaWxzIG9iamVjdCwgaWQgOiBhdWRpbyB0cmFjayBpZCwgc3RhdHMgOiB7IHRyZXF1ZXN0LCB0Zmlyc3QsIHRsb2FkLCBtdGltZSB9IH1cbiAgICBBVURJT19UUkFDS19MT0FERUQ6ICdobHNBdWRpb1RyYWNrTG9hZGVkJyxcbiAgICAvLyBmaXJlZCB0byBub3RpZnkgdGhhdCBzdWJ0aXRsZSB0cmFjayBsaXN0cyBoYXMgYmVlbiB1cGRhdGVkIC0gZGF0YTogeyBzdWJ0aXRsZVRyYWNrcyA6IHN1YnRpdGxlVHJhY2tzIH1cbiAgICBTVUJUSVRMRV9UUkFDS1NfVVBEQVRFRDogJ2hsc1N1YnRpdGxlVHJhY2tzVXBkYXRlZCcsXG4gICAgLy8gZmlyZWQgd2hlbiBhbiBzdWJ0aXRsZSB0cmFjayBzd2l0Y2ggb2NjdXJzIC0gZGF0YTogeyBpZCA6IHN1YnRpdGxlIHRyYWNrIGlkIH1cbiAgICBTVUJUSVRMRV9UUkFDS19TV0lUQ0g6ICdobHNTdWJ0aXRsZVRyYWNrU3dpdGNoJyxcbiAgICAvLyBmaXJlZCB3aGVuIGEgc3VidGl0bGUgdHJhY2sgbG9hZGluZyBzdGFydHMgLSBkYXRhOiB7IHVybCA6IHN1YnRpdGxlIHRyYWNrIFVSTCwgaWQgOiBzdWJ0aXRsZSB0cmFjayBpZCB9XG4gICAgU1VCVElUTEVfVFJBQ0tfTE9BRElORzogJ2hsc1N1YnRpdGxlVHJhY2tMb2FkaW5nJyxcbiAgICAvLyBmaXJlZCB3aGVuIGEgc3VidGl0bGUgdHJhY2sgbG9hZGluZyBmaW5pc2hlcyAtIGRhdGE6IHsgZGV0YWlscyA6IGxldmVsRGV0YWlscyBvYmplY3QsIGlkIDogc3VidGl0bGUgdHJhY2sgaWQsIHN0YXRzIDogeyB0cmVxdWVzdCwgdGZpcnN0LCB0bG9hZCwgbXRpbWUgfSB9XG4gICAgU1VCVElUTEVfVFJBQ0tfTE9BREVEOiAnaGxzU3VidGl0bGVUcmFja0xvYWRlZCcsXG4gICAgLy8gZmlyZWQgd2hlbiBhIHN1YnRpdGxlIGZyYWdtZW50IGhhcyBiZWVuIHByb2Nlc3NlZCAtIGRhdGE6IHsgc3VjY2VzcyA6IGJvb2xlYW4sIGZyYWcgOiB0aGUgcHJvY2Vzc2VkIGZyYWcgfVxuICAgIFNVQlRJVExFX0ZSQUdfUFJPQ0VTU0VEOiAnaGxzU3VidGl0bGVGcmFnUHJvY2Vzc2VkJyxcbiAgICAvLyBmaXJlZCB3aGVuIHRoZSBmaXJzdCB0aW1lc3RhbXAgaXMgZm91bmQgLSBkYXRhOiB7IGlkIDogZGVtdXhlciBpZCwgaW5pdFBUUzogaW5pdFBUUywgZnJhZyA6IGZyYWdtZW50IG9iamVjdCB9XG4gICAgSU5JVF9QVFNfRk9VTkQ6ICdobHNJbml0UHRzRm91bmQnLFxuICAgIC8vIGZpcmVkIHdoZW4gYSBmcmFnbWVudCBsb2FkaW5nIHN0YXJ0cyAtIGRhdGE6IHsgZnJhZyA6IGZyYWdtZW50IG9iamVjdCB9XG4gICAgRlJBR19MT0FESU5HOiAnaGxzRnJhZ0xvYWRpbmcnLFxuICAgIC8vIGZpcmVkIHdoZW4gYSBmcmFnbWVudCBsb2FkaW5nIGlzIHByb2dyZXNzaW5nIC0gZGF0YTogeyBmcmFnIDogZnJhZ21lbnQgb2JqZWN0LCB7IHRyZXF1ZXN0LCB0Zmlyc3QsIGxvYWRlZCB9IH1cbiAgICBGUkFHX0xPQURfUFJPR1JFU1M6ICdobHNGcmFnTG9hZFByb2dyZXNzJyxcbiAgICAvLyBJZGVudGlmaWVyIGZvciBmcmFnbWVudCBsb2FkIGFib3J0aW5nIGZvciBlbWVyZ2VuY3kgc3dpdGNoIGRvd24gLSBkYXRhOiB7IGZyYWcgOiBmcmFnbWVudCBvYmplY3QgfVxuICAgIEZSQUdfTE9BRF9FTUVSR0VOQ1lfQUJPUlRFRDogJ2hsc0ZyYWdMb2FkRW1lcmdlbmN5QWJvcnRlZCcsXG4gICAgLy8gZmlyZWQgd2hlbiBhIGZyYWdtZW50IGxvYWRpbmcgaXMgY29tcGxldGVkIC0gZGF0YTogeyBmcmFnIDogZnJhZ21lbnQgb2JqZWN0LCBwYXlsb2FkIDogZnJhZ21lbnQgcGF5bG9hZCwgc3RhdHMgOiB7IHRyZXF1ZXN0LCB0Zmlyc3QsIHRsb2FkLCBsZW5ndGggfSB9XG4gICAgRlJBR19MT0FERUQ6ICdobHNGcmFnTG9hZGVkJyxcbiAgICAvLyBmaXJlZCB3aGVuIGEgZnJhZ21lbnQgaGFzIGZpbmlzaGVkIGRlY3J5cHRpbmcgLSBkYXRhOiB7IGlkIDogZGVtdXhlciBpZCwgZnJhZzogZnJhZ21lbnQgb2JqZWN0LCBwYXlsb2FkIDogZnJhZ21lbnQgcGF5bG9hZCwgc3RhdHMgOiB7IHRzdGFydCwgdGRlY3J5cHQgfSB9XG4gICAgRlJBR19ERUNSWVBURUQ6ICdobHNGcmFnRGVjcnlwdGVkJyxcbiAgICAvLyBmaXJlZCB3aGVuIEluaXQgU2VnbWVudCBoYXMgYmVlbiBleHRyYWN0ZWQgZnJvbSBmcmFnbWVudCAtIGRhdGE6IHsgaWQgOiBkZW11eGVyIGlkLCBmcmFnOiBmcmFnbWVudCBvYmplY3QsIG1vb3YgOiBtb292IE1QNCBib3gsIGNvZGVjcyA6IGNvZGVjcyBmb3VuZCB3aGlsZSBwYXJzaW5nIGZyYWdtZW50IH1cbiAgICBGUkFHX1BBUlNJTkdfSU5JVF9TRUdNRU5UOiAnaGxzRnJhZ1BhcnNpbmdJbml0U2VnbWVudCcsXG4gICAgLy8gZmlyZWQgd2hlbiBwYXJzaW5nIHNlaSB0ZXh0IGlzIGNvbXBsZXRlZCAtIGRhdGE6IHsgaWQgOiBkZW11eGVyIGlkLCBmcmFnOiBmcmFnbWVudCBvYmplY3QsIHNhbXBsZXMgOiBbIHNlaSBzYW1wbGVzIHBlcyBdIH1cbiAgICBGUkFHX1BBUlNJTkdfVVNFUkRBVEE6ICdobHNGcmFnUGFyc2luZ1VzZXJkYXRhJyxcbiAgICAvLyBmaXJlZCB3aGVuIHBhcnNpbmcgaWQzIGlzIGNvbXBsZXRlZCAtIGRhdGE6IHsgaWQgOiBkZW11eGVyIGlkLCBmcmFnOiBmcmFnbWVudCBvYmplY3QsIHNhbXBsZXMgOiBbIGlkMyBzYW1wbGVzIHBlcyBdIH1cbiAgICBGUkFHX1BBUlNJTkdfTUVUQURBVEE6ICdobHNGcmFnUGFyc2luZ01ldGFkYXRhJyxcbiAgICAvLyBmaXJlZCB3aGVuIGRhdGEgaGF2ZSBiZWVuIGV4dHJhY3RlZCBmcm9tIGZyYWdtZW50IC0gZGF0YTogeyBpZCA6IGRlbXV4ZXIgaWQsIGZyYWc6IGZyYWdtZW50IG9iamVjdCwgZGF0YTEgOiBtb29mIE1QNCBib3ggb3IgVFMgZnJhZ21lbnRzLCBkYXRhMiA6IG1kYXQgTVA0IGJveCBvciBudWxsfVxuICAgIEZSQUdfUEFSU0lOR19EQVRBOiAnaGxzRnJhZ1BhcnNpbmdEYXRhJyxcbiAgICAvLyBmaXJlZCB3aGVuIGZyYWdtZW50IHBhcnNpbmcgaXMgY29tcGxldGVkIC0gZGF0YTogeyBpZCA6IGRlbXV4ZXIgaWQsIGZyYWc6IGZyYWdtZW50IG9iamVjdCB9XG4gICAgRlJBR19QQVJTRUQ6ICdobHNGcmFnUGFyc2VkJyxcbiAgICAvLyBmaXJlZCB3aGVuIGZyYWdtZW50IHJlbXV4ZWQgTVA0IGJveGVzIGhhdmUgYWxsIGJlZW4gYXBwZW5kZWQgaW50byBTb3VyY2VCdWZmZXIgLSBkYXRhOiB7IGlkIDogZGVtdXhlciBpZCwgZnJhZyA6IGZyYWdtZW50IG9iamVjdCwgc3RhdHMgOiB7IHRyZXF1ZXN0LCB0Zmlyc3QsIHRsb2FkLCB0cGFyc2VkLCB0YnVmZmVyZWQsIGxlbmd0aCwgYndFc3RpbWF0ZSB9IH1cbiAgICBGUkFHX0JVRkZFUkVEOiAnaGxzRnJhZ0J1ZmZlcmVkJyxcbiAgICAvLyBmaXJlZCB3aGVuIGZyYWdtZW50IG1hdGNoaW5nIHdpdGggY3VycmVudCBtZWRpYSBwb3NpdGlvbiBpcyBjaGFuZ2luZyAtIGRhdGEgOiB7IGlkIDogZGVtdXhlciBpZCwgZnJhZyA6IGZyYWdtZW50IG9iamVjdCB9XG4gICAgRlJBR19DSEFOR0VEOiAnaGxzRnJhZ0NoYW5nZWQnLFxuICAgIC8vIElkZW50aWZpZXIgZm9yIGEgRlBTIGRyb3AgZXZlbnQgLSBkYXRhOiB7IGN1cmVudERyb3BwZWQsIGN1cnJlbnREZWNvZGVkLCB0b3RhbERyb3BwZWRGcmFtZXMgfVxuICAgIEZQU19EUk9QOiAnaGxzRnBzRHJvcCcsXG4gICAgLy8gdHJpZ2dlcmVkIHdoZW4gRlBTIGRyb3AgdHJpZ2dlcnMgYXV0byBsZXZlbCBjYXBwaW5nIC0gZGF0YTogeyBsZXZlbCwgZHJvcHBlZGxldmVsIH1cbiAgICBGUFNfRFJPUF9MRVZFTF9DQVBQSU5HOiAnaGxzRnBzRHJvcExldmVsQ2FwcGluZycsXG4gICAgLy8gSWRlbnRpZmllciBmb3IgYW4gZXJyb3IgZXZlbnQgLSBkYXRhOiB7IHR5cGUgOiBlcnJvciB0eXBlLCBkZXRhaWxzIDogZXJyb3IgZGV0YWlscywgZmF0YWwgOiBpZiB0cnVlLCBobHMuanMgY2Fubm90L3dpbGwgbm90IHRyeSB0byByZWNvdmVyLCBpZiBmYWxzZSwgaGxzLmpzIHdpbGwgdHJ5IHRvIHJlY292ZXIsb3RoZXIgZXJyb3Igc3BlY2lmaWMgZGF0YSB9XG4gICAgRVJST1I6ICdobHNFcnJvcicsXG4gICAgLy8gZmlyZWQgd2hlbiBobHMuanMgaW5zdGFuY2Ugc3RhcnRzIGRlc3Ryb3lpbmcuIERpZmZlcmVudCBmcm9tIE1FRElBX0RFVEFDSEVEIGFzIG9uZSBjb3VsZCB3YW50IHRvIGRldGFjaCBhbmQgcmVhdHRhY2ggYSBtZWRpYSB0byB0aGUgaW5zdGFuY2Ugb2YgaGxzLmpzIHRvIGhhbmRsZSBtaWQtcm9sbHMgZm9yIGV4YW1wbGUgLSBkYXRhOiB7IH1cbiAgICBERVNUUk9ZSU5HOiAnaGxzRGVzdHJveWluZycsXG4gICAgLy8gZmlyZWQgd2hlbiBhIGRlY3J5cHQga2V5IGxvYWRpbmcgc3RhcnRzIC0gZGF0YTogeyBmcmFnIDogZnJhZ21lbnQgb2JqZWN0IH1cbiAgICBLRVlfTE9BRElORzogJ2hsc0tleUxvYWRpbmcnLFxuICAgIC8vIGZpcmVkIHdoZW4gYSBkZWNyeXB0IGtleSBsb2FkaW5nIGlzIGNvbXBsZXRlZCAtIGRhdGE6IHsgZnJhZyA6IGZyYWdtZW50IG9iamVjdCwgcGF5bG9hZCA6IGtleSBwYXlsb2FkLCBzdGF0cyA6IHsgdHJlcXVlc3QsIHRmaXJzdCwgdGxvYWQsIGxlbmd0aCB9IH1cbiAgICBLRVlfTE9BREVEOiAnaGxzS2V5TG9hZGVkJyxcbiAgICAvLyBmaXJlZCB1cG9uIHN0cmVhbSBjb250cm9sbGVyIHN0YXRlIHRyYW5zaXRpb25zIC0gZGF0YTogeyBwcmV2aW91c1N0YXRlLCBuZXh0U3RhdGUgfVxuICAgIFNUUkVBTV9TVEFURV9UUkFOU0lUSU9OOiAnaGxzU3RyZWFtU3RhdGVUcmFuc2l0aW9uJ1xufTtcbmV4cG9ydHMuZGVmYXVsdCA9IEhsc0V2ZW50cztcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9obHMuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2hscy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qISBNb2R1bGVDb25jYXRlbmF0aW9uIGJhaWxvdXQ6IE1vZHVsZSBpcyBub3QgYW4gRUNNQVNjcmlwdCBtb2R1bGUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIFVSTFRvb2xraXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISB1cmwtdG9vbGtpdCAqLyBcIi4vbm9kZV9tb2R1bGVzL3VybC10b29sa2l0L3NyYy91cmwtdG9vbGtpdC5qc1wiKTtcbnZhciBlcnJvcnNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZXJyb3JzICovIFwiLi9zcmMvZXJyb3JzLmpzXCIpO1xudmFyIHBsYXlsaXN0X2xvYWRlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9sb2FkZXIvcGxheWxpc3QtbG9hZGVyICovIFwiLi9zcmMvbG9hZGVyL3BsYXlsaXN0LWxvYWRlci5qc1wiKTtcbnZhciBmcmFnbWVudF9sb2FkZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vbG9hZGVyL2ZyYWdtZW50LWxvYWRlciAqLyBcIi4vc3JjL2xvYWRlci9mcmFnbWVudC1sb2FkZXIuanNcIik7XG52YXIga2V5X2xvYWRlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9sb2FkZXIva2V5LWxvYWRlciAqLyBcIi4vc3JjL2xvYWRlci9rZXktbG9hZGVyLmpzXCIpO1xudmFyIGZyYWdtZW50X3RyYWNrZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vY29udHJvbGxlci9mcmFnbWVudC10cmFja2VyICovIFwiLi9zcmMvY29udHJvbGxlci9mcmFnbWVudC10cmFja2VyLmpzXCIpO1xudmFyIHN0cmVhbV9jb250cm9sbGVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2NvbnRyb2xsZXIvc3RyZWFtLWNvbnRyb2xsZXIgKi8gXCIuL3NyYy9jb250cm9sbGVyL3N0cmVhbS1jb250cm9sbGVyLmpzXCIpO1xudmFyIGxldmVsX2NvbnRyb2xsZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vY29udHJvbGxlci9sZXZlbC1jb250cm9sbGVyICovIFwiLi9zcmMvY29udHJvbGxlci9sZXZlbC1jb250cm9sbGVyLmpzXCIpO1xudmFyIGlkM190cmFja19jb250cm9sbGVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2NvbnRyb2xsZXIvaWQzLXRyYWNrLWNvbnRyb2xsZXIgKi8gXCIuL3NyYy9jb250cm9sbGVyL2lkMy10cmFjay1jb250cm9sbGVyLmpzXCIpO1xudmFyIGlzX3N1cHBvcnRlZF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pcy1zdXBwb3J0ZWQgKi8gXCIuL3NyYy9pcy1zdXBwb3J0ZWQuanNcIik7XG52YXIgbG9nZ2VyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3V0aWxzL2xvZ2dlciAqLyBcIi4vc3JjL3V0aWxzL2xvZ2dlci5qc1wiKTtcbnZhciBjb25maWdfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vY29uZmlnICovIFwiLi9zcmMvY29uZmlnLmpzXCIpO1xudmFyIGV2ZW50c18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9ldmVudHMgKi8gXCIuL3NyYy9ldmVudHMuanNcIik7XG52YXIgb2JzZXJ2ZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vb2JzZXJ2ZXIgKi8gXCIuL3NyYy9vYnNlcnZlci5qc1wiKTtcbi8qKlxuICogQG1vZHVsZSBIbHNcbiAqIEBjbGFzc1xuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBIbHMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEhscywgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIGFuIEhMUyBjbGllbnQgdGhhdCBjYW4gYXR0YWNoIHRvIGV4YWN0bHkgb25lIGBIVE1MTWVkaWFFbGVtZW50YC5cbiAgICAgKlxuICAgICAqIEBjb25zdHJ1Y3RzIEhsc1xuICAgICAqIEBwYXJhbSB7SGxzQ29uZmlnfSBjb25maWdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBIbHMoY29uZmlnKSB7XG4gICAgICAgIGlmIChjb25maWcgPT09IHZvaWQgMCkgeyBjb25maWcgPSB7fTsgfVxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICB2YXIgZGVmYXVsdENvbmZpZyA9IEhscy5EZWZhdWx0Q29uZmlnO1xuICAgICAgICBpZiAoKGNvbmZpZy5saXZlU3luY0R1cmF0aW9uQ291bnQgfHwgY29uZmlnLmxpdmVNYXhMYXRlbmN5RHVyYXRpb25Db3VudCkgJiYgKGNvbmZpZy5saXZlU3luY0R1cmF0aW9uIHx8IGNvbmZpZy5saXZlTWF4TGF0ZW5jeUR1cmF0aW9uKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbGxlZ2FsIGhscy5qcyBjb25maWc6IGRvblxcJ3QgbWl4IHVwIGxpdmVTeW5jRHVyYXRpb25Db3VudC9saXZlTWF4TGF0ZW5jeUR1cmF0aW9uQ291bnQgYW5kIGxpdmVTeW5jRHVyYXRpb24vbGl2ZU1heExhdGVuY3lEdXJhdGlvbicpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIHByb3AgaW4gZGVmYXVsdENvbmZpZykge1xuICAgICAgICAgICAgaWYgKHByb3AgaW4gY29uZmlnKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgY29uZmlnW3Byb3BdID0gZGVmYXVsdENvbmZpZ1twcm9wXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29uZmlnLmxpdmVNYXhMYXRlbmN5RHVyYXRpb25Db3VudCAhPT0gdW5kZWZpbmVkICYmIGNvbmZpZy5saXZlTWF4TGF0ZW5jeUR1cmF0aW9uQ291bnQgPD0gY29uZmlnLmxpdmVTeW5jRHVyYXRpb25Db3VudCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbGxlZ2FsIGhscy5qcyBjb25maWc6IFwibGl2ZU1heExhdGVuY3lEdXJhdGlvbkNvdW50XCIgbXVzdCBiZSBndCBcImxpdmVTeW5jRHVyYXRpb25Db3VudFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbmZpZy5saXZlTWF4TGF0ZW5jeUR1cmF0aW9uICE9PSB1bmRlZmluZWQgJiYgKGNvbmZpZy5saXZlTWF4TGF0ZW5jeUR1cmF0aW9uIDw9IGNvbmZpZy5saXZlU3luY0R1cmF0aW9uIHx8IGNvbmZpZy5saXZlU3luY0R1cmF0aW9uID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lsbGVnYWwgaGxzLmpzIGNvbmZpZzogXCJsaXZlTWF4TGF0ZW5jeUR1cmF0aW9uXCIgbXVzdCBiZSBndCBcImxpdmVTeW5jRHVyYXRpb25cIicpO1xuICAgICAgICB9XG4gICAgICAgIGxvZ2dlcl8xLmVuYWJsZUxvZ3MoY29uZmlnLmRlYnVnKTtcbiAgICAgICAgX3RoaXMuY29uZmlnID0gY29uZmlnO1xuICAgICAgICBfdGhpcy5fYXV0b0xldmVsQ2FwcGluZyA9IC0xO1xuICAgICAgICAvLyBjb3JlIGNvbnRyb2xsZXJzIGFuZCBuZXR3b3JrIGxvYWRlcnNcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0FickNvbnRyb2xsZXJ9IGFickNvbnRyb2xsZXJcbiAgICAgICAgICovXG4gICAgICAgIHZhciBhYnJDb250cm9sbGVyID0gX3RoaXMuYWJyQ29udHJvbGxlciA9IG5ldyBjb25maWcuYWJyQ29udHJvbGxlcihfdGhpcyk7XG4gICAgICAgIHZhciBidWZmZXJDb250cm9sbGVyID0gbmV3IGNvbmZpZy5idWZmZXJDb250cm9sbGVyKF90aGlzKTtcbiAgICAgICAgdmFyIGNhcExldmVsQ29udHJvbGxlciA9IG5ldyBjb25maWcuY2FwTGV2ZWxDb250cm9sbGVyKF90aGlzKTtcbiAgICAgICAgdmFyIGZwc0NvbnRyb2xsZXIgPSBuZXcgY29uZmlnLmZwc0NvbnRyb2xsZXIoX3RoaXMpO1xuICAgICAgICB2YXIgcGxheUxpc3RMb2FkZXIgPSBuZXcgcGxheWxpc3RfbG9hZGVyXzEuZGVmYXVsdChfdGhpcyk7XG4gICAgICAgIHZhciBmcmFnbWVudExvYWRlciA9IG5ldyBmcmFnbWVudF9sb2FkZXJfMS5kZWZhdWx0KF90aGlzKTtcbiAgICAgICAgdmFyIGtleUxvYWRlciA9IG5ldyBrZXlfbG9hZGVyXzEuZGVmYXVsdChfdGhpcyk7XG4gICAgICAgIHZhciBpZDNUcmFja0NvbnRyb2xsZXIgPSBuZXcgaWQzX3RyYWNrX2NvbnRyb2xsZXJfMS5kZWZhdWx0KF90aGlzKTtcbiAgICAgICAgLy8gbmV0d29yayBjb250cm9sbGVyc1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TGV2ZWxDb250cm9sbGVyfSBsZXZlbENvbnRyb2xsZXJcbiAgICAgICAgICovXG4gICAgICAgIHZhciBsZXZlbENvbnRyb2xsZXIgPSBfdGhpcy5sZXZlbENvbnRyb2xsZXIgPSBuZXcgbGV2ZWxfY29udHJvbGxlcl8xLmRlZmF1bHQoX3RoaXMpO1xuICAgICAgICAvLyBGSVhNRTogRnJhZ21lbnRUcmFja2VyIG11c3QgYmUgZGVmaW5lZCBiZWZvcmUgU3RyZWFtQ29udHJvbGxlciBiZWNhdXNlIHRoZSBvcmRlciBvZiBldmVudCBoYW5kbGluZyBpcyBpbXBvcnRhbnRcbiAgICAgICAgdmFyIGZyYWdtZW50VHJhY2tlciA9IG5ldyBmcmFnbWVudF90cmFja2VyXzEuRnJhZ21lbnRUcmFja2VyKF90aGlzKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmVhbUNvbnRyb2xsZXJ9IHN0cmVhbUNvbnRyb2xsZXJcbiAgICAgICAgICovXG4gICAgICAgIHZhciBzdHJlYW1Db250cm9sbGVyID0gX3RoaXMuc3RyZWFtQ29udHJvbGxlciA9IG5ldyBzdHJlYW1fY29udHJvbGxlcl8xLmRlZmF1bHQoX3RoaXMsIGZyYWdtZW50VHJhY2tlcik7XG4gICAgICAgIHZhciBuZXR3b3JrQ29udHJvbGxlcnMgPSBbbGV2ZWxDb250cm9sbGVyLCBzdHJlYW1Db250cm9sbGVyXTtcbiAgICAgICAgLy8gb3B0aW9uYWwgYXVkaW8gc3RyZWFtIGNvbnRyb2xsZXJcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB2YXIge0lDb3JlQ29tcG9uZW50IHwgQ29udHJvbGxlcn1cbiAgICAgICAgICovXG4gICAgICAgIHZhciBDb250cm9sbGVyID0gY29uZmlnLmF1ZGlvU3RyZWFtQ29udHJvbGxlcjtcbiAgICAgICAgaWYgKENvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgIG5ldHdvcmtDb250cm9sbGVycy5wdXNoKG5ldyBDb250cm9sbGVyKF90aGlzLCBmcmFnbWVudFRyYWNrZXIpKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7SU5ldHdvcmtDb250cm9sbGVyW119IG5ldHdvcmtDb250cm9sbGVyc1xuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMubmV0d29ya0NvbnRyb2xsZXJzID0gbmV0d29ya0NvbnRyb2xsZXJzO1xuICAgICAgICAvKipcbiAgICAgICAgICogQHZhciB7SUNvcmVDb21wb25lbnRbXX1cbiAgICAgICAgICovXG4gICAgICAgIHZhciBjb3JlQ29tcG9uZW50cyA9IFtcbiAgICAgICAgICAgIHBsYXlMaXN0TG9hZGVyLFxuICAgICAgICAgICAgZnJhZ21lbnRMb2FkZXIsXG4gICAgICAgICAgICBrZXlMb2FkZXIsXG4gICAgICAgICAgICBhYnJDb250cm9sbGVyLFxuICAgICAgICAgICAgYnVmZmVyQ29udHJvbGxlcixcbiAgICAgICAgICAgIGNhcExldmVsQ29udHJvbGxlcixcbiAgICAgICAgICAgIGZwc0NvbnRyb2xsZXIsXG4gICAgICAgICAgICBpZDNUcmFja0NvbnRyb2xsZXIsXG4gICAgICAgICAgICBmcmFnbWVudFRyYWNrZXJcbiAgICAgICAgXTtcbiAgICAgICAgLy8gb3B0aW9uYWwgYXVkaW8gdHJhY2sgYW5kIHN1YnRpdGxlIGNvbnRyb2xsZXJcbiAgICAgICAgQ29udHJvbGxlciA9IGNvbmZpZy5hdWRpb1RyYWNrQ29udHJvbGxlcjtcbiAgICAgICAgaWYgKENvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgIHZhciBhdWRpb1RyYWNrQ29udHJvbGxlciA9IG5ldyBDb250cm9sbGVyKF90aGlzKTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQG1lbWJlciB7QXVkaW9UcmFja0NvbnRyb2xsZXJ9IGF1ZGlvVHJhY2tDb250cm9sbGVyXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIF90aGlzLmF1ZGlvVHJhY2tDb250cm9sbGVyID0gYXVkaW9UcmFja0NvbnRyb2xsZXI7XG4gICAgICAgICAgICBjb3JlQ29tcG9uZW50cy5wdXNoKGF1ZGlvVHJhY2tDb250cm9sbGVyKTtcbiAgICAgICAgfVxuICAgICAgICBDb250cm9sbGVyID0gY29uZmlnLnN1YnRpdGxlVHJhY2tDb250cm9sbGVyO1xuICAgICAgICBpZiAoQ29udHJvbGxlcikge1xuICAgICAgICAgICAgdmFyIHN1YnRpdGxlVHJhY2tDb250cm9sbGVyID0gbmV3IENvbnRyb2xsZXIoX3RoaXMpO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAbWVtYmVyIHtTdWJ0aXRsZVRyYWNrQ29udHJvbGxlcn0gc3VidGl0bGVUcmFja0NvbnRyb2xsZXJcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgX3RoaXMuc3VidGl0bGVUcmFja0NvbnRyb2xsZXIgPSBzdWJ0aXRsZVRyYWNrQ29udHJvbGxlcjtcbiAgICAgICAgICAgIG5ldHdvcmtDb250cm9sbGVycy5wdXNoKHN1YnRpdGxlVHJhY2tDb250cm9sbGVyKTtcbiAgICAgICAgfVxuICAgICAgICBDb250cm9sbGVyID0gY29uZmlnLmVtZUNvbnRyb2xsZXI7XG4gICAgICAgIGlmIChDb250cm9sbGVyKSB7XG4gICAgICAgICAgICB2YXIgZW1lQ29udHJvbGxlciA9IG5ldyBDb250cm9sbGVyKF90aGlzKTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQG1lbWJlciB7RU1FQ29udHJvbGxlcn0gZW1lQ29udHJvbGxlclxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBfdGhpcy5lbWVDb250cm9sbGVyID0gZW1lQ29udHJvbGxlcjtcbiAgICAgICAgICAgIGNvcmVDb21wb25lbnRzLnB1c2goZW1lQ29udHJvbGxlcik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gb3B0aW9uYWwgc3VidGl0bGUgY29udHJvbGxlcnNcbiAgICAgICAgQ29udHJvbGxlciA9IGNvbmZpZy5zdWJ0aXRsZVN0cmVhbUNvbnRyb2xsZXI7XG4gICAgICAgIGlmIChDb250cm9sbGVyKSB7XG4gICAgICAgICAgICBuZXR3b3JrQ29udHJvbGxlcnMucHVzaChuZXcgQ29udHJvbGxlcihfdGhpcywgZnJhZ21lbnRUcmFja2VyKSk7XG4gICAgICAgIH1cbiAgICAgICAgQ29udHJvbGxlciA9IGNvbmZpZy50aW1lbGluZUNvbnRyb2xsZXI7XG4gICAgICAgIGlmIChDb250cm9sbGVyKSB7XG4gICAgICAgICAgICBjb3JlQ29tcG9uZW50cy5wdXNoKG5ldyBDb250cm9sbGVyKF90aGlzKSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0lDb3JlQ29tcG9uZW50W119XG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5jb3JlQ29tcG9uZW50cyA9IGNvcmVDb21wb25lbnRzO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShIbHMsIFwidmVyc2lvblwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gXCIwLjEyLjRcIjtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgSGxzLmlzU3VwcG9ydGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gaXNfc3VwcG9ydGVkXzEuaXNTdXBwb3J0ZWQoKTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShIbHMsIFwiRXZlbnRzXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtIbHNFdmVudHN9XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBldmVudHNfMS5kZWZhdWx0O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSGxzLCBcIkVycm9yVHlwZXNcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge0hsc0Vycm9yVHlwZXN9XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBlcnJvcnNfMS5FcnJvclR5cGVzO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSGxzLCBcIkVycm9yRGV0YWlsc1wiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7SGxzRXJyb3JEZXRhaWxzfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gZXJyb3JzXzEuRXJyb3JEZXRhaWxzO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSGxzLCBcIkRlZmF1bHRDb25maWdcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge0hsc0NvbmZpZ31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCFIbHMuZGVmYXVsdENvbmZpZykge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb25maWdfMS5obHNEZWZhdWx0Q29uZmlnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIEhscy5kZWZhdWx0Q29uZmlnO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge0hsc0NvbmZpZ31cbiAgICAgICAgICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKGRlZmF1bHRDb25maWcpIHtcbiAgICAgICAgICAgIEhscy5kZWZhdWx0Q29uZmlnID0gZGVmYXVsdENvbmZpZztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogRGlzcG9zZSBvZiB0aGUgaW5zdGFuY2VcbiAgICAgKi9cbiAgICBIbHMucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGxvZ2dlcl8xLmxvZ2dlci5sb2coJ2Rlc3Ryb3knKTtcbiAgICAgICAgdGhpcy50cmlnZ2VyKGV2ZW50c18xLmRlZmF1bHQuREVTVFJPWUlORyk7XG4gICAgICAgIHRoaXMuZGV0YWNoTWVkaWEoKTtcbiAgICAgICAgdGhpcy5jb3JlQ29tcG9uZW50cy5jb25jYXQodGhpcy5uZXR3b3JrQ29udHJvbGxlcnMpLmZvckVhY2goZnVuY3Rpb24gKGNvbXBvbmVudCkge1xuICAgICAgICAgICAgY29tcG9uZW50LmRlc3Ryb3koKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudXJsID0gbnVsbDtcbiAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICAgICAgdGhpcy5fYXV0b0xldmVsQ2FwcGluZyA9IC0xO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQXR0YWNoIGEgbWVkaWEgZWxlbWVudFxuICAgICAqIEBwYXJhbSB7SFRNTE1lZGlhRWxlbWVudH0gbWVkaWFcbiAgICAgKi9cbiAgICBIbHMucHJvdG90eXBlLmF0dGFjaE1lZGlhID0gZnVuY3Rpb24gKG1lZGlhKSB7XG4gICAgICAgIGxvZ2dlcl8xLmxvZ2dlci5sb2coJ2F0dGFjaE1lZGlhJyk7XG4gICAgICAgIHRoaXMubWVkaWEgPSBtZWRpYTtcbiAgICAgICAgdGhpcy50cmlnZ2VyKGV2ZW50c18xLmRlZmF1bHQuTUVESUFfQVRUQUNISU5HLCB7IG1lZGlhOiBtZWRpYSB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIERldGFjaCBmcm9tIHRoZSBtZWRpYVxuICAgICAqL1xuICAgIEhscy5wcm90b3R5cGUuZGV0YWNoTWVkaWEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGxvZ2dlcl8xLmxvZ2dlci5sb2coJ2RldGFjaE1lZGlhJyk7XG4gICAgICAgIHRoaXMudHJpZ2dlcihldmVudHNfMS5kZWZhdWx0Lk1FRElBX0RFVEFDSElORyk7XG4gICAgICAgIHRoaXMubWVkaWEgPSBudWxsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBzb3VyY2UgVVJMLiBDYW4gYmUgcmVsYXRpdmUgb3IgYWJzb2x1dGUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVybFxuICAgICAqL1xuICAgIEhscy5wcm90b3R5cGUubG9hZFNvdXJjZSA9IGZ1bmN0aW9uICh1cmwpIHtcbiAgICAgICAgdXJsID0gVVJMVG9vbGtpdC5idWlsZEFic29sdXRlVVJMKHdpbmRvdy5sb2NhdGlvbi5ocmVmLCB1cmwsIHsgYWx3YXlzTm9ybWFsaXplOiB0cnVlIH0pO1xuICAgICAgICBsb2dnZXJfMS5sb2dnZXIubG9nKFwibG9hZFNvdXJjZTpcIiArIHVybCk7XG4gICAgICAgIHRoaXMudXJsID0gdXJsO1xuICAgICAgICAvLyB3aGVuIGF0dGFjaGluZyB0byBhIHNvdXJjZSBVUkwsIHRyaWdnZXIgYSBwbGF5bGlzdCBsb2FkXG4gICAgICAgIHRoaXMudHJpZ2dlcihldmVudHNfMS5kZWZhdWx0Lk1BTklGRVNUX0xPQURJTkcsIHsgdXJsOiB1cmwgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTdGFydCBsb2FkaW5nIGRhdGEgZnJvbSB0aGUgc3RyZWFtIHNvdXJjZS5cbiAgICAgKiBEZXBlbmRpbmcgb24gZGVmYXVsdCBjb25maWcsIGNsaWVudCBzdGFydHMgbG9hZGluZyBhdXRvbWF0aWNhbGx5IHdoZW4gYSBzb3VyY2UgaXMgc2V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0UG9zaXRpb24gU2V0IHRoZSBzdGFydCBwb3NpdGlvbiB0byBzdHJlYW0gZnJvbVxuICAgICAqIEBkZWZhdWx0IC0xIE5vbmUgKGZyb20gZWFybGllc3QgcG9pbnQpXG4gICAgICovXG4gICAgSGxzLnByb3RvdHlwZS5zdGFydExvYWQgPSBmdW5jdGlvbiAoc3RhcnRQb3NpdGlvbikge1xuICAgICAgICBpZiAoc3RhcnRQb3NpdGlvbiA9PT0gdm9pZCAwKSB7IHN0YXJ0UG9zaXRpb24gPSAtMTsgfVxuICAgICAgICBsb2dnZXJfMS5sb2dnZXIubG9nKFwic3RhcnRMb2FkKFwiICsgc3RhcnRQb3NpdGlvbiArIFwiKVwiKTtcbiAgICAgICAgdGhpcy5uZXR3b3JrQ29udHJvbGxlcnMuZm9yRWFjaChmdW5jdGlvbiAoY29udHJvbGxlcikge1xuICAgICAgICAgICAgY29udHJvbGxlci5zdGFydExvYWQoc3RhcnRQb3NpdGlvbik7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU3RvcCBsb2FkaW5nIG9mIGFueSBzdHJlYW0gZGF0YS5cbiAgICAgKi9cbiAgICBIbHMucHJvdG90eXBlLnN0b3BMb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBsb2dnZXJfMS5sb2dnZXIubG9nKCdzdG9wTG9hZCcpO1xuICAgICAgICB0aGlzLm5ldHdvcmtDb250cm9sbGVycy5mb3JFYWNoKGZ1bmN0aW9uIChjb250cm9sbGVyKSB7XG4gICAgICAgICAgICBjb250cm9sbGVyLnN0b3BMb2FkKCk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU3dhcCB0aHJvdWdoIHBvc3NpYmxlIGF1ZGlvIGNvZGVjcyBpbiB0aGUgc3RyZWFtIChmb3IgZXhhbXBsZSB0byBzd2l0Y2ggZnJvbSBzdGVyZW8gdG8gNS4xKVxuICAgICAqL1xuICAgIEhscy5wcm90b3R5cGUuc3dhcEF1ZGlvQ29kZWMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGxvZ2dlcl8xLmxvZ2dlci5sb2coJ3N3YXBBdWRpb0NvZGVjJyk7XG4gICAgICAgIHRoaXMuc3RyZWFtQ29udHJvbGxlci5zd2FwQXVkaW9Db2RlYygpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogV2hlbiB0aGUgbWVkaWEtZWxlbWVudCBmYWlscywgdGhpcyBhbGxvd3MgdG8gZGV0YWNoIGFuZCB0aGVuIHJlLWF0dGFjaCBpdFxuICAgICAqIGFzIG9uZSBjYWxsIChjb252ZW5pZW5jZSBtZXRob2QpLlxuICAgICAqXG4gICAgICogQXV0b21hdGljIHJlY292ZXJ5IG9mIG1lZGlhLWVycm9ycyBieSB0aGlzIHByb2Nlc3MgaXMgY29uZmlndXJhYmxlLlxuICAgICAqL1xuICAgIEhscy5wcm90b3R5cGUucmVjb3Zlck1lZGlhRXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGxvZ2dlcl8xLmxvZ2dlci5sb2coJ3JlY292ZXJNZWRpYUVycm9yJyk7XG4gICAgICAgIHZhciBtZWRpYSA9IHRoaXMubWVkaWE7XG4gICAgICAgIHRoaXMuZGV0YWNoTWVkaWEoKTtcbiAgICAgICAgdGhpcy5hdHRhY2hNZWRpYShtZWRpYSk7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSGxzLnByb3RvdHlwZSwgXCJsZXZlbHNcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge1F1YWxpdHlMZXZlbFtdfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sZXZlbENvbnRyb2xsZXIubGV2ZWxzO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSGxzLnByb3RvdHlwZSwgXCJjdXJyZW50TGV2ZWxcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogSW5kZXggb2YgcXVhbGl0eSBsZXZlbCBjdXJyZW50bHkgcGxheWVkXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0cmVhbUNvbnRyb2xsZXIuY3VycmVudExldmVsO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IHF1YWxpdHkgbGV2ZWwgaW5kZXggaW1tZWRpYXRlbHkgLlxuICAgICAgICAgKiBUaGlzIHdpbGwgZmx1c2ggdGhlIGN1cnJlbnQgYnVmZmVyIHRvIHJlcGxhY2UgdGhlIHF1YWxpdHkgYXNhcC5cbiAgICAgICAgICogVGhhdCBtZWFucyBwbGF5YmFjayB3aWxsIGludGVycnVwdCBhdCBsZWFzdCBzaG9ydGx5IHRvIHJlLWJ1ZmZlciBhbmQgcmUtc3luYyBldmVudHVhbGx5LlxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfSAtMSBmb3IgYXV0b21hdGljIGxldmVsIHNlbGVjdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAobmV3TGV2ZWwpIHtcbiAgICAgICAgICAgIGxvZ2dlcl8xLmxvZ2dlci5sb2coXCJzZXQgY3VycmVudExldmVsOlwiICsgbmV3TGV2ZWwpO1xuICAgICAgICAgICAgdGhpcy5sb2FkTGV2ZWwgPSBuZXdMZXZlbDtcbiAgICAgICAgICAgIHRoaXMuc3RyZWFtQ29udHJvbGxlci5pbW1lZGlhdGVMZXZlbFN3aXRjaCgpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSGxzLnByb3RvdHlwZSwgXCJuZXh0TGV2ZWxcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogSW5kZXggb2YgbmV4dCBxdWFsaXR5IGxldmVsIGxvYWRlZCBhcyBzY2hlZHVsZWQgYnkgc3RyZWFtIGNvbnRyb2xsZXIuXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0cmVhbUNvbnRyb2xsZXIubmV4dExldmVsO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IHF1YWxpdHkgbGV2ZWwgaW5kZXggZm9yIG5leHQgbG9hZGVkIGRhdGEuXG4gICAgICAgICAqIFRoaXMgd2lsbCBzd2l0Y2ggdGhlIHZpZGVvIHF1YWxpdHkgYXNhcCwgd2l0aG91dCBpbnRlcnJ1cHRpbmcgcGxheWJhY2suXG4gICAgICAgICAqIE1heSBhYm9ydCBjdXJyZW50IGxvYWRpbmcgb2YgZGF0YSwgYW5kIGZsdXNoIHBhcnRzIG9mIGJ1ZmZlciAob3V0c2lkZSBjdXJyZW50bHkgcGxheWVkIGZyYWdtZW50IHJlZ2lvbikuXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9IC0xIGZvciBhdXRvbWF0aWMgbGV2ZWwgc2VsZWN0aW9uXG4gICAgICAgICAqL1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChuZXdMZXZlbCkge1xuICAgICAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLmxvZyhcInNldCBuZXh0TGV2ZWw6XCIgKyBuZXdMZXZlbCk7XG4gICAgICAgICAgICB0aGlzLmxldmVsQ29udHJvbGxlci5tYW51YWxMZXZlbCA9IG5ld0xldmVsO1xuICAgICAgICAgICAgdGhpcy5zdHJlYW1Db250cm9sbGVyLm5leHRMZXZlbFN3aXRjaCgpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSGxzLnByb3RvdHlwZSwgXCJsb2FkTGV2ZWxcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJuIHRoZSBxdWFsaXR5IGxldmVsIG9mIHRoZSBjdXJyZW50bHkgb3IgbGFzdCAob2Ygbm9uZSBpcyBsb2FkZWQgY3VycmVudGx5KSBzZWdtZW50XG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxldmVsQ29udHJvbGxlci5sZXZlbDtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldCBxdWFsaXR5IGxldmVsIGluZGV4IGZvciBuZXh0IGxvYWRlZCBkYXRhIGluIGEgY29uc2VydmF0aXZlIHdheS5cbiAgICAgICAgICogVGhpcyB3aWxsIHN3aXRjaCB0aGUgcXVhbGl0eSB3aXRob3V0IGZsdXNoaW5nLCBidXQgaW50ZXJydXB0IGN1cnJlbnQgbG9hZGluZy5cbiAgICAgICAgICogVGh1cyB0aGUgbW9tZW50IHdoZW4gdGhlIHF1YWxpdHkgc3dpdGNoIHdpbGwgYXBwZWFyIGluIGVmZmVjdCB3aWxsIG9ubHkgYmUgYWZ0ZXIgdGhlIGFscmVhZHkgZXhpc3RpbmcgYnVmZmVyLlxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfSBuZXdMZXZlbCAtMSBmb3IgYXV0b21hdGljIGxldmVsIHNlbGVjdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAobmV3TGV2ZWwpIHtcbiAgICAgICAgICAgIGxvZ2dlcl8xLmxvZ2dlci5sb2coXCJzZXQgbG9hZExldmVsOlwiICsgbmV3TGV2ZWwpO1xuICAgICAgICAgICAgdGhpcy5sZXZlbENvbnRyb2xsZXIubWFudWFsTGV2ZWwgPSBuZXdMZXZlbDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEhscy5wcm90b3R5cGUsIFwibmV4dExvYWRMZXZlbFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBnZXQgbmV4dCBxdWFsaXR5IGxldmVsIGxvYWRlZFxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sZXZlbENvbnRyb2xsZXIubmV4dExvYWRMZXZlbDtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldCBxdWFsaXR5IGxldmVsIG9mIG5leHQgbG9hZGVkIHNlZ21lbnQgaW4gYSBmdWxseSBcIm5vbi1kZXN0cnVjdGl2ZVwiIHdheS5cbiAgICAgICAgICogU2FtZSBhcyBgbG9hZExldmVsYCBidXQgd2lsbCB3YWl0IGZvciBuZXh0IHN3aXRjaCAodW50aWwgY3VycmVudCBsb2FkaW5nIGlzIGRvbmUpLlxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfSBsZXZlbFxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAobGV2ZWwpIHtcbiAgICAgICAgICAgIHRoaXMubGV2ZWxDb250cm9sbGVyLm5leHRMb2FkTGV2ZWwgPSBsZXZlbDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEhscy5wcm90b3R5cGUsIFwiZmlyc3RMZXZlbFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm4gXCJmaXJzdCBsZXZlbFwiOiBsaWtlIGEgZGVmYXVsdCBsZXZlbCwgaWYgbm90IHNldCxcbiAgICAgICAgICogZmFsbHMgYmFjayB0byBpbmRleCBvZiBmaXJzdCBsZXZlbCByZWZlcmVuY2VkIGluIG1hbmlmZXN0XG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLm1heCh0aGlzLmxldmVsQ29udHJvbGxlci5maXJzdExldmVsLCB0aGlzLm1pbkF1dG9MZXZlbCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXRzIFwiZmlyc3QtbGV2ZWxcIiwgc2VlIGdldHRlci5cbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKG5ld0xldmVsKSB7XG4gICAgICAgICAgICBsb2dnZXJfMS5sb2dnZXIubG9nKFwic2V0IGZpcnN0TGV2ZWw6XCIgKyBuZXdMZXZlbCk7XG4gICAgICAgICAgICB0aGlzLmxldmVsQ29udHJvbGxlci5maXJzdExldmVsID0gbmV3TGV2ZWw7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShIbHMucHJvdG90eXBlLCBcInN0YXJ0TGV2ZWxcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJuIHN0YXJ0IGxldmVsIChsZXZlbCBvZiBmaXJzdCBmcmFnbWVudCB0aGF0IHdpbGwgYmUgcGxheWVkIGJhY2spXG4gICAgICAgICAqIGlmIG5vdCBvdmVycmlkZWQgYnkgdXNlciwgZmlyc3QgbGV2ZWwgYXBwZWFyaW5nIGluIG1hbmlmZXN0IHdpbGwgYmUgdXNlZCBhcyBzdGFydCBsZXZlbFxuICAgICAgICAgKiBpZiAtMSA6IGF1dG9tYXRpYyBzdGFydCBsZXZlbCBzZWxlY3Rpb24sIHBsYXliYWNrIHdpbGwgc3RhcnQgZnJvbSBsZXZlbCBtYXRjaGluZyBkb3dubG9hZCBiYW5kd2lkdGhcbiAgICAgICAgICogKGRldGVybWluZWQgZnJvbSBkb3dubG9hZCBvZiBmaXJzdCBzZWdtZW50KVxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sZXZlbENvbnRyb2xsZXIuc3RhcnRMZXZlbDtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHNldCAgc3RhcnQgbGV2ZWwgKGxldmVsIG9mIGZpcnN0IGZyYWdtZW50IHRoYXQgd2lsbCBiZSBwbGF5ZWQgYmFjaylcbiAgICAgICAgICogaWYgbm90IG92ZXJyaWRlZCBieSB1c2VyLCBmaXJzdCBsZXZlbCBhcHBlYXJpbmcgaW4gbWFuaWZlc3Qgd2lsbCBiZSB1c2VkIGFzIHN0YXJ0IGxldmVsXG4gICAgICAgICAqIGlmIC0xIDogYXV0b21hdGljIHN0YXJ0IGxldmVsIHNlbGVjdGlvbiwgcGxheWJhY2sgd2lsbCBzdGFydCBmcm9tIGxldmVsIG1hdGNoaW5nIGRvd25sb2FkIGJhbmR3aWR0aFxuICAgICAgICAgKiAoZGV0ZXJtaW5lZCBmcm9tIGRvd25sb2FkIG9mIGZpcnN0IHNlZ21lbnQpXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9IG5ld0xldmVsXG4gICAgICAgICAqL1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChuZXdMZXZlbCkge1xuICAgICAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLmxvZyhcInNldCBzdGFydExldmVsOlwiICsgbmV3TGV2ZWwpO1xuICAgICAgICAgICAgdmFyIGhscyA9IHRoaXM7XG4gICAgICAgICAgICAvLyBpZiBub3QgaW4gYXV0b21hdGljIHN0YXJ0IGxldmVsIGRldGVjdGlvbiwgZW5zdXJlIHN0YXJ0TGV2ZWwgaXMgZ3JlYXRlciB0aGFuIG1pbkF1dG9MZXZlbFxuICAgICAgICAgICAgaWYgKG5ld0xldmVsICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIG5ld0xldmVsID0gTWF0aC5tYXgobmV3TGV2ZWwsIGhscy5taW5BdXRvTGV2ZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaGxzLmxldmVsQ29udHJvbGxlci5zdGFydExldmVsID0gbmV3TGV2ZWw7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShIbHMucHJvdG90eXBlLCBcImF1dG9MZXZlbENhcHBpbmdcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2FwcGluZy9tYXggbGV2ZWwgdmFsdWUgdGhhdCBzaG91bGQgYmUgdXNlZCBieSBhdXRvbWF0aWMgbGV2ZWwgc2VsZWN0aW9uIGFsZ29yaXRobSAoYEFCUkNvbnRyb2xsZXJgKVxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYXV0b0xldmVsQ2FwcGluZztcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhcHBpbmcvbWF4IGxldmVsIHZhbHVlIHRoYXQgc2hvdWxkIGJlIHVzZWQgYnkgYXV0b21hdGljIGxldmVsIHNlbGVjdGlvbiBhbGdvcml0aG0gKGBBQlJDb250cm9sbGVyYClcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKG5ld0xldmVsKSB7XG4gICAgICAgICAgICBsb2dnZXJfMS5sb2dnZXIubG9nKFwic2V0IGF1dG9MZXZlbENhcHBpbmc6XCIgKyBuZXdMZXZlbCk7XG4gICAgICAgICAgICB0aGlzLl9hdXRvTGV2ZWxDYXBwaW5nID0gbmV3TGV2ZWw7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShIbHMucHJvdG90eXBlLCBcImF1dG9MZXZlbEVuYWJsZWRcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVHJ1ZSB3aGVuIGF1dG9tYXRpYyBsZXZlbCBzZWxlY3Rpb24gZW5hYmxlZFxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICh0aGlzLmxldmVsQ29udHJvbGxlci5tYW51YWxMZXZlbCA9PT0gLTEpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSGxzLnByb3RvdHlwZSwgXCJtYW51YWxMZXZlbFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMZXZlbCBzZXQgbWFudWFsbHkgKGlmIGFueSlcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGV2ZWxDb250cm9sbGVyLm1hbnVhbExldmVsO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSGxzLnByb3RvdHlwZSwgXCJtaW5BdXRvTGV2ZWxcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogbWluIGxldmVsIHNlbGVjdGFibGUgaW4gYXV0byBtb2RlIGFjY29yZGluZyB0byBjb25maWcubWluQXV0b0JpdHJhdGVcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGhscyA9IHRoaXMsIGxldmVscyA9IGhscy5sZXZlbHMsIG1pbkF1dG9CaXRyYXRlID0gaGxzLmNvbmZpZy5taW5BdXRvQml0cmF0ZSwgbGVuID0gbGV2ZWxzID8gbGV2ZWxzLmxlbmd0aCA6IDA7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxldmVsTmV4dEJpdHJhdGUgPSBsZXZlbHNbaV0ucmVhbEJpdHJhdGUgPyBNYXRoLm1heChsZXZlbHNbaV0ucmVhbEJpdHJhdGUsIGxldmVsc1tpXS5iaXRyYXRlKSA6IGxldmVsc1tpXS5iaXRyYXRlO1xuICAgICAgICAgICAgICAgIGlmIChsZXZlbE5leHRCaXRyYXRlID4gbWluQXV0b0JpdHJhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShIbHMucHJvdG90eXBlLCBcIm1heEF1dG9MZXZlbFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBtYXggbGV2ZWwgc2VsZWN0YWJsZSBpbiBhdXRvIG1vZGUgYWNjb3JkaW5nIHRvIGF1dG9MZXZlbENhcHBpbmdcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGhscyA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgbGV2ZWxzID0gaGxzLmxldmVscztcbiAgICAgICAgICAgIHZhciBhdXRvTGV2ZWxDYXBwaW5nID0gaGxzLmF1dG9MZXZlbENhcHBpbmc7XG4gICAgICAgICAgICB2YXIgbWF4QXV0b0xldmVsO1xuICAgICAgICAgICAgaWYgKGF1dG9MZXZlbENhcHBpbmcgPT09IC0xICYmIGxldmVscyAmJiBsZXZlbHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgbWF4QXV0b0xldmVsID0gbGV2ZWxzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBtYXhBdXRvTGV2ZWwgPSBhdXRvTGV2ZWxDYXBwaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1heEF1dG9MZXZlbDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEhscy5wcm90b3R5cGUsIFwibmV4dEF1dG9MZXZlbFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBuZXh0IGF1dG9tYXRpY2FsbHkgc2VsZWN0ZWQgcXVhbGl0eSBsZXZlbFxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgaGxzID0gdGhpcztcbiAgICAgICAgICAgIC8vIGVuc3VyZSBuZXh0IGF1dG8gbGV2ZWwgaXMgYmV0d2VlbiAgbWluIGFuZCBtYXggYXV0byBsZXZlbFxuICAgICAgICAgICAgcmV0dXJuIE1hdGgubWluKE1hdGgubWF4KGhscy5hYnJDb250cm9sbGVyLm5leHRBdXRvTGV2ZWwsIGhscy5taW5BdXRvTGV2ZWwpLCBobHMubWF4QXV0b0xldmVsKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHRoaXMgc2V0dGVyIGlzIHVzZWQgdG8gZm9yY2UgbmV4dCBhdXRvIGxldmVsLlxuICAgICAgICAgKiB0aGlzIGlzIHVzZWZ1bCB0byBmb3JjZSBhIHN3aXRjaCBkb3duIGluIGF1dG8gbW9kZTpcbiAgICAgICAgICogaW4gY2FzZSBvZiBsb2FkIGVycm9yIG9uIGxldmVsIE4sIGhscy5qcyBjYW4gc2V0IG5leHRBdXRvTGV2ZWwgdG8gTi0xIGZvciBleGFtcGxlKVxuICAgICAgICAgKiBmb3JjZWQgdmFsdWUgaXMgdmFsaWQgZm9yIG9uZSBmcmFnbWVudC4gdXBvbiBzdWNjZXNmdWwgZnJhZyBsb2FkaW5nIGF0IGZvcmNlZCBsZXZlbCxcbiAgICAgICAgICogdGhpcyB2YWx1ZSB3aWxsIGJlIHJlc2V0dGVkIHRvIC0xIGJ5IEFCUiBjb250cm9sbGVyLlxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAobmV4dExldmVsKSB7XG4gICAgICAgICAgICB2YXIgaGxzID0gdGhpcztcbiAgICAgICAgICAgIGhscy5hYnJDb250cm9sbGVyLm5leHRBdXRvTGV2ZWwgPSBNYXRoLm1heChobHMubWluQXV0b0xldmVsLCBuZXh0TGV2ZWwpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSGxzLnByb3RvdHlwZSwgXCJhdWRpb1RyYWNrc1wiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7QXVkaW9UcmFja1tdfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYXVkaW9UcmFja0NvbnRyb2xsZXIgPSB0aGlzLmF1ZGlvVHJhY2tDb250cm9sbGVyO1xuICAgICAgICAgICAgcmV0dXJuIGF1ZGlvVHJhY2tDb250cm9sbGVyID8gYXVkaW9UcmFja0NvbnRyb2xsZXIuYXVkaW9UcmFja3MgOiBbXTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEhscy5wcm90b3R5cGUsIFwiYXVkaW9UcmFja1wiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBpbmRleCBvZiB0aGUgc2VsZWN0ZWQgYXVkaW8gdHJhY2sgKGluZGV4IGluIGF1ZGlvIHRyYWNrIGxpc3RzKVxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYXVkaW9UcmFja0NvbnRyb2xsZXIgPSB0aGlzLmF1ZGlvVHJhY2tDb250cm9sbGVyO1xuICAgICAgICAgICAgcmV0dXJuIGF1ZGlvVHJhY2tDb250cm9sbGVyID8gYXVkaW9UcmFja0NvbnRyb2xsZXIuYXVkaW9UcmFjayA6IC0xO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogc2VsZWN0cyBhbiBhdWRpbyB0cmFjaywgYmFzZWQgb24gaXRzIGluZGV4IGluIGF1ZGlvIHRyYWNrIGxpc3RzXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChhdWRpb1RyYWNrSWQpIHtcbiAgICAgICAgICAgIHZhciBhdWRpb1RyYWNrQ29udHJvbGxlciA9IHRoaXMuYXVkaW9UcmFja0NvbnRyb2xsZXI7XG4gICAgICAgICAgICBpZiAoYXVkaW9UcmFja0NvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgICAgICBhdWRpb1RyYWNrQ29udHJvbGxlci5hdWRpb1RyYWNrID0gYXVkaW9UcmFja0lkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSGxzLnByb3RvdHlwZSwgXCJsaXZlU3luY1Bvc2l0aW9uXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtTZWNvbmRzfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdHJlYW1Db250cm9sbGVyLmxpdmVTeW5jUG9zaXRpb247XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShIbHMucHJvdG90eXBlLCBcInN1YnRpdGxlVHJhY2tzXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGdldCBhbHRlcm5hdGUgc3VidGl0bGUgdHJhY2tzIGxpc3QgZnJvbSBwbGF5bGlzdFxuICAgICAgICAgKiBAdHlwZSB7U3VidGl0bGVUcmFja1tdfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgc3VidGl0bGVUcmFja0NvbnRyb2xsZXIgPSB0aGlzLnN1YnRpdGxlVHJhY2tDb250cm9sbGVyO1xuICAgICAgICAgICAgcmV0dXJuIHN1YnRpdGxlVHJhY2tDb250cm9sbGVyID8gc3VidGl0bGVUcmFja0NvbnRyb2xsZXIuc3VidGl0bGVUcmFja3MgOiBbXTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEhscy5wcm90b3R5cGUsIFwic3VidGl0bGVUcmFja1wiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBpbmRleCBvZiB0aGUgc2VsZWN0ZWQgc3VidGl0bGUgdHJhY2sgKGluZGV4IGluIHN1YnRpdGxlIHRyYWNrIGxpc3RzKVxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgc3VidGl0bGVUcmFja0NvbnRyb2xsZXIgPSB0aGlzLnN1YnRpdGxlVHJhY2tDb250cm9sbGVyO1xuICAgICAgICAgICAgcmV0dXJuIHN1YnRpdGxlVHJhY2tDb250cm9sbGVyID8gc3VidGl0bGVUcmFja0NvbnRyb2xsZXIuc3VidGl0bGVUcmFjayA6IC0xO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogc2VsZWN0IGFuIHN1YnRpdGxlIHRyYWNrLCBiYXNlZCBvbiBpdHMgaW5kZXggaW4gc3VidGl0bGUgdHJhY2sgbGlzdHNcbiAgICAgICAgICogQHR5cGV7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoc3VidGl0bGVUcmFja0lkKSB7XG4gICAgICAgICAgICB2YXIgc3VidGl0bGVUcmFja0NvbnRyb2xsZXIgPSB0aGlzLnN1YnRpdGxlVHJhY2tDb250cm9sbGVyO1xuICAgICAgICAgICAgaWYgKHN1YnRpdGxlVHJhY2tDb250cm9sbGVyKSB7XG4gICAgICAgICAgICAgICAgc3VidGl0bGVUcmFja0NvbnRyb2xsZXIuc3VidGl0bGVUcmFjayA9IHN1YnRpdGxlVHJhY2tJZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEhscy5wcm90b3R5cGUsIFwic3VidGl0bGVEaXNwbGF5XCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgc3VidGl0bGVUcmFja0NvbnRyb2xsZXIgPSB0aGlzLnN1YnRpdGxlVHJhY2tDb250cm9sbGVyO1xuICAgICAgICAgICAgcmV0dXJuIHN1YnRpdGxlVHJhY2tDb250cm9sbGVyID8gc3VidGl0bGVUcmFja0NvbnRyb2xsZXIuc3VidGl0bGVEaXNwbGF5IDogZmFsc2U7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbmFibGUvZGlzYWJsZSBzdWJ0aXRsZSBkaXNwbGF5IHJlbmRlcmluZ1xuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgc3VidGl0bGVUcmFja0NvbnRyb2xsZXIgPSB0aGlzLnN1YnRpdGxlVHJhY2tDb250cm9sbGVyO1xuICAgICAgICAgICAgaWYgKHN1YnRpdGxlVHJhY2tDb250cm9sbGVyKSB7XG4gICAgICAgICAgICAgICAgc3VidGl0bGVUcmFja0NvbnRyb2xsZXIuc3VidGl0bGVEaXNwbGF5ID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBIbHM7XG59KG9ic2VydmVyXzEuT2JzZXJ2ZXIpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IEhscztcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9pcy1zdXBwb3J0ZWQuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2lzLXN1cHBvcnRlZC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qISBNb2R1bGVDb25jYXRlbmF0aW9uIGJhaWxvdXQ6IE1vZHVsZSBpcyBub3QgYW4gRUNNQVNjcmlwdCBtb2R1bGUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBtZWRpYXNvdXJjZV9oZWxwZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdXRpbHMvbWVkaWFzb3VyY2UtaGVscGVyICovIFwiLi9zcmMvdXRpbHMvbWVkaWFzb3VyY2UtaGVscGVyLmpzXCIpO1xuZnVuY3Rpb24gaXNTdXBwb3J0ZWQoKSB7XG4gICAgdmFyIG1lZGlhU291cmNlID0gbWVkaWFzb3VyY2VfaGVscGVyXzEuZ2V0TWVkaWFTb3VyY2UoKTtcbiAgICB2YXIgc291cmNlQnVmZmVyID0gd2luZG93LlNvdXJjZUJ1ZmZlciB8fCB3aW5kb3cuV2ViS2l0U291cmNlQnVmZmVyO1xuICAgIHZhciBpc1R5cGVTdXBwb3J0ZWQgPSBtZWRpYVNvdXJjZSAmJlxuICAgICAgICB0eXBlb2YgbWVkaWFTb3VyY2UuaXNUeXBlU3VwcG9ydGVkID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAgIG1lZGlhU291cmNlLmlzVHlwZVN1cHBvcnRlZCgndmlkZW8vbXA0OyBjb2RlY3M9XCJhdmMxLjQyRTAxRSxtcDRhLjQwLjJcIicpO1xuICAgIC8vIGlmIFNvdXJjZUJ1ZmZlciBpcyBleHBvc2VkIGVuc3VyZSBpdHMgQVBJIGlzIHZhbGlkXG4gICAgLy8gc2FmYXJpIGFuZCBvbGQgdmVyc2lvbiBvZiBDaHJvbWUgZG9lIG5vdCBleHBvc2UgU291cmNlQnVmZmVyIGdsb2JhbGx5IHNvIGNoZWNraW5nIFNvdXJjZUJ1ZmZlci5wcm90b3R5cGUgaXMgaW1wb3NzaWJsZVxuICAgIHZhciBzb3VyY2VCdWZmZXJWYWxpZEFQSSA9ICFzb3VyY2VCdWZmZXIgfHxcbiAgICAgICAgKHNvdXJjZUJ1ZmZlci5wcm90b3R5cGUgJiZcbiAgICAgICAgICAgIHR5cGVvZiBzb3VyY2VCdWZmZXIucHJvdG90eXBlLmFwcGVuZEJ1ZmZlciA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgICAgICAgdHlwZW9mIHNvdXJjZUJ1ZmZlci5wcm90b3R5cGUucmVtb3ZlID09PSAnZnVuY3Rpb24nKTtcbiAgICByZXR1cm4gISFpc1R5cGVTdXBwb3J0ZWQgJiYgISFzb3VyY2VCdWZmZXJWYWxpZEFQSTtcbn1cbmV4cG9ydHMuaXNTdXBwb3J0ZWQgPSBpc1N1cHBvcnRlZDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9sb2FkZXIvZnJhZ21lbnQtbG9hZGVyLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvbG9hZGVyL2ZyYWdtZW50LWxvYWRlci5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovKGZ1bmN0aW9uKE51bWJlcikge1xuLypcbiAqIEZyYWdtZW50IExvYWRlclxuKi9cbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGV2ZW50c18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZXZlbnRzICovIFwiLi9zcmMvZXZlbnRzLmpzXCIpO1xudmFyIGV2ZW50X2hhbmRsZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2V2ZW50LWhhbmRsZXIgKi8gXCIuL3NyYy9ldmVudC1oYW5kbGVyLmpzXCIpO1xudmFyIGVycm9yc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZXJyb3JzICovIFwiLi9zcmMvZXJyb3JzLmpzXCIpO1xudmFyIGxvZ2dlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvbG9nZ2VyICovIFwiLi9zcmMvdXRpbHMvbG9nZ2VyLmpzXCIpO1xudmFyIEZyYWdtZW50TG9hZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhGcmFnbWVudExvYWRlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBGcmFnbWVudExvYWRlcihobHMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgaGxzLCBldmVudHNfMS5kZWZhdWx0LkZSQUdfTE9BRElORykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMubG9hZGVycyA9IHt9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEZyYWdtZW50TG9hZGVyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbG9hZGVycyA9IHRoaXMubG9hZGVycztcbiAgICAgICAgZm9yICh2YXIgbG9hZGVyTmFtZSBpbiBsb2FkZXJzKSB7XG4gICAgICAgICAgICB2YXIgbG9hZGVyID0gbG9hZGVyc1tsb2FkZXJOYW1lXTtcbiAgICAgICAgICAgIGlmIChsb2FkZXIpIHtcbiAgICAgICAgICAgICAgICBsb2FkZXIuZGVzdHJveSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMubG9hZGVycyA9IHt9O1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLmRlc3Ryb3kuY2FsbCh0aGlzKTtcbiAgICB9O1xuICAgIEZyYWdtZW50TG9hZGVyLnByb3RvdHlwZS5vbkZyYWdMb2FkaW5nID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdmFyIGZyYWcgPSBkYXRhLmZyYWcsIHR5cGUgPSBmcmFnLnR5cGUsIGxvYWRlcnMgPSB0aGlzLmxvYWRlcnMsIGNvbmZpZyA9IHRoaXMuaGxzLmNvbmZpZywgRnJhZ21lbnRJTG9hZGVyID0gY29uZmlnLmZMb2FkZXIsIERlZmF1bHRJTG9hZGVyID0gY29uZmlnLmxvYWRlcjtcbiAgICAgICAgLy8gcmVzZXQgZnJhZ21lbnQgc3RhdGVcbiAgICAgICAgZnJhZy5sb2FkZWQgPSAwO1xuICAgICAgICB2YXIgbG9hZGVyID0gbG9hZGVyc1t0eXBlXTtcbiAgICAgICAgaWYgKGxvYWRlcikge1xuICAgICAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLndhcm4oXCJhYm9ydCBwcmV2aW91cyBmcmFnbWVudCBsb2FkZXIgZm9yIHR5cGU6IFwiICsgdHlwZSk7XG4gICAgICAgICAgICBsb2FkZXIuYWJvcnQoKTtcbiAgICAgICAgfVxuICAgICAgICBsb2FkZXIgPSBsb2FkZXJzW3R5cGVdID0gZnJhZy5sb2FkZXIgPVxuICAgICAgICAgICAgY29uZmlnLmZMb2FkZXIgPyBuZXcgRnJhZ21lbnRJTG9hZGVyKGNvbmZpZykgOiBuZXcgRGVmYXVsdElMb2FkZXIoY29uZmlnKTtcbiAgICAgICAgdmFyIGxvYWRlckNvbnRleHQsIGxvYWRlckNvbmZpZywgbG9hZGVyQ2FsbGJhY2tzO1xuICAgICAgICBsb2FkZXJDb250ZXh0ID0geyB1cmw6IGZyYWcudXJsLCBmcmFnOiBmcmFnLCByZXNwb25zZVR5cGU6ICdhcnJheWJ1ZmZlcicsIHByb2dyZXNzRGF0YTogZmFsc2UgfTtcbiAgICAgICAgdmFyIHN0YXJ0ID0gZnJhZy5ieXRlUmFuZ2VTdGFydE9mZnNldCwgZW5kID0gZnJhZy5ieXRlUmFuZ2VFbmRPZmZzZXQ7XG4gICAgICAgIGlmIChOdW1iZXIuaXNGaW5pdGUoc3RhcnQpICYmIE51bWJlci5pc0Zpbml0ZShlbmQpKSB7XG4gICAgICAgICAgICBsb2FkZXJDb250ZXh0LnJhbmdlU3RhcnQgPSBzdGFydDtcbiAgICAgICAgICAgIGxvYWRlckNvbnRleHQucmFuZ2VFbmQgPSBlbmQ7XG4gICAgICAgIH1cbiAgICAgICAgbG9hZGVyQ29uZmlnID0ge1xuICAgICAgICAgICAgdGltZW91dDogY29uZmlnLmZyYWdMb2FkaW5nVGltZU91dCxcbiAgICAgICAgICAgIG1heFJldHJ5OiAwLFxuICAgICAgICAgICAgcmV0cnlEZWxheTogMCxcbiAgICAgICAgICAgIG1heFJldHJ5RGVsYXk6IGNvbmZpZy5mcmFnTG9hZGluZ01heFJldHJ5VGltZW91dFxuICAgICAgICB9O1xuICAgICAgICBsb2FkZXJDYWxsYmFja3MgPSB7XG4gICAgICAgICAgICBvblN1Y2Nlc3M6IHRoaXMubG9hZHN1Y2Nlc3MuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIG9uRXJyb3I6IHRoaXMubG9hZGVycm9yLmJpbmQodGhpcyksXG4gICAgICAgICAgICBvblRpbWVvdXQ6IHRoaXMubG9hZHRpbWVvdXQuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIG9uUHJvZ3Jlc3M6IHRoaXMubG9hZHByb2dyZXNzLmJpbmQodGhpcylcbiAgICAgICAgfTtcbiAgICAgICAgbG9hZGVyLmxvYWQobG9hZGVyQ29udGV4dCwgbG9hZGVyQ29uZmlnLCBsb2FkZXJDYWxsYmFja3MpO1xuICAgIH07XG4gICAgRnJhZ21lbnRMb2FkZXIucHJvdG90eXBlLmxvYWRzdWNjZXNzID0gZnVuY3Rpb24gKHJlc3BvbnNlLCBzdGF0cywgY29udGV4dCwgbmV0d29ya0RldGFpbHMpIHtcbiAgICAgICAgaWYgKG5ldHdvcmtEZXRhaWxzID09PSB2b2lkIDApIHsgbmV0d29ya0RldGFpbHMgPSBudWxsOyB9XG4gICAgICAgIHZhciBwYXlsb2FkID0gcmVzcG9uc2UuZGF0YSwgZnJhZyA9IGNvbnRleHQuZnJhZztcbiAgICAgICAgLy8gZGV0YWNoIGZyYWdtZW50IGxvYWRlciBvbiBsb2FkIHN1Y2Nlc3NcbiAgICAgICAgZnJhZy5sb2FkZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMubG9hZGVyc1tmcmFnLnR5cGVdID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmhscy50cmlnZ2VyKGV2ZW50c18xLmRlZmF1bHQuRlJBR19MT0FERUQsIHsgcGF5bG9hZDogcGF5bG9hZCwgZnJhZzogZnJhZywgc3RhdHM6IHN0YXRzLCBuZXR3b3JrRGV0YWlsczogbmV0d29ya0RldGFpbHMgfSk7XG4gICAgfTtcbiAgICBGcmFnbWVudExvYWRlci5wcm90b3R5cGUubG9hZGVycm9yID0gZnVuY3Rpb24gKHJlc3BvbnNlLCBjb250ZXh0LCBuZXR3b3JrRGV0YWlscykge1xuICAgICAgICBpZiAobmV0d29ya0RldGFpbHMgPT09IHZvaWQgMCkgeyBuZXR3b3JrRGV0YWlscyA9IG51bGw7IH1cbiAgICAgICAgdmFyIGZyYWcgPSBjb250ZXh0LmZyYWc7XG4gICAgICAgIHZhciBsb2FkZXIgPSBmcmFnLmxvYWRlcjtcbiAgICAgICAgaWYgKGxvYWRlcikge1xuICAgICAgICAgICAgbG9hZGVyLmFib3J0KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sb2FkZXJzW2ZyYWcudHlwZV0gPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoZXZlbnRzXzEuZGVmYXVsdC5FUlJPUiwgeyB0eXBlOiBlcnJvcnNfMS5FcnJvclR5cGVzLk5FVFdPUktfRVJST1IsIGRldGFpbHM6IGVycm9yc18xLkVycm9yRGV0YWlscy5GUkFHX0xPQURfRVJST1IsIGZhdGFsOiBmYWxzZSwgZnJhZzogY29udGV4dC5mcmFnLCByZXNwb25zZTogcmVzcG9uc2UsIG5ldHdvcmtEZXRhaWxzOiBuZXR3b3JrRGV0YWlscyB9KTtcbiAgICB9O1xuICAgIEZyYWdtZW50TG9hZGVyLnByb3RvdHlwZS5sb2FkdGltZW91dCA9IGZ1bmN0aW9uIChzdGF0cywgY29udGV4dCwgbmV0d29ya0RldGFpbHMpIHtcbiAgICAgICAgaWYgKG5ldHdvcmtEZXRhaWxzID09PSB2b2lkIDApIHsgbmV0d29ya0RldGFpbHMgPSBudWxsOyB9XG4gICAgICAgIHZhciBmcmFnID0gY29udGV4dC5mcmFnO1xuICAgICAgICB2YXIgbG9hZGVyID0gZnJhZy5sb2FkZXI7XG4gICAgICAgIGlmIChsb2FkZXIpIHtcbiAgICAgICAgICAgIGxvYWRlci5hYm9ydCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubG9hZGVyc1tmcmFnLnR5cGVdID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmhscy50cmlnZ2VyKGV2ZW50c18xLmRlZmF1bHQuRVJST1IsIHsgdHlwZTogZXJyb3JzXzEuRXJyb3JUeXBlcy5ORVRXT1JLX0VSUk9SLCBkZXRhaWxzOiBlcnJvcnNfMS5FcnJvckRldGFpbHMuRlJBR19MT0FEX1RJTUVPVVQsIGZhdGFsOiBmYWxzZSwgZnJhZzogY29udGV4dC5mcmFnLCBuZXR3b3JrRGV0YWlsczogbmV0d29ya0RldGFpbHMgfSk7XG4gICAgfTtcbiAgICAvLyBkYXRhIHdpbGwgYmUgdXNlZCBmb3IgcHJvZ3Jlc3NpdmUgcGFyc2luZ1xuICAgIEZyYWdtZW50TG9hZGVyLnByb3RvdHlwZS5sb2FkcHJvZ3Jlc3MgPSBmdW5jdGlvbiAoc3RhdHMsIGNvbnRleHQsIGRhdGEsIG5ldHdvcmtEZXRhaWxzKSB7XG4gICAgICAgIGlmIChuZXR3b3JrRGV0YWlscyA9PT0gdm9pZCAwKSB7IG5ldHdvcmtEZXRhaWxzID0gbnVsbDsgfVxuICAgICAgICB2YXIgZnJhZyA9IGNvbnRleHQuZnJhZztcbiAgICAgICAgZnJhZy5sb2FkZWQgPSBzdGF0cy5sb2FkZWQ7XG4gICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoZXZlbnRzXzEuZGVmYXVsdC5GUkFHX0xPQURfUFJPR1JFU1MsIHsgZnJhZzogZnJhZywgc3RhdHM6IHN0YXRzLCBuZXR3b3JrRGV0YWlsczogbmV0d29ya0RldGFpbHMgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gRnJhZ21lbnRMb2FkZXI7XG59KGV2ZW50X2hhbmRsZXJfMS5kZWZhdWx0KSk7XG5leHBvcnRzLmRlZmF1bHQgPSBGcmFnbWVudExvYWRlcjtcblxuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovfS5jYWxsKHRoaXMsIF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vc3JjL3BvbHlmaWxscy9udW1iZXIgKi8gXCIuL3NyYy9wb2x5ZmlsbHMvbnVtYmVyLmpzXCIpW1wiTnVtYmVyXCJdKSlcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvbG9hZGVyL2ZyYWdtZW50LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9sb2FkZXIvZnJhZ21lbnQuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovKGZ1bmN0aW9uKE51bWJlcikge1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIFVSTFRvb2xraXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISB1cmwtdG9vbGtpdCAqLyBcIi4vbm9kZV9tb2R1bGVzL3VybC10b29sa2l0L3NyYy91cmwtdG9vbGtpdC5qc1wiKTtcbnZhciBsZXZlbF9rZXlfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vbGV2ZWwta2V5ICovIFwiLi9zcmMvbG9hZGVyL2xldmVsLWtleS5qc1wiKTtcbnZhciBGcmFnbWVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBGcmFnbWVudCgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB0aGlzLl91cmwgPSBudWxsO1xuICAgICAgICB0aGlzLl9ieXRlUmFuZ2UgPSBudWxsO1xuICAgICAgICB0aGlzLl9kZWNyeXB0ZGF0YSA9IG51bGw7XG4gICAgICAgIHRoaXMudGFnTGlzdCA9IFtdO1xuICAgICAgICB0aGlzLnByb2dyYW1EYXRlVGltZSA9IG51bGw7XG4gICAgICAgIHRoaXMucmF3UHJvZ3JhbURhdGVUaW1lID0gbnVsbDtcbiAgICAgICAgLy8gSG9sZHMgdGhlIHR5cGVzIG9mIGRhdGEgdGhpcyBmcmFnbWVudCBzdXBwb3J0c1xuICAgICAgICB0aGlzLl9lbGVtZW50YXJ5U3RyZWFtcyA9IChfYSA9IHt9LFxuICAgICAgICAgICAgX2FbRnJhZ21lbnQuRWxlbWVudGFyeVN0cmVhbVR5cGVzLkFVRElPXSA9IGZhbHNlLFxuICAgICAgICAgICAgX2FbRnJhZ21lbnQuRWxlbWVudGFyeVN0cmVhbVR5cGVzLlZJREVPXSA9IGZhbHNlLFxuICAgICAgICAgICAgX2EpO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRnJhZ21lbnQsIFwiRWxlbWVudGFyeVN0cmVhbVR5cGVzXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGB0eXBlYCBwcm9wZXJ0eSBmb3IgdGhpcy5fZWxlbWVudGFyeVN0cmVhbXNcbiAgICAgICAgICpcbiAgICAgICAgICogQGVudW1cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBBVURJTzogJ2F1ZGlvJyxcbiAgICAgICAgICAgICAgICBWSURFTzogJ3ZpZGVvJ1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZyYWdtZW50LnByb3RvdHlwZSwgXCJ1cmxcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fdXJsICYmIHRoaXMucmVsdXJsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdXJsID0gVVJMVG9vbGtpdC5idWlsZEFic29sdXRlVVJMKHRoaXMuYmFzZXVybCwgdGhpcy5yZWx1cmwsIHsgYWx3YXlzTm9ybWFsaXplOiB0cnVlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3VybDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX3VybCA9IHZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRnJhZ21lbnQucHJvdG90eXBlLCBcImJ5dGVSYW5nZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9ieXRlUmFuZ2UgJiYgIXRoaXMucmF3Qnl0ZVJhbmdlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX2J5dGVSYW5nZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9ieXRlUmFuZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgYnl0ZVJhbmdlID0gW107XG4gICAgICAgICAgICBpZiAodGhpcy5yYXdCeXRlUmFuZ2UpIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFyYW1zID0gdGhpcy5yYXdCeXRlUmFuZ2Uuc3BsaXQoJ0AnLCAyKTtcbiAgICAgICAgICAgICAgICBpZiAocGFyYW1zLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGFzdEJ5dGVSYW5nZUVuZE9mZnNldCA9IHRoaXMubGFzdEJ5dGVSYW5nZUVuZE9mZnNldDtcbiAgICAgICAgICAgICAgICAgICAgYnl0ZVJhbmdlWzBdID0gbGFzdEJ5dGVSYW5nZUVuZE9mZnNldCB8fCAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYnl0ZVJhbmdlWzBdID0gcGFyc2VJbnQocGFyYW1zWzFdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnl0ZVJhbmdlWzFdID0gcGFyc2VJbnQocGFyYW1zWzBdKSArIGJ5dGVSYW5nZVswXTtcbiAgICAgICAgICAgICAgICB0aGlzLl9ieXRlUmFuZ2UgPSBieXRlUmFuZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYnl0ZVJhbmdlO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRnJhZ21lbnQucHJvdG90eXBlLCBcImJ5dGVSYW5nZVN0YXJ0T2Zmc2V0XCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJ5dGVSYW5nZVswXTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZyYWdtZW50LnByb3RvdHlwZSwgXCJieXRlUmFuZ2VFbmRPZmZzZXRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJ5dGVSYW5nZVsxXTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZyYWdtZW50LnByb3RvdHlwZSwgXCJkZWNyeXB0ZGF0YVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9kZWNyeXB0ZGF0YSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2RlY3J5cHRkYXRhID0gdGhpcy5mcmFnbWVudERlY3J5cHRkYXRhRnJvbUxldmVsa2V5KHRoaXMubGV2ZWxrZXksIHRoaXMuc24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RlY3J5cHRkYXRhO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRnJhZ21lbnQucHJvdG90eXBlLCBcImVuZFByb2dyYW1EYXRlVGltZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUodGhpcy5wcm9ncmFtRGF0ZVRpbWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZHVyYXRpb24gPSAhTnVtYmVyLmlzRmluaXRlKHRoaXMuZHVyYXRpb24pID8gMCA6IHRoaXMuZHVyYXRpb247XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm9ncmFtRGF0ZVRpbWUgKyAoZHVyYXRpb24gKiAxMDAwKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZyYWdtZW50LnByb3RvdHlwZSwgXCJlbmNyeXB0ZWRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAhISgodGhpcy5kZWNyeXB0ZGF0YSAmJiB0aGlzLmRlY3J5cHRkYXRhLnVyaSAhPT0gbnVsbCkgJiYgKHRoaXMuZGVjcnlwdGRhdGEua2V5ID09PSBudWxsKSk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7RWxlbWVudGFyeVN0cmVhbVR5cGV9IHR5cGVcbiAgICAgKi9cbiAgICBGcmFnbWVudC5wcm90b3R5cGUuYWRkRWxlbWVudGFyeVN0cmVhbSA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgIHRoaXMuX2VsZW1lbnRhcnlTdHJlYW1zW3R5cGVdID0gdHJ1ZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7RWxlbWVudGFyeVN0cmVhbVR5cGV9IHR5cGVcbiAgICAgKi9cbiAgICBGcmFnbWVudC5wcm90b3R5cGUuaGFzRWxlbWVudGFyeVN0cmVhbSA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9lbGVtZW50YXJ5U3RyZWFtc1t0eXBlXSA9PT0gdHJ1ZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFV0aWxpdHkgbWV0aG9kIGZvciBwYXJzZUxldmVsUGxheWxpc3QgdG8gY3JlYXRlIGFuIGluaXRpYWxpemF0aW9uIHZlY3RvciBmb3IgYSBnaXZlbiBzZWdtZW50XG4gICAgICogQHJldHVybnMge1VpbnQ4QXJyYXl9XG4gICAgICovXG4gICAgRnJhZ21lbnQucHJvdG90eXBlLmNyZWF0ZUluaXRpYWxpemF0aW9uVmVjdG9yID0gZnVuY3Rpb24gKHNlZ21lbnROdW1iZXIpIHtcbiAgICAgICAgdmFyIHVpbnQ4VmlldyA9IG5ldyBVaW50OEFycmF5KDE2KTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDEyOyBpIDwgMTY7IGkrKykge1xuICAgICAgICAgICAgdWludDhWaWV3W2ldID0gKHNlZ21lbnROdW1iZXIgPj4gOCAqICgxNSAtIGkpKSAmIDB4ZmY7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVpbnQ4VmlldztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFV0aWxpdHkgbWV0aG9kIGZvciBwYXJzZUxldmVsUGxheWxpc3QgdG8gZ2V0IGEgZnJhZ21lbnQncyBkZWNyeXB0aW9uIGRhdGEgZnJvbSB0aGUgY3VycmVudGx5IHBhcnNlZCBlbmNyeXB0aW9uIGtleSBkYXRhXG4gICAgICogQHBhcmFtIGxldmVsa2V5IC0gYSBwbGF5bGlzdCdzIGVuY3J5cHRpb24gaW5mb1xuICAgICAqIEBwYXJhbSBzZWdtZW50TnVtYmVyIC0gdGhlIGZyYWdtZW50J3Mgc2VnbWVudCBudW1iZXJcbiAgICAgKiBAcmV0dXJucyB7Kn0gLSBhbiBvYmplY3QgdG8gYmUgYXBwbGllZCBhcyBhIGZyYWdtZW50J3MgZGVjcnlwdGRhdGFcbiAgICAgKi9cbiAgICBGcmFnbWVudC5wcm90b3R5cGUuZnJhZ21lbnREZWNyeXB0ZGF0YUZyb21MZXZlbGtleSA9IGZ1bmN0aW9uIChsZXZlbGtleSwgc2VnbWVudE51bWJlcikge1xuICAgICAgICB2YXIgZGVjcnlwdGRhdGEgPSBsZXZlbGtleTtcbiAgICAgICAgaWYgKGxldmVsa2V5ICYmIGxldmVsa2V5Lm1ldGhvZCAmJiBsZXZlbGtleS51cmkgJiYgIWxldmVsa2V5Lml2KSB7XG4gICAgICAgICAgICBkZWNyeXB0ZGF0YSA9IG5ldyBsZXZlbF9rZXlfMS5kZWZhdWx0KCk7XG4gICAgICAgICAgICBkZWNyeXB0ZGF0YS5tZXRob2QgPSBsZXZlbGtleS5tZXRob2Q7XG4gICAgICAgICAgICBkZWNyeXB0ZGF0YS5iYXNldXJpID0gbGV2ZWxrZXkuYmFzZXVyaTtcbiAgICAgICAgICAgIGRlY3J5cHRkYXRhLnJlbHVyaSA9IGxldmVsa2V5LnJlbHVyaTtcbiAgICAgICAgICAgIGRlY3J5cHRkYXRhLml2ID0gdGhpcy5jcmVhdGVJbml0aWFsaXphdGlvblZlY3RvcihzZWdtZW50TnVtYmVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVjcnlwdGRhdGE7XG4gICAgfTtcbiAgICByZXR1cm4gRnJhZ21lbnQ7XG59KCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gRnJhZ21lbnQ7XG5cbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqL30uY2FsbCh0aGlzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3NyYy9wb2x5ZmlsbHMvbnVtYmVyICovIFwiLi9zcmMvcG9seWZpbGxzL251bWJlci5qc1wiKVtcIk51bWJlclwiXSkpXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2xvYWRlci9rZXktbG9hZGVyLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2xvYWRlci9rZXktbG9hZGVyLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKlxuICogRGVjcnlwdCBrZXkgTG9hZGVyXG4qL1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZXZlbnRzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9ldmVudHMgKi8gXCIuL3NyYy9ldmVudHMuanNcIik7XG52YXIgZXZlbnRfaGFuZGxlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZXZlbnQtaGFuZGxlciAqLyBcIi4vc3JjL2V2ZW50LWhhbmRsZXIuanNcIik7XG52YXIgZXJyb3JzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9lcnJvcnMgKi8gXCIuL3NyYy9lcnJvcnMuanNcIik7XG52YXIgbG9nZ2VyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy9sb2dnZXIgKi8gXCIuL3NyYy91dGlscy9sb2dnZXIuanNcIik7XG52YXIgS2V5TG9hZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhLZXlMb2FkZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gS2V5TG9hZGVyKGhscykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBobHMsIGV2ZW50c18xLmRlZmF1bHQuS0VZX0xPQURJTkcpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmxvYWRlcnMgPSB7fTtcbiAgICAgICAgX3RoaXMuZGVjcnlwdGtleSA9IG51bGw7XG4gICAgICAgIF90aGlzLmRlY3J5cHR1cmwgPSBudWxsO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEtleUxvYWRlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZm9yICh2YXIgbG9hZGVyTmFtZSBpbiB0aGlzLmxvYWRlcnMpIHtcbiAgICAgICAgICAgIHZhciBsb2FkZXIgPSB0aGlzLmxvYWRlcnNbbG9hZGVyTmFtZV07XG4gICAgICAgICAgICBpZiAobG9hZGVyKSB7XG4gICAgICAgICAgICAgICAgbG9hZGVyLmRlc3Ryb3koKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxvYWRlcnMgPSB7fTtcbiAgICAgICAgZXZlbnRfaGFuZGxlcl8xLmRlZmF1bHQucHJvdG90eXBlLmRlc3Ryb3kuY2FsbCh0aGlzKTtcbiAgICB9O1xuICAgIEtleUxvYWRlci5wcm90b3R5cGUub25LZXlMb2FkaW5nID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdmFyIGZyYWcgPSBkYXRhLmZyYWcsIHR5cGUgPSBmcmFnLnR5cGUsIGxvYWRlciA9IHRoaXMubG9hZGVyc1t0eXBlXSwgZGVjcnlwdGRhdGEgPSBmcmFnLmRlY3J5cHRkYXRhLCB1cmkgPSBkZWNyeXB0ZGF0YS51cmk7XG4gICAgICAgIC8vIGlmIHVyaSBpcyBkaWZmZXJlbnQgZnJvbSBwcmV2aW91cyBvbmUgb3IgaWYgZGVjcnlwdCBrZXkgbm90IHJldHJpZXZlZCB5ZXRcbiAgICAgICAgaWYgKHVyaSAhPT0gdGhpcy5kZWNyeXB0dXJsIHx8IHRoaXMuZGVjcnlwdGtleSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIGNvbmZpZyA9IHRoaXMuaGxzLmNvbmZpZztcbiAgICAgICAgICAgIGlmIChsb2FkZXIpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXJfMS5sb2dnZXIud2FybihcImFib3J0IHByZXZpb3VzIGtleSBsb2FkZXIgZm9yIHR5cGU6XCIgKyB0eXBlKTtcbiAgICAgICAgICAgICAgICBsb2FkZXIuYWJvcnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZyYWcubG9hZGVyID0gdGhpcy5sb2FkZXJzW3R5cGVdID0gbmV3IGNvbmZpZy5sb2FkZXIoY29uZmlnKTtcbiAgICAgICAgICAgIHRoaXMuZGVjcnlwdHVybCA9IHVyaTtcbiAgICAgICAgICAgIHRoaXMuZGVjcnlwdGtleSA9IG51bGw7XG4gICAgICAgICAgICB2YXIgbG9hZGVyQ29udGV4dCA9IHZvaWQgMCwgbG9hZGVyQ29uZmlnID0gdm9pZCAwLCBsb2FkZXJDYWxsYmFja3MgPSB2b2lkIDA7XG4gICAgICAgICAgICBsb2FkZXJDb250ZXh0ID0geyB1cmw6IHVyaSwgZnJhZzogZnJhZywgcmVzcG9uc2VUeXBlOiAnYXJyYXlidWZmZXInIH07XG4gICAgICAgICAgICAvLyBtYXhSZXRyeSBpcyAwIHNvIHRoYXQgaW5zdGVhZCBvZiByZXRyeWluZyB0aGUgc2FtZSBrZXkgb24gdGhlIHNhbWUgdmFyaWFudCBtdWx0aXBsZSB0aW1lcyxcbiAgICAgICAgICAgIC8vIGtleS1sb2FkZXIgd2lsbCB0cmlnZ2VyIGFuIGVycm9yIGFuZCByZWx5IG9uIHN0cmVhbS1jb250cm9sbGVyIHRvIGhhbmRsZSByZXRyeSBsb2dpYy5cbiAgICAgICAgICAgIC8vIHRoaXMgd2lsbCBhbHNvIGFsaWduIHJldHJ5IGxvZ2ljIHdpdGggZnJhZ21lbnQtbG9hZGVyXG4gICAgICAgICAgICBsb2FkZXJDb25maWcgPSB7IHRpbWVvdXQ6IGNvbmZpZy5mcmFnTG9hZGluZ1RpbWVPdXQsIG1heFJldHJ5OiAwLCByZXRyeURlbGF5OiBjb25maWcuZnJhZ0xvYWRpbmdSZXRyeURlbGF5LCBtYXhSZXRyeURlbGF5OiBjb25maWcuZnJhZ0xvYWRpbmdNYXhSZXRyeVRpbWVvdXQgfTtcbiAgICAgICAgICAgIGxvYWRlckNhbGxiYWNrcyA9IHsgb25TdWNjZXNzOiB0aGlzLmxvYWRzdWNjZXNzLmJpbmQodGhpcyksIG9uRXJyb3I6IHRoaXMubG9hZGVycm9yLmJpbmQodGhpcyksIG9uVGltZW91dDogdGhpcy5sb2FkdGltZW91dC5iaW5kKHRoaXMpIH07XG4gICAgICAgICAgICBmcmFnLmxvYWRlci5sb2FkKGxvYWRlckNvbnRleHQsIGxvYWRlckNvbmZpZywgbG9hZGVyQ2FsbGJhY2tzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmRlY3J5cHRrZXkpIHtcbiAgICAgICAgICAgIC8vIHdlIGFscmVhZHkgbG9hZGVkIHRoaXMga2V5LCByZXR1cm4gaXRcbiAgICAgICAgICAgIGRlY3J5cHRkYXRhLmtleSA9IHRoaXMuZGVjcnlwdGtleTtcbiAgICAgICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoZXZlbnRzXzEuZGVmYXVsdC5LRVlfTE9BREVELCB7IGZyYWc6IGZyYWcgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEtleUxvYWRlci5wcm90b3R5cGUubG9hZHN1Y2Nlc3MgPSBmdW5jdGlvbiAocmVzcG9uc2UsIHN0YXRzLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBmcmFnID0gY29udGV4dC5mcmFnO1xuICAgICAgICB0aGlzLmRlY3J5cHRrZXkgPSBmcmFnLmRlY3J5cHRkYXRhLmtleSA9IG5ldyBVaW50OEFycmF5KHJlc3BvbnNlLmRhdGEpO1xuICAgICAgICAvLyBkZXRhY2ggZnJhZ21lbnQgbG9hZGVyIG9uIGxvYWQgc3VjY2Vzc1xuICAgICAgICBmcmFnLmxvYWRlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5sb2FkZXJzW2ZyYWcudHlwZV0gPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoZXZlbnRzXzEuZGVmYXVsdC5LRVlfTE9BREVELCB7IGZyYWc6IGZyYWcgfSk7XG4gICAgfTtcbiAgICBLZXlMb2FkZXIucHJvdG90eXBlLmxvYWRlcnJvciA9IGZ1bmN0aW9uIChyZXNwb25zZSwgY29udGV4dCkge1xuICAgICAgICB2YXIgZnJhZyA9IGNvbnRleHQuZnJhZywgbG9hZGVyID0gZnJhZy5sb2FkZXI7XG4gICAgICAgIGlmIChsb2FkZXIpIHtcbiAgICAgICAgICAgIGxvYWRlci5hYm9ydCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubG9hZGVyc1tjb250ZXh0LnR5cGVdID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmhscy50cmlnZ2VyKGV2ZW50c18xLmRlZmF1bHQuRVJST1IsIHsgdHlwZTogZXJyb3JzXzEuRXJyb3JUeXBlcy5ORVRXT1JLX0VSUk9SLCBkZXRhaWxzOiBlcnJvcnNfMS5FcnJvckRldGFpbHMuS0VZX0xPQURfRVJST1IsIGZhdGFsOiBmYWxzZSwgZnJhZzogZnJhZywgcmVzcG9uc2U6IHJlc3BvbnNlIH0pO1xuICAgIH07XG4gICAgS2V5TG9hZGVyLnByb3RvdHlwZS5sb2FkdGltZW91dCA9IGZ1bmN0aW9uIChzdGF0cywgY29udGV4dCkge1xuICAgICAgICB2YXIgZnJhZyA9IGNvbnRleHQuZnJhZywgbG9hZGVyID0gZnJhZy5sb2FkZXI7XG4gICAgICAgIGlmIChsb2FkZXIpIHtcbiAgICAgICAgICAgIGxvYWRlci5hYm9ydCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubG9hZGVyc1tjb250ZXh0LnR5cGVdID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmhscy50cmlnZ2VyKGV2ZW50c18xLmRlZmF1bHQuRVJST1IsIHsgdHlwZTogZXJyb3JzXzEuRXJyb3JUeXBlcy5ORVRXT1JLX0VSUk9SLCBkZXRhaWxzOiBlcnJvcnNfMS5FcnJvckRldGFpbHMuS0VZX0xPQURfVElNRU9VVCwgZmF0YWw6IGZhbHNlLCBmcmFnOiBmcmFnIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIEtleUxvYWRlcjtcbn0oZXZlbnRfaGFuZGxlcl8xLmRlZmF1bHQpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IEtleUxvYWRlcjtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9sb2FkZXIvbGV2ZWwta2V5LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvbG9hZGVyL2xldmVsLWtleS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgVVJMVG9vbGtpdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIHVybC10b29sa2l0ICovIFwiLi9ub2RlX21vZHVsZXMvdXJsLXRvb2xraXQvc3JjL3VybC10b29sa2l0LmpzXCIpO1xudmFyIExldmVsS2V5ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIExldmVsS2V5KCkge1xuICAgICAgICB0aGlzLm1ldGhvZCA9IG51bGw7XG4gICAgICAgIHRoaXMua2V5ID0gbnVsbDtcbiAgICAgICAgdGhpcy5pdiA9IG51bGw7XG4gICAgICAgIHRoaXMuX3VyaSA9IG51bGw7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShMZXZlbEtleS5wcm90b3R5cGUsIFwidXJpXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX3VyaSAmJiB0aGlzLnJlbHVyaSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3VyaSA9IFVSTFRvb2xraXQuYnVpbGRBYnNvbHV0ZVVSTCh0aGlzLmJhc2V1cmksIHRoaXMucmVsdXJpLCB7IGFsd2F5c05vcm1hbGl6ZTogdHJ1ZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl91cmk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBMZXZlbEtleTtcbn0oKSk7XG5leHBvcnRzLmRlZmF1bHQgPSBMZXZlbEtleTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9sb2FkZXIvbGV2ZWwuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2xvYWRlci9sZXZlbC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qISBNb2R1bGVDb25jYXRlbmF0aW9uIGJhaWxvdXQ6IE1vZHVsZSBpcyBub3QgYW4gRUNNQVNjcmlwdCBtb2R1bGUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi8oZnVuY3Rpb24oTnVtYmVyKSB7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgTGV2ZWwgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTGV2ZWwoYmFzZVVybCkge1xuICAgICAgICAvLyBQbGVhc2Uga2VlcCBwcm9wZXJ0aWVzIGluIGFscGhhYmV0aWNhbCBvcmRlclxuICAgICAgICB0aGlzLmVuZENDID0gMDtcbiAgICAgICAgdGhpcy5lbmRTTiA9IDA7XG4gICAgICAgIHRoaXMuZnJhZ21lbnRzID0gW107XG4gICAgICAgIHRoaXMuaW5pdFNlZ21lbnQgPSBudWxsO1xuICAgICAgICB0aGlzLmxpdmUgPSB0cnVlO1xuICAgICAgICB0aGlzLm5lZWRTaWR4UmFuZ2VzID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc3RhcnRDQyA9IDA7XG4gICAgICAgIHRoaXMuc3RhcnRTTiA9IDA7XG4gICAgICAgIHRoaXMuc3RhcnRUaW1lT2Zmc2V0ID0gbnVsbDtcbiAgICAgICAgdGhpcy50YXJnZXRkdXJhdGlvbiA9IDA7XG4gICAgICAgIHRoaXMudG90YWxkdXJhdGlvbiA9IDA7XG4gICAgICAgIHRoaXMudHlwZSA9IG51bGw7XG4gICAgICAgIHRoaXMudXJsID0gYmFzZVVybDtcbiAgICAgICAgdGhpcy52ZXJzaW9uID0gbnVsbDtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KExldmVsLnByb3RvdHlwZSwgXCJoYXNQcm9ncmFtRGF0ZVRpbWVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAhISh0aGlzLmZyYWdtZW50c1swXSAmJiBOdW1iZXIuaXNGaW5pdGUodGhpcy5mcmFnbWVudHNbMF0ucHJvZ3JhbURhdGVUaW1lKSk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBMZXZlbDtcbn0oKSk7XG5leHBvcnRzLmRlZmF1bHQgPSBMZXZlbDtcblxuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovfS5jYWxsKHRoaXMsIF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vc3JjL3BvbHlmaWxscy9udW1iZXIgKi8gXCIuL3NyYy9wb2x5ZmlsbHMvbnVtYmVyLmpzXCIpW1wiTnVtYmVyXCJdKSlcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvbG9hZGVyL20zdTgtcGFyc2VyLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9sb2FkZXIvbTN1OC1wYXJzZXIuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovKGZ1bmN0aW9uKE51bWJlcikge1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIFVSTFRvb2xraXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISB1cmwtdG9vbGtpdCAqLyBcIi4vbm9kZV9tb2R1bGVzL3VybC10b29sa2l0L3NyYy91cmwtdG9vbGtpdC5qc1wiKTtcbnZhciBmcmFnbWVudF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9mcmFnbWVudCAqLyBcIi4vc3JjL2xvYWRlci9mcmFnbWVudC5qc1wiKTtcbnZhciBsZXZlbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9sZXZlbCAqLyBcIi4vc3JjL2xvYWRlci9sZXZlbC5qc1wiKTtcbnZhciBsZXZlbF9rZXlfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vbGV2ZWwta2V5ICovIFwiLi9zcmMvbG9hZGVyL2xldmVsLWtleS5qc1wiKTtcbnZhciBhdHRyX2xpc3RfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL2F0dHItbGlzdCAqLyBcIi4vc3JjL3V0aWxzL2F0dHItbGlzdC5qc1wiKTtcbnZhciBsb2dnZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL2xvZ2dlciAqLyBcIi4vc3JjL3V0aWxzL2xvZ2dlci5qc1wiKTtcbnZhciBjb2RlY3NfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL2NvZGVjcyAqLyBcIi4vc3JjL3V0aWxzL2NvZGVjcy5qc1wiKTtcbi8qKlxuICogTTNVOCBwYXJzZXJcbiAqIEBtb2R1bGVcbiAqL1xuLy8gaHR0cHM6Ly9yZWdleDEwMS5jb20gaXMgeW91ciBmcmllbmRcbnZhciBNQVNURVJfUExBWUxJU1RfUkVHRVggPSAvI0VYVC1YLVNUUkVBTS1JTkY6KFteXFxuXFxyXSopW1xcclxcbl0rKFteXFxyXFxuXSspL2c7XG52YXIgTUFTVEVSX1BMQVlMSVNUX01FRElBX1JFR0VYID0gLyNFWFQtWC1NRURJQTooLiopL2c7XG52YXIgTEVWRUxfUExBWUxJU1RfUkVHRVhfRkFTVCA9IG5ldyBSZWdFeHAoW1xuICAgIC8jRVhUSU5GOlxccyooXFxkKig/OlxcLlxcZCspPykoPzosKC4qKVxccyspPy8uc291cmNlLFxuICAgIC98KD8hIykoW1xcUysgP10rKS8uc291cmNlLFxuICAgIC98I0VYVC1YLUJZVEVSQU5HRToqKC4rKS8uc291cmNlLFxuICAgIC98I0VYVC1YLVBST0dSQU0tREFURS1USU1FOiguKykvLnNvdXJjZSxcbiAgICAvfCMuKi8uc291cmNlIC8vIEFsbCBvdGhlciBub24tc2VnbWVudCBvcmllbnRlZCB0YWdzIHdpbGwgbWF0Y2ggd2l0aCBhbGwgZ3JvdXBzIGVtcHR5XG5dLmpvaW4oJycpLCAnZycpO1xudmFyIExFVkVMX1BMQVlMSVNUX1JFR0VYX1NMT1cgPSAvKD86KD86IyhFWFRNM1UpKXwoPzojRVhULVgtKFBMQVlMSVNULVRZUEUpOiguKykpfCg/OiNFWFQtWC0oTUVESUEtU0VRVUVOQ0UpOiAqKFxcZCspKXwoPzojRVhULVgtKFRBUkdFVERVUkFUSU9OKTogKihcXGQrKSl8KD86I0VYVC1YLShLRVkpOiguKykpfCg/OiNFWFQtWC0oU1RBUlQpOiguKykpfCg/OiNFWFQtWC0oRU5ETElTVCkpfCg/OiNFWFQtWC0oRElTQ09OVElOVUlUWS1TRVEpVUVOQ0U6KFxcZCspKXwoPzojRVhULVgtKERJUylDT05USU5VSVRZKSl8KD86I0VYVC1YLShWRVJTSU9OKTooXFxkKykpfCg/OiNFWFQtWC0oTUFQKTooLispKXwoPzooIykoW146XSopOiguKikpfCg/OigjKSguKikpKD86LiopXFxyP1xcbj8vO1xudmFyIE1QNF9SRUdFWF9TVUZGSVggPSAvXFwuKG1wNHxtNHN8bTR2fG00YSkkL2k7XG52YXIgTTNVOFBhcnNlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNM1U4UGFyc2VyKCkge1xuICAgIH1cbiAgICBNM1U4UGFyc2VyLmZpbmRHcm91cCA9IGZ1bmN0aW9uIChncm91cHMsIG1lZGlhR3JvdXBJZCkge1xuICAgICAgICBpZiAoIWdyb3Vwcykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1hdGNoaW5nR3JvdXAgPSBudWxsO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdyb3Vwcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGdyb3VwID0gZ3JvdXBzW2ldO1xuICAgICAgICAgICAgaWYgKGdyb3VwLmlkID09PSBtZWRpYUdyb3VwSWQpIHtcbiAgICAgICAgICAgICAgICBtYXRjaGluZ0dyb3VwID0gZ3JvdXA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1hdGNoaW5nR3JvdXA7XG4gICAgfTtcbiAgICBNM1U4UGFyc2VyLmNvbnZlcnRBVkMxVG9BVkNPVEkgPSBmdW5jdGlvbiAoY29kZWMpIHtcbiAgICAgICAgdmFyIHJlc3VsdCwgYXZjZGF0YSA9IGNvZGVjLnNwbGl0KCcuJyk7XG4gICAgICAgIGlmIChhdmNkYXRhLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGF2Y2RhdGEuc2hpZnQoKSArICcuJztcbiAgICAgICAgICAgIHJlc3VsdCArPSBwYXJzZUludChhdmNkYXRhLnNoaWZ0KCkpLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgICAgIHJlc3VsdCArPSAoJzAwMCcgKyBwYXJzZUludChhdmNkYXRhLnNoaWZ0KCkpLnRvU3RyaW5nKDE2KSkuc3Vic3RyKC00KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGNvZGVjO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBNM1U4UGFyc2VyLnJlc29sdmUgPSBmdW5jdGlvbiAodXJsLCBiYXNlVXJsKSB7XG4gICAgICAgIHJldHVybiBVUkxUb29sa2l0LmJ1aWxkQWJzb2x1dGVVUkwoYmFzZVVybCwgdXJsLCB7IGFsd2F5c05vcm1hbGl6ZTogdHJ1ZSB9KTtcbiAgICB9O1xuICAgIE0zVThQYXJzZXIucGFyc2VNYXN0ZXJQbGF5bGlzdCA9IGZ1bmN0aW9uIChzdHJpbmcsIGJhc2V1cmwpIHtcbiAgICAgICAgdmFyIGxldmVscyA9IFtdLCByZXN1bHQ7XG4gICAgICAgIE1BU1RFUl9QTEFZTElTVF9SRUdFWC5sYXN0SW5kZXggPSAwO1xuICAgICAgICBmdW5jdGlvbiBzZXRDb2RlY3MoY29kZWNzLCBsZXZlbCkge1xuICAgICAgICAgICAgWyd2aWRlbycsICdhdWRpbyddLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgZmlsdGVyZWQgPSBjb2RlY3MuZmlsdGVyKGZ1bmN0aW9uIChjb2RlYykgeyByZXR1cm4gY29kZWNzXzEuaXNDb2RlY1R5cGUoY29kZWMsIHR5cGUpOyB9KTtcbiAgICAgICAgICAgICAgICBpZiAoZmlsdGVyZWQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwcmVmZXJyZWQgPSBmaWx0ZXJlZC5maWx0ZXIoZnVuY3Rpb24gKGNvZGVjKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29kZWMubGFzdEluZGV4T2YoJ2F2YzEnLCAwKSA9PT0gMCB8fCBjb2RlYy5sYXN0SW5kZXhPZignbXA0YScsIDApID09PSAwO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgbGV2ZWxbdHlwZSArIFwiQ29kZWNcIl0gPSBwcmVmZXJyZWQubGVuZ3RoID4gMCA/IHByZWZlcnJlZFswXSA6IGZpbHRlcmVkWzBdO1xuICAgICAgICAgICAgICAgICAgICAvLyByZW1vdmUgZnJvbSBsaXN0XG4gICAgICAgICAgICAgICAgICAgIGNvZGVjcyA9IGNvZGVjcy5maWx0ZXIoZnVuY3Rpb24gKGNvZGVjKSB7IHJldHVybiBmaWx0ZXJlZC5pbmRleE9mKGNvZGVjKSA9PT0gLTE7IH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbGV2ZWwudW5rbm93bkNvZGVjcyA9IGNvZGVjcztcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoKHJlc3VsdCA9IE1BU1RFUl9QTEFZTElTVF9SRUdFWC5leGVjKHN0cmluZykpICE9IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBsZXZlbCA9IHt9O1xuICAgICAgICAgICAgdmFyIGF0dHJzID0gbGV2ZWwuYXR0cnMgPSBuZXcgYXR0cl9saXN0XzEuZGVmYXVsdChyZXN1bHRbMV0pO1xuICAgICAgICAgICAgbGV2ZWwudXJsID0gTTNVOFBhcnNlci5yZXNvbHZlKHJlc3VsdFsyXSwgYmFzZXVybCk7XG4gICAgICAgICAgICB2YXIgcmVzb2x1dGlvbiA9IGF0dHJzLmRlY2ltYWxSZXNvbHV0aW9uKCdSRVNPTFVUSU9OJyk7XG4gICAgICAgICAgICBpZiAocmVzb2x1dGlvbikge1xuICAgICAgICAgICAgICAgIGxldmVsLndpZHRoID0gcmVzb2x1dGlvbi53aWR0aDtcbiAgICAgICAgICAgICAgICBsZXZlbC5oZWlnaHQgPSByZXNvbHV0aW9uLmhlaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldmVsLmJpdHJhdGUgPSBhdHRycy5kZWNpbWFsSW50ZWdlcignQVZFUkFHRS1CQU5EV0lEVEgnKSB8fCBhdHRycy5kZWNpbWFsSW50ZWdlcignQkFORFdJRFRIJyk7XG4gICAgICAgICAgICBsZXZlbC5uYW1lID0gYXR0cnMuTkFNRTtcbiAgICAgICAgICAgIHNldENvZGVjcyhbXS5jb25jYXQoKGF0dHJzLkNPREVDUyB8fCAnJykuc3BsaXQoL1sgLF0rLykpLCBsZXZlbCk7XG4gICAgICAgICAgICBpZiAobGV2ZWwudmlkZW9Db2RlYyAmJiBsZXZlbC52aWRlb0NvZGVjLmluZGV4T2YoJ2F2YzEnKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBsZXZlbC52aWRlb0NvZGVjID0gTTNVOFBhcnNlci5jb252ZXJ0QVZDMVRvQVZDT1RJKGxldmVsLnZpZGVvQ29kZWMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV2ZWxzLnB1c2gobGV2ZWwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsZXZlbHM7XG4gICAgfTtcbiAgICBNM1U4UGFyc2VyLnBhcnNlTWFzdGVyUGxheWxpc3RNZWRpYSA9IGZ1bmN0aW9uIChzdHJpbmcsIGJhc2V1cmwsIHR5cGUsIGF1ZGlvR3JvdXBzKSB7XG4gICAgICAgIGlmIChhdWRpb0dyb3VwcyA9PT0gdm9pZCAwKSB7IGF1ZGlvR3JvdXBzID0gW107IH1cbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgdmFyIG1lZGlhcyA9IFtdO1xuICAgICAgICB2YXIgaWQgPSAwO1xuICAgICAgICBNQVNURVJfUExBWUxJU1RfTUVESUFfUkVHRVgubGFzdEluZGV4ID0gMDtcbiAgICAgICAgd2hpbGUgKChyZXN1bHQgPSBNQVNURVJfUExBWUxJU1RfTUVESUFfUkVHRVguZXhlYyhzdHJpbmcpKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIG1lZGlhID0ge307XG4gICAgICAgICAgICB2YXIgYXR0cnMgPSBuZXcgYXR0cl9saXN0XzEuZGVmYXVsdChyZXN1bHRbMV0pO1xuICAgICAgICAgICAgaWYgKGF0dHJzLlRZUEUgPT09IHR5cGUpIHtcbiAgICAgICAgICAgICAgICBtZWRpYS5ncm91cElkID0gYXR0cnNbJ0dST1VQLUlEJ107XG4gICAgICAgICAgICAgICAgbWVkaWEubmFtZSA9IGF0dHJzLk5BTUU7XG4gICAgICAgICAgICAgICAgbWVkaWEudHlwZSA9IHR5cGU7XG4gICAgICAgICAgICAgICAgbWVkaWEuZGVmYXVsdCA9IChhdHRycy5ERUZBVUxUID09PSAnWUVTJyk7XG4gICAgICAgICAgICAgICAgbWVkaWEuYXV0b3NlbGVjdCA9IChhdHRycy5BVVRPU0VMRUNUID09PSAnWUVTJyk7XG4gICAgICAgICAgICAgICAgbWVkaWEuZm9yY2VkID0gKGF0dHJzLkZPUkNFRCA9PT0gJ1lFUycpO1xuICAgICAgICAgICAgICAgIGlmIChhdHRycy5VUkkpIHtcbiAgICAgICAgICAgICAgICAgICAgbWVkaWEudXJsID0gTTNVOFBhcnNlci5yZXNvbHZlKGF0dHJzLlVSSSwgYmFzZXVybCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG1lZGlhLmxhbmcgPSBhdHRycy5MQU5HVUFHRTtcbiAgICAgICAgICAgICAgICBpZiAoIW1lZGlhLm5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgbWVkaWEubmFtZSA9IG1lZGlhLmxhbmc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChhdWRpb0dyb3Vwcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGdyb3VwQ29kZWMgPSBNM1U4UGFyc2VyLmZpbmRHcm91cChhdWRpb0dyb3VwcywgbWVkaWEuZ3JvdXBJZCk7XG4gICAgICAgICAgICAgICAgICAgIG1lZGlhLmF1ZGlvQ29kZWMgPSBncm91cENvZGVjID8gZ3JvdXBDb2RlYy5jb2RlYyA6IGF1ZGlvR3JvdXBzWzBdLmNvZGVjO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtZWRpYS5pZCA9IGlkKys7XG4gICAgICAgICAgICAgICAgbWVkaWFzLnB1c2gobWVkaWEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZWRpYXM7XG4gICAgfTtcbiAgICBNM1U4UGFyc2VyLnBhcnNlTGV2ZWxQbGF5bGlzdCA9IGZ1bmN0aW9uIChzdHJpbmcsIGJhc2V1cmwsIGlkLCB0eXBlLCBsZXZlbFVybElkKSB7XG4gICAgICAgIHZhciBjdXJyZW50U04gPSAwO1xuICAgICAgICB2YXIgdG90YWxkdXJhdGlvbiA9IDA7XG4gICAgICAgIHZhciBsZXZlbCA9IG5ldyBsZXZlbF8xLmRlZmF1bHQoYmFzZXVybCk7XG4gICAgICAgIHZhciBsZXZlbGtleSA9IG5ldyBsZXZlbF9rZXlfMS5kZWZhdWx0KCk7XG4gICAgICAgIHZhciBjYyA9IDA7XG4gICAgICAgIHZhciBwcmV2RnJhZyA9IG51bGw7XG4gICAgICAgIHZhciBmcmFnID0gbmV3IGZyYWdtZW50XzEuZGVmYXVsdCgpO1xuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgdmFyIGZpcnN0UGR0SW5kZXggPSBudWxsO1xuICAgICAgICBMRVZFTF9QTEFZTElTVF9SRUdFWF9GQVNULmxhc3RJbmRleCA9IDA7XG4gICAgICAgIHdoaWxlICgocmVzdWx0ID0gTEVWRUxfUExBWUxJU1RfUkVHRVhfRkFTVC5leGVjKHN0cmluZykpICE9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgZHVyYXRpb24gPSByZXN1bHRbMV07XG4gICAgICAgICAgICBpZiAoZHVyYXRpb24pIHsgLy8gSU5GXG4gICAgICAgICAgICAgICAgZnJhZy5kdXJhdGlvbiA9IHBhcnNlRmxvYXQoZHVyYXRpb24pO1xuICAgICAgICAgICAgICAgIC8vIGF2b2lkIHNsaWNlZCBzdHJpbmdzICAgIGh0dHBzOi8vZ2l0aHViLmNvbS92aWRlby1kZXYvaGxzLmpzL2lzc3Vlcy85MzlcbiAgICAgICAgICAgICAgICB2YXIgdGl0bGUgPSAoJyAnICsgcmVzdWx0WzJdKS5zbGljZSgxKTtcbiAgICAgICAgICAgICAgICBmcmFnLnRpdGxlID0gdGl0bGUgfHwgbnVsbDtcbiAgICAgICAgICAgICAgICBmcmFnLnRhZ0xpc3QucHVzaCh0aXRsZSA/IFsnSU5GJywgZHVyYXRpb24sIHRpdGxlXSA6IFsnSU5GJywgZHVyYXRpb25dKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHJlc3VsdFszXSkgeyAvLyB1cmxcbiAgICAgICAgICAgICAgICBpZiAoTnVtYmVyLmlzRmluaXRlKGZyYWcuZHVyYXRpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzbiA9IGN1cnJlbnRTTisrO1xuICAgICAgICAgICAgICAgICAgICBmcmFnLnR5cGUgPSB0eXBlO1xuICAgICAgICAgICAgICAgICAgICBmcmFnLnN0YXJ0ID0gdG90YWxkdXJhdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgZnJhZy5sZXZlbGtleSA9IGxldmVsa2V5O1xuICAgICAgICAgICAgICAgICAgICBmcmFnLnNuID0gc247XG4gICAgICAgICAgICAgICAgICAgIGZyYWcubGV2ZWwgPSBpZDtcbiAgICAgICAgICAgICAgICAgICAgZnJhZy5jYyA9IGNjO1xuICAgICAgICAgICAgICAgICAgICBmcmFnLnVybElkID0gbGV2ZWxVcmxJZDtcbiAgICAgICAgICAgICAgICAgICAgZnJhZy5iYXNldXJsID0gYmFzZXVybDtcbiAgICAgICAgICAgICAgICAgICAgLy8gYXZvaWQgc2xpY2VkIHN0cmluZ3MgICAgaHR0cHM6Ly9naXRodWIuY29tL3ZpZGVvLWRldi9obHMuanMvaXNzdWVzLzkzOVxuICAgICAgICAgICAgICAgICAgICBmcmFnLnJlbHVybCA9ICgnICcgKyByZXN1bHRbM10pLnNsaWNlKDEpO1xuICAgICAgICAgICAgICAgICAgICBhc3NpZ25Qcm9ncmFtRGF0ZVRpbWUoZnJhZywgcHJldkZyYWcpO1xuICAgICAgICAgICAgICAgICAgICBsZXZlbC5mcmFnbWVudHMucHVzaChmcmFnKTtcbiAgICAgICAgICAgICAgICAgICAgcHJldkZyYWcgPSBmcmFnO1xuICAgICAgICAgICAgICAgICAgICB0b3RhbGR1cmF0aW9uICs9IGZyYWcuZHVyYXRpb247XG4gICAgICAgICAgICAgICAgICAgIGZyYWcgPSBuZXcgZnJhZ21lbnRfMS5kZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocmVzdWx0WzRdKSB7IC8vIFgtQllURVJBTkdFXG4gICAgICAgICAgICAgICAgZnJhZy5yYXdCeXRlUmFuZ2UgPSAoJyAnICsgcmVzdWx0WzRdKS5zbGljZSgxKTtcbiAgICAgICAgICAgICAgICBpZiAocHJldkZyYWcpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxhc3RCeXRlUmFuZ2VFbmRPZmZzZXQgPSBwcmV2RnJhZy5ieXRlUmFuZ2VFbmRPZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsYXN0Qnl0ZVJhbmdlRW5kT2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmcmFnLmxhc3RCeXRlUmFuZ2VFbmRPZmZzZXQgPSBsYXN0Qnl0ZVJhbmdlRW5kT2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocmVzdWx0WzVdKSB7IC8vIFBST0dSQU0tREFURS1USU1FXG4gICAgICAgICAgICAgICAgLy8gYXZvaWQgc2xpY2VkIHN0cmluZ3MgICAgaHR0cHM6Ly9naXRodWIuY29tL3ZpZGVvLWRldi9obHMuanMvaXNzdWVzLzkzOVxuICAgICAgICAgICAgICAgIGZyYWcucmF3UHJvZ3JhbURhdGVUaW1lID0gKCcgJyArIHJlc3VsdFs1XSkuc2xpY2UoMSk7XG4gICAgICAgICAgICAgICAgZnJhZy50YWdMaXN0LnB1c2goWydQUk9HUkFNLURBVEUtVElNRScsIGZyYWcucmF3UHJvZ3JhbURhdGVUaW1lXSk7XG4gICAgICAgICAgICAgICAgaWYgKGZpcnN0UGR0SW5kZXggPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgZmlyc3RQZHRJbmRleCA9IGxldmVsLmZyYWdtZW50cy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0WzBdLm1hdGNoKExFVkVMX1BMQVlMSVNUX1JFR0VYX1NMT1cpO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDE7IGkgPCByZXN1bHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdFtpXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBhdm9pZCBzbGljZWQgc3RyaW5ncyAgICBodHRwczovL2dpdGh1Yi5jb20vdmlkZW8tZGV2L2hscy5qcy9pc3N1ZXMvOTM5XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlMSA9ICgnICcgKyByZXN1bHRbaSArIDFdKS5zbGljZSgxKTtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUyID0gKCcgJyArIHJlc3VsdFtpICsgMl0pLnNsaWNlKDEpO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAocmVzdWx0W2ldKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJyMnOlxuICAgICAgICAgICAgICAgICAgICAgICAgZnJhZy50YWdMaXN0LnB1c2godmFsdWUyID8gW3ZhbHVlMSwgdmFsdWUyXSA6IFt2YWx1ZTFdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdQTEFZTElTVC1UWVBFJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldmVsLnR5cGUgPSB2YWx1ZTEudG9VcHBlckNhc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdNRURJQS1TRVFVRU5DRSc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50U04gPSBsZXZlbC5zdGFydFNOID0gcGFyc2VJbnQodmFsdWUxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdUQVJHRVREVVJBVElPTic6XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXZlbC50YXJnZXRkdXJhdGlvbiA9IHBhcnNlRmxvYXQodmFsdWUxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdWRVJTSU9OJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldmVsLnZlcnNpb24gPSBwYXJzZUludCh2YWx1ZTEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ0VYVE0zVSc6XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnRU5ETElTVCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXZlbC5saXZlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnRElTJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNjKys7XG4gICAgICAgICAgICAgICAgICAgICAgICBmcmFnLnRhZ0xpc3QucHVzaChbJ0RJUyddKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdESVNDT05USU5VSVRZLVNFUSc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYyA9IHBhcnNlSW50KHZhbHVlMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnS0VZJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9kcmFmdC1wYW50b3MtaHR0cC1saXZlLXN0cmVhbWluZy0wOCNzZWN0aW9uLTMuNC40XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGVjcnlwdHBhcmFtcyA9IHZhbHVlMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBrZXlBdHRycyA9IG5ldyBhdHRyX2xpc3RfMS5kZWZhdWx0KGRlY3J5cHRwYXJhbXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRlY3J5cHRtZXRob2QgPSBrZXlBdHRycy5lbnVtZXJhdGVkU3RyaW5nKCdNRVRIT0QnKSwgZGVjcnlwdHVyaSA9IGtleUF0dHJzLlVSSSwgZGVjcnlwdGl2ID0ga2V5QXR0cnMuaGV4YWRlY2ltYWxJbnRlZ2VyKCdJVicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRlY3J5cHRtZXRob2QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXZlbGtleSA9IG5ldyBsZXZlbF9rZXlfMS5kZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChkZWNyeXB0dXJpKSAmJiAoWydBRVMtMTI4JywgJ1NBTVBMRS1BRVMnLCAnU0FNUExFLUFFUy1DRU5DJ10uaW5kZXhPZihkZWNyeXB0bWV0aG9kKSA+PSAwKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXZlbGtleS5tZXRob2QgPSBkZWNyeXB0bWV0aG9kO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBVUkkgdG8gZ2V0IHRoZSBrZXlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV2ZWxrZXkuYmFzZXVyaSA9IGJhc2V1cmw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldmVsa2V5LnJlbHVyaSA9IGRlY3J5cHR1cmk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldmVsa2V5LmtleSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEluaXRpYWxpemF0aW9uIFZlY3RvciAoSVYpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldmVsa2V5Lml2ID0gZGVjcnlwdGl2O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdTVEFSVCc6XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3RhcnRQYXJhbXMgPSB2YWx1ZTE7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3RhcnRBdHRycyA9IG5ldyBhdHRyX2xpc3RfMS5kZWZhdWx0KHN0YXJ0UGFyYW1zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdGFydFRpbWVPZmZzZXQgPSBzdGFydEF0dHJzLmRlY2ltYWxGbG9hdGluZ1BvaW50KCdUSU1FLU9GRlNFVCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVElNRS1PRkZTRVQgY2FuIGJlIDBcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChOdW1iZXIuaXNGaW5pdGUoc3RhcnRUaW1lT2Zmc2V0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldmVsLnN0YXJ0VGltZU9mZnNldCA9IHN0YXJ0VGltZU9mZnNldDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdNQVAnOlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1hcEF0dHJzID0gbmV3IGF0dHJfbGlzdF8xLmRlZmF1bHQodmFsdWUxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyYWcucmVsdXJsID0gbWFwQXR0cnMuVVJJO1xuICAgICAgICAgICAgICAgICAgICAgICAgZnJhZy5yYXdCeXRlUmFuZ2UgPSBtYXBBdHRycy5CWVRFUkFOR0U7XG4gICAgICAgICAgICAgICAgICAgICAgICBmcmFnLmJhc2V1cmwgPSBiYXNldXJsO1xuICAgICAgICAgICAgICAgICAgICAgICAgZnJhZy5sZXZlbCA9IGlkO1xuICAgICAgICAgICAgICAgICAgICAgICAgZnJhZy50eXBlID0gdHlwZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyYWcuc24gPSAnaW5pdFNlZ21lbnQnO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV2ZWwuaW5pdFNlZ21lbnQgPSBmcmFnO1xuICAgICAgICAgICAgICAgICAgICAgICAgZnJhZyA9IG5ldyBmcmFnbWVudF8xLmRlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyYWcucmF3UHJvZ3JhbURhdGVUaW1lID0gbGV2ZWwuaW5pdFNlZ21lbnQucmF3UHJvZ3JhbURhdGVUaW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXJfMS5sb2dnZXIud2FybihcImxpbmUgcGFyc2VkIGJ1dCBub3QgaGFuZGxlZDogXCIgKyByZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZyYWcgPSBwcmV2RnJhZztcbiAgICAgICAgLy8gbG9nZ2VyLmxvZygnZm91bmQgJyArIGxldmVsLmZyYWdtZW50cy5sZW5ndGggKyAnIGZyYWdtZW50cycpO1xuICAgICAgICBpZiAoZnJhZyAmJiAhZnJhZy5yZWx1cmwpIHtcbiAgICAgICAgICAgIGxldmVsLmZyYWdtZW50cy5wb3AoKTtcbiAgICAgICAgICAgIHRvdGFsZHVyYXRpb24gLT0gZnJhZy5kdXJhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBsZXZlbC50b3RhbGR1cmF0aW9uID0gdG90YWxkdXJhdGlvbjtcbiAgICAgICAgbGV2ZWwuYXZlcmFnZXRhcmdldGR1cmF0aW9uID0gdG90YWxkdXJhdGlvbiAvIGxldmVsLmZyYWdtZW50cy5sZW5ndGg7XG4gICAgICAgIGxldmVsLmVuZFNOID0gY3VycmVudFNOIC0gMTtcbiAgICAgICAgbGV2ZWwuc3RhcnRDQyA9IGxldmVsLmZyYWdtZW50c1swXSA/IGxldmVsLmZyYWdtZW50c1swXS5jYyA6IDA7XG4gICAgICAgIGxldmVsLmVuZENDID0gY2M7XG4gICAgICAgIGlmICghbGV2ZWwuaW5pdFNlZ21lbnQgJiYgbGV2ZWwuZnJhZ21lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgLy8gdGhpcyBpcyBhIGJpdCBsdXJreSBidXQgSExTIHJlYWxseSBoYXMgbm8gb3RoZXIgd2F5IHRvIHRlbGwgdXNcbiAgICAgICAgICAgIC8vIGlmIHRoZSBmcmFnbWVudHMgYXJlIFRTIG9yIE1QNCwgZXhjZXB0IGlmIHdlIGRvd25sb2FkIHRoZW0gOi9cbiAgICAgICAgICAgIC8vIGJ1dCB0aGlzIGlzIHRvIGJlIGFibGUgdG8gaGFuZGxlIFNJRFguXG4gICAgICAgICAgICBpZiAobGV2ZWwuZnJhZ21lbnRzLmV2ZXJ5KGZ1bmN0aW9uIChmcmFnKSB7IHJldHVybiBNUDRfUkVHRVhfU1VGRklYLnRlc3QoZnJhZy5yZWx1cmwpOyB9KSkge1xuICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmxvZ2dlci53YXJuKCdNUDQgZnJhZ21lbnRzIGZvdW5kIGJ1dCBubyBpbml0IHNlZ21lbnQgKHByb2JhYmx5IG5vIE1BUCwgaW5jb21wbGV0ZSBNM1U4KSwgdHJ5aW5nIHRvIGZldGNoIFNJRFgnKTtcbiAgICAgICAgICAgICAgICBmcmFnID0gbmV3IGZyYWdtZW50XzEuZGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIGZyYWcucmVsdXJsID0gbGV2ZWwuZnJhZ21lbnRzWzBdLnJlbHVybDtcbiAgICAgICAgICAgICAgICBmcmFnLmJhc2V1cmwgPSBiYXNldXJsO1xuICAgICAgICAgICAgICAgIGZyYWcubGV2ZWwgPSBpZDtcbiAgICAgICAgICAgICAgICBmcmFnLnR5cGUgPSB0eXBlO1xuICAgICAgICAgICAgICAgIGZyYWcuc24gPSAnaW5pdFNlZ21lbnQnO1xuICAgICAgICAgICAgICAgIGxldmVsLmluaXRTZWdtZW50ID0gZnJhZztcbiAgICAgICAgICAgICAgICBsZXZlbC5uZWVkU2lkeFJhbmdlcyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEJhY2tmaWxsIGFueSBtaXNzaW5nIFBEVCB2YWx1ZXNcbiAgICAgICAgICAgXCJJZiB0aGUgZmlyc3QgRVhULVgtUFJPR1JBTS1EQVRFLVRJTUUgdGFnIGluIGEgUGxheWxpc3QgYXBwZWFycyBhZnRlclxuICAgICAgICAgICBvbmUgb3IgbW9yZSBNZWRpYSBTZWdtZW50IFVSSXMsIHRoZSBjbGllbnQgU0hPVUxEIGV4dHJhcG9sYXRlXG4gICAgICAgICAgIGJhY2t3YXJkIGZyb20gdGhhdCB0YWcgKHVzaW5nIEVYVElORiBkdXJhdGlvbnMgYW5kL29yIG1lZGlhXG4gICAgICAgICAgIHRpbWVzdGFtcHMpIHRvIGFzc29jaWF0ZSBkYXRlcyB3aXRoIHRob3NlIHNlZ21lbnRzLlwiXG4gICAgICAgICAqIFdlIGhhdmUgYWxyZWFkeSBleHRyYXBvbGF0ZWQgZm9yd2FyZCwgYnV0IGFsbCBmcmFnbWVudHMgdXAgdG8gdGhlIGZpcnN0IGluc3RhbmNlIG9mIFBEVCBkbyBub3QgaGF2ZSB0aGVpciBQRFRzXG4gICAgICAgICAqIGNvbXB1dGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKGZpcnN0UGR0SW5kZXgpIHtcbiAgICAgICAgICAgIGJhY2tmaWxsUHJvZ3JhbURhdGVUaW1lcyhsZXZlbC5mcmFnbWVudHMsIGZpcnN0UGR0SW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsZXZlbDtcbiAgICB9O1xuICAgIHJldHVybiBNM1U4UGFyc2VyO1xufSgpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IE0zVThQYXJzZXI7XG5mdW5jdGlvbiBiYWNrZmlsbFByb2dyYW1EYXRlVGltZXMoZnJhZ21lbnRzLCBzdGFydEluZGV4KSB7XG4gICAgdmFyIGZyYWdQcmV2ID0gZnJhZ21lbnRzW3N0YXJ0SW5kZXhdO1xuICAgIGZvciAodmFyIGkgPSBzdGFydEluZGV4IC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgdmFyIGZyYWcgPSBmcmFnbWVudHNbaV07XG4gICAgICAgIGZyYWcucHJvZ3JhbURhdGVUaW1lID0gZnJhZ1ByZXYucHJvZ3JhbURhdGVUaW1lIC0gKGZyYWcuZHVyYXRpb24gKiAxMDAwKTtcbiAgICAgICAgZnJhZ1ByZXYgPSBmcmFnO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGFzc2lnblByb2dyYW1EYXRlVGltZShmcmFnLCBwcmV2RnJhZykge1xuICAgIGlmIChmcmFnLnJhd1Byb2dyYW1EYXRlVGltZSkge1xuICAgICAgICBmcmFnLnByb2dyYW1EYXRlVGltZSA9IERhdGUucGFyc2UoZnJhZy5yYXdQcm9ncmFtRGF0ZVRpbWUpO1xuICAgIH1cbiAgICBlbHNlIGlmIChwcmV2RnJhZyAmJiBwcmV2RnJhZy5wcm9ncmFtRGF0ZVRpbWUpIHtcbiAgICAgICAgZnJhZy5wcm9ncmFtRGF0ZVRpbWUgPSBwcmV2RnJhZy5lbmRQcm9ncmFtRGF0ZVRpbWU7XG4gICAgfVxuICAgIGlmICghTnVtYmVyLmlzRmluaXRlKGZyYWcucHJvZ3JhbURhdGVUaW1lKSkge1xuICAgICAgICBmcmFnLnByb2dyYW1EYXRlVGltZSA9IG51bGw7XG4gICAgICAgIGZyYWcucmF3UHJvZ3JhbURhdGVUaW1lID0gbnVsbDtcbiAgICB9XG59XG5cbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqL30uY2FsbCh0aGlzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3NyYy9wb2x5ZmlsbHMvbnVtYmVyICovIFwiLi9zcmMvcG9seWZpbGxzL251bWJlci5qc1wiKVtcIk51bWJlclwiXSkpXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2xvYWRlci9wbGF5bGlzdC1sb2FkZXIuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9sb2FkZXIvcGxheWxpc3QtbG9hZGVyLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qISBNb2R1bGVDb25jYXRlbmF0aW9uIGJhaWxvdXQ6IE1vZHVsZSBpcyBub3QgYW4gRUNNQVNjcmlwdCBtb2R1bGUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi8oZnVuY3Rpb24oTnVtYmVyKSB7XG4vKipcbiAqIFBsYXlsaXN0TG9hZGVyIC0gZGVsZWdhdGUgZm9yIG1lZGlhIG1hbmlmZXN0L3BsYXlsaXN0IGxvYWRpbmcgdGFza3MuIFRha2VzIGNhcmUgb2YgcGFyc2luZyBtZWRpYSB0byBpbnRlcm5hbCBkYXRhLW1vZGVscy5cbiAqXG4gKiBPbmNlIGxvYWRlZCwgZGlzcGF0Y2hlcyBldmVudHMgd2l0aCBwYXJzZWQgZGF0YS1tb2RlbHMgb2YgbWFuaWZlc3QvbGV2ZWxzL2F1ZGlvL3N1YnRpdGxlIHRyYWNrcy5cbiAqXG4gKiBVc2VzIGxvYWRlcihzKSBzZXQgaW4gY29uZmlnIHRvIGRvIGFjdHVhbCBpbnRlcm5hbCBsb2FkaW5nIG9mIHJlc291cmNlIHRhc2tzLlxuICpcbiAqIEBtb2R1bGVcbiAqXG4gKi9cbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGV2ZW50c18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZXZlbnRzICovIFwiLi9zcmMvZXZlbnRzLmpzXCIpO1xudmFyIGV2ZW50X2hhbmRsZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2V2ZW50LWhhbmRsZXIgKi8gXCIuL3NyYy9ldmVudC1oYW5kbGVyLmpzXCIpO1xudmFyIGVycm9yc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZXJyb3JzICovIFwiLi9zcmMvZXJyb3JzLmpzXCIpO1xudmFyIGxvZ2dlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvbG9nZ2VyICovIFwiLi9zcmMvdXRpbHMvbG9nZ2VyLmpzXCIpO1xudmFyIG1wNGRlbXV4ZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2RlbXV4L21wNGRlbXV4ZXIgKi8gXCIuL3NyYy9kZW11eC9tcDRkZW11eGVyLmpzXCIpO1xudmFyIG0zdThfcGFyc2VyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL20zdTgtcGFyc2VyICovIFwiLi9zcmMvbG9hZGVyL20zdTgtcGFyc2VyLmpzXCIpO1xudmFyIHBlcmZvcm1hbmNlID0gd2luZG93LnBlcmZvcm1hbmNlO1xuLyoqXG4gKiBgdHlwZWAgcHJvcGVydHkgdmFsdWVzIGZvciB0aGlzIGxvYWRlcnMnIGNvbnRleHQgb2JqZWN0XG4gKiBAZW51bVxuICpcbiAqL1xudmFyIENvbnRleHRUeXBlID0ge1xuICAgIE1BTklGRVNUOiAnbWFuaWZlc3QnLFxuICAgIExFVkVMOiAnbGV2ZWwnLFxuICAgIEFVRElPX1RSQUNLOiAnYXVkaW9UcmFjaycsXG4gICAgU1VCVElUTEVfVFJBQ0s6ICdzdWJ0aXRsZVRyYWNrJ1xufTtcbi8qKlxuICogQGVudW0ge3N0cmluZ31cbiAqL1xudmFyIExldmVsVHlwZSA9IHtcbiAgICBNQUlOOiAnbWFpbicsXG4gICAgQVVESU86ICdhdWRpbycsXG4gICAgU1VCVElUTEU6ICdzdWJ0aXRsZSdcbn07XG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgUGxheWxpc3RMb2FkZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFBsYXlsaXN0TG9hZGVyLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBjb25zdHJ1Y3RzXG4gICAgICogQHBhcmFtIHtIbHN9IGhsc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIFBsYXlsaXN0TG9hZGVyKGhscykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBobHMsIGV2ZW50c18xLmRlZmF1bHQuTUFOSUZFU1RfTE9BRElORywgZXZlbnRzXzEuZGVmYXVsdC5MRVZFTF9MT0FESU5HLCBldmVudHNfMS5kZWZhdWx0LkFVRElPX1RSQUNLX0xPQURJTkcsIGV2ZW50c18xLmRlZmF1bHQuU1VCVElUTEVfVFJBQ0tfTE9BRElORykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMubG9hZGVycyA9IHt9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShQbGF5bGlzdExvYWRlciwgXCJDb250ZXh0VHlwZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIENvbnRleHRUeXBlO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUGxheWxpc3RMb2FkZXIsIFwiTGV2ZWxUeXBlXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gTGV2ZWxUeXBlO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0NvbnRleHRUeXBlfSB0eXBlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgUGxheWxpc3RMb2FkZXIuY2FuSGF2ZVF1YWxpdHlMZXZlbHMgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICByZXR1cm4gKHR5cGUgIT09IENvbnRleHRUeXBlLkFVRElPX1RSQUNLICYmXG4gICAgICAgICAgICB0eXBlICE9PSBDb250ZXh0VHlwZS5TVUJUSVRMRV9UUkFDSyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBNYXAgY29udGV4dC50eXBlIHRvIExldmVsVHlwZVxuICAgICAqIEBwYXJhbSB7e3R5cGU6IENvbnRleHRUeXBlfX0gY29udGV4dFxuICAgICAqIEByZXR1cm5zIHtMZXZlbFR5cGV9XG4gICAgICovXG4gICAgUGxheWxpc3RMb2FkZXIubWFwQ29udGV4dFRvTGV2ZWxUeXBlID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgICAgdmFyIHR5cGUgPSBjb250ZXh0LnR5cGU7XG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgY2FzZSBDb250ZXh0VHlwZS5BVURJT19UUkFDSzpcbiAgICAgICAgICAgICAgICByZXR1cm4gTGV2ZWxUeXBlLkFVRElPO1xuICAgICAgICAgICAgY2FzZSBDb250ZXh0VHlwZS5TVUJUSVRMRV9UUkFDSzpcbiAgICAgICAgICAgICAgICByZXR1cm4gTGV2ZWxUeXBlLlNVQlRJVExFO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gTGV2ZWxUeXBlLk1BSU47XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFBsYXlsaXN0TG9hZGVyLmdldFJlc3BvbnNlVXJsID0gZnVuY3Rpb24gKHJlc3BvbnNlLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciB1cmwgPSByZXNwb25zZS51cmw7XG4gICAgICAgIC8vIHJlc3BvbnNlVVJMIG5vdCBzdXBwb3J0ZWQgb24gc29tZSBicm93c2VycyAoaXQgaXMgdXNlZCB0byBkZXRlY3QgVVJMIHJlZGlyZWN0aW9uKVxuICAgICAgICAvLyBkYXRhLXVyaSBtb2RlIGFsc28gbm90IHN1cHBvcnRlZCAoYnV0IG5vIG5lZWQgdG8gZGV0ZWN0IHJlZGlyZWN0aW9uKVxuICAgICAgICBpZiAodXJsID09PSB1bmRlZmluZWQgfHwgdXJsLmluZGV4T2YoJ2RhdGE6JykgPT09IDApIHtcbiAgICAgICAgICAgIC8vIGZhbGxiYWNrIHRvIGluaXRpYWwgVVJMXG4gICAgICAgICAgICB1cmwgPSBjb250ZXh0LnVybDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdXJsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBkZWZhdWx0cyBvciBjb25maWd1cmVkIGxvYWRlci10eXBlIG92ZXJsb2FkcyAocExvYWRlciBhbmQgbG9hZGVyIGNvbmZpZyBwYXJhbXMpXG4gICAgICogRGVmYXVsdCBsb2FkZXIgaXMgWEhSTG9hZGVyIChzZWUgdXRpbHMpXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGNvbnRleHRcbiAgICAgKiBAcmV0dXJucyB7WEhSTG9hZGVyfSBvciBvdGhlciBjb21wYXRpYmxlIGNvbmZpZ3VyZWQgb3ZlcmxvYWRcbiAgICAgKi9cbiAgICBQbGF5bGlzdExvYWRlci5wcm90b3R5cGUuY3JlYXRlSW50ZXJuYWxMb2FkZXIgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgICB2YXIgY29uZmlnID0gdGhpcy5obHMuY29uZmlnO1xuICAgICAgICB2YXIgUExvYWRlciA9IGNvbmZpZy5wTG9hZGVyO1xuICAgICAgICB2YXIgTG9hZGVyID0gY29uZmlnLmxvYWRlcjtcbiAgICAgICAgdmFyIEludGVybmFsTG9hZGVyID0gUExvYWRlciB8fCBMb2FkZXI7XG4gICAgICAgIHZhciBsb2FkZXIgPSBuZXcgSW50ZXJuYWxMb2FkZXIoY29uZmlnKTtcbiAgICAgICAgY29udGV4dC5sb2FkZXIgPSBsb2FkZXI7XG4gICAgICAgIHRoaXMubG9hZGVyc1tjb250ZXh0LnR5cGVdID0gbG9hZGVyO1xuICAgICAgICByZXR1cm4gbG9hZGVyO1xuICAgIH07XG4gICAgUGxheWxpc3RMb2FkZXIucHJvdG90eXBlLmdldEludGVybmFsTG9hZGVyID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9hZGVyc1tjb250ZXh0LnR5cGVdO1xuICAgIH07XG4gICAgUGxheWxpc3RMb2FkZXIucHJvdG90eXBlLnJlc2V0SW50ZXJuYWxMb2FkZXIgPSBmdW5jdGlvbiAoY29udGV4dFR5cGUpIHtcbiAgICAgICAgaWYgKHRoaXMubG9hZGVyc1tjb250ZXh0VHlwZV0pIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmxvYWRlcnNbY29udGV4dFR5cGVdO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDYWxsIGBkZXN0cm95YCBvbiBhbGwgaW50ZXJuYWwgbG9hZGVyIGluc3RhbmNlcyBtYXBwZWQgKG9uZSBwZXIgY29udGV4dCB0eXBlKVxuICAgICAqL1xuICAgIFBsYXlsaXN0TG9hZGVyLnByb3RvdHlwZS5kZXN0cm95SW50ZXJuYWxMb2FkZXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBmb3IgKHZhciBjb250ZXh0VHlwZSBpbiB0aGlzLmxvYWRlcnMpIHtcbiAgICAgICAgICAgIHZhciBsb2FkZXIgPSB0aGlzLmxvYWRlcnNbY29udGV4dFR5cGVdO1xuICAgICAgICAgICAgaWYgKGxvYWRlcikge1xuICAgICAgICAgICAgICAgIGxvYWRlci5kZXN0cm95KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnJlc2V0SW50ZXJuYWxMb2FkZXIoY29udGV4dFR5cGUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBQbGF5bGlzdExvYWRlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5kZXN0cm95SW50ZXJuYWxMb2FkZXJzKCk7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuZGVzdHJveS5jYWxsKHRoaXMpO1xuICAgIH07XG4gICAgUGxheWxpc3RMb2FkZXIucHJvdG90eXBlLm9uTWFuaWZlc3RMb2FkaW5nID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdGhpcy5sb2FkKGRhdGEudXJsLCB7IHR5cGU6IENvbnRleHRUeXBlLk1BTklGRVNULCBsZXZlbDogMCwgaWQ6IG51bGwgfSk7XG4gICAgfTtcbiAgICBQbGF5bGlzdExvYWRlci5wcm90b3R5cGUub25MZXZlbExvYWRpbmcgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB0aGlzLmxvYWQoZGF0YS51cmwsIHsgdHlwZTogQ29udGV4dFR5cGUuTEVWRUwsIGxldmVsOiBkYXRhLmxldmVsLCBpZDogZGF0YS5pZCB9KTtcbiAgICB9O1xuICAgIFBsYXlsaXN0TG9hZGVyLnByb3RvdHlwZS5vbkF1ZGlvVHJhY2tMb2FkaW5nID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdGhpcy5sb2FkKGRhdGEudXJsLCB7IHR5cGU6IENvbnRleHRUeXBlLkFVRElPX1RSQUNLLCBsZXZlbDogbnVsbCwgaWQ6IGRhdGEuaWQgfSk7XG4gICAgfTtcbiAgICBQbGF5bGlzdExvYWRlci5wcm90b3R5cGUub25TdWJ0aXRsZVRyYWNrTG9hZGluZyA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHRoaXMubG9hZChkYXRhLnVybCwgeyB0eXBlOiBDb250ZXh0VHlwZS5TVUJUSVRMRV9UUkFDSywgbGV2ZWw6IG51bGwsIGlkOiBkYXRhLmlkIH0pO1xuICAgIH07XG4gICAgUGxheWxpc3RMb2FkZXIucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbiAodXJsLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBjb25maWcgPSB0aGlzLmhscy5jb25maWc7XG4gICAgICAgIGxvZ2dlcl8xLmxvZ2dlci5kZWJ1ZyhcIkxvYWRpbmcgcGxheWxpc3Qgb2YgdHlwZSBcIiArIGNvbnRleHQudHlwZSArIFwiLCBsZXZlbDogXCIgKyBjb250ZXh0LmxldmVsICsgXCIsIGlkOiBcIiArIGNvbnRleHQuaWQpO1xuICAgICAgICAvLyBDaGVjayBpZiBhIGxvYWRlciBmb3IgdGhpcyBjb250ZXh0IGFscmVhZHkgZXhpc3RzXG4gICAgICAgIHZhciBsb2FkZXIgPSB0aGlzLmdldEludGVybmFsTG9hZGVyKGNvbnRleHQpO1xuICAgICAgICBpZiAobG9hZGVyKSB7XG4gICAgICAgICAgICB2YXIgbG9hZGVyQ29udGV4dCA9IGxvYWRlci5jb250ZXh0O1xuICAgICAgICAgICAgaWYgKGxvYWRlckNvbnRleHQgJiYgbG9hZGVyQ29udGV4dC51cmwgPT09IHVybCkgeyAvLyBzYW1lIFVSTCBjYW4ndCBvdmVybGFwXG4gICAgICAgICAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLnRyYWNlKCdwbGF5bGlzdCByZXF1ZXN0IG9uZ29pbmcnKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsb2dnZXJfMS5sb2dnZXIud2FybihcImFib3J0aW5nIHByZXZpb3VzIGxvYWRlciBmb3IgdHlwZTogXCIgKyBjb250ZXh0LnR5cGUpO1xuICAgICAgICAgICAgICAgIGxvYWRlci5hYm9ydCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBtYXhSZXRyeSwgdGltZW91dCwgcmV0cnlEZWxheSwgbWF4UmV0cnlEZWxheTtcbiAgICAgICAgLy8gYXBwbHkgZGlmZmVyZW50IGNvbmZpZ3MgZm9yIHJldHJpZXMgZGVwZW5kaW5nIG9uXG4gICAgICAgIC8vIGNvbnRleHQgKG1hbmlmZXN0LCBsZXZlbCwgYXVkaW8vc3VicyBwbGF5bGlzdClcbiAgICAgICAgc3dpdGNoIChjb250ZXh0LnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgQ29udGV4dFR5cGUuTUFOSUZFU1Q6XG4gICAgICAgICAgICAgICAgbWF4UmV0cnkgPSBjb25maWcubWFuaWZlc3RMb2FkaW5nTWF4UmV0cnk7XG4gICAgICAgICAgICAgICAgdGltZW91dCA9IGNvbmZpZy5tYW5pZmVzdExvYWRpbmdUaW1lT3V0O1xuICAgICAgICAgICAgICAgIHJldHJ5RGVsYXkgPSBjb25maWcubWFuaWZlc3RMb2FkaW5nUmV0cnlEZWxheTtcbiAgICAgICAgICAgICAgICBtYXhSZXRyeURlbGF5ID0gY29uZmlnLm1hbmlmZXN0TG9hZGluZ01heFJldHJ5VGltZW91dDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgQ29udGV4dFR5cGUuTEVWRUw6XG4gICAgICAgICAgICAgICAgLy8gRGlzYWJsZSBpbnRlcm5hbCBsb2FkZXIgcmV0cnkgbG9naWMsIHNpbmNlIHdlIGFyZSBtYW5hZ2luZyByZXRyaWVzIGluIExldmVsIENvbnRyb2xsZXJcbiAgICAgICAgICAgICAgICBtYXhSZXRyeSA9IDA7XG4gICAgICAgICAgICAgICAgdGltZW91dCA9IGNvbmZpZy5sZXZlbExvYWRpbmdUaW1lT3V0O1xuICAgICAgICAgICAgICAgIC8vIFRPRE8gSW50cm9kdWNlIHJldHJ5IHNldHRpbmdzIGZvciBhdWRpby10cmFjayBhbmQgc3VidGl0bGUtdHJhY2ssIGl0IHNob3VsZCBub3QgdXNlIGxldmVsIHJldHJ5IGNvbmZpZ1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBtYXhSZXRyeSA9IGNvbmZpZy5sZXZlbExvYWRpbmdNYXhSZXRyeTtcbiAgICAgICAgICAgICAgICB0aW1lb3V0ID0gY29uZmlnLmxldmVsTG9hZGluZ1RpbWVPdXQ7XG4gICAgICAgICAgICAgICAgcmV0cnlEZWxheSA9IGNvbmZpZy5sZXZlbExvYWRpbmdSZXRyeURlbGF5O1xuICAgICAgICAgICAgICAgIG1heFJldHJ5RGVsYXkgPSBjb25maWcubGV2ZWxMb2FkaW5nTWF4UmV0cnlUaW1lb3V0O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGxvYWRlciA9IHRoaXMuY3JlYXRlSW50ZXJuYWxMb2FkZXIoY29udGV4dCk7XG4gICAgICAgIGNvbnRleHQudXJsID0gdXJsO1xuICAgICAgICBjb250ZXh0LnJlc3BvbnNlVHlwZSA9IGNvbnRleHQucmVzcG9uc2VUeXBlIHx8ICcnOyAvLyBGSVhNRTogKHNob3VsZCBub3QgYmUgbmVjZXNzYXJ5IHRvIGRvIHRoaXMpXG4gICAgICAgIHZhciBsb2FkZXJDb25maWcgPSB7XG4gICAgICAgICAgICB0aW1lb3V0OiB0aW1lb3V0LFxuICAgICAgICAgICAgbWF4UmV0cnk6IG1heFJldHJ5LFxuICAgICAgICAgICAgcmV0cnlEZWxheTogcmV0cnlEZWxheSxcbiAgICAgICAgICAgIG1heFJldHJ5RGVsYXk6IG1heFJldHJ5RGVsYXlcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGxvYWRlckNhbGxiYWNrcyA9IHtcbiAgICAgICAgICAgIG9uU3VjY2VzczogdGhpcy5sb2Fkc3VjY2Vzcy5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgb25FcnJvcjogdGhpcy5sb2FkZXJyb3IuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIG9uVGltZW91dDogdGhpcy5sb2FkdGltZW91dC5iaW5kKHRoaXMpXG4gICAgICAgIH07XG4gICAgICAgIGxvZ2dlcl8xLmxvZ2dlci5kZWJ1ZyhcIkNhbGxpbmcgaW50ZXJuYWwgbG9hZGVyIGRlbGVnYXRlIGZvciBVUkw6IFwiICsgdXJsKTtcbiAgICAgICAgbG9hZGVyLmxvYWQoY29udGV4dCwgbG9hZGVyQ29uZmlnLCBsb2FkZXJDYWxsYmFja3MpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIFBsYXlsaXN0TG9hZGVyLnByb3RvdHlwZS5sb2Fkc3VjY2VzcyA9IGZ1bmN0aW9uIChyZXNwb25zZSwgc3RhdHMsIGNvbnRleHQsIG5ldHdvcmtEZXRhaWxzKSB7XG4gICAgICAgIGlmIChuZXR3b3JrRGV0YWlscyA9PT0gdm9pZCAwKSB7IG5ldHdvcmtEZXRhaWxzID0gbnVsbDsgfVxuICAgICAgICBpZiAoY29udGV4dC5pc1NpZHhSZXF1ZXN0KSB7XG4gICAgICAgICAgICB0aGlzLl9oYW5kbGVTaWR4UmVxdWVzdChyZXNwb25zZSwgY29udGV4dCk7XG4gICAgICAgICAgICB0aGlzLl9oYW5kbGVQbGF5bGlzdExvYWRlZChyZXNwb25zZSwgc3RhdHMsIGNvbnRleHQsIG5ldHdvcmtEZXRhaWxzKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlc2V0SW50ZXJuYWxMb2FkZXIoY29udGV4dC50eXBlKTtcbiAgICAgICAgdmFyIHN0cmluZyA9IHJlc3BvbnNlLmRhdGE7XG4gICAgICAgIHN0YXRzLnRsb2FkID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgIC8vIHN0YXRzLm10aW1lID0gbmV3IERhdGUodGFyZ2V0LmdldFJlc3BvbnNlSGVhZGVyKCdMYXN0LU1vZGlmaWVkJykpO1xuICAgICAgICAvLyBWYWxpZGF0ZSBpZiBpdCBpcyBhbiBNM1U4IGF0IGFsbFxuICAgICAgICBpZiAoc3RyaW5nLmluZGV4T2YoJyNFWFRNM1UnKSAhPT0gMCkge1xuICAgICAgICAgICAgdGhpcy5faGFuZGxlTWFuaWZlc3RQYXJzaW5nRXJyb3IocmVzcG9uc2UsIGNvbnRleHQsICdubyBFWFRNM1UgZGVsaW1pdGVyJywgbmV0d29ya0RldGFpbHMpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIENoZWNrIGlmIGNodW5rLWxpc3Qgb3IgbWFzdGVyLiBoYW5kbGUgZW1wdHkgY2h1bmsgbGlzdCBjYXNlIChmaXJzdCBFWFRJTkYgbm90IHNpZ25hbGVkLCBidXQgVEFSR0VURFVSQVRJT04gcHJlc2VudClcbiAgICAgICAgaWYgKHN0cmluZy5pbmRleE9mKCcjRVhUSU5GOicpID4gMCB8fCBzdHJpbmcuaW5kZXhPZignI0VYVC1YLVRBUkdFVERVUkFUSU9OOicpID4gMCkge1xuICAgICAgICAgICAgdGhpcy5faGFuZGxlVHJhY2tPckxldmVsUGxheWxpc3QocmVzcG9uc2UsIHN0YXRzLCBjb250ZXh0LCBuZXR3b3JrRGV0YWlscyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9oYW5kbGVNYXN0ZXJQbGF5bGlzdChyZXNwb25zZSwgc3RhdHMsIGNvbnRleHQsIG5ldHdvcmtEZXRhaWxzKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUGxheWxpc3RMb2FkZXIucHJvdG90eXBlLmxvYWRlcnJvciA9IGZ1bmN0aW9uIChyZXNwb25zZSwgY29udGV4dCwgbmV0d29ya0RldGFpbHMpIHtcbiAgICAgICAgaWYgKG5ldHdvcmtEZXRhaWxzID09PSB2b2lkIDApIHsgbmV0d29ya0RldGFpbHMgPSBudWxsOyB9XG4gICAgICAgIHRoaXMuX2hhbmRsZU5ldHdvcmtFcnJvcihjb250ZXh0LCBuZXR3b3JrRGV0YWlscywgZmFsc2UsIHJlc3BvbnNlKTtcbiAgICB9O1xuICAgIFBsYXlsaXN0TG9hZGVyLnByb3RvdHlwZS5sb2FkdGltZW91dCA9IGZ1bmN0aW9uIChzdGF0cywgY29udGV4dCwgbmV0d29ya0RldGFpbHMpIHtcbiAgICAgICAgaWYgKG5ldHdvcmtEZXRhaWxzID09PSB2b2lkIDApIHsgbmV0d29ya0RldGFpbHMgPSBudWxsOyB9XG4gICAgICAgIHRoaXMuX2hhbmRsZU5ldHdvcmtFcnJvcihjb250ZXh0LCBuZXR3b3JrRGV0YWlscywgdHJ1ZSk7XG4gICAgfTtcbiAgICBQbGF5bGlzdExvYWRlci5wcm90b3R5cGUuX2hhbmRsZU1hc3RlclBsYXlsaXN0ID0gZnVuY3Rpb24gKHJlc3BvbnNlLCBzdGF0cywgY29udGV4dCwgbmV0d29ya0RldGFpbHMpIHtcbiAgICAgICAgdmFyIGhscyA9IHRoaXMuaGxzO1xuICAgICAgICB2YXIgc3RyaW5nID0gcmVzcG9uc2UuZGF0YTtcbiAgICAgICAgdmFyIHVybCA9IFBsYXlsaXN0TG9hZGVyLmdldFJlc3BvbnNlVXJsKHJlc3BvbnNlLCBjb250ZXh0KTtcbiAgICAgICAgdmFyIGxldmVscyA9IG0zdThfcGFyc2VyXzEuZGVmYXVsdC5wYXJzZU1hc3RlclBsYXlsaXN0KHN0cmluZywgdXJsKTtcbiAgICAgICAgaWYgKCFsZXZlbHMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLl9oYW5kbGVNYW5pZmVzdFBhcnNpbmdFcnJvcihyZXNwb25zZSwgY29udGV4dCwgJ25vIGxldmVsIGZvdW5kIGluIG1hbmlmZXN0JywgbmV0d29ya0RldGFpbHMpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIG11bHRpIGxldmVsIHBsYXlsaXN0LCBwYXJzZSBsZXZlbCBpbmZvXG4gICAgICAgIHZhciBhdWRpb0dyb3VwcyA9IGxldmVscy5tYXAoZnVuY3Rpb24gKGxldmVsKSB7IHJldHVybiAoe1xuICAgICAgICAgICAgaWQ6IGxldmVsLmF0dHJzLkFVRElPLFxuICAgICAgICAgICAgY29kZWM6IGxldmVsLmF1ZGlvQ29kZWNcbiAgICAgICAgfSk7IH0pO1xuICAgICAgICB2YXIgYXVkaW9UcmFja3MgPSBtM3U4X3BhcnNlcl8xLmRlZmF1bHQucGFyc2VNYXN0ZXJQbGF5bGlzdE1lZGlhKHN0cmluZywgdXJsLCAnQVVESU8nLCBhdWRpb0dyb3Vwcyk7XG4gICAgICAgIHZhciBzdWJ0aXRsZXMgPSBtM3U4X3BhcnNlcl8xLmRlZmF1bHQucGFyc2VNYXN0ZXJQbGF5bGlzdE1lZGlhKHN0cmluZywgdXJsLCAnU1VCVElUTEVTJyk7XG4gICAgICAgIGlmIChhdWRpb1RyYWNrcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIGNoZWNrIGlmIHdlIGhhdmUgZm91bmQgYW4gYXVkaW8gdHJhY2sgZW1iZWRkZWQgaW4gbWFpbiBwbGF5bGlzdCAoYXVkaW8gdHJhY2sgd2l0aG91dCBVUkkgYXR0cmlidXRlKVxuICAgICAgICAgICAgdmFyIGVtYmVkZGVkQXVkaW9Gb3VuZF8xID0gZmFsc2U7XG4gICAgICAgICAgICBhdWRpb1RyYWNrcy5mb3JFYWNoKGZ1bmN0aW9uIChhdWRpb1RyYWNrKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFhdWRpb1RyYWNrLnVybCkge1xuICAgICAgICAgICAgICAgICAgICBlbWJlZGRlZEF1ZGlvRm91bmRfMSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBpZiBubyBlbWJlZGRlZCBhdWRpbyB0cmFjayBkZWZpbmVkLCBidXQgYXVkaW8gY29kZWMgc2lnbmFsZWQgaW4gcXVhbGl0eSBsZXZlbCxcbiAgICAgICAgICAgIC8vIHdlIG5lZWQgdG8gc2lnbmFsIHRoaXMgbWFpbiBhdWRpbyB0cmFjayB0aGlzIGNvdWxkIGhhcHBlbiB3aXRoIHBsYXlsaXN0cyB3aXRoXG4gICAgICAgICAgICAvLyBhbHQgYXVkaW8gcmVuZGl0aW9uIGluIHdoaWNoIHF1YWxpdHkgbGV2ZWxzIChtYWluKVxuICAgICAgICAgICAgLy8gY29udGFpbnMgYm90aCBhdWRpbyt2aWRlby4gYnV0IHdpdGggbWl4ZWQgYXVkaW8gdHJhY2sgbm90IHNpZ25hbGVkXG4gICAgICAgICAgICBpZiAoZW1iZWRkZWRBdWRpb0ZvdW5kXzEgPT09IGZhbHNlICYmIGxldmVsc1swXS5hdWRpb0NvZGVjICYmICFsZXZlbHNbMF0uYXR0cnMuQVVESU8pIHtcbiAgICAgICAgICAgICAgICBsb2dnZXJfMS5sb2dnZXIubG9nKCdhdWRpbyBjb2RlYyBzaWduYWxlZCBpbiBxdWFsaXR5IGxldmVsLCBidXQgbm8gZW1iZWRkZWQgYXVkaW8gdHJhY2sgc2lnbmFsZWQsIGNyZWF0ZSBvbmUnKTtcbiAgICAgICAgICAgICAgICBhdWRpb1RyYWNrcy51bnNoaWZ0KHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ21haW4nLFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnbWFpbidcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBobHMudHJpZ2dlcihldmVudHNfMS5kZWZhdWx0Lk1BTklGRVNUX0xPQURFRCwge1xuICAgICAgICAgICAgbGV2ZWxzOiBsZXZlbHMsXG4gICAgICAgICAgICBhdWRpb1RyYWNrczogYXVkaW9UcmFja3MsXG4gICAgICAgICAgICBzdWJ0aXRsZXM6IHN1YnRpdGxlcyxcbiAgICAgICAgICAgIHVybDogdXJsLFxuICAgICAgICAgICAgc3RhdHM6IHN0YXRzLFxuICAgICAgICAgICAgbmV0d29ya0RldGFpbHM6IG5ldHdvcmtEZXRhaWxzXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgUGxheWxpc3RMb2FkZXIucHJvdG90eXBlLl9oYW5kbGVUcmFja09yTGV2ZWxQbGF5bGlzdCA9IGZ1bmN0aW9uIChyZXNwb25zZSwgc3RhdHMsIGNvbnRleHQsIG5ldHdvcmtEZXRhaWxzKSB7XG4gICAgICAgIHZhciBobHMgPSB0aGlzLmhscztcbiAgICAgICAgdmFyIGlkID0gY29udGV4dC5pZCwgbGV2ZWwgPSBjb250ZXh0LmxldmVsLCB0eXBlID0gY29udGV4dC50eXBlO1xuICAgICAgICB2YXIgdXJsID0gUGxheWxpc3RMb2FkZXIuZ2V0UmVzcG9uc2VVcmwocmVzcG9uc2UsIGNvbnRleHQpO1xuICAgICAgICB2YXIgbGV2ZWxVcmxJZCA9IE51bWJlci5pc0Zpbml0ZShpZCkgPyBpZCA6IDA7XG4gICAgICAgIHZhciBsZXZlbElkID0gTnVtYmVyLmlzRmluaXRlKGxldmVsKSA/IGxldmVsIDogbGV2ZWxVcmxJZDtcbiAgICAgICAgdmFyIGxldmVsVHlwZSA9IFBsYXlsaXN0TG9hZGVyLm1hcENvbnRleHRUb0xldmVsVHlwZShjb250ZXh0KTtcbiAgICAgICAgdmFyIGxldmVsRGV0YWlscyA9IG0zdThfcGFyc2VyXzEuZGVmYXVsdC5wYXJzZUxldmVsUGxheWxpc3QocmVzcG9uc2UuZGF0YSwgdXJsLCBsZXZlbElkLCBsZXZlbFR5cGUsIGxldmVsVXJsSWQpO1xuICAgICAgICAvLyBzZXQgc3RhdHMgb24gbGV2ZWwgc3RydWN0dXJlXG4gICAgICAgIGxldmVsRGV0YWlscy50bG9hZCA9IHN0YXRzLnRsb2FkO1xuICAgICAgICAvLyBXZSBoYXZlIGRvbmUgb3VyIGZpcnN0IHJlcXVlc3QgKE1hbmlmZXN0LXR5cGUpIGFuZCByZWNlaXZlXG4gICAgICAgIC8vIG5vdCBhIG1hc3RlciBwbGF5bGlzdCBidXQgYSBjaHVuay1saXN0ICh0cmFjay9sZXZlbClcbiAgICAgICAgLy8gV2UgZmlyZSB0aGUgbWFuaWZlc3QtbG9hZGVkIGV2ZW50IGFueXdheSB3aXRoIHRoZSBwYXJzZWQgbGV2ZWwtZGV0YWlsc1xuICAgICAgICAvLyBieSBjcmVhdGluZyBhIHNpbmdsZS1sZXZlbCBzdHJ1Y3R1cmUgZm9yIGl0LlxuICAgICAgICBpZiAodHlwZSA9PT0gQ29udGV4dFR5cGUuTUFOSUZFU1QpIHtcbiAgICAgICAgICAgIHZhciBzaW5nbGVMZXZlbCA9IHtcbiAgICAgICAgICAgICAgICB1cmw6IHVybCxcbiAgICAgICAgICAgICAgICBkZXRhaWxzOiBsZXZlbERldGFpbHNcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBobHMudHJpZ2dlcihldmVudHNfMS5kZWZhdWx0Lk1BTklGRVNUX0xPQURFRCwge1xuICAgICAgICAgICAgICAgIGxldmVsczogW3NpbmdsZUxldmVsXSxcbiAgICAgICAgICAgICAgICBhdWRpb1RyYWNrczogW10sXG4gICAgICAgICAgICAgICAgdXJsOiB1cmwsXG4gICAgICAgICAgICAgICAgc3RhdHM6IHN0YXRzLFxuICAgICAgICAgICAgICAgIG5ldHdvcmtEZXRhaWxzOiBuZXR3b3JrRGV0YWlsc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2F2ZSBwYXJzaW5nIHRpbWVcbiAgICAgICAgc3RhdHMudHBhcnNlZCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICAvLyBpbiBjYXNlIHdlIG5lZWQgU0lEWCByYW5nZXNcbiAgICAgICAgLy8gcmV0dXJuIGVhcmx5IGFmdGVyIGNhbGxpbmcgbG9hZCBmb3JcbiAgICAgICAgLy8gdGhlIFNJRFggYm94LlxuICAgICAgICBpZiAobGV2ZWxEZXRhaWxzLm5lZWRTaWR4UmFuZ2VzKSB7XG4gICAgICAgICAgICB2YXIgc2lkeFVybCA9IGxldmVsRGV0YWlscy5pbml0U2VnbWVudC51cmw7XG4gICAgICAgICAgICB0aGlzLmxvYWQoc2lkeFVybCwge1xuICAgICAgICAgICAgICAgIGlzU2lkeFJlcXVlc3Q6IHRydWUsXG4gICAgICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgICAgICBsZXZlbDogbGV2ZWwsXG4gICAgICAgICAgICAgICAgbGV2ZWxEZXRhaWxzOiBsZXZlbERldGFpbHMsXG4gICAgICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgICAgIHJhbmdlU3RhcnQ6IDAsXG4gICAgICAgICAgICAgICAgcmFuZ2VFbmQ6IDIwNDgsXG4gICAgICAgICAgICAgICAgcmVzcG9uc2VUeXBlOiAnYXJyYXlidWZmZXInXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBleHRlbmQgdGhlIGNvbnRleHQgd2l0aCB0aGUgbmV3IGxldmVsRGV0YWlscyBwcm9wZXJ0eVxuICAgICAgICBjb250ZXh0LmxldmVsRGV0YWlscyA9IGxldmVsRGV0YWlscztcbiAgICAgICAgdGhpcy5faGFuZGxlUGxheWxpc3RMb2FkZWQocmVzcG9uc2UsIHN0YXRzLCBjb250ZXh0LCBuZXR3b3JrRGV0YWlscyk7XG4gICAgfTtcbiAgICBQbGF5bGlzdExvYWRlci5wcm90b3R5cGUuX2hhbmRsZVNpZHhSZXF1ZXN0ID0gZnVuY3Rpb24gKHJlc3BvbnNlLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBzaWR4SW5mbyA9IG1wNGRlbXV4ZXJfMS5kZWZhdWx0LnBhcnNlU2VnbWVudEluZGV4KG5ldyBVaW50OEFycmF5KHJlc3BvbnNlLmRhdGEpKTtcbiAgICAgICAgLy8gaWYgcHJvdmlkZWQgZnJhZ21lbnQgZG9lcyBub3QgY29udGFpbiBzaWR4LCBlYXJseSByZXR1cm5cbiAgICAgICAgaWYgKCFzaWR4SW5mbykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzaWR4UmVmZXJlbmNlcyA9IHNpZHhJbmZvLnJlZmVyZW5jZXM7XG4gICAgICAgIHZhciBsZXZlbERldGFpbHMgPSBjb250ZXh0LmxldmVsRGV0YWlscztcbiAgICAgICAgc2lkeFJlZmVyZW5jZXMuZm9yRWFjaChmdW5jdGlvbiAoc2VnbWVudFJlZiwgaW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBzZWdSZWZJbmZvID0gc2VnbWVudFJlZi5pbmZvO1xuICAgICAgICAgICAgdmFyIGZyYWcgPSBsZXZlbERldGFpbHMuZnJhZ21lbnRzW2luZGV4XTtcbiAgICAgICAgICAgIGlmIChmcmFnLmJ5dGVSYW5nZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBmcmFnLnJhd0J5dGVSYW5nZSA9IFN0cmluZygxICsgc2VnUmVmSW5mby5lbmQgLSBzZWdSZWZJbmZvLnN0YXJ0KSArICdAJyArIFN0cmluZyhzZWdSZWZJbmZvLnN0YXJ0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGxldmVsRGV0YWlscy5pbml0U2VnbWVudC5yYXdCeXRlUmFuZ2UgPSBTdHJpbmcoc2lkeEluZm8ubW9vdkVuZE9mZnNldCkgKyAnQDAnO1xuICAgIH07XG4gICAgUGxheWxpc3RMb2FkZXIucHJvdG90eXBlLl9oYW5kbGVNYW5pZmVzdFBhcnNpbmdFcnJvciA9IGZ1bmN0aW9uIChyZXNwb25zZSwgY29udGV4dCwgcmVhc29uLCBuZXR3b3JrRGV0YWlscykge1xuICAgICAgICB0aGlzLmhscy50cmlnZ2VyKGV2ZW50c18xLmRlZmF1bHQuRVJST1IsIHtcbiAgICAgICAgICAgIHR5cGU6IGVycm9yc18xLkVycm9yVHlwZXMuTkVUV09SS19FUlJPUixcbiAgICAgICAgICAgIGRldGFpbHM6IGVycm9yc18xLkVycm9yRGV0YWlscy5NQU5JRkVTVF9QQVJTSU5HX0VSUk9SLFxuICAgICAgICAgICAgZmF0YWw6IHRydWUsXG4gICAgICAgICAgICB1cmw6IHJlc3BvbnNlLnVybCxcbiAgICAgICAgICAgIHJlYXNvbjogcmVhc29uLFxuICAgICAgICAgICAgbmV0d29ya0RldGFpbHM6IG5ldHdvcmtEZXRhaWxzXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgUGxheWxpc3RMb2FkZXIucHJvdG90eXBlLl9oYW5kbGVOZXR3b3JrRXJyb3IgPSBmdW5jdGlvbiAoY29udGV4dCwgbmV0d29ya0RldGFpbHMsIHRpbWVvdXQsIHJlc3BvbnNlKSB7XG4gICAgICAgIGlmICh0aW1lb3V0ID09PSB2b2lkIDApIHsgdGltZW91dCA9IGZhbHNlOyB9XG4gICAgICAgIGlmIChyZXNwb25zZSA9PT0gdm9pZCAwKSB7IHJlc3BvbnNlID0gbnVsbDsgfVxuICAgICAgICBsb2dnZXJfMS5sb2dnZXIuaW5mbyhcIkEgbmV0d29yayBlcnJvciBvY2N1cmVkIHdoaWxlIGxvYWRpbmcgYSBcIiArIGNvbnRleHQudHlwZSArIFwiLXR5cGUgcGxheWxpc3RcIik7XG4gICAgICAgIHZhciBkZXRhaWxzO1xuICAgICAgICB2YXIgZmF0YWw7XG4gICAgICAgIHZhciBsb2FkZXIgPSB0aGlzLmdldEludGVybmFsTG9hZGVyKGNvbnRleHQpO1xuICAgICAgICBzd2l0Y2ggKGNvbnRleHQudHlwZSkge1xuICAgICAgICAgICAgY2FzZSBDb250ZXh0VHlwZS5NQU5JRkVTVDpcbiAgICAgICAgICAgICAgICBkZXRhaWxzID0gKHRpbWVvdXQgPyBlcnJvcnNfMS5FcnJvckRldGFpbHMuTUFOSUZFU1RfTE9BRF9USU1FT1VUIDogZXJyb3JzXzEuRXJyb3JEZXRhaWxzLk1BTklGRVNUX0xPQURfRVJST1IpO1xuICAgICAgICAgICAgICAgIGZhdGFsID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgQ29udGV4dFR5cGUuTEVWRUw6XG4gICAgICAgICAgICAgICAgZGV0YWlscyA9ICh0aW1lb3V0ID8gZXJyb3JzXzEuRXJyb3JEZXRhaWxzLkxFVkVMX0xPQURfVElNRU9VVCA6IGVycm9yc18xLkVycm9yRGV0YWlscy5MRVZFTF9MT0FEX0VSUk9SKTtcbiAgICAgICAgICAgICAgICBmYXRhbCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBDb250ZXh0VHlwZS5BVURJT19UUkFDSzpcbiAgICAgICAgICAgICAgICBkZXRhaWxzID0gKHRpbWVvdXQgPyBlcnJvcnNfMS5FcnJvckRldGFpbHMuQVVESU9fVFJBQ0tfTE9BRF9USU1FT1VUIDogZXJyb3JzXzEuRXJyb3JEZXRhaWxzLkFVRElPX1RSQUNLX0xPQURfRVJST1IpO1xuICAgICAgICAgICAgICAgIGZhdGFsID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIC8vIGRldGFpbHMgPSAuLi4/XG4gICAgICAgICAgICAgICAgZmF0YWwgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobG9hZGVyKSB7XG4gICAgICAgICAgICBsb2FkZXIuYWJvcnQoKTtcbiAgICAgICAgICAgIHRoaXMucmVzZXRJbnRlcm5hbExvYWRlcihjb250ZXh0LnR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlcnJvckRhdGEgPSB7XG4gICAgICAgICAgICB0eXBlOiBlcnJvcnNfMS5FcnJvclR5cGVzLk5FVFdPUktfRVJST1IsXG4gICAgICAgICAgICBkZXRhaWxzOiBkZXRhaWxzLFxuICAgICAgICAgICAgZmF0YWw6IGZhdGFsLFxuICAgICAgICAgICAgdXJsOiBsb2FkZXIudXJsLFxuICAgICAgICAgICAgbG9hZGVyOiBsb2FkZXIsXG4gICAgICAgICAgICBjb250ZXh0OiBjb250ZXh0LFxuICAgICAgICAgICAgbmV0d29ya0RldGFpbHM6IG5ldHdvcmtEZXRhaWxzXG4gICAgICAgIH07XG4gICAgICAgIGlmIChyZXNwb25zZSkge1xuICAgICAgICAgICAgZXJyb3JEYXRhLnJlc3BvbnNlID0gcmVzcG9uc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5obHMudHJpZ2dlcihldmVudHNfMS5kZWZhdWx0LkVSUk9SLCBlcnJvckRhdGEpO1xuICAgIH07XG4gICAgUGxheWxpc3RMb2FkZXIucHJvdG90eXBlLl9oYW5kbGVQbGF5bGlzdExvYWRlZCA9IGZ1bmN0aW9uIChyZXNwb25zZSwgc3RhdHMsIGNvbnRleHQsIG5ldHdvcmtEZXRhaWxzKSB7XG4gICAgICAgIHZhciB0eXBlID0gY29udGV4dC50eXBlLCBsZXZlbCA9IGNvbnRleHQubGV2ZWwsIGlkID0gY29udGV4dC5pZCwgbGV2ZWxEZXRhaWxzID0gY29udGV4dC5sZXZlbERldGFpbHM7XG4gICAgICAgIGlmICghbGV2ZWxEZXRhaWxzLnRhcmdldGR1cmF0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLl9oYW5kbGVNYW5pZmVzdFBhcnNpbmdFcnJvcihyZXNwb25zZSwgY29udGV4dCwgJ2ludmFsaWQgdGFyZ2V0IGR1cmF0aW9uJywgbmV0d29ya0RldGFpbHMpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjYW5IYXZlTGV2ZWxzID0gUGxheWxpc3RMb2FkZXIuY2FuSGF2ZVF1YWxpdHlMZXZlbHMoY29udGV4dC50eXBlKTtcbiAgICAgICAgaWYgKGNhbkhhdmVMZXZlbHMpIHtcbiAgICAgICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoZXZlbnRzXzEuZGVmYXVsdC5MRVZFTF9MT0FERUQsIHtcbiAgICAgICAgICAgICAgICBkZXRhaWxzOiBsZXZlbERldGFpbHMsXG4gICAgICAgICAgICAgICAgbGV2ZWw6IGxldmVsIHx8IDAsXG4gICAgICAgICAgICAgICAgaWQ6IGlkIHx8IDAsXG4gICAgICAgICAgICAgICAgc3RhdHM6IHN0YXRzLFxuICAgICAgICAgICAgICAgIG5ldHdvcmtEZXRhaWxzOiBuZXR3b3JrRGV0YWlsc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIENvbnRleHRUeXBlLkFVRElPX1RSQUNLOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmhscy50cmlnZ2VyKGV2ZW50c18xLmRlZmF1bHQuQVVESU9fVFJBQ0tfTE9BREVELCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZXRhaWxzOiBsZXZlbERldGFpbHMsXG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0czogc3RhdHMsXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXR3b3JrRGV0YWlsczogbmV0d29ya0RldGFpbHNcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgQ29udGV4dFR5cGUuU1VCVElUTEVfVFJBQ0s6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoZXZlbnRzXzEuZGVmYXVsdC5TVUJUSVRMRV9UUkFDS19MT0FERUQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRldGFpbHM6IGxldmVsRGV0YWlscyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRzOiBzdGF0cyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldHdvcmtEZXRhaWxzOiBuZXR3b3JrRGV0YWlsc1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBQbGF5bGlzdExvYWRlcjtcbn0oZXZlbnRfaGFuZGxlcl8xLmRlZmF1bHQpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IFBsYXlsaXN0TG9hZGVyO1xuXG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwodGhpcywgX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9zcmMvcG9seWZpbGxzL251bWJlciAqLyBcIi4vc3JjL3BvbHlmaWxscy9udW1iZXIuanNcIilbXCJOdW1iZXJcIl0pKVxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9vYnNlcnZlci5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9vYnNlcnZlci5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZXZlbnRlbWl0dGVyM18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgZXZlbnRlbWl0dGVyMyAqLyBcIi4vbm9kZV9tb2R1bGVzL2V2ZW50ZW1pdHRlcjMvaW5kZXguanNcIik7XG4vKipcbiAqIEBjbGFzc1xuICpcbiAqIFNpbXBsZSBhZGFwdGVyIHN1Yi1jbGFzcyBvZiBOb2RlanMtbGlrZSBFdmVudEVtaXR0ZXIuXG4gKlxuICogV2Ugc2ltcGx5IHdhbnQgdG8gcGFzcyBhbG9uZyB0aGUgZXZlbnQtbmFtZSBpdHNlbGZcbiAqIGluIGV2ZXJ5IGNhbGwgdG8gYSBoYW5kbGVyLCB3aGljaCBpcyB0aGUgcHVycG9zZSBvZiBvdXIgYHRyaWdnZXJgIG1ldGhvZFxuICogZXh0ZW5kaW5nIHRoZSBzdGFuZGFyZCBBUEkuXG4gKlxuICovXG52YXIgT2JzZXJ2ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE9ic2VydmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE9ic2VydmVyKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50XG4gICAgICogQHBhcmFtIHthbnl9IGRhdGFcbiAgICAgKi9cbiAgICBPYnNlcnZlci5wcm90b3R5cGUudHJpZ2dlciA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB2YXIgZGF0YSA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgZGF0YVtfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVtaXQuYXBwbHkodGhpcywgW2V2ZW50LCBldmVudF0uY29uY2F0KGRhdGEpKTtcbiAgICB9O1xuICAgIHJldHVybiBPYnNlcnZlcjtcbn0oZXZlbnRlbWl0dGVyM18xLkV2ZW50RW1pdHRlcikpO1xuZXhwb3J0cy5PYnNlcnZlciA9IE9ic2VydmVyO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3BvbHlmaWxscy9udW1iZXIuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9wb2x5ZmlsbHMvbnVtYmVyLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qISBNb2R1bGVDb25jYXRlbmF0aW9uIGJhaWxvdXQ6IE1vZHVsZSBpcyBub3QgYW4gRUNNQVNjcmlwdCBtb2R1bGUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBnZXRfc2VsZl9zY29wZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvZ2V0LXNlbGYtc2NvcGUgKi8gXCIuL3NyYy91dGlscy9nZXQtc2VsZi1zY29wZS5qc1wiKTtcbnZhciBzZWxmID0gZ2V0X3NlbGZfc2NvcGVfMS5nZXRTZWxmU2NvcGUoKTtcbnZhciBOdW1iZXIgPSBzZWxmLk51bWJlcjtcbmV4cG9ydHMuTnVtYmVyID0gTnVtYmVyO1xuLy8gVE9ETzogZ2V0IHJpZCBvZiBnbG9iYWwgcG9seWZpbGxzIGFuZCByZXBsYWNlIHRoZW0gd2l0aCB3cmFwcGVycyAoXCJwb255ZmlsbHNcIilcbk51bWJlci5pc0Zpbml0ZSA9IE51bWJlci5pc0Zpbml0ZSB8fCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiBpc0Zpbml0ZSh2YWx1ZSk7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3JlbXV4L2FhYy1oZWxwZXIuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9yZW11eC9hYWMtaGVscGVyLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qISBNb2R1bGVDb25jYXRlbmF0aW9uIGJhaWxvdXQ6IE1vZHVsZSBpcyBub3QgYW4gRUNNQVNjcmlwdCBtb2R1bGUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogIEFBQyBoZWxwZXJcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIEFBQyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBQUMoKSB7XG4gICAgfVxuICAgIEFBQy5nZXRTaWxlbnRGcmFtZSA9IGZ1bmN0aW9uIChjb2RlYywgY2hhbm5lbENvdW50KSB7XG4gICAgICAgIHN3aXRjaCAoY29kZWMpIHtcbiAgICAgICAgICAgIGNhc2UgJ21wNGEuNDAuMic6XG4gICAgICAgICAgICAgICAgaWYgKGNoYW5uZWxDb3VudCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoWzB4MDAsIDB4YzgsIDB4MDAsIDB4ODAsIDB4MjMsIDB4ODBdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY2hhbm5lbENvdW50ID09PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShbMHgyMSwgMHgwMCwgMHg0OSwgMHg5MCwgMHgwMiwgMHgxOSwgMHgwMCwgMHgyMywgMHg4MF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjaGFubmVsQ291bnQgPT09IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFsweDAwLCAweGM4LCAweDAwLCAweDgwLCAweDIwLCAweDg0LCAweDAxLCAweDI2LCAweDQwLCAweDA4LCAweDY0LCAweDAwLCAweDhlXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNoYW5uZWxDb3VudCA9PT0gNCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoWzB4MDAsIDB4YzgsIDB4MDAsIDB4ODAsIDB4MjAsIDB4ODQsIDB4MDEsIDB4MjYsIDB4NDAsIDB4MDgsIDB4NjQsIDB4MDAsIDB4ODAsIDB4MmMsIDB4ODAsIDB4MDgsIDB4MDIsIDB4MzhdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY2hhbm5lbENvdW50ID09PSA1KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShbMHgwMCwgMHhjOCwgMHgwMCwgMHg4MCwgMHgyMCwgMHg4NCwgMHgwMSwgMHgyNiwgMHg0MCwgMHgwOCwgMHg2NCwgMHgwMCwgMHg4MiwgMHgzMCwgMHgwNCwgMHg5OSwgMHgwMCwgMHgyMSwgMHg5MCwgMHgwMiwgMHgzOF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjaGFubmVsQ291bnQgPT09IDYpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFsweDAwLCAweGM4LCAweDAwLCAweDgwLCAweDIwLCAweDg0LCAweDAxLCAweDI2LCAweDQwLCAweDA4LCAweDY0LCAweDAwLCAweDgyLCAweDMwLCAweDA0LCAweDk5LCAweDAwLCAweDIxLCAweDkwLCAweDAyLCAweDAwLCAweGIyLCAweDAwLCAweDIwLCAweDA4LCAweGUwXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgLy8gaGFuZGxlIEhFLUFBQyBiZWxvdyAobXA0YS40MC41IC8gbXA0YS40MC4yOSlcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgaWYgKGNoYW5uZWxDb3VudCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBmZm1wZWcgLXkgLWYgbGF2ZmkgLWkgXCJhZXZhbHNyYz0wOmQ9MC4wNVwiIC1jOmEgbGliZmRrX2FhYyAtcHJvZmlsZTphIGFhY19oZSAtYjphIDRrIG91dHB1dC5hYWMgJiYgaGV4ZHVtcCAtdiAtZSAnMTYvMSBcIjB4JXgsXCIgXCJcXG5cIicgLXYgb3V0cHV0LmFhY1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoWzB4MSwgMHg0MCwgMHgyMiwgMHg4MCwgMHhhMywgMHg0ZSwgMHhlNiwgMHg4MCwgMHhiYSwgMHg4LCAweDAsIDB4MCwgMHgwLCAweDFjLCAweDYsIDB4ZjEsIDB4YzEsIDB4YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1ZV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjaGFubmVsQ291bnQgPT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZmZtcGVnIC15IC1mIGxhdmZpIC1pIFwiYWV2YWxzcmM9MHwwOmQ9MC4wNVwiIC1jOmEgbGliZmRrX2FhYyAtcHJvZmlsZTphIGFhY19oZV92MiAtYjphIDRrIG91dHB1dC5hYWMgJiYgaGV4ZHVtcCAtdiAtZSAnMTYvMSBcIjB4JXgsXCIgXCJcXG5cIicgLXYgb3V0cHV0LmFhY1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoWzB4MSwgMHg0MCwgMHgyMiwgMHg4MCwgMHhhMywgMHg1ZSwgMHhlNiwgMHg4MCwgMHhiYSwgMHg4LCAweDAsIDB4MCwgMHgwLCAweDAsIDB4OTUsIDB4MCwgMHg2LCAweGYxLCAweGExLCAweGEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWVdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY2hhbm5lbENvdW50ID09PSAzKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGZmbXBlZyAteSAtZiBsYXZmaSAtaSBcImFldmFsc3JjPTB8MHwwOmQ9MC4wNVwiIC1jOmEgbGliZmRrX2FhYyAtcHJvZmlsZTphIGFhY19oZV92MiAtYjphIDRrIG91dHB1dC5hYWMgJiYgaGV4ZHVtcCAtdiAtZSAnMTYvMSBcIjB4JXgsXCIgXCJcXG5cIicgLXYgb3V0cHV0LmFhY1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoWzB4MSwgMHg0MCwgMHgyMiwgMHg4MCwgMHhhMywgMHg1ZSwgMHhlNiwgMHg4MCwgMHhiYSwgMHg4LCAweDAsIDB4MCwgMHgwLCAweDAsIDB4OTUsIDB4MCwgMHg2LCAweGYxLCAweGExLCAweGEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWVdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICByZXR1cm4gQUFDO1xufSgpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IEFBQztcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9yZW11eC9tcDQtZ2VuZXJhdG9yLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvcmVtdXgvbXA0LWdlbmVyYXRvci5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKipcbiAqIEdlbmVyYXRlIE1QNCBCb3hcbiovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgVUlOVDMyX01BWCA9IE1hdGgucG93KDIsIDMyKSAtIDE7XG52YXIgTVA0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1QNCgpIHtcbiAgICB9XG4gICAgTVA0LmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIE1QNC50eXBlcyA9IHtcbiAgICAgICAgICAgIGF2YzE6IFtdLFxuICAgICAgICAgICAgYXZjQzogW10sXG4gICAgICAgICAgICBidHJ0OiBbXSxcbiAgICAgICAgICAgIGRpbmY6IFtdLFxuICAgICAgICAgICAgZHJlZjogW10sXG4gICAgICAgICAgICBlc2RzOiBbXSxcbiAgICAgICAgICAgIGZ0eXA6IFtdLFxuICAgICAgICAgICAgaGRscjogW10sXG4gICAgICAgICAgICBtZGF0OiBbXSxcbiAgICAgICAgICAgIG1kaGQ6IFtdLFxuICAgICAgICAgICAgbWRpYTogW10sXG4gICAgICAgICAgICBtZmhkOiBbXSxcbiAgICAgICAgICAgIG1pbmY6IFtdLFxuICAgICAgICAgICAgbW9vZjogW10sXG4gICAgICAgICAgICBtb292OiBbXSxcbiAgICAgICAgICAgIG1wNGE6IFtdLFxuICAgICAgICAgICAgJy5tcDMnOiBbXSxcbiAgICAgICAgICAgIG12ZXg6IFtdLFxuICAgICAgICAgICAgbXZoZDogW10sXG4gICAgICAgICAgICBwYXNwOiBbXSxcbiAgICAgICAgICAgIHNkdHA6IFtdLFxuICAgICAgICAgICAgc3RibDogW10sXG4gICAgICAgICAgICBzdGNvOiBbXSxcbiAgICAgICAgICAgIHN0c2M6IFtdLFxuICAgICAgICAgICAgc3RzZDogW10sXG4gICAgICAgICAgICBzdHN6OiBbXSxcbiAgICAgICAgICAgIHN0dHM6IFtdLFxuICAgICAgICAgICAgdGZkdDogW10sXG4gICAgICAgICAgICB0ZmhkOiBbXSxcbiAgICAgICAgICAgIHRyYWY6IFtdLFxuICAgICAgICAgICAgdHJhazogW10sXG4gICAgICAgICAgICB0cnVuOiBbXSxcbiAgICAgICAgICAgIHRyZXg6IFtdLFxuICAgICAgICAgICAgdGtoZDogW10sXG4gICAgICAgICAgICB2bWhkOiBbXSxcbiAgICAgICAgICAgIHNtaGQ6IFtdXG4gICAgICAgIH07XG4gICAgICAgIHZhciBpO1xuICAgICAgICBmb3IgKGkgaW4gTVA0LnR5cGVzKSB7XG4gICAgICAgICAgICBpZiAoTVA0LnR5cGVzLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICAgICAgICAgICAgTVA0LnR5cGVzW2ldID0gW1xuICAgICAgICAgICAgICAgICAgICBpLmNoYXJDb2RlQXQoMCksXG4gICAgICAgICAgICAgICAgICAgIGkuY2hhckNvZGVBdCgxKSxcbiAgICAgICAgICAgICAgICAgICAgaS5jaGFyQ29kZUF0KDIpLFxuICAgICAgICAgICAgICAgICAgICBpLmNoYXJDb2RlQXQoMylcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciB2aWRlb0hkbHIgPSBuZXcgVWludDhBcnJheShbXG4gICAgICAgICAgICAweDAwLFxuICAgICAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAgICAgICAweDc2LCAweDY5LCAweDY0LCAweDY1LFxuICAgICAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgICAgICAgICAgMHg1NiwgMHg2OSwgMHg2NCwgMHg2NSxcbiAgICAgICAgICAgIDB4NmYsIDB4NDgsIDB4NjEsIDB4NmUsXG4gICAgICAgICAgICAweDY0LCAweDZjLCAweDY1LCAweDcyLCAweDAwIC8vIG5hbWU6ICdWaWRlb0hhbmRsZXInXG4gICAgICAgIF0pO1xuICAgICAgICB2YXIgYXVkaW9IZGxyID0gbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgICAgICAgMHgwMCxcbiAgICAgICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgICAgICAgICAgMHg3MywgMHg2ZiwgMHg3NSwgMHg2ZSxcbiAgICAgICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgICAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgICAgICAgIDB4NTMsIDB4NmYsIDB4NzUsIDB4NmUsXG4gICAgICAgICAgICAweDY0LCAweDQ4LCAweDYxLCAweDZlLFxuICAgICAgICAgICAgMHg2NCwgMHg2YywgMHg2NSwgMHg3MiwgMHgwMCAvLyBuYW1lOiAnU291bmRIYW5kbGVyJ1xuICAgICAgICBdKTtcbiAgICAgICAgTVA0LkhETFJfVFlQRVMgPSB7XG4gICAgICAgICAgICAndmlkZW8nOiB2aWRlb0hkbHIsXG4gICAgICAgICAgICAnYXVkaW8nOiBhdWRpb0hkbHJcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGRyZWYgPSBuZXcgVWludDhBcnJheShbXG4gICAgICAgICAgICAweDAwLFxuICAgICAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDEsXG4gICAgICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDBjLFxuICAgICAgICAgICAgMHg3NSwgMHg3MiwgMHg2YywgMHgyMCxcbiAgICAgICAgICAgIDB4MDAsXG4gICAgICAgICAgICAweDAwLCAweDAwLCAweDAxIC8vIGVudHJ5X2ZsYWdzXG4gICAgICAgIF0pO1xuICAgICAgICB2YXIgc3RjbyA9IG5ldyBVaW50OEFycmF5KFtcbiAgICAgICAgICAgIDB4MDAsXG4gICAgICAgICAgICAweDAwLCAweDAwLCAweDAwLFxuICAgICAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCAvLyBlbnRyeV9jb3VudFxuICAgICAgICBdKTtcbiAgICAgICAgTVA0LlNUVFMgPSBNUDQuU1RTQyA9IE1QNC5TVENPID0gc3RjbztcbiAgICAgICAgTVA0LlNUU1ogPSBuZXcgVWludDhBcnJheShbXG4gICAgICAgICAgICAweDAwLFxuICAgICAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwIC8vIHNhbXBsZV9jb3VudFxuICAgICAgICBdKTtcbiAgICAgICAgTVA0LlZNSEQgPSBuZXcgVWludDhBcnJheShbXG4gICAgICAgICAgICAweDAwLFxuICAgICAgICAgICAgMHgwMCwgMHgwMCwgMHgwMSxcbiAgICAgICAgICAgIDB4MDAsIDB4MDAsXG4gICAgICAgICAgICAweDAwLCAweDAwLFxuICAgICAgICAgICAgMHgwMCwgMHgwMCxcbiAgICAgICAgICAgIDB4MDAsIDB4MDAgLy8gb3Bjb2xvclxuICAgICAgICBdKTtcbiAgICAgICAgTVA0LlNNSEQgPSBuZXcgVWludDhBcnJheShbXG4gICAgICAgICAgICAweDAwLFxuICAgICAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgICAgICAgIDB4MDAsIDB4MDAsXG4gICAgICAgICAgICAweDAwLCAweDAwIC8vIHJlc2VydmVkXG4gICAgICAgIF0pO1xuICAgICAgICBNUDQuU1RTRCA9IG5ldyBVaW50OEFycmF5KFtcbiAgICAgICAgICAgIDB4MDAsXG4gICAgICAgICAgICAweDAwLCAweDAwLCAweDAwLFxuICAgICAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMVxuICAgICAgICBdKTsgLy8gZW50cnlfY291bnRcbiAgICAgICAgdmFyIG1ham9yQnJhbmQgPSBuZXcgVWludDhBcnJheShbMTA1LCAxMTUsIDExMSwgMTA5XSk7IC8vIGlzb21cbiAgICAgICAgdmFyIGF2YzFCcmFuZCA9IG5ldyBVaW50OEFycmF5KFs5NywgMTE4LCA5OSwgNDldKTsgLy8gYXZjMVxuICAgICAgICB2YXIgbWlub3JWZXJzaW9uID0gbmV3IFVpbnQ4QXJyYXkoWzAsIDAsIDAsIDFdKTtcbiAgICAgICAgTVA0LkZUWVAgPSBNUDQuYm94KE1QNC50eXBlcy5mdHlwLCBtYWpvckJyYW5kLCBtaW5vclZlcnNpb24sIG1ham9yQnJhbmQsIGF2YzFCcmFuZCk7XG4gICAgICAgIE1QNC5ESU5GID0gTVA0LmJveChNUDQudHlwZXMuZGluZiwgTVA0LmJveChNUDQudHlwZXMuZHJlZiwgZHJlZikpO1xuICAgIH07XG4gICAgTVA0LmJveCA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgIHZhciBwYXlsb2FkID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSwgc2l6ZSA9IDgsIGkgPSBwYXlsb2FkLmxlbmd0aCwgbGVuID0gaSwgcmVzdWx0O1xuICAgICAgICAvLyBjYWxjdWxhdGUgdGhlIHRvdGFsIHNpemUgd2UgbmVlZCB0byBhbGxvY2F0ZVxuICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgICBzaXplICs9IHBheWxvYWRbaV0uYnl0ZUxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgPSBuZXcgVWludDhBcnJheShzaXplKTtcbiAgICAgICAgcmVzdWx0WzBdID0gKHNpemUgPj4gMjQpICYgMHhmZjtcbiAgICAgICAgcmVzdWx0WzFdID0gKHNpemUgPj4gMTYpICYgMHhmZjtcbiAgICAgICAgcmVzdWx0WzJdID0gKHNpemUgPj4gOCkgJiAweGZmO1xuICAgICAgICByZXN1bHRbM10gPSBzaXplICYgMHhmZjtcbiAgICAgICAgcmVzdWx0LnNldCh0eXBlLCA0KTtcbiAgICAgICAgLy8gY29weSB0aGUgcGF5bG9hZCBpbnRvIHRoZSByZXN1bHRcbiAgICAgICAgZm9yIChpID0gMCwgc2l6ZSA9IDg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgLy8gY29weSBwYXlsb2FkW2ldIGFycmF5IEAgb2Zmc2V0IHNpemVcbiAgICAgICAgICAgIHJlc3VsdC5zZXQocGF5bG9hZFtpXSwgc2l6ZSk7XG4gICAgICAgICAgICBzaXplICs9IHBheWxvYWRbaV0uYnl0ZUxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgTVA0LmhkbHIgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMuaGRsciwgTVA0LkhETFJfVFlQRVNbdHlwZV0pO1xuICAgIH07XG4gICAgTVA0Lm1kYXQgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMubWRhdCwgZGF0YSk7XG4gICAgfTtcbiAgICBNUDQubWRoZCA9IGZ1bmN0aW9uICh0aW1lc2NhbGUsIGR1cmF0aW9uKSB7XG4gICAgICAgIGR1cmF0aW9uICo9IHRpbWVzY2FsZTtcbiAgICAgICAgdmFyIHVwcGVyV29yZER1cmF0aW9uID0gTWF0aC5mbG9vcihkdXJhdGlvbiAvIChVSU5UMzJfTUFYICsgMSkpO1xuICAgICAgICB2YXIgbG93ZXJXb3JkRHVyYXRpb24gPSBNYXRoLmZsb29yKGR1cmF0aW9uICUgKFVJTlQzMl9NQVggKyAxKSk7XG4gICAgICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5tZGhkLCBuZXcgVWludDhBcnJheShbXG4gICAgICAgICAgICAweDAxLFxuICAgICAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDIsXG4gICAgICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAzLFxuICAgICAgICAgICAgKHRpbWVzY2FsZSA+PiAyNCkgJiAweEZGLFxuICAgICAgICAgICAgKHRpbWVzY2FsZSA+PiAxNikgJiAweEZGLFxuICAgICAgICAgICAgKHRpbWVzY2FsZSA+PiA4KSAmIDB4RkYsXG4gICAgICAgICAgICB0aW1lc2NhbGUgJiAweEZGLFxuICAgICAgICAgICAgKHVwcGVyV29yZER1cmF0aW9uID4+IDI0KSxcbiAgICAgICAgICAgICh1cHBlcldvcmREdXJhdGlvbiA+PiAxNikgJiAweEZGLFxuICAgICAgICAgICAgKHVwcGVyV29yZER1cmF0aW9uID4+IDgpICYgMHhGRixcbiAgICAgICAgICAgIHVwcGVyV29yZER1cmF0aW9uICYgMHhGRixcbiAgICAgICAgICAgIChsb3dlcldvcmREdXJhdGlvbiA+PiAyNCksXG4gICAgICAgICAgICAobG93ZXJXb3JkRHVyYXRpb24gPj4gMTYpICYgMHhGRixcbiAgICAgICAgICAgIChsb3dlcldvcmREdXJhdGlvbiA+PiA4KSAmIDB4RkYsXG4gICAgICAgICAgICBsb3dlcldvcmREdXJhdGlvbiAmIDB4RkYsXG4gICAgICAgICAgICAweDU1LCAweGM0LFxuICAgICAgICAgICAgMHgwMCwgMHgwMFxuICAgICAgICBdKSk7XG4gICAgfTtcbiAgICBNUDQubWRpYSA9IGZ1bmN0aW9uICh0cmFjaykge1xuICAgICAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMubWRpYSwgTVA0Lm1kaGQodHJhY2sudGltZXNjYWxlLCB0cmFjay5kdXJhdGlvbiksIE1QNC5oZGxyKHRyYWNrLnR5cGUpLCBNUDQubWluZih0cmFjaykpO1xuICAgIH07XG4gICAgTVA0Lm1maGQgPSBmdW5jdGlvbiAoc2VxdWVuY2VOdW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLm1maGQsIG5ldyBVaW50OEFycmF5KFtcbiAgICAgICAgICAgIDB4MDAsXG4gICAgICAgICAgICAweDAwLCAweDAwLCAweDAwLFxuICAgICAgICAgICAgKHNlcXVlbmNlTnVtYmVyID4+IDI0KSxcbiAgICAgICAgICAgIChzZXF1ZW5jZU51bWJlciA+PiAxNikgJiAweEZGLFxuICAgICAgICAgICAgKHNlcXVlbmNlTnVtYmVyID4+IDgpICYgMHhGRixcbiAgICAgICAgICAgIHNlcXVlbmNlTnVtYmVyICYgMHhGRiAvLyBzZXF1ZW5jZV9udW1iZXJcbiAgICAgICAgXSkpO1xuICAgIH07XG4gICAgTVA0Lm1pbmYgPSBmdW5jdGlvbiAodHJhY2spIHtcbiAgICAgICAgaWYgKHRyYWNrLnR5cGUgPT09ICdhdWRpbycpIHtcbiAgICAgICAgICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5taW5mLCBNUDQuYm94KE1QNC50eXBlcy5zbWhkLCBNUDQuU01IRCksIE1QNC5ESU5GLCBNUDQuc3RibCh0cmFjaykpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLm1pbmYsIE1QNC5ib3goTVA0LnR5cGVzLnZtaGQsIE1QNC5WTUhEKSwgTVA0LkRJTkYsIE1QNC5zdGJsKHRyYWNrKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1QNC5tb29mID0gZnVuY3Rpb24gKHNuLCBiYXNlTWVkaWFEZWNvZGVUaW1lLCB0cmFjaykge1xuICAgICAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMubW9vZiwgTVA0Lm1maGQoc24pLCBNUDQudHJhZih0cmFjaywgYmFzZU1lZGlhRGVjb2RlVGltZSkpO1xuICAgIH07XG4gICAgLyoqXG4gICAqIEBwYXJhbSB0cmFja3MuLi4gKG9wdGlvbmFsKSB7YXJyYXl9IHRoZSB0cmFja3MgYXNzb2NpYXRlZCB3aXRoIHRoaXMgbW92aWVcbiAgICovXG4gICAgTVA0Lm1vb3YgPSBmdW5jdGlvbiAodHJhY2tzKSB7XG4gICAgICAgIHZhciBpID0gdHJhY2tzLmxlbmd0aCwgYm94ZXMgPSBbXTtcbiAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgYm94ZXNbaV0gPSBNUDQudHJhayh0cmFja3NbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBNUDQuYm94LmFwcGx5KG51bGwsIFtNUDQudHlwZXMubW9vdiwgTVA0Lm12aGQodHJhY2tzWzBdLnRpbWVzY2FsZSwgdHJhY2tzWzBdLmR1cmF0aW9uKV0uY29uY2F0KGJveGVzKS5jb25jYXQoTVA0Lm12ZXgodHJhY2tzKSkpO1xuICAgIH07XG4gICAgTVA0Lm12ZXggPSBmdW5jdGlvbiAodHJhY2tzKSB7XG4gICAgICAgIHZhciBpID0gdHJhY2tzLmxlbmd0aCwgYm94ZXMgPSBbXTtcbiAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgYm94ZXNbaV0gPSBNUDQudHJleCh0cmFja3NbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBNUDQuYm94LmFwcGx5KG51bGwsIFtNUDQudHlwZXMubXZleF0uY29uY2F0KGJveGVzKSk7XG4gICAgfTtcbiAgICBNUDQubXZoZCA9IGZ1bmN0aW9uICh0aW1lc2NhbGUsIGR1cmF0aW9uKSB7XG4gICAgICAgIGR1cmF0aW9uICo9IHRpbWVzY2FsZTtcbiAgICAgICAgdmFyIHVwcGVyV29yZER1cmF0aW9uID0gTWF0aC5mbG9vcihkdXJhdGlvbiAvIChVSU5UMzJfTUFYICsgMSkpO1xuICAgICAgICB2YXIgbG93ZXJXb3JkRHVyYXRpb24gPSBNYXRoLmZsb29yKGR1cmF0aW9uICUgKFVJTlQzMl9NQVggKyAxKSk7XG4gICAgICAgIHZhciBieXRlcyA9IG5ldyBVaW50OEFycmF5KFtcbiAgICAgICAgICAgIDB4MDEsXG4gICAgICAgICAgICAweDAwLCAweDAwLCAweDAwLFxuICAgICAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMixcbiAgICAgICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDMsXG4gICAgICAgICAgICAodGltZXNjYWxlID4+IDI0KSAmIDB4RkYsXG4gICAgICAgICAgICAodGltZXNjYWxlID4+IDE2KSAmIDB4RkYsXG4gICAgICAgICAgICAodGltZXNjYWxlID4+IDgpICYgMHhGRixcbiAgICAgICAgICAgIHRpbWVzY2FsZSAmIDB4RkYsXG4gICAgICAgICAgICAodXBwZXJXb3JkRHVyYXRpb24gPj4gMjQpLFxuICAgICAgICAgICAgKHVwcGVyV29yZER1cmF0aW9uID4+IDE2KSAmIDB4RkYsXG4gICAgICAgICAgICAodXBwZXJXb3JkRHVyYXRpb24gPj4gOCkgJiAweEZGLFxuICAgICAgICAgICAgdXBwZXJXb3JkRHVyYXRpb24gJiAweEZGLFxuICAgICAgICAgICAgKGxvd2VyV29yZER1cmF0aW9uID4+IDI0KSxcbiAgICAgICAgICAgIChsb3dlcldvcmREdXJhdGlvbiA+PiAxNikgJiAweEZGLFxuICAgICAgICAgICAgKGxvd2VyV29yZER1cmF0aW9uID4+IDgpICYgMHhGRixcbiAgICAgICAgICAgIGxvd2VyV29yZER1cmF0aW9uICYgMHhGRixcbiAgICAgICAgICAgIDB4MDAsIDB4MDEsIDB4MDAsIDB4MDAsXG4gICAgICAgICAgICAweDAxLCAweDAwLFxuICAgICAgICAgICAgMHgwMCwgMHgwMCxcbiAgICAgICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgICAgICAgICAgMHgwMCwgMHgwMSwgMHgwMCwgMHgwMCxcbiAgICAgICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgICAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgICAgICAgIDB4MDAsIDB4MDEsIDB4MDAsIDB4MDAsXG4gICAgICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgICAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAgICAgICAweDQwLCAweDAwLCAweDAwLCAweDAwLFxuICAgICAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgICAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgICAgICAgICAgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiAvLyBuZXh0X3RyYWNrX0lEXG4gICAgICAgIF0pO1xuICAgICAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMubXZoZCwgYnl0ZXMpO1xuICAgIH07XG4gICAgTVA0LnNkdHAgPSBmdW5jdGlvbiAodHJhY2spIHtcbiAgICAgICAgdmFyIHNhbXBsZXMgPSB0cmFjay5zYW1wbGVzIHx8IFtdLCBieXRlcyA9IG5ldyBVaW50OEFycmF5KDQgKyBzYW1wbGVzLmxlbmd0aCksIGZsYWdzLCBpO1xuICAgICAgICAvLyBsZWF2ZSB0aGUgZnVsbCBib3ggaGVhZGVyICg0IGJ5dGVzKSBhbGwgemVyb1xuICAgICAgICAvLyB3cml0ZSB0aGUgc2FtcGxlIHRhYmxlXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBzYW1wbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBmbGFncyA9IHNhbXBsZXNbaV0uZmxhZ3M7XG4gICAgICAgICAgICBieXRlc1tpICsgNF0gPSAoZmxhZ3MuZGVwZW5kc09uIDw8IDQpIHxcbiAgICAgICAgICAgICAgICAoZmxhZ3MuaXNEZXBlbmRlZE9uIDw8IDIpIHxcbiAgICAgICAgICAgICAgICAoZmxhZ3MuaGFzUmVkdW5kYW5jeSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLnNkdHAsIGJ5dGVzKTtcbiAgICB9O1xuICAgIE1QNC5zdGJsID0gZnVuY3Rpb24gKHRyYWNrKSB7XG4gICAgICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5zdGJsLCBNUDQuc3RzZCh0cmFjayksIE1QNC5ib3goTVA0LnR5cGVzLnN0dHMsIE1QNC5TVFRTKSwgTVA0LmJveChNUDQudHlwZXMuc3RzYywgTVA0LlNUU0MpLCBNUDQuYm94KE1QNC50eXBlcy5zdHN6LCBNUDQuU1RTWiksIE1QNC5ib3goTVA0LnR5cGVzLnN0Y28sIE1QNC5TVENPKSk7XG4gICAgfTtcbiAgICBNUDQuYXZjMSA9IGZ1bmN0aW9uICh0cmFjaykge1xuICAgICAgICB2YXIgc3BzID0gW10sIHBwcyA9IFtdLCBpLCBkYXRhLCBsZW47XG4gICAgICAgIC8vIGFzc2VtYmxlIHRoZSBTUFNzXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0cmFjay5zcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGRhdGEgPSB0cmFjay5zcHNbaV07XG4gICAgICAgICAgICBsZW4gPSBkYXRhLmJ5dGVMZW5ndGg7XG4gICAgICAgICAgICBzcHMucHVzaCgobGVuID4+PiA4KSAmIDB4RkYpO1xuICAgICAgICAgICAgc3BzLnB1c2goKGxlbiAmIDB4RkYpKTtcbiAgICAgICAgICAgIC8vIFNQU1xuICAgICAgICAgICAgc3BzID0gc3BzLmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChkYXRhKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYXNzZW1ibGUgdGhlIFBQU3NcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHRyYWNrLnBwcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgZGF0YSA9IHRyYWNrLnBwc1tpXTtcbiAgICAgICAgICAgIGxlbiA9IGRhdGEuYnl0ZUxlbmd0aDtcbiAgICAgICAgICAgIHBwcy5wdXNoKChsZW4gPj4+IDgpICYgMHhGRik7XG4gICAgICAgICAgICBwcHMucHVzaCgobGVuICYgMHhGRikpO1xuICAgICAgICAgICAgcHBzID0gcHBzLmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChkYXRhKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGF2Y2MgPSBNUDQuYm94KE1QNC50eXBlcy5hdmNDLCBuZXcgVWludDhBcnJheShbXG4gICAgICAgICAgICAweDAxLFxuICAgICAgICAgICAgc3BzWzNdLFxuICAgICAgICAgICAgc3BzWzRdLFxuICAgICAgICAgICAgc3BzWzVdLFxuICAgICAgICAgICAgMHhmYyB8IDMsXG4gICAgICAgICAgICAweEUwIHwgdHJhY2suc3BzLmxlbmd0aCAvLyAzYml0IHJlc2VydmVkICgxMTEpICsgbnVtT2ZTZXF1ZW5jZVBhcmFtZXRlclNldHNcbiAgICAgICAgXS5jb25jYXQoc3BzKS5jb25jYXQoW1xuICAgICAgICAgICAgdHJhY2sucHBzLmxlbmd0aCAvLyBudW1PZlBpY3R1cmVQYXJhbWV0ZXJTZXRzXG4gICAgICAgIF0pLmNvbmNhdChwcHMpKSksIC8vIFwiUFBTXCJcbiAgICAgICAgd2lkdGggPSB0cmFjay53aWR0aCwgaGVpZ2h0ID0gdHJhY2suaGVpZ2h0LCBoU3BhY2luZyA9IHRyYWNrLnBpeGVsUmF0aW9bMF0sIHZTcGFjaW5nID0gdHJhY2sucGl4ZWxSYXRpb1sxXTtcbiAgICAgICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLmF2YzEsIG5ldyBVaW50OEFycmF5KFtcbiAgICAgICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAgICAgICAweDAwLCAweDAwLCAweDAwLFxuICAgICAgICAgICAgMHgwMCwgMHgwMSxcbiAgICAgICAgICAgIDB4MDAsIDB4MDAsXG4gICAgICAgICAgICAweDAwLCAweDAwLFxuICAgICAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgICAgICAgICAgKHdpZHRoID4+IDgpICYgMHhGRixcbiAgICAgICAgICAgIHdpZHRoICYgMHhmZixcbiAgICAgICAgICAgIChoZWlnaHQgPj4gOCkgJiAweEZGLFxuICAgICAgICAgICAgaGVpZ2h0ICYgMHhmZixcbiAgICAgICAgICAgIDB4MDAsIDB4NDgsIDB4MDAsIDB4MDAsXG4gICAgICAgICAgICAweDAwLCAweDQ4LCAweDAwLCAweDAwLFxuICAgICAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgICAgICAgIDB4MDAsIDB4MDEsXG4gICAgICAgICAgICAweDEyLFxuICAgICAgICAgICAgMHg2NCwgMHg2MSwgMHg2OSwgMHg2QyxcbiAgICAgICAgICAgIDB4NzksIDB4NkQsIDB4NkYsIDB4NzQsXG4gICAgICAgICAgICAweDY5LCAweDZGLCAweDZFLCAweDJGLFxuICAgICAgICAgICAgMHg2OCwgMHg2QywgMHg3MywgMHgyRSxcbiAgICAgICAgICAgIDB4NkEsIDB4NzMsIDB4MDAsIDB4MDAsXG4gICAgICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgICAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAgICAgICAweDAwLCAweDE4LFxuICAgICAgICAgICAgMHgxMSwgMHgxMVxuICAgICAgICBdKSwgLy8gcHJlX2RlZmluZWQgPSAtMVxuICAgICAgICBhdmNjLCBNUDQuYm94KE1QNC50eXBlcy5idHJ0LCBuZXcgVWludDhBcnJheShbXG4gICAgICAgICAgICAweDAwLCAweDFjLCAweDljLCAweDgwLFxuICAgICAgICAgICAgMHgwMCwgMHgyZCwgMHhjNiwgMHhjMCxcbiAgICAgICAgICAgIDB4MDAsIDB4MmQsIDB4YzYsIDB4YzBcbiAgICAgICAgXSkpLCAvLyBhdmdCaXRyYXRlXG4gICAgICAgIE1QNC5ib3goTVA0LnR5cGVzLnBhc3AsIG5ldyBVaW50OEFycmF5KFtcbiAgICAgICAgICAgIChoU3BhY2luZyA+PiAyNCksXG4gICAgICAgICAgICAoaFNwYWNpbmcgPj4gMTYpICYgMHhGRixcbiAgICAgICAgICAgIChoU3BhY2luZyA+PiA4KSAmIDB4RkYsXG4gICAgICAgICAgICBoU3BhY2luZyAmIDB4RkYsXG4gICAgICAgICAgICAodlNwYWNpbmcgPj4gMjQpLFxuICAgICAgICAgICAgKHZTcGFjaW5nID4+IDE2KSAmIDB4RkYsXG4gICAgICAgICAgICAodlNwYWNpbmcgPj4gOCkgJiAweEZGLFxuICAgICAgICAgICAgdlNwYWNpbmcgJiAweEZGXG4gICAgICAgIF0pKSk7XG4gICAgfTtcbiAgICBNUDQuZXNkcyA9IGZ1bmN0aW9uICh0cmFjaykge1xuICAgICAgICB2YXIgY29uZmlnbGVuID0gdHJhY2suY29uZmlnLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFtcbiAgICAgICAgICAgIDB4MDAsXG4gICAgICAgICAgICAweDAwLCAweDAwLCAweDAwLFxuICAgICAgICAgICAgMHgwMyxcbiAgICAgICAgICAgIDB4MTcgKyBjb25maWdsZW4sXG4gICAgICAgICAgICAweDAwLCAweDAxLFxuICAgICAgICAgICAgMHgwMCxcbiAgICAgICAgICAgIDB4MDQsXG4gICAgICAgICAgICAweDBmICsgY29uZmlnbGVuLFxuICAgICAgICAgICAgMHg0MCxcbiAgICAgICAgICAgIDB4MTUsXG4gICAgICAgICAgICAweDAwLCAweDAwLCAweDAwLFxuICAgICAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAgICAgICAweDA1IC8vIGRlc2NyaXB0b3JfdHlwZVxuICAgICAgICBdLmNvbmNhdChbY29uZmlnbGVuXSkuY29uY2F0KHRyYWNrLmNvbmZpZykuY29uY2F0KFsweDA2LCAweDAxLCAweDAyXSkpOyAvLyBHQVNwZWNpZmljQ29uZmlnKSk7IC8vIGxlbmd0aCArIGF1ZGlvIGNvbmZpZyBkZXNjcmlwdG9yXG4gICAgfTtcbiAgICBNUDQubXA0YSA9IGZ1bmN0aW9uICh0cmFjaykge1xuICAgICAgICB2YXIgc2FtcGxlcmF0ZSA9IHRyYWNrLnNhbXBsZXJhdGU7XG4gICAgICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5tcDRhLCBuZXcgVWludDhBcnJheShbXG4gICAgICAgICAgICAweDAwLCAweDAwLCAweDAwLFxuICAgICAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgICAgICAgIDB4MDAsIDB4MDEsXG4gICAgICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgICAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgICAgICAgIDB4MDAsIHRyYWNrLmNoYW5uZWxDb3VudCxcbiAgICAgICAgICAgIDB4MDAsIDB4MTAsXG4gICAgICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgICAgICAgICAgKHNhbXBsZXJhdGUgPj4gOCkgJiAweEZGLFxuICAgICAgICAgICAgc2FtcGxlcmF0ZSAmIDB4ZmYsXG4gICAgICAgICAgICAweDAwLCAweDAwXG4gICAgICAgIF0pLCBNUDQuYm94KE1QNC50eXBlcy5lc2RzLCBNUDQuZXNkcyh0cmFjaykpKTtcbiAgICB9O1xuICAgIE1QNC5tcDMgPSBmdW5jdGlvbiAodHJhY2spIHtcbiAgICAgICAgdmFyIHNhbXBsZXJhdGUgPSB0cmFjay5zYW1wbGVyYXRlO1xuICAgICAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXNbJy5tcDMnXSwgbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAgICAgICAweDAwLCAweDAxLFxuICAgICAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAgICAgICAweDAwLCB0cmFjay5jaGFubmVsQ291bnQsXG4gICAgICAgICAgICAweDAwLCAweDEwLFxuICAgICAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgICAgICAgIChzYW1wbGVyYXRlID4+IDgpICYgMHhGRixcbiAgICAgICAgICAgIHNhbXBsZXJhdGUgJiAweGZmLFxuICAgICAgICAgICAgMHgwMCwgMHgwMFxuICAgICAgICBdKSk7XG4gICAgfTtcbiAgICBNUDQuc3RzZCA9IGZ1bmN0aW9uICh0cmFjaykge1xuICAgICAgICBpZiAodHJhY2sudHlwZSA9PT0gJ2F1ZGlvJykge1xuICAgICAgICAgICAgaWYgKCF0cmFjay5pc0FBQyAmJiB0cmFjay5jb2RlYyA9PT0gJ21wMycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMuc3RzZCwgTVA0LlNUU0QsIE1QNC5tcDModHJhY2spKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5zdHNkLCBNUDQuU1RTRCwgTVA0Lm1wNGEodHJhY2spKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5zdHNkLCBNUDQuU1RTRCwgTVA0LmF2YzEodHJhY2spKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTVA0LnRraGQgPSBmdW5jdGlvbiAodHJhY2spIHtcbiAgICAgICAgdmFyIGlkID0gdHJhY2suaWQsIGR1cmF0aW9uID0gdHJhY2suZHVyYXRpb24gKiB0cmFjay50aW1lc2NhbGUsIHdpZHRoID0gdHJhY2sud2lkdGgsIGhlaWdodCA9IHRyYWNrLmhlaWdodCwgdXBwZXJXb3JkRHVyYXRpb24gPSBNYXRoLmZsb29yKGR1cmF0aW9uIC8gKFVJTlQzMl9NQVggKyAxKSksIGxvd2VyV29yZER1cmF0aW9uID0gTWF0aC5mbG9vcihkdXJhdGlvbiAlIChVSU5UMzJfTUFYICsgMSkpO1xuICAgICAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMudGtoZCwgbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgICAgICAgMHgwMSxcbiAgICAgICAgICAgIDB4MDAsIDB4MDAsIDB4MDcsXG4gICAgICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAyLFxuICAgICAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMyxcbiAgICAgICAgICAgIChpZCA+PiAyNCkgJiAweEZGLFxuICAgICAgICAgICAgKGlkID4+IDE2KSAmIDB4RkYsXG4gICAgICAgICAgICAoaWQgPj4gOCkgJiAweEZGLFxuICAgICAgICAgICAgaWQgJiAweEZGLFxuICAgICAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgICAgICAgICh1cHBlcldvcmREdXJhdGlvbiA+PiAyNCksXG4gICAgICAgICAgICAodXBwZXJXb3JkRHVyYXRpb24gPj4gMTYpICYgMHhGRixcbiAgICAgICAgICAgICh1cHBlcldvcmREdXJhdGlvbiA+PiA4KSAmIDB4RkYsXG4gICAgICAgICAgICB1cHBlcldvcmREdXJhdGlvbiAmIDB4RkYsXG4gICAgICAgICAgICAobG93ZXJXb3JkRHVyYXRpb24gPj4gMjQpLFxuICAgICAgICAgICAgKGxvd2VyV29yZER1cmF0aW9uID4+IDE2KSAmIDB4RkYsXG4gICAgICAgICAgICAobG93ZXJXb3JkRHVyYXRpb24gPj4gOCkgJiAweEZGLFxuICAgICAgICAgICAgbG93ZXJXb3JkRHVyYXRpb24gJiAweEZGLFxuICAgICAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAgICAgICAweDAwLCAweDAwLFxuICAgICAgICAgICAgMHgwMCwgMHgwMCxcbiAgICAgICAgICAgIDB4MDAsIDB4MDAsXG4gICAgICAgICAgICAweDAwLCAweDAwLFxuICAgICAgICAgICAgMHgwMCwgMHgwMSwgMHgwMCwgMHgwMCxcbiAgICAgICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgICAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgICAgICAgIDB4MDAsIDB4MDEsIDB4MDAsIDB4MDAsXG4gICAgICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgICAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAgICAgICAweDQwLCAweDAwLCAweDAwLCAweDAwLFxuICAgICAgICAgICAgKHdpZHRoID4+IDgpICYgMHhGRixcbiAgICAgICAgICAgIHdpZHRoICYgMHhGRixcbiAgICAgICAgICAgIDB4MDAsIDB4MDAsXG4gICAgICAgICAgICAoaGVpZ2h0ID4+IDgpICYgMHhGRixcbiAgICAgICAgICAgIGhlaWdodCAmIDB4RkYsXG4gICAgICAgICAgICAweDAwLCAweDAwIC8vIGhlaWdodFxuICAgICAgICBdKSk7XG4gICAgfTtcbiAgICBNUDQudHJhZiA9IGZ1bmN0aW9uICh0cmFjaywgYmFzZU1lZGlhRGVjb2RlVGltZSkge1xuICAgICAgICB2YXIgc2FtcGxlRGVwZW5kZW5jeVRhYmxlID0gTVA0LnNkdHAodHJhY2spLCBpZCA9IHRyYWNrLmlkLCB1cHBlcldvcmRCYXNlTWVkaWFEZWNvZGVUaW1lID0gTWF0aC5mbG9vcihiYXNlTWVkaWFEZWNvZGVUaW1lIC8gKFVJTlQzMl9NQVggKyAxKSksIGxvd2VyV29yZEJhc2VNZWRpYURlY29kZVRpbWUgPSBNYXRoLmZsb29yKGJhc2VNZWRpYURlY29kZVRpbWUgJSAoVUlOVDMyX01BWCArIDEpKTtcbiAgICAgICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLnRyYWYsIE1QNC5ib3goTVA0LnR5cGVzLnRmaGQsIG5ldyBVaW50OEFycmF5KFtcbiAgICAgICAgICAgIDB4MDAsXG4gICAgICAgICAgICAweDAwLCAweDAwLCAweDAwLFxuICAgICAgICAgICAgKGlkID4+IDI0KSxcbiAgICAgICAgICAgIChpZCA+PiAxNikgJiAwWEZGLFxuICAgICAgICAgICAgKGlkID4+IDgpICYgMFhGRixcbiAgICAgICAgICAgIChpZCAmIDB4RkYpIC8vIHRyYWNrX0lEXG4gICAgICAgIF0pKSwgTVA0LmJveChNUDQudHlwZXMudGZkdCwgbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgICAgICAgMHgwMSxcbiAgICAgICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAgICAgICAodXBwZXJXb3JkQmFzZU1lZGlhRGVjb2RlVGltZSA+PiAyNCksXG4gICAgICAgICAgICAodXBwZXJXb3JkQmFzZU1lZGlhRGVjb2RlVGltZSA+PiAxNikgJiAwWEZGLFxuICAgICAgICAgICAgKHVwcGVyV29yZEJhc2VNZWRpYURlY29kZVRpbWUgPj4gOCkgJiAwWEZGLFxuICAgICAgICAgICAgKHVwcGVyV29yZEJhc2VNZWRpYURlY29kZVRpbWUgJiAweEZGKSxcbiAgICAgICAgICAgIChsb3dlcldvcmRCYXNlTWVkaWFEZWNvZGVUaW1lID4+IDI0KSxcbiAgICAgICAgICAgIChsb3dlcldvcmRCYXNlTWVkaWFEZWNvZGVUaW1lID4+IDE2KSAmIDBYRkYsXG4gICAgICAgICAgICAobG93ZXJXb3JkQmFzZU1lZGlhRGVjb2RlVGltZSA+PiA4KSAmIDBYRkYsXG4gICAgICAgICAgICAobG93ZXJXb3JkQmFzZU1lZGlhRGVjb2RlVGltZSAmIDB4RkYpXG4gICAgICAgIF0pKSwgTVA0LnRydW4odHJhY2ssIHNhbXBsZURlcGVuZGVuY3lUYWJsZS5sZW5ndGggK1xuICAgICAgICAgICAgMTYgKyAvLyB0ZmhkXG4gICAgICAgICAgICAyMCArIC8vIHRmZHRcbiAgICAgICAgICAgIDggKyAvLyB0cmFmIGhlYWRlclxuICAgICAgICAgICAgMTYgKyAvLyBtZmhkXG4gICAgICAgICAgICA4ICsgLy8gbW9vZiBoZWFkZXJcbiAgICAgICAgICAgIDgpLCAvLyBtZGF0IGhlYWRlclxuICAgICAgICBzYW1wbGVEZXBlbmRlbmN5VGFibGUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGUgYSB0cmFjayBib3guXG4gICAgICogQHBhcmFtIHRyYWNrIHtvYmplY3R9IGEgdHJhY2sgZGVmaW5pdGlvblxuICAgICAqIEByZXR1cm4ge1VpbnQ4QXJyYXl9IHRoZSB0cmFjayBib3hcbiAgICAgKi9cbiAgICBNUDQudHJhayA9IGZ1bmN0aW9uICh0cmFjaykge1xuICAgICAgICB0cmFjay5kdXJhdGlvbiA9IHRyYWNrLmR1cmF0aW9uIHx8IDB4ZmZmZmZmZmY7XG4gICAgICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy50cmFrLCBNUDQudGtoZCh0cmFjayksIE1QNC5tZGlhKHRyYWNrKSk7XG4gICAgfTtcbiAgICBNUDQudHJleCA9IGZ1bmN0aW9uICh0cmFjaykge1xuICAgICAgICB2YXIgaWQgPSB0cmFjay5pZDtcbiAgICAgICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLnRyZXgsIG5ldyBVaW50OEFycmF5KFtcbiAgICAgICAgICAgIDB4MDAsXG4gICAgICAgICAgICAweDAwLCAweDAwLCAweDAwLFxuICAgICAgICAgICAgKGlkID4+IDI0KSxcbiAgICAgICAgICAgIChpZCA+PiAxNikgJiAwWEZGLFxuICAgICAgICAgICAgKGlkID4+IDgpICYgMFhGRixcbiAgICAgICAgICAgIChpZCAmIDB4RkYpLFxuICAgICAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMSxcbiAgICAgICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgICAgICAgICAgMHgwMCwgMHgwMSwgMHgwMCwgMHgwMSAvLyBkZWZhdWx0X3NhbXBsZV9mbGFnc1xuICAgICAgICBdKSk7XG4gICAgfTtcbiAgICBNUDQudHJ1biA9IGZ1bmN0aW9uICh0cmFjaywgb2Zmc2V0KSB7XG4gICAgICAgIHZhciBzYW1wbGVzID0gdHJhY2suc2FtcGxlcyB8fCBbXSwgbGVuID0gc2FtcGxlcy5sZW5ndGgsIGFycmF5bGVuID0gMTIgKyAoMTYgKiBsZW4pLCBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5bGVuKSwgaSwgc2FtcGxlLCBkdXJhdGlvbiwgc2l6ZSwgZmxhZ3MsIGN0cztcbiAgICAgICAgb2Zmc2V0ICs9IDggKyBhcnJheWxlbjtcbiAgICAgICAgYXJyYXkuc2V0KFtcbiAgICAgICAgICAgIDB4MDAsXG4gICAgICAgICAgICAweDAwLCAweDBmLCAweDAxLFxuICAgICAgICAgICAgKGxlbiA+Pj4gMjQpICYgMHhGRixcbiAgICAgICAgICAgIChsZW4gPj4+IDE2KSAmIDB4RkYsXG4gICAgICAgICAgICAobGVuID4+PiA4KSAmIDB4RkYsXG4gICAgICAgICAgICBsZW4gJiAweEZGLFxuICAgICAgICAgICAgKG9mZnNldCA+Pj4gMjQpICYgMHhGRixcbiAgICAgICAgICAgIChvZmZzZXQgPj4+IDE2KSAmIDB4RkYsXG4gICAgICAgICAgICAob2Zmc2V0ID4+PiA4KSAmIDB4RkYsXG4gICAgICAgICAgICBvZmZzZXQgJiAweEZGIC8vIGRhdGFfb2Zmc2V0XG4gICAgICAgIF0sIDApO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHNhbXBsZSA9IHNhbXBsZXNbaV07XG4gICAgICAgICAgICBkdXJhdGlvbiA9IHNhbXBsZS5kdXJhdGlvbjtcbiAgICAgICAgICAgIHNpemUgPSBzYW1wbGUuc2l6ZTtcbiAgICAgICAgICAgIGZsYWdzID0gc2FtcGxlLmZsYWdzO1xuICAgICAgICAgICAgY3RzID0gc2FtcGxlLmN0cztcbiAgICAgICAgICAgIGFycmF5LnNldChbXG4gICAgICAgICAgICAgICAgKGR1cmF0aW9uID4+PiAyNCkgJiAweEZGLFxuICAgICAgICAgICAgICAgIChkdXJhdGlvbiA+Pj4gMTYpICYgMHhGRixcbiAgICAgICAgICAgICAgICAoZHVyYXRpb24gPj4+IDgpICYgMHhGRixcbiAgICAgICAgICAgICAgICBkdXJhdGlvbiAmIDB4RkYsXG4gICAgICAgICAgICAgICAgKHNpemUgPj4+IDI0KSAmIDB4RkYsXG4gICAgICAgICAgICAgICAgKHNpemUgPj4+IDE2KSAmIDB4RkYsXG4gICAgICAgICAgICAgICAgKHNpemUgPj4+IDgpICYgMHhGRixcbiAgICAgICAgICAgICAgICBzaXplICYgMHhGRixcbiAgICAgICAgICAgICAgICAoZmxhZ3MuaXNMZWFkaW5nIDw8IDIpIHwgZmxhZ3MuZGVwZW5kc09uLFxuICAgICAgICAgICAgICAgIChmbGFncy5pc0RlcGVuZGVkT24gPDwgNikgfFxuICAgICAgICAgICAgICAgICAgICAoZmxhZ3MuaGFzUmVkdW5kYW5jeSA8PCA0KSB8XG4gICAgICAgICAgICAgICAgICAgIChmbGFncy5wYWRkaW5nVmFsdWUgPDwgMSkgfFxuICAgICAgICAgICAgICAgICAgICBmbGFncy5pc05vblN5bmMsXG4gICAgICAgICAgICAgICAgZmxhZ3MuZGVncmFkUHJpbyAmIDB4RjAgPDwgOCxcbiAgICAgICAgICAgICAgICBmbGFncy5kZWdyYWRQcmlvICYgMHgwRixcbiAgICAgICAgICAgICAgICAoY3RzID4+PiAyNCkgJiAweEZGLFxuICAgICAgICAgICAgICAgIChjdHMgPj4+IDE2KSAmIDB4RkYsXG4gICAgICAgICAgICAgICAgKGN0cyA+Pj4gOCkgJiAweEZGLFxuICAgICAgICAgICAgICAgIGN0cyAmIDB4RkYgLy8gc2FtcGxlX2NvbXBvc2l0aW9uX3RpbWVfb2Zmc2V0XG4gICAgICAgICAgICBdLCAxMiArIDE2ICogaSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLnRydW4sIGFycmF5KTtcbiAgICB9O1xuICAgIE1QNC5pbml0U2VnbWVudCA9IGZ1bmN0aW9uICh0cmFja3MpIHtcbiAgICAgICAgaWYgKCFNUDQudHlwZXMpIHtcbiAgICAgICAgICAgIE1QNC5pbml0KCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1vdmllID0gTVA0Lm1vb3YodHJhY2tzKSwgcmVzdWx0O1xuICAgICAgICByZXN1bHQgPSBuZXcgVWludDhBcnJheShNUDQuRlRZUC5ieXRlTGVuZ3RoICsgbW92aWUuYnl0ZUxlbmd0aCk7XG4gICAgICAgIHJlc3VsdC5zZXQoTVA0LkZUWVApO1xuICAgICAgICByZXN1bHQuc2V0KG1vdmllLCBNUDQuRlRZUC5ieXRlTGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIHJldHVybiBNUDQ7XG59KCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gTVA0O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3JlbXV4L21wNC1yZW11eGVyLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3JlbXV4L21wNC1yZW11eGVyLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKipcbiAqIGZNUDQgcmVtdXhlclxuKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBhYWNfaGVscGVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2FhYy1oZWxwZXIgKi8gXCIuL3NyYy9yZW11eC9hYWMtaGVscGVyLmpzXCIpO1xudmFyIG1wNF9nZW5lcmF0b3JfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vbXA0LWdlbmVyYXRvciAqLyBcIi4vc3JjL3JlbXV4L21wNC1nZW5lcmF0b3IuanNcIik7XG52YXIgZXZlbnRzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9ldmVudHMgKi8gXCIuL3NyYy9ldmVudHMuanNcIik7XG52YXIgZXJyb3JzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9lcnJvcnMgKi8gXCIuL3NyYy9lcnJvcnMuanNcIik7XG52YXIgbG9nZ2VyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy9sb2dnZXIgKi8gXCIuL3NyYy91dGlscy9sb2dnZXIuanNcIik7XG4vLyAxMCBzZWNvbmRzXG52YXIgTUFYX1NJTEVOVF9GUkFNRV9EVVJBVElPTiA9IDEwICogMTAwMDtcbnZhciBNUDRSZW11eGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1QNFJlbXV4ZXIob2JzZXJ2ZXIsIGNvbmZpZywgdHlwZVN1cHBvcnRlZCwgdmVuZG9yKSB7XG4gICAgICAgIHRoaXMub2JzZXJ2ZXIgPSBvYnNlcnZlcjtcbiAgICAgICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgICAgIHRoaXMudHlwZVN1cHBvcnRlZCA9IHR5cGVTdXBwb3J0ZWQ7XG4gICAgICAgIHZhciB1c2VyQWdlbnQgPSBuYXZpZ2F0b3IudXNlckFnZW50O1xuICAgICAgICB0aGlzLmlzU2FmYXJpID0gdmVuZG9yICYmIHZlbmRvci5pbmRleE9mKCdBcHBsZScpID4gLTEgJiYgdXNlckFnZW50ICYmICF1c2VyQWdlbnQubWF0Y2goJ0NyaU9TJyk7XG4gICAgICAgIHRoaXMuSVNHZW5lcmF0ZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgTVA0UmVtdXhlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICB9O1xuICAgIE1QNFJlbXV4ZXIucHJvdG90eXBlLnJlc2V0VGltZVN0YW1wID0gZnVuY3Rpb24gKGRlZmF1bHRUaW1lU3RhbXApIHtcbiAgICAgICAgdGhpcy5faW5pdFBUUyA9IHRoaXMuX2luaXREVFMgPSBkZWZhdWx0VGltZVN0YW1wO1xuICAgIH07XG4gICAgTVA0UmVtdXhlci5wcm90b3R5cGUucmVzZXRJbml0U2VnbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5JU0dlbmVyYXRlZCA9IGZhbHNlO1xuICAgIH07XG4gICAgTVA0UmVtdXhlci5wcm90b3R5cGUucmVtdXggPSBmdW5jdGlvbiAoYXVkaW9UcmFjaywgdmlkZW9UcmFjaywgaWQzVHJhY2ssIHRleHRUcmFjaywgdGltZU9mZnNldCwgY29udGlndW91cywgYWNjdXJhdGVUaW1lT2Zmc2V0KSB7XG4gICAgICAgIC8vIGdlbmVyYXRlIEluaXQgU2VnbWVudCBpZiBuZWVkZWRcbiAgICAgICAgaWYgKCF0aGlzLklTR2VuZXJhdGVkKSB7XG4gICAgICAgICAgICB0aGlzLmdlbmVyYXRlSVMoYXVkaW9UcmFjaywgdmlkZW9UcmFjaywgdGltZU9mZnNldCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuSVNHZW5lcmF0ZWQpIHtcbiAgICAgICAgICAgIHZhciBuYkF1ZGlvU2FtcGxlcyA9IGF1ZGlvVHJhY2suc2FtcGxlcy5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgbmJWaWRlb1NhbXBsZXMgPSB2aWRlb1RyYWNrLnNhbXBsZXMubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIGF1ZGlvVGltZU9mZnNldCA9IHRpbWVPZmZzZXQ7XG4gICAgICAgICAgICB2YXIgdmlkZW9UaW1lT2Zmc2V0ID0gdGltZU9mZnNldDtcbiAgICAgICAgICAgIGlmIChuYkF1ZGlvU2FtcGxlcyAmJiBuYlZpZGVvU2FtcGxlcykge1xuICAgICAgICAgICAgICAgIC8vIHRpbWVPZmZzZXQgaXMgZXhwZWN0ZWQgdG8gYmUgdGhlIG9mZnNldCBvZiB0aGUgZmlyc3QgdGltZXN0YW1wIG9mIHRoaXMgZnJhZ21lbnQgKGZpcnN0IERUUylcbiAgICAgICAgICAgICAgICAvLyBpZiBmaXJzdCBhdWRpbyBEVFMgaXMgbm90IGFsaWduZWQgd2l0aCBmaXJzdCB2aWRlbyBEVFMgdGhlbiB3ZSBuZWVkIHRvIHRha2UgdGhhdCBpbnRvIGFjY291bnRcbiAgICAgICAgICAgICAgICAvLyB3aGVuIHByb3ZpZGluZyB0aW1lT2Zmc2V0IHRvIHJlbXV4QXVkaW8gLyByZW11eFZpZGVvLiBpZiB3ZSBkb24ndCBkbyB0aGF0LCB0aGVyZSBtaWdodCBiZSBhIHBlcm1hbmVudCAvIHNtYWxsXG4gICAgICAgICAgICAgICAgLy8gZHJpZnQgYmV0d2VlbiBhdWRpbyBhbmQgdmlkZW8gc3RyZWFtc1xuICAgICAgICAgICAgICAgIHZhciBhdWRpb3ZpZGVvRGVsdGFEdHMgPSAoYXVkaW9UcmFjay5zYW1wbGVzWzBdLnB0cyAtIHZpZGVvVHJhY2suc2FtcGxlc1swXS5wdHMpIC8gdmlkZW9UcmFjay5pbnB1dFRpbWVTY2FsZTtcbiAgICAgICAgICAgICAgICBhdWRpb1RpbWVPZmZzZXQgKz0gTWF0aC5tYXgoMCwgYXVkaW92aWRlb0RlbHRhRHRzKTtcbiAgICAgICAgICAgICAgICB2aWRlb1RpbWVPZmZzZXQgKz0gTWF0aC5tYXgoMCwgLWF1ZGlvdmlkZW9EZWx0YUR0cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBQdXJwb3NlZnVsbHkgcmVtdXhpbmcgYXVkaW8gYmVmb3JlIHZpZGVvLCBzbyB0aGF0IHJlbXV4VmlkZW8gY2FuIHVzZSBuZXh0QXVkaW9QdHMsIHdoaWNoIGlzXG4gICAgICAgICAgICAvLyBjYWxjdWxhdGVkIGluIHJlbXV4QXVkaW8uXG4gICAgICAgICAgICAvLyBsb2dnZXIubG9nKCduYiBBQUMgc2FtcGxlczonICsgYXVkaW9UcmFjay5zYW1wbGVzLmxlbmd0aCk7XG4gICAgICAgICAgICBpZiAobmJBdWRpb1NhbXBsZXMpIHtcbiAgICAgICAgICAgICAgICAvLyBpZiBpbml0U2VnbWVudCB3YXMgZ2VuZXJhdGVkIHdpdGhvdXQgdmlkZW8gc2FtcGxlcywgcmVnZW5lcmF0ZSBpdCBhZ2FpblxuICAgICAgICAgICAgICAgIGlmICghYXVkaW9UcmFjay50aW1lc2NhbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLndhcm4oJ3JlZ2VuZXJhdGUgSW5pdFNlZ21lbnQgYXMgYXVkaW8gZGV0ZWN0ZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nZW5lcmF0ZUlTKGF1ZGlvVHJhY2ssIHZpZGVvVHJhY2ssIHRpbWVPZmZzZXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgYXVkaW9EYXRhID0gdGhpcy5yZW11eEF1ZGlvKGF1ZGlvVHJhY2ssIGF1ZGlvVGltZU9mZnNldCwgY29udGlndW91cywgYWNjdXJhdGVUaW1lT2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAvLyBsb2dnZXIubG9nKCduYiBBVkMgc2FtcGxlczonICsgdmlkZW9UcmFjay5zYW1wbGVzLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgaWYgKG5iVmlkZW9TYW1wbGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhdWRpb1RyYWNrTGVuZ3RoID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXVkaW9EYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhdWRpb1RyYWNrTGVuZ3RoID0gYXVkaW9EYXRhLmVuZFBUUyAtIGF1ZGlvRGF0YS5zdGFydFBUUztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBpZiBpbml0U2VnbWVudCB3YXMgZ2VuZXJhdGVkIHdpdGhvdXQgdmlkZW8gc2FtcGxlcywgcmVnZW5lcmF0ZSBpdCBhZ2FpblxuICAgICAgICAgICAgICAgICAgICBpZiAoIXZpZGVvVHJhY2sudGltZXNjYWxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXJfMS5sb2dnZXIud2FybigncmVnZW5lcmF0ZSBJbml0U2VnbWVudCBhcyB2aWRlbyBkZXRlY3RlZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5nZW5lcmF0ZUlTKGF1ZGlvVHJhY2ssIHZpZGVvVHJhY2ssIHRpbWVPZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVtdXhWaWRlbyh2aWRlb1RyYWNrLCB2aWRlb1RpbWVPZmZzZXQsIGNvbnRpZ3VvdXMsIGF1ZGlvVHJhY2tMZW5ndGgsIGFjY3VyYXRlVGltZU9mZnNldCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gbG9nZ2VyLmxvZygnbmIgQVZDIHNhbXBsZXM6JyArIHZpZGVvVHJhY2suc2FtcGxlcy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGlmIChuYlZpZGVvU2FtcGxlcykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmlkZW9EYXRhID0gdGhpcy5yZW11eFZpZGVvKHZpZGVvVHJhY2ssIHZpZGVvVGltZU9mZnNldCwgY29udGlndW91cywgMCwgYWNjdXJhdGVUaW1lT2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZpZGVvRGF0YSAmJiBhdWRpb1RyYWNrLmNvZGVjKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbXV4RW1wdHlBdWRpbyhhdWRpb1RyYWNrLCBhdWRpb1RpbWVPZmZzZXQsIGNvbnRpZ3VvdXMsIHZpZGVvRGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gbG9nZ2VyLmxvZygnbmIgSUQzIHNhbXBsZXM6JyArIGF1ZGlvVHJhY2suc2FtcGxlcy5sZW5ndGgpO1xuICAgICAgICBpZiAoaWQzVHJhY2suc2FtcGxlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMucmVtdXhJRDMoaWQzVHJhY2ssIHRpbWVPZmZzZXQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGxvZ2dlci5sb2coJ25iIElEMyBzYW1wbGVzOicgKyBhdWRpb1RyYWNrLnNhbXBsZXMubGVuZ3RoKTtcbiAgICAgICAgaWYgKHRleHRUcmFjay5zYW1wbGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5yZW11eFRleHQodGV4dFRyYWNrLCB0aW1lT2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBub3RpZnkgZW5kIG9mIHBhcnNpbmdcbiAgICAgICAgdGhpcy5vYnNlcnZlci50cmlnZ2VyKGV2ZW50c18xLmRlZmF1bHQuRlJBR19QQVJTRUQpO1xuICAgIH07XG4gICAgTVA0UmVtdXhlci5wcm90b3R5cGUuZ2VuZXJhdGVJUyA9IGZ1bmN0aW9uIChhdWRpb1RyYWNrLCB2aWRlb1RyYWNrLCB0aW1lT2Zmc2V0KSB7XG4gICAgICAgIHZhciBvYnNlcnZlciA9IHRoaXMub2JzZXJ2ZXIsIGF1ZGlvU2FtcGxlcyA9IGF1ZGlvVHJhY2suc2FtcGxlcywgdmlkZW9TYW1wbGVzID0gdmlkZW9UcmFjay5zYW1wbGVzLCB0eXBlU3VwcG9ydGVkID0gdGhpcy50eXBlU3VwcG9ydGVkLCBjb250YWluZXIgPSAnYXVkaW8vbXA0JywgdHJhY2tzID0ge30sIGRhdGEgPSB7IHRyYWNrczogdHJhY2tzIH0sIGNvbXB1dGVQVFNEVFMgPSAodGhpcy5faW5pdFBUUyA9PT0gdW5kZWZpbmVkKSwgaW5pdFBUUywgaW5pdERUUztcbiAgICAgICAgaWYgKGNvbXB1dGVQVFNEVFMpIHtcbiAgICAgICAgICAgIGluaXRQVFMgPSBpbml0RFRTID0gSW5maW5pdHk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGF1ZGlvVHJhY2suY29uZmlnICYmIGF1ZGlvU2FtcGxlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIGxldCdzIHVzZSBhdWRpbyBzYW1wbGluZyByYXRlIGFzIE1QNCB0aW1lIHNjYWxlLlxuICAgICAgICAgICAgLy8gcmF0aW9uYWxlIGlzIHRoYXQgdGhlcmUgaXMgYSBpbnRlZ2VyIG5iIG9mIGF1ZGlvIGZyYW1lcyBwZXIgYXVkaW8gc2FtcGxlICgxMDI0IGZvciBBQUMpXG4gICAgICAgICAgICAvLyB1c2luZyBhdWRpbyBzYW1wbGluZyByYXRlIGhlcmUgaGVscHMgaGF2aW5nIGFuIGludGVnZXIgTVA0IGZyYW1lIGR1cmF0aW9uXG4gICAgICAgICAgICAvLyB0aGlzIGF2b2lkcyBwb3RlbnRpYWwgcm91bmRpbmcgaXNzdWUgYW5kIEFWIHN5bmMgaXNzdWVcbiAgICAgICAgICAgIGF1ZGlvVHJhY2sudGltZXNjYWxlID0gYXVkaW9UcmFjay5zYW1wbGVyYXRlO1xuICAgICAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLmxvZyhcImF1ZGlvIHNhbXBsaW5nIHJhdGUgOiBcIiArIGF1ZGlvVHJhY2suc2FtcGxlcmF0ZSk7XG4gICAgICAgICAgICBpZiAoIWF1ZGlvVHJhY2suaXNBQUMpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZVN1cHBvcnRlZC5tcGVnKSB7IC8vIENocm9tZSBhbmQgU2FmYXJpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lciA9ICdhdWRpby9tcGVnJztcbiAgICAgICAgICAgICAgICAgICAgYXVkaW9UcmFjay5jb2RlYyA9ICcnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlU3VwcG9ydGVkLm1wMykgeyAvLyBGaXJlZm94XG4gICAgICAgICAgICAgICAgICAgIGF1ZGlvVHJhY2suY29kZWMgPSAnbXAzJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cmFja3MuYXVkaW8gPSB7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyOiBjb250YWluZXIsXG4gICAgICAgICAgICAgICAgY29kZWM6IGF1ZGlvVHJhY2suY29kZWMsXG4gICAgICAgICAgICAgICAgaW5pdFNlZ21lbnQ6ICFhdWRpb1RyYWNrLmlzQUFDICYmIHR5cGVTdXBwb3J0ZWQubXBlZyA/IG5ldyBVaW50OEFycmF5KCkgOiBtcDRfZ2VuZXJhdG9yXzEuZGVmYXVsdC5pbml0U2VnbWVudChbYXVkaW9UcmFja10pLFxuICAgICAgICAgICAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5uZWxDb3VudDogYXVkaW9UcmFjay5jaGFubmVsQ291bnRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKGNvbXB1dGVQVFNEVFMpIHtcbiAgICAgICAgICAgICAgICAvLyByZW1lbWJlciBmaXJzdCBQVFMgb2YgdGhpcyBkZW11eGluZyBjb250ZXh0LiBmb3IgYXVkaW8sIFBUUyA9IERUU1xuICAgICAgICAgICAgICAgIGluaXRQVFMgPSBpbml0RFRTID0gYXVkaW9TYW1wbGVzWzBdLnB0cyAtIGF1ZGlvVHJhY2suaW5wdXRUaW1lU2NhbGUgKiB0aW1lT2Zmc2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh2aWRlb1RyYWNrLnNwcyAmJiB2aWRlb1RyYWNrLnBwcyAmJiB2aWRlb1NhbXBsZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyBsZXQncyB1c2UgaW5wdXQgdGltZSBzY2FsZSBhcyBNUDQgdmlkZW8gdGltZXNjYWxlXG4gICAgICAgICAgICAvLyB3ZSB1c2UgaW5wdXQgdGltZSBzY2FsZSBzdHJhaWdodCBhd2F5IHRvIGF2b2lkIHJvdW5kaW5nIGlzc3VlcyBvbiBmcmFtZSBkdXJhdGlvbiAvIGN0cyBjb21wdXRhdGlvblxuICAgICAgICAgICAgdmFyIGlucHV0VGltZVNjYWxlID0gdmlkZW9UcmFjay5pbnB1dFRpbWVTY2FsZTtcbiAgICAgICAgICAgIHZpZGVvVHJhY2sudGltZXNjYWxlID0gaW5wdXRUaW1lU2NhbGU7XG4gICAgICAgICAgICB0cmFja3MudmlkZW8gPSB7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyOiAndmlkZW8vbXA0JyxcbiAgICAgICAgICAgICAgICBjb2RlYzogdmlkZW9UcmFjay5jb2RlYyxcbiAgICAgICAgICAgICAgICBpbml0U2VnbWVudDogbXA0X2dlbmVyYXRvcl8xLmRlZmF1bHQuaW5pdFNlZ21lbnQoW3ZpZGVvVHJhY2tdKSxcbiAgICAgICAgICAgICAgICBtZXRhZGF0YToge1xuICAgICAgICAgICAgICAgICAgICB3aWR0aDogdmlkZW9UcmFjay53aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiB2aWRlb1RyYWNrLmhlaWdodFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoY29tcHV0ZVBUU0RUUykge1xuICAgICAgICAgICAgICAgIGluaXRQVFMgPSBNYXRoLm1pbihpbml0UFRTLCB2aWRlb1NhbXBsZXNbMF0ucHRzIC0gaW5wdXRUaW1lU2NhbGUgKiB0aW1lT2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBpbml0RFRTID0gTWF0aC5taW4oaW5pdERUUywgdmlkZW9TYW1wbGVzWzBdLmR0cyAtIGlucHV0VGltZVNjYWxlICogdGltZU9mZnNldCk7XG4gICAgICAgICAgICAgICAgdGhpcy5vYnNlcnZlci50cmlnZ2VyKGV2ZW50c18xLmRlZmF1bHQuSU5JVF9QVFNfRk9VTkQsIHsgaW5pdFBUUzogaW5pdFBUUyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoT2JqZWN0LmtleXModHJhY2tzKS5sZW5ndGgpIHtcbiAgICAgICAgICAgIG9ic2VydmVyLnRyaWdnZXIoZXZlbnRzXzEuZGVmYXVsdC5GUkFHX1BBUlNJTkdfSU5JVF9TRUdNRU5ULCBkYXRhKTtcbiAgICAgICAgICAgIHRoaXMuSVNHZW5lcmF0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKGNvbXB1dGVQVFNEVFMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9pbml0UFRTID0gaW5pdFBUUztcbiAgICAgICAgICAgICAgICB0aGlzLl9pbml0RFRTID0gaW5pdERUUztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9ic2VydmVyLnRyaWdnZXIoZXZlbnRzXzEuZGVmYXVsdC5FUlJPUiwgeyB0eXBlOiBlcnJvcnNfMS5FcnJvclR5cGVzLk1FRElBX0VSUk9SLCBkZXRhaWxzOiBlcnJvcnNfMS5FcnJvckRldGFpbHMuRlJBR19QQVJTSU5HX0VSUk9SLCBmYXRhbDogZmFsc2UsIHJlYXNvbjogJ25vIGF1ZGlvL3ZpZGVvIHNhbXBsZXMgZm91bmQnIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBNUDRSZW11eGVyLnByb3RvdHlwZS5yZW11eFZpZGVvID0gZnVuY3Rpb24gKHRyYWNrLCB0aW1lT2Zmc2V0LCBjb250aWd1b3VzLCBhdWRpb1RyYWNrTGVuZ3RoLCBhY2N1cmF0ZVRpbWVPZmZzZXQpIHtcbiAgICAgICAgdmFyIG9mZnNldCA9IDg7XG4gICAgICAgIHZhciBtcDRTYW1wbGVEdXJhdGlvbjtcbiAgICAgICAgdmFyIG1kYXQ7XG4gICAgICAgIHZhciBtb29mO1xuICAgICAgICB2YXIgZmlyc3RQVFM7XG4gICAgICAgIHZhciBmaXJzdERUUztcbiAgICAgICAgdmFyIGxhc3RQVFM7XG4gICAgICAgIHZhciBsYXN0RFRTO1xuICAgICAgICB2YXIgdGltZVNjYWxlID0gdHJhY2sudGltZXNjYWxlO1xuICAgICAgICB2YXIgaW5wdXRTYW1wbGVzID0gdHJhY2suc2FtcGxlcztcbiAgICAgICAgdmFyIG91dHB1dFNhbXBsZXMgPSBbXTtcbiAgICAgICAgdmFyIG5iU2FtcGxlcyA9IGlucHV0U2FtcGxlcy5sZW5ndGg7XG4gICAgICAgIHZhciBwdHNOb3JtYWxpemUgPSB0aGlzLl9QVFNOb3JtYWxpemU7XG4gICAgICAgIHZhciBpbml0UFRTID0gdGhpcy5faW5pdFBUUztcbiAgICAgICAgLy8gaWYgcGFyc2VkIGZyYWdtZW50IGlzIGNvbnRpZ3VvdXMgd2l0aCBsYXN0IG9uZSwgbGV0J3MgdXNlIGxhc3QgRFRTIHZhbHVlIGFzIHJlZmVyZW5jZVxuICAgICAgICB2YXIgbmV4dEF2Y0R0cyA9IHRoaXMubmV4dEF2Y0R0cztcbiAgICAgICAgdmFyIGlzU2FmYXJpID0gdGhpcy5pc1NhZmFyaTtcbiAgICAgICAgaWYgKG5iU2FtcGxlcyA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNhZmFyaSBkb2VzIG5vdCBsaWtlIG92ZXJsYXBwaW5nIERUUyBvbiBjb25zZWN1dGl2ZSBmcmFnbWVudHMuIGxldCdzIHVzZSBuZXh0QXZjRHRzIHRvIG92ZXJjb21lIHRoaXMgaWYgZnJhZ21lbnRzIGFyZSBjb25zZWN1dGl2ZVxuICAgICAgICBpZiAoaXNTYWZhcmkpIHtcbiAgICAgICAgICAgIC8vIGFsc28gY29uc2lkZXIgY29uc2VjdXRpdmUgZnJhZ21lbnRzIGFzIGJlaW5nIGNvbnRpZ3VvdXMgKGV2ZW4gaWYgYSBsZXZlbCBzd2l0Y2ggb2NjdXJzKSxcbiAgICAgICAgICAgIC8vIGZvciBzYWtlIG9mIGNsYXJpdHk6XG4gICAgICAgICAgICAvLyBjb25zZWN1dGl2ZSBmcmFnbWVudHMgYXJlIGZyYWdzIHdpdGhcbiAgICAgICAgICAgIC8vICAtIGxlc3MgdGhhbiAxMDBtcyBnYXBzIGJldHdlZW4gbmV3IHRpbWUgb2Zmc2V0IChpZiBhY2N1cmF0ZSkgYW5kIG5leHQgZXhwZWN0ZWQgUFRTIE9SXG4gICAgICAgICAgICAvLyAgLSBsZXNzIHRoYW4gMjAwIG1zIFBUUyBnYXBzICh0aW1lU2NhbGUvNSlcbiAgICAgICAgICAgIGNvbnRpZ3VvdXMgfD0gKGlucHV0U2FtcGxlcy5sZW5ndGggJiYgbmV4dEF2Y0R0cyAmJlxuICAgICAgICAgICAgICAgICgoYWNjdXJhdGVUaW1lT2Zmc2V0ICYmIE1hdGguYWJzKHRpbWVPZmZzZXQgLSBuZXh0QXZjRHRzIC8gdGltZVNjYWxlKSA8IDAuMSkgfHxcbiAgICAgICAgICAgICAgICAgICAgTWF0aC5hYnMoKGlucHV0U2FtcGxlc1swXS5wdHMgLSBuZXh0QXZjRHRzIC0gaW5pdFBUUykpIDwgdGltZVNjYWxlIC8gNSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY29udGlndW91cykge1xuICAgICAgICAgICAgLy8gaWYgbm90IGNvbnRpZ3VvdXMsIGxldCdzIHVzZSB0YXJnZXQgdGltZU9mZnNldFxuICAgICAgICAgICAgbmV4dEF2Y0R0cyA9IHRpbWVPZmZzZXQgKiB0aW1lU2NhbGU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUFRTIGlzIGNvZGVkIG9uIDMzYml0cywgYW5kIGNhbiBsb29wIGZyb20gLTJeMzIgdG8gMl4zMlxuICAgICAgICAvLyBwdHNOb3JtYWxpemUgd2lsbCBtYWtlIFBUUy9EVFMgdmFsdWUgbW9ub3RvbmljLCB3ZSB1c2UgbGFzdCBrbm93biBEVFMgdmFsdWUgYXMgcmVmZXJlbmNlIHZhbHVlXG4gICAgICAgIGlucHV0U2FtcGxlcy5mb3JFYWNoKGZ1bmN0aW9uIChzYW1wbGUpIHtcbiAgICAgICAgICAgIHNhbXBsZS5wdHMgPSBwdHNOb3JtYWxpemUoc2FtcGxlLnB0cyAtIGluaXRQVFMsIG5leHRBdmNEdHMpO1xuICAgICAgICAgICAgc2FtcGxlLmR0cyA9IHB0c05vcm1hbGl6ZShzYW1wbGUuZHRzIC0gaW5pdFBUUywgbmV4dEF2Y0R0cyk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBzb3J0IHZpZGVvIHNhbXBsZXMgYnkgRFRTIHRoZW4gUFRTIHRoZW4gZGVtdXggaWQgb3JkZXJcbiAgICAgICAgaW5wdXRTYW1wbGVzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgIHZhciBkZWx0YWR0cyA9IGEuZHRzIC0gYi5kdHM7XG4gICAgICAgICAgICB2YXIgZGVsdGFwdHMgPSBhLnB0cyAtIGIucHRzO1xuICAgICAgICAgICAgcmV0dXJuIGRlbHRhZHRzIHx8IChkZWx0YXB0cyB8fCAoYS5pZCAtIGIuaWQpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIGhhbmRsZSBicm9rZW4gc3RyZWFtcyB3aXRoIFBUUyA8IERUUywgdG9sZXJhbmNlIHVwIDIwMG1zICgxODAwMCBpbiA5MGtIeiB0aW1lc2NhbGUpXG4gICAgICAgIHZhciBQVFNEVFNzaGlmdCA9IGlucHV0U2FtcGxlcy5yZWR1Y2UoZnVuY3Rpb24gKHByZXYsIGN1cnIpIHsgcmV0dXJuIE1hdGgubWF4KE1hdGgubWluKHByZXYsIGN1cnIucHRzIC0gY3Vyci5kdHMpLCAtMTgwMDApOyB9LCAwKTtcbiAgICAgICAgaWYgKFBUU0RUU3NoaWZ0IDwgMCkge1xuICAgICAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLndhcm4oXCJQVFMgPCBEVFMgZGV0ZWN0ZWQgaW4gdmlkZW8gc2FtcGxlcywgc2hpZnRpbmcgRFRTIGJ5IFwiICsgTWF0aC5yb3VuZChQVFNEVFNzaGlmdCAvIDkwKSArIFwiIG1zIHRvIG92ZXJjb21lIHRoaXMgaXNzdWVcIik7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlucHV0U2FtcGxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlucHV0U2FtcGxlc1tpXS5kdHMgKz0gUFRTRFRTc2hpZnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gY29tcHV0ZSBmaXJzdCBEVFMgYW5kIGxhc3QgRFRTLCBub3JtYWxpemUgdGhlbSBhZ2FpbnN0IHJlZmVyZW5jZSB2YWx1ZVxuICAgICAgICB2YXIgc2FtcGxlID0gaW5wdXRTYW1wbGVzWzBdO1xuICAgICAgICBmaXJzdERUUyA9IE1hdGgubWF4KHNhbXBsZS5kdHMsIDApO1xuICAgICAgICBmaXJzdFBUUyA9IE1hdGgubWF4KHNhbXBsZS5wdHMsIDApO1xuICAgICAgICAvLyBjaGVjayB0aW1lc3RhbXAgY29udGludWl0eSBhY2Nyb3NzIGNvbnNlY3V0aXZlIGZyYWdtZW50cyAodGhpcyBpcyB0byByZW1vdmUgaW50ZXItZnJhZ21lbnQgZ2FwL2hvbGUpXG4gICAgICAgIHZhciBkZWx0YSA9IE1hdGgucm91bmQoKGZpcnN0RFRTIC0gbmV4dEF2Y0R0cykgLyA5MCk7XG4gICAgICAgIC8vIGlmIGZyYWdtZW50IGFyZSBjb250aWd1b3VzLCBkZXRlY3QgaG9sZS9vdmVybGFwcGluZyBiZXR3ZWVuIGZyYWdtZW50c1xuICAgICAgICBpZiAoY29udGlndW91cykge1xuICAgICAgICAgICAgaWYgKGRlbHRhKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRlbHRhID4gMSkge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXJfMS5sb2dnZXIubG9nKFwiQVZDOlwiICsgZGVsdGEgKyBcIiBtcyBob2xlIGJldHdlZW4gZnJhZ21lbnRzIGRldGVjdGVkLGZpbGxpbmcgaXRcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGRlbHRhIDwgLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLmxvZyhcIkFWQzpcIiArICgtZGVsdGEpICsgXCIgbXMgb3ZlcmxhcHBpbmcgYmV0d2VlbiBmcmFnbWVudHMgZGV0ZWN0ZWRcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBob2xlL2dhcCA6IHNldCBEVFMgdG8gbmV4dCBleHBlY3RlZCBEVFNcbiAgICAgICAgICAgICAgICBmaXJzdERUUyA9IG5leHRBdmNEdHM7XG4gICAgICAgICAgICAgICAgaW5wdXRTYW1wbGVzWzBdLmR0cyA9IGZpcnN0RFRTO1xuICAgICAgICAgICAgICAgIC8vIG9mZnNldCBQVFMgYXMgd2VsbCwgZW5zdXJlIHRoYXQgUFRTIGlzIHNtYWxsZXIgb3IgZXF1YWwgdGhhbiBuZXcgRFRTXG4gICAgICAgICAgICAgICAgZmlyc3RQVFMgPSBNYXRoLm1heChmaXJzdFBUUyAtIGRlbHRhLCBuZXh0QXZjRHRzKTtcbiAgICAgICAgICAgICAgICBpbnB1dFNhbXBsZXNbMF0ucHRzID0gZmlyc3RQVFM7XG4gICAgICAgICAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLmxvZyhcIlZpZGVvL1BUUy9EVFMgYWRqdXN0ZWQ6IFwiICsgTWF0aC5yb3VuZChmaXJzdFBUUyAvIDkwKSArIFwiL1wiICsgTWF0aC5yb3VuZChmaXJzdERUUyAvIDkwKSArIFwiLGRlbHRhOlwiICsgZGVsdGEgKyBcIiBtc1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBjb21wdXRlIGxhc3RQVFMvbGFzdERUU1xuICAgICAgICBzYW1wbGUgPSBpbnB1dFNhbXBsZXNbaW5wdXRTYW1wbGVzLmxlbmd0aCAtIDFdO1xuICAgICAgICBsYXN0RFRTID0gTWF0aC5tYXgoc2FtcGxlLmR0cywgMCk7XG4gICAgICAgIGxhc3RQVFMgPSBNYXRoLm1heChzYW1wbGUucHRzLCAwLCBsYXN0RFRTKTtcbiAgICAgICAgLy8gb24gU2FmYXJpIGxldCdzIHNpZ25hbCB0aGUgc2FtZSBzYW1wbGUgZHVyYXRpb24gZm9yIGFsbCBzYW1wbGVzXG4gICAgICAgIC8vIHNhbXBsZSBkdXJhdGlvbiAoYXMgZXhwZWN0ZWQgYnkgdHJ1biBNUDQgYm94ZXMpLCBzaG91bGQgYmUgdGhlIGRlbHRhIGJldHdlZW4gc2FtcGxlIERUU1xuICAgICAgICAvLyBzZXQgdGhpcyBjb25zdGFudCBkdXJhdGlvbiBhcyBiZWluZyB0aGUgYXZnIGRlbHRhIGJldHdlZW4gY29uc2VjdXRpdmUgRFRTLlxuICAgICAgICBpZiAoaXNTYWZhcmkpIHtcbiAgICAgICAgICAgIG1wNFNhbXBsZUR1cmF0aW9uID0gTWF0aC5yb3VuZCgobGFzdERUUyAtIGZpcnN0RFRTKSAvIChpbnB1dFNhbXBsZXMubGVuZ3RoIC0gMSkpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBuYk5hbHUgPSAwLCBuYWx1TGVuID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuYlNhbXBsZXM7IGkrKykge1xuICAgICAgICAgICAgLy8gY29tcHV0ZSB0b3RhbC9hdmMgc2FtcGxlIGxlbmd0aCBhbmQgbmIgb2YgTkFMIHVuaXRzXG4gICAgICAgICAgICB2YXIgc2FtcGxlXzEgPSBpbnB1dFNhbXBsZXNbaV0sIHVuaXRzID0gc2FtcGxlXzEudW5pdHMsIG5iVW5pdHMgPSB1bml0cy5sZW5ndGgsIHNhbXBsZUxlbiA9IDA7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG5iVW5pdHM7IGorKykge1xuICAgICAgICAgICAgICAgIHNhbXBsZUxlbiArPSB1bml0c1tqXS5kYXRhLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5hbHVMZW4gKz0gc2FtcGxlTGVuO1xuICAgICAgICAgICAgbmJOYWx1ICs9IG5iVW5pdHM7XG4gICAgICAgICAgICBzYW1wbGVfMS5sZW5ndGggPSBzYW1wbGVMZW47XG4gICAgICAgICAgICAvLyBub3JtYWxpemUgUFRTL0RUU1xuICAgICAgICAgICAgaWYgKGlzU2FmYXJpKSB7XG4gICAgICAgICAgICAgICAgLy8gc2FtcGxlIERUUyBpcyBjb21wdXRlZCB1c2luZyBhIGNvbnN0YW50IGRlY29kaW5nIG9mZnNldCAobXA0U2FtcGxlRHVyYXRpb24pIGJldHdlZW4gc2FtcGxlc1xuICAgICAgICAgICAgICAgIHNhbXBsZV8xLmR0cyA9IGZpcnN0RFRTICsgaSAqIG1wNFNhbXBsZUR1cmF0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gZW5zdXJlIHNhbXBsZSBtb25vdG9uaWMgRFRTXG4gICAgICAgICAgICAgICAgc2FtcGxlXzEuZHRzID0gTWF0aC5tYXgoc2FtcGxlXzEuZHRzLCBmaXJzdERUUyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBlbnN1cmUgdGhhdCBjb21wdXRlZCB2YWx1ZSBpcyBncmVhdGVyIG9yIGVxdWFsIHRoYW4gc2FtcGxlIERUU1xuICAgICAgICAgICAgc2FtcGxlXzEucHRzID0gTWF0aC5tYXgoc2FtcGxlXzEucHRzLCBzYW1wbGVfMS5kdHMpO1xuICAgICAgICB9XG4gICAgICAgIC8qIGNvbmNhdGVuYXRlIHRoZSB2aWRlbyBkYXRhIGFuZCBjb25zdHJ1Y3QgdGhlIG1kYXQgaW4gcGxhY2VcbiAgICAgICAgICAobmVlZCA4IG1vcmUgYnl0ZXMgdG8gZmlsbCBsZW5ndGggYW5kIG1wZGF0IHR5cGUpICovXG4gICAgICAgIHZhciBtZGF0U2l6ZSA9IG5hbHVMZW4gKyAoNCAqIG5iTmFsdSkgKyA4O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbWRhdCA9IG5ldyBVaW50OEFycmF5KG1kYXRTaXplKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLm9ic2VydmVyLnRyaWdnZXIoZXZlbnRzXzEuZGVmYXVsdC5FUlJPUiwgeyB0eXBlOiBlcnJvcnNfMS5FcnJvclR5cGVzLk1VWF9FUlJPUiwgZGV0YWlsczogZXJyb3JzXzEuRXJyb3JEZXRhaWxzLlJFTVVYX0FMTE9DX0VSUk9SLCBmYXRhbDogZmFsc2UsIGJ5dGVzOiBtZGF0U2l6ZSwgcmVhc29uOiBcImZhaWwgYWxsb2NhdGluZyB2aWRlbyBtZGF0IFwiICsgbWRhdFNpemUgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHZpZXcgPSBuZXcgRGF0YVZpZXcobWRhdC5idWZmZXIpO1xuICAgICAgICB2aWV3LnNldFVpbnQzMigwLCBtZGF0U2l6ZSk7XG4gICAgICAgIG1kYXQuc2V0KG1wNF9nZW5lcmF0b3JfMS5kZWZhdWx0LnR5cGVzLm1kYXQsIDQpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5iU2FtcGxlczsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgYXZjU2FtcGxlID0gaW5wdXRTYW1wbGVzW2ldLCBhdmNTYW1wbGVVbml0cyA9IGF2Y1NhbXBsZS51bml0cywgbXA0U2FtcGxlTGVuZ3RoID0gMCwgY29tcG9zaXRpb25UaW1lT2Zmc2V0ID0gdm9pZCAwO1xuICAgICAgICAgICAgLy8gY29udmVydCBOQUxVIGJpdHN0cmVhbSB0byBNUDQgZm9ybWF0IChwcmVwZW5kIE5BTFUgd2l0aCBzaXplIGZpZWxkKVxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDAsIG5iVW5pdHMgPSBhdmNTYW1wbGVVbml0cy5sZW5ndGg7IGogPCBuYlVuaXRzOyBqKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgdW5pdCA9IGF2Y1NhbXBsZVVuaXRzW2pdLCB1bml0RGF0YSA9IHVuaXQuZGF0YSwgdW5pdERhdGFMZW4gPSB1bml0LmRhdGEuYnl0ZUxlbmd0aDtcbiAgICAgICAgICAgICAgICB2aWV3LnNldFVpbnQzMihvZmZzZXQsIHVuaXREYXRhTGVuKTtcbiAgICAgICAgICAgICAgICBvZmZzZXQgKz0gNDtcbiAgICAgICAgICAgICAgICBtZGF0LnNldCh1bml0RGF0YSwgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBvZmZzZXQgKz0gdW5pdERhdGFMZW47XG4gICAgICAgICAgICAgICAgbXA0U2FtcGxlTGVuZ3RoICs9IDQgKyB1bml0RGF0YUxlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaXNTYWZhcmkpIHtcbiAgICAgICAgICAgICAgICAvLyBleHBlY3RlZCBzYW1wbGUgZHVyYXRpb24gaXMgdGhlIERlY29kaW5nIFRpbWVzdGFtcCBkaWZmIG9mIGNvbnNlY3V0aXZlIHNhbXBsZXNcbiAgICAgICAgICAgICAgICBpZiAoaSA8IG5iU2FtcGxlcyAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgbXA0U2FtcGxlRHVyYXRpb24gPSBpbnB1dFNhbXBsZXNbaSArIDFdLmR0cyAtIGF2Y1NhbXBsZS5kdHM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29uZmlnID0gdGhpcy5jb25maWcsIGxhc3RGcmFtZUR1cmF0aW9uID0gYXZjU2FtcGxlLmR0cyAtIGlucHV0U2FtcGxlc1tpID4gMCA/IGkgLSAxIDogaV0uZHRzO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29uZmlnLnN0cmV0Y2hTaG9ydFZpZGVvVHJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEluIHNvbWUgY2FzZXMsIGEgc2VnbWVudCdzIGF1ZGlvIHRyYWNrIGR1cmF0aW9uIG1heSBleGNlZWQgdGhlIHZpZGVvIHRyYWNrIGR1cmF0aW9uLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2luY2Ugd2UndmUgYWxyZWFkeSByZW11eGVkIGF1ZGlvLCBhbmQgd2Uga25vdyBob3cgbG9uZyB0aGUgYXVkaW8gdHJhY2sgaXMsIHdlIGxvb2sgdG9cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNlZSBpZiB0aGUgZGVsdGEgdG8gdGhlIG5leHQgc2VnbWVudCBpcyBsb25nZXIgdGhhbiBtYXhCdWZmZXJIb2xlLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgc28sIHBsYXliYWNrIHdvdWxkIHBvdGVudGlhbGx5IGdldCBzdHVjaywgc28gd2UgYXJ0aWZpY2lhbGx5IGluZmxhdGVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSBkdXJhdGlvbiBvZiB0aGUgbGFzdCBmcmFtZSB0byBtaW5pbWl6ZSBhbnkgcG90ZW50aWFsIGdhcCBiZXR3ZWVuIHNlZ21lbnRzLlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1heEJ1ZmZlckhvbGUgPSBjb25maWcubWF4QnVmZmVySG9sZSwgZ2FwVG9sZXJhbmNlID0gTWF0aC5mbG9vcihtYXhCdWZmZXJIb2xlICogdGltZVNjYWxlKSwgZGVsdGFUb0ZyYW1lRW5kID0gKGF1ZGlvVHJhY2tMZW5ndGggPyBmaXJzdFBUUyArIGF1ZGlvVHJhY2tMZW5ndGggKiB0aW1lU2NhbGUgOiB0aGlzLm5leHRBdWRpb1B0cykgLSBhdmNTYW1wbGUucHRzO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRlbHRhVG9GcmFtZUVuZCA+IGdhcFRvbGVyYW5jZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIHN1YnRyYWN0IGxhc3RGcmFtZUR1cmF0aW9uIGZyb20gZGVsdGFUb0ZyYW1lRW5kIHRvIHRyeSB0byBwcmV2ZW50IGFueSB2aWRlb1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZyYW1lIG92ZXJsYXAuIG1heEJ1ZmZlckhvbGUgc2hvdWxkIGJlID4+IGxhc3RGcmFtZUR1cmF0aW9uIGFueXdheS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtcDRTYW1wbGVEdXJhdGlvbiA9IGRlbHRhVG9GcmFtZUVuZCAtIGxhc3RGcmFtZUR1cmF0aW9uO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtcDRTYW1wbGVEdXJhdGlvbiA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbXA0U2FtcGxlRHVyYXRpb24gPSBsYXN0RnJhbWVEdXJhdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLmxvZyhcIkl0IGlzIGFwcHJveGltYXRlbHkgXCIgKyBkZWx0YVRvRnJhbWVFbmQgLyA5MCArIFwiIG1zIHRvIHRoZSBuZXh0IHNlZ21lbnQ7IHVzaW5nIGR1cmF0aW9uIFwiICsgbXA0U2FtcGxlRHVyYXRpb24gLyA5MCArIFwiIG1zIGZvciB0aGUgbGFzdCB2aWRlbyBmcmFtZS5cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtcDRTYW1wbGVEdXJhdGlvbiA9IGxhc3RGcmFtZUR1cmF0aW9uO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbXA0U2FtcGxlRHVyYXRpb24gPSBsYXN0RnJhbWVEdXJhdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb21wb3NpdGlvblRpbWVPZmZzZXQgPSBNYXRoLnJvdW5kKGF2Y1NhbXBsZS5wdHMgLSBhdmNTYW1wbGUuZHRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbXBvc2l0aW9uVGltZU9mZnNldCA9IE1hdGgubWF4KDAsIG1wNFNhbXBsZUR1cmF0aW9uICogTWF0aC5yb3VuZCgoYXZjU2FtcGxlLnB0cyAtIGF2Y1NhbXBsZS5kdHMpIC8gbXA0U2FtcGxlRHVyYXRpb24pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdQVFMvRFRTL2luaXREVFMvbm9ybVBUUy9ub3JtRFRTL3JlbGF0aXZlIFBUUyA6ICR7YXZjU2FtcGxlLnB0c30vJHthdmNTYW1wbGUuZHRzfS8ke2luaXREVFN9LyR7cHRzbm9ybX0vJHtkdHNub3JtfS8keyhhdmNTYW1wbGUucHRzLzQyOTQ5NjcyOTYpLnRvRml4ZWQoMyl9Jyk7XG4gICAgICAgICAgICBvdXRwdXRTYW1wbGVzLnB1c2goe1xuICAgICAgICAgICAgICAgIHNpemU6IG1wNFNhbXBsZUxlbmd0aCxcbiAgICAgICAgICAgICAgICAvLyBjb25zdGFudCBkdXJhdGlvblxuICAgICAgICAgICAgICAgIGR1cmF0aW9uOiBtcDRTYW1wbGVEdXJhdGlvbixcbiAgICAgICAgICAgICAgICBjdHM6IGNvbXBvc2l0aW9uVGltZU9mZnNldCxcbiAgICAgICAgICAgICAgICBmbGFnczoge1xuICAgICAgICAgICAgICAgICAgICBpc0xlYWRpbmc6IDAsXG4gICAgICAgICAgICAgICAgICAgIGlzRGVwZW5kZWRPbjogMCxcbiAgICAgICAgICAgICAgICAgICAgaGFzUmVkdW5kYW5jeTogMCxcbiAgICAgICAgICAgICAgICAgICAgZGVncmFkUHJpbzogMCxcbiAgICAgICAgICAgICAgICAgICAgZGVwZW5kc09uOiBhdmNTYW1wbGUua2V5ID8gMiA6IDEsXG4gICAgICAgICAgICAgICAgICAgIGlzTm9uU3luYzogYXZjU2FtcGxlLmtleSA/IDAgOiAxXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbmV4dCBBVkMgc2FtcGxlIERUUyBzaG91bGQgYmUgZXF1YWwgdG8gbGFzdCBzYW1wbGUgRFRTICsgbGFzdCBzYW1wbGUgZHVyYXRpb24gKGluIFBFUyB0aW1lc2NhbGUpXG4gICAgICAgIHRoaXMubmV4dEF2Y0R0cyA9IGxhc3REVFMgKyBtcDRTYW1wbGVEdXJhdGlvbjtcbiAgICAgICAgdmFyIGRyb3BwZWQgPSB0cmFjay5kcm9wcGVkO1xuICAgICAgICB0cmFjay5sZW4gPSAwO1xuICAgICAgICB0cmFjay5uYk5hbHUgPSAwO1xuICAgICAgICB0cmFjay5kcm9wcGVkID0gMDtcbiAgICAgICAgaWYgKG91dHB1dFNhbXBsZXMubGVuZ3RoICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5pbmRleE9mKCdjaHJvbWUnKSA+IC0xKSB7XG4gICAgICAgICAgICB2YXIgZmxhZ3MgPSBvdXRwdXRTYW1wbGVzWzBdLmZsYWdzO1xuICAgICAgICAgICAgLy8gY2hyb21lIHdvcmthcm91bmQsIG1hcmsgZmlyc3Qgc2FtcGxlIGFzIGJlaW5nIGEgUmFuZG9tIEFjY2VzcyBQb2ludCB0byBhdm9pZCBzb3VyY2VidWZmZXIgYXBwZW5kIGlzc3VlXG4gICAgICAgICAgICAvLyBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MjI5NDEyXG4gICAgICAgICAgICBmbGFncy5kZXBlbmRzT24gPSAyO1xuICAgICAgICAgICAgZmxhZ3MuaXNOb25TeW5jID0gMDtcbiAgICAgICAgfVxuICAgICAgICB0cmFjay5zYW1wbGVzID0gb3V0cHV0U2FtcGxlcztcbiAgICAgICAgbW9vZiA9IG1wNF9nZW5lcmF0b3JfMS5kZWZhdWx0Lm1vb2YodHJhY2suc2VxdWVuY2VOdW1iZXIrKywgZmlyc3REVFMsIHRyYWNrKTtcbiAgICAgICAgdHJhY2suc2FtcGxlcyA9IFtdO1xuICAgICAgICB2YXIgZGF0YSA9IHtcbiAgICAgICAgICAgIGRhdGExOiBtb29mLFxuICAgICAgICAgICAgZGF0YTI6IG1kYXQsXG4gICAgICAgICAgICBzdGFydFBUUzogZmlyc3RQVFMgLyB0aW1lU2NhbGUsXG4gICAgICAgICAgICBlbmRQVFM6IChsYXN0UFRTICsgbXA0U2FtcGxlRHVyYXRpb24pIC8gdGltZVNjYWxlLFxuICAgICAgICAgICAgc3RhcnREVFM6IGZpcnN0RFRTIC8gdGltZVNjYWxlLFxuICAgICAgICAgICAgZW5kRFRTOiB0aGlzLm5leHRBdmNEdHMgLyB0aW1lU2NhbGUsXG4gICAgICAgICAgICB0eXBlOiAndmlkZW8nLFxuICAgICAgICAgICAgaGFzQXVkaW86IGZhbHNlLFxuICAgICAgICAgICAgaGFzVmlkZW86IHRydWUsXG4gICAgICAgICAgICBuYjogb3V0cHV0U2FtcGxlcy5sZW5ndGgsXG4gICAgICAgICAgICBkcm9wcGVkOiBkcm9wcGVkXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMub2JzZXJ2ZXIudHJpZ2dlcihldmVudHNfMS5kZWZhdWx0LkZSQUdfUEFSU0lOR19EQVRBLCBkYXRhKTtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfTtcbiAgICBNUDRSZW11eGVyLnByb3RvdHlwZS5yZW11eEF1ZGlvID0gZnVuY3Rpb24gKHRyYWNrLCB0aW1lT2Zmc2V0LCBjb250aWd1b3VzLCBhY2N1cmF0ZVRpbWVPZmZzZXQpIHtcbiAgICAgICAgdmFyIGlucHV0VGltZVNjYWxlID0gdHJhY2suaW5wdXRUaW1lU2NhbGU7XG4gICAgICAgIHZhciBtcDR0aW1lU2NhbGUgPSB0cmFjay50aW1lc2NhbGU7XG4gICAgICAgIHZhciBzY2FsZUZhY3RvciA9IGlucHV0VGltZVNjYWxlIC8gbXA0dGltZVNjYWxlO1xuICAgICAgICB2YXIgbXA0U2FtcGxlRHVyYXRpb24gPSB0cmFjay5pc0FBQyA/IDEwMjQgOiAxMTUyO1xuICAgICAgICB2YXIgaW5wdXRTYW1wbGVEdXJhdGlvbiA9IG1wNFNhbXBsZUR1cmF0aW9uICogc2NhbGVGYWN0b3I7XG4gICAgICAgIHZhciBwdHNOb3JtYWxpemUgPSB0aGlzLl9QVFNOb3JtYWxpemU7XG4gICAgICAgIHZhciBpbml0UFRTID0gdGhpcy5faW5pdFBUUztcbiAgICAgICAgdmFyIHJhd01QRUcgPSAhdHJhY2suaXNBQUMgJiYgdGhpcy50eXBlU3VwcG9ydGVkLm1wZWc7XG4gICAgICAgIHZhciBvZmZzZXQsIG1wNFNhbXBsZSwgZmlsbEZyYW1lLCBtZGF0LCBtb29mLCBmaXJzdFBUUywgbGFzdFBUUywgaW5wdXRTYW1wbGVzID0gdHJhY2suc2FtcGxlcywgb3V0cHV0U2FtcGxlcyA9IFtdLCBuZXh0QXVkaW9QdHMgPSB0aGlzLm5leHRBdWRpb1B0cztcbiAgICAgICAgLy8gZm9yIGF1ZGlvIHNhbXBsZXMsIGFsc28gY29uc2lkZXIgY29uc2VjdXRpdmUgZnJhZ21lbnRzIGFzIGJlaW5nIGNvbnRpZ3VvdXMgKGV2ZW4gaWYgYSBsZXZlbCBzd2l0Y2ggb2NjdXJzKSxcbiAgICAgICAgLy8gZm9yIHNha2Ugb2YgY2xhcml0eTpcbiAgICAgICAgLy8gY29uc2VjdXRpdmUgZnJhZ21lbnRzIGFyZSBmcmFncyB3aXRoXG4gICAgICAgIC8vICAtIGxlc3MgdGhhbiAxMDBtcyBnYXBzIGJldHdlZW4gbmV3IHRpbWUgb2Zmc2V0IChpZiBhY2N1cmF0ZSkgYW5kIG5leHQgZXhwZWN0ZWQgUFRTIE9SXG4gICAgICAgIC8vICAtIGxlc3MgdGhhbiAyMCBhdWRpbyBmcmFtZXMgZGlzdGFuY2VcbiAgICAgICAgLy8gY29udGlndW91cyBmcmFnbWVudHMgYXJlIGNvbnNlY3V0aXZlIGZyYWdtZW50cyBmcm9tIHNhbWUgcXVhbGl0eSBsZXZlbCAoc2FtZSBsZXZlbCwgbmV3IFNOID0gb2xkIFNOICsgMSlcbiAgICAgICAgLy8gdGhpcyBoZWxwcyBlbnN1cmluZyBhdWRpbyBjb250aW51aXR5XG4gICAgICAgIC8vIGFuZCB0aGlzIGFsc28gYXZvaWRzIGF1ZGlvIGdsaXRjaGVzL2N1dCB3aGVuIHN3aXRjaGluZyBxdWFsaXR5LCBvciByZXBvcnRpbmcgd3JvbmcgZHVyYXRpb24gb24gZmlyc3QgYXVkaW8gZnJhbWVcbiAgICAgICAgY29udGlndW91cyB8PSAoaW5wdXRTYW1wbGVzLmxlbmd0aCAmJiBuZXh0QXVkaW9QdHMgJiZcbiAgICAgICAgICAgICgoYWNjdXJhdGVUaW1lT2Zmc2V0ICYmIE1hdGguYWJzKHRpbWVPZmZzZXQgLSBuZXh0QXVkaW9QdHMgLyBpbnB1dFRpbWVTY2FsZSkgPCAwLjEpIHx8XG4gICAgICAgICAgICAgICAgTWF0aC5hYnMoKGlucHV0U2FtcGxlc1swXS5wdHMgLSBuZXh0QXVkaW9QdHMgLSBpbml0UFRTKSkgPCAyMCAqIGlucHV0U2FtcGxlRHVyYXRpb24pKTtcbiAgICAgICAgLy8gY29tcHV0ZSBub3JtYWxpemVkIFBUU1xuICAgICAgICBpbnB1dFNhbXBsZXMuZm9yRWFjaChmdW5jdGlvbiAoc2FtcGxlKSB7XG4gICAgICAgICAgICBzYW1wbGUucHRzID0gc2FtcGxlLmR0cyA9IHB0c05vcm1hbGl6ZShzYW1wbGUucHRzIC0gaW5pdFBUUywgdGltZU9mZnNldCAqIGlucHV0VGltZVNjYWxlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIGZpbHRlciBvdXQgc2FtcGxlIHdpdGggbmVnYXRpdmUgUFRTIHRoYXQgYXJlIG5vdCBwbGF5YWJsZSBhbnl3YXlcbiAgICAgICAgLy8gaWYgd2UgZG9uJ3QgcmVtb3ZlIHRoZXNlIG5lZ2F0aXZlIHNhbXBsZXMsIHRoZXkgd2lsbCBzaGlmdCBhbGwgYXVkaW8gc2FtcGxlcyBmb3J3YXJkLlxuICAgICAgICAvLyBsZWFkaW5nIHRvIGF1ZGlvIG92ZXJsYXAgYmV0d2VlbiBjdXJyZW50IC8gbmV4dCBmcmFnbWVudFxuICAgICAgICBpbnB1dFNhbXBsZXMgPSBpbnB1dFNhbXBsZXMuZmlsdGVyKGZ1bmN0aW9uIChzYW1wbGUpIHtcbiAgICAgICAgICAgIHJldHVybiBzYW1wbGUucHRzID49IDA7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBpbiBjYXNlIGFsbCBzYW1wbGVzIGhhdmUgbmVnYXRpdmUgUFRTLCBhbmQgaGF2ZSBiZWVuIGZpbHRlcmVkIG91dCwgcmV0dXJuIG5vd1xuICAgICAgICBpZiAoaW5wdXRTYW1wbGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY29udGlndW91cykge1xuICAgICAgICAgICAgaWYgKCFhY2N1cmF0ZVRpbWVPZmZzZXQpIHtcbiAgICAgICAgICAgICAgICAvLyBpZiBmcmFnIGFyZSBtb3QgY29udGlndW91cyBhbmQgaWYgd2UgY2FudCB0cnVzdCB0aW1lIG9mZnNldCwgbGV0J3MgdXNlIGZpcnN0IHNhbXBsZSBQVFMgYXMgbmV4dCBhdWRpbyBQVFNcbiAgICAgICAgICAgICAgICBuZXh0QXVkaW9QdHMgPSBpbnB1dFNhbXBsZXNbMF0ucHRzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgdGltZU9mZnNldCBpcyBhY2N1cmF0ZSwgbGV0J3MgdXNlIGl0IGFzIHByZWRpY3RlZCBuZXh0IGF1ZGlvIFBUU1xuICAgICAgICAgICAgICAgIG5leHRBdWRpb1B0cyA9IHRpbWVPZmZzZXQgKiBpbnB1dFRpbWVTY2FsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGUgYXVkaW8gdHJhY2sgaXMgbWlzc2luZyBzYW1wbGVzLCB0aGUgZnJhbWVzIHNlZW0gdG8gZ2V0IFwibGVmdC1zaGlmdGVkXCIgd2l0aGluIHRoZVxuICAgICAgICAvLyByZXN1bHRpbmcgbXA0IHNlZ21lbnQsIGNhdXNpbmcgc3luYyBpc3N1ZXMgYW5kIGxlYXZpbmcgZ2FwcyBhdCB0aGUgZW5kIG9mIHRoZSBhdWRpbyBzZWdtZW50LlxuICAgICAgICAvLyBJbiBhbiBlZmZvcnQgdG8gcHJldmVudCB0aGlzIGZyb20gaGFwcGVuaW5nLCB3ZSBpbmplY3QgZnJhbWVzIGhlcmUgd2hlcmUgdGhlcmUgYXJlIGdhcHMuXG4gICAgICAgIC8vIFdoZW4gcG9zc2libGUsIHdlIGluamVjdCBhIHNpbGVudCBmcmFtZTsgd2hlbiB0aGF0J3Mgbm90IHBvc3NpYmxlLCB3ZSBkdXBsaWNhdGUgdGhlIGxhc3RcbiAgICAgICAgLy8gZnJhbWUuXG4gICAgICAgIGlmICh0cmFjay5pc0FBQykge1xuICAgICAgICAgICAgdmFyIG1heEF1ZGlvRnJhbWVzRHJpZnQgPSB0aGlzLmNvbmZpZy5tYXhBdWRpb0ZyYW1lc0RyaWZ0O1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIG5leHRQdHMgPSBuZXh0QXVkaW9QdHM7IGkgPCBpbnB1dFNhbXBsZXMubGVuZ3RoOykge1xuICAgICAgICAgICAgICAgIC8vIEZpcnN0LCBsZXQncyBzZWUgaG93IGZhciBvZmYgdGhpcyBmcmFtZSBpcyBmcm9tIHdoZXJlIHdlIGV4cGVjdCBpdCB0byBiZVxuICAgICAgICAgICAgICAgIHZhciBzYW1wbGUgPSBpbnB1dFNhbXBsZXNbaV0sIGRlbHRhO1xuICAgICAgICAgICAgICAgIHZhciBwdHMgPSBzYW1wbGUucHRzO1xuICAgICAgICAgICAgICAgIGRlbHRhID0gcHRzIC0gbmV4dFB0cztcbiAgICAgICAgICAgICAgICB2YXIgZHVyYXRpb24gPSBNYXRoLmFicygxMDAwICogZGVsdGEgLyBpbnB1dFRpbWVTY2FsZSk7XG4gICAgICAgICAgICAgICAgLy8gSWYgd2UncmUgb3ZlcmxhcHBpbmcgYnkgbW9yZSB0aGFuIGEgZHVyYXRpb24sIGRyb3AgdGhpcyBzYW1wbGVcbiAgICAgICAgICAgICAgICBpZiAoZGVsdGEgPD0gLW1heEF1ZGlvRnJhbWVzRHJpZnQgKiBpbnB1dFNhbXBsZUR1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmxvZ2dlci53YXJuKFwiRHJvcHBpbmcgMSBhdWRpbyBmcmFtZSBAIFwiICsgKG5leHRQdHMgLyBpbnB1dFRpbWVTY2FsZSkudG9GaXhlZCgzKSArIFwicyBkdWUgdG8gXCIgKyBNYXRoLnJvdW5kKGR1cmF0aW9uKSArIFwiIG1zIG92ZXJsYXAuXCIpO1xuICAgICAgICAgICAgICAgICAgICBpbnB1dFNhbXBsZXMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICB0cmFjay5sZW4gLT0gc2FtcGxlLnVuaXQubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAvLyBEb24ndCB0b3VjaCBuZXh0UHRzTm9ybSBvciBpXG4gICAgICAgICAgICAgICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGJyYWNlLXN0eWxlXG4gICAgICAgICAgICAgICAgLy8gSW5zZXJ0IG1pc3NpbmcgZnJhbWVzIGlmOlxuICAgICAgICAgICAgICAgIC8vIDE6IFdlJ3JlIG1vcmUgdGhhbiBtYXhBdWRpb0ZyYW1lc0RyaWZ0IGZyYW1lIGF3YXlcbiAgICAgICAgICAgICAgICAvLyAyOiBOb3QgbW9yZSB0aGFuIE1BWF9TSUxFTlRfRlJBTUVfRFVSQVRJT04gYXdheVxuICAgICAgICAgICAgICAgIC8vIDM6IGN1cnJlbnRUaW1lIChha2EgbmV4dFB0c05vcm0pIGlzIG5vdCAwXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZGVsdGEgPj0gbWF4QXVkaW9GcmFtZXNEcmlmdCAqIGlucHV0U2FtcGxlRHVyYXRpb24gJiYgZHVyYXRpb24gPCBNQVhfU0lMRU5UX0ZSQU1FX0RVUkFUSU9OICYmIG5leHRQdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1pc3NpbmcgPSBNYXRoLnJvdW5kKGRlbHRhIC8gaW5wdXRTYW1wbGVEdXJhdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmxvZ2dlci53YXJuKFwiSW5qZWN0aW5nIFwiICsgbWlzc2luZyArIFwiIGF1ZGlvIGZyYW1lIEAgXCIgKyAobmV4dFB0cyAvIGlucHV0VGltZVNjYWxlKS50b0ZpeGVkKDMpICsgXCJzIGR1ZSB0byBcIiArIE1hdGgucm91bmQoMTAwMCAqIGRlbHRhIC8gaW5wdXRUaW1lU2NhbGUpICsgXCIgbXMgZ2FwLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtaXNzaW5nOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuZXdTdGFtcCA9IE1hdGgubWF4KG5leHRQdHMsIDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlsbEZyYW1lID0gYWFjX2hlbHBlcl8xLmRlZmF1bHQuZ2V0U2lsZW50RnJhbWUodHJhY2subWFuaWZlc3RDb2RlYyB8fCB0cmFjay5jb2RlYywgdHJhY2suY2hhbm5lbENvdW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZmlsbEZyYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLmxvZygnVW5hYmxlIHRvIGdldCBzaWxlbnQgZnJhbWUgZm9yIGdpdmVuIGF1ZGlvIGNvZGVjOyBkdXBsaWNhdGluZyBsYXN0IGZyYW1lIGluc3RlYWQuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsbEZyYW1lID0gc2FtcGxlLnVuaXQuc3ViYXJyYXkoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0U2FtcGxlcy5zcGxpY2UoaSwgMCwgeyB1bml0OiBmaWxsRnJhbWUsIHB0czogbmV3U3RhbXAsIGR0czogbmV3U3RhbXAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFjay5sZW4gKz0gZmlsbEZyYW1lLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHRQdHMgKz0gaW5wdXRTYW1wbGVEdXJhdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBBZGp1c3Qgc2FtcGxlIHRvIG5leHQgZXhwZWN0ZWQgcHRzXG4gICAgICAgICAgICAgICAgICAgIHNhbXBsZS5wdHMgPSBzYW1wbGUuZHRzID0gbmV4dFB0cztcbiAgICAgICAgICAgICAgICAgICAgbmV4dFB0cyArPSBpbnB1dFNhbXBsZUR1cmF0aW9uO1xuICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2UsIGp1c3QgYWRqdXN0IHB0c1xuICAgICAgICAgICAgICAgICAgICBpZiAoTWF0aC5hYnMoZGVsdGEpID4gKDAuMSAqIGlucHV0U2FtcGxlRHVyYXRpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBsb2dnZXIubG9nKGBJbnZhbGlkIGZyYW1lIGRlbHRhICR7TWF0aC5yb3VuZChkZWx0YSArIGlucHV0U2FtcGxlRHVyYXRpb24pfSBhdCBQVFMgJHtNYXRoLnJvdW5kKHB0cyAvIDkwKX0gKHNob3VsZCBiZSAke01hdGgucm91bmQoaW5wdXRTYW1wbGVEdXJhdGlvbil9KS5gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzYW1wbGUucHRzID0gc2FtcGxlLmR0cyA9IG5leHRQdHM7XG4gICAgICAgICAgICAgICAgICAgIG5leHRQdHMgKz0gaW5wdXRTYW1wbGVEdXJhdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBqID0gMCwgbmJTYW1wbGVzXzEgPSBpbnB1dFNhbXBsZXMubGVuZ3RoOyBqIDwgbmJTYW1wbGVzXzE7IGorKykge1xuICAgICAgICAgICAgdmFyIGF1ZGlvU2FtcGxlID0gaW5wdXRTYW1wbGVzW2pdO1xuICAgICAgICAgICAgdmFyIHVuaXQgPSBhdWRpb1NhbXBsZS51bml0O1xuICAgICAgICAgICAgdmFyIHB0cyA9IGF1ZGlvU2FtcGxlLnB0cztcbiAgICAgICAgICAgIC8vIGxvZ2dlci5sb2coYEF1ZGlvL1BUUzoke01hdGgucm91bmQocHRzLzkwKX1gKTtcbiAgICAgICAgICAgIC8vIGlmIG5vdCBmaXJzdCBzYW1wbGVcbiAgICAgICAgICAgIGlmIChsYXN0UFRTICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBtcDRTYW1wbGUuZHVyYXRpb24gPSBNYXRoLnJvdW5kKChwdHMgLSBsYXN0UFRTKSAvIHNjYWxlRmFjdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBkZWx0YV8xID0gTWF0aC5yb3VuZCgxMDAwICogKHB0cyAtIG5leHRBdWRpb1B0cykgLyBpbnB1dFRpbWVTY2FsZSksIG51bU1pc3NpbmdGcmFtZXMgPSAwO1xuICAgICAgICAgICAgICAgIC8vIGlmIGZyYWdtZW50IGFyZSBjb250aWd1b3VzLCBkZXRlY3QgaG9sZS9vdmVybGFwcGluZyBiZXR3ZWVuIGZyYWdtZW50c1xuICAgICAgICAgICAgICAgIC8vIGNvbnRpZ3VvdXMgZnJhZ21lbnRzIGFyZSBjb25zZWN1dGl2ZSBmcmFnbWVudHMgZnJvbSBzYW1lIHF1YWxpdHkgbGV2ZWwgKHNhbWUgbGV2ZWwsIG5ldyBTTiA9IG9sZCBTTiArIDEpXG4gICAgICAgICAgICAgICAgaWYgKGNvbnRpZ3VvdXMgJiYgdHJhY2suaXNBQUMpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbG9nIGRlbHRhXG4gICAgICAgICAgICAgICAgICAgIGlmIChkZWx0YV8xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGVsdGFfMSA+IDAgJiYgZGVsdGFfMSA8IE1BWF9TSUxFTlRfRlJBTUVfRFVSQVRJT04pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBudW1NaXNzaW5nRnJhbWVzID0gTWF0aC5yb3VuZCgocHRzIC0gbmV4dEF1ZGlvUHRzKSAvIGlucHV0U2FtcGxlRHVyYXRpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmxvZ2dlci5sb2coZGVsdGFfMSArIFwiIG1zIGhvbGUgYmV0d2VlbiBBQUMgc2FtcGxlcyBkZXRlY3RlZCxmaWxsaW5nIGl0XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChudW1NaXNzaW5nRnJhbWVzID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxsRnJhbWUgPSBhYWNfaGVscGVyXzEuZGVmYXVsdC5nZXRTaWxlbnRGcmFtZSh0cmFjay5tYW5pZmVzdENvZGVjIHx8IHRyYWNrLmNvZGVjLCB0cmFjay5jaGFubmVsQ291bnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWZpbGxGcmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsbEZyYW1lID0gdW5pdC5zdWJhcnJheSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYWNrLmxlbiArPSBudW1NaXNzaW5nRnJhbWVzICogZmlsbEZyYW1lLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgd2UgaGF2ZSBmcmFtZSBvdmVybGFwLCBvdmVybGFwcGluZyBmb3IgbW9yZSB0aGFuIGhhbGYgYSBmcmFtZSBkdXJhaW9uXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChkZWx0YV8xIDwgLTEyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZHJvcCBvdmVybGFwcGluZyBhdWRpbyBmcmFtZXMuLi4gYnJvd3NlciB3aWxsIGRlYWwgd2l0aCBpdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmxvZ2dlci5sb2coXCJkcm9wIG92ZXJsYXBwaW5nIEFBQyBzYW1wbGUsIGV4cGVjdGVkL3BhcnNlZC9kZWx0YTpcIiArIChuZXh0QXVkaW9QdHMgLyBpbnB1dFRpbWVTY2FsZSkudG9GaXhlZCgzKSArIFwicy9cIiArIChwdHMgLyBpbnB1dFRpbWVTY2FsZSkudG9GaXhlZCgzKSArIFwicy9cIiArICgtZGVsdGFfMSkgKyBcIm1zXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYWNrLmxlbiAtPSB1bml0LmJ5dGVMZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzZXQgUFRTL0RUUyB0byBleHBlY3RlZCBQVFMvRFRTXG4gICAgICAgICAgICAgICAgICAgICAgICBwdHMgPSBuZXh0QXVkaW9QdHM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gcmVtZW1iZXIgZmlyc3QgUFRTIG9mIG91ciBhdWRpb1NhbXBsZXNcbiAgICAgICAgICAgICAgICBmaXJzdFBUUyA9IHB0cztcbiAgICAgICAgICAgICAgICBpZiAodHJhY2subGVuID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAvKiBjb25jYXRlbmF0ZSB0aGUgYXVkaW8gZGF0YSBhbmQgY29uc3RydWN0IHRoZSBtZGF0IGluIHBsYWNlXG4gICAgICAgICAgICAgICAgICAgICAgKG5lZWQgOCBtb3JlIGJ5dGVzIHRvIGZpbGwgbGVuZ3RoIGFuZCBtZGF0IHR5cGUpICovXG4gICAgICAgICAgICAgICAgICAgIHZhciBtZGF0U2l6ZSA9IHJhd01QRUcgPyB0cmFjay5sZW4gOiB0cmFjay5sZW4gKyA4O1xuICAgICAgICAgICAgICAgICAgICBvZmZzZXQgPSByYXdNUEVHID8gMCA6IDg7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZGF0ID0gbmV3IFVpbnQ4QXJyYXkobWRhdFNpemUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub2JzZXJ2ZXIudHJpZ2dlcihldmVudHNfMS5kZWZhdWx0LkVSUk9SLCB7IHR5cGU6IGVycm9yc18xLkVycm9yVHlwZXMuTVVYX0VSUk9SLCBkZXRhaWxzOiBlcnJvcnNfMS5FcnJvckRldGFpbHMuUkVNVVhfQUxMT0NfRVJST1IsIGZhdGFsOiBmYWxzZSwgYnl0ZXM6IG1kYXRTaXplLCByZWFzb246IFwiZmFpbCBhbGxvY2F0aW5nIGF1ZGlvIG1kYXQgXCIgKyBtZGF0U2l6ZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIXJhd01QRUcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2aWV3ID0gbmV3IERhdGFWaWV3KG1kYXQuYnVmZmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpZXcuc2V0VWludDMyKDAsIG1kYXRTaXplKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1kYXQuc2V0KG1wNF9nZW5lcmF0b3JfMS5kZWZhdWx0LnR5cGVzLm1kYXQsIDQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBubyBhdWRpbyBzYW1wbGVzXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1NaXNzaW5nRnJhbWVzOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgZmlsbEZyYW1lID0gYWFjX2hlbHBlcl8xLmRlZmF1bHQuZ2V0U2lsZW50RnJhbWUodHJhY2subWFuaWZlc3RDb2RlYyB8fCB0cmFjay5jb2RlYywgdHJhY2suY2hhbm5lbENvdW50KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFmaWxsRnJhbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmxvZ2dlci5sb2coJ1VuYWJsZSB0byBnZXQgc2lsZW50IGZyYW1lIGZvciBnaXZlbiBhdWRpbyBjb2RlYzsgZHVwbGljYXRpbmcgdGhpcyBmcmFtZSBpbnN0ZWFkLicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlsbEZyYW1lID0gdW5pdC5zdWJhcnJheSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG1kYXQuc2V0KGZpbGxGcmFtZSwgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ICs9IGZpbGxGcmFtZS5ieXRlTGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBtcDRTYW1wbGUgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaXplOiBmaWxsRnJhbWUuYnl0ZUxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0czogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGR1cmF0aW9uOiAxMDI0LFxuICAgICAgICAgICAgICAgICAgICAgICAgZmxhZ3M6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0xlYWRpbmc6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNEZXBlbmRlZE9uOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhc1JlZHVuZGFuY3k6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVncmFkUHJpbzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXBlbmRzT246IDFcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0U2FtcGxlcy5wdXNoKG1wNFNhbXBsZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWRhdC5zZXQodW5pdCwgb2Zmc2V0KTtcbiAgICAgICAgICAgIHZhciB1bml0TGVuID0gdW5pdC5ieXRlTGVuZ3RoO1xuICAgICAgICAgICAgb2Zmc2V0ICs9IHVuaXRMZW47XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnUFRTL0RUUy9pbml0RFRTL25vcm1QVFMvbm9ybURUUy9yZWxhdGl2ZSBQVFMgOiAke2F1ZGlvU2FtcGxlLnB0c30vJHthdWRpb1NhbXBsZS5kdHN9LyR7aW5pdERUU30vJHtwdHNub3JtfS8ke2R0c25vcm19LyR7KGF1ZGlvU2FtcGxlLnB0cy80Mjk0OTY3Mjk2KS50b0ZpeGVkKDMpfScpO1xuICAgICAgICAgICAgbXA0U2FtcGxlID0ge1xuICAgICAgICAgICAgICAgIHNpemU6IHVuaXRMZW4sXG4gICAgICAgICAgICAgICAgY3RzOiAwLFxuICAgICAgICAgICAgICAgIGR1cmF0aW9uOiAwLFxuICAgICAgICAgICAgICAgIGZsYWdzOiB7XG4gICAgICAgICAgICAgICAgICAgIGlzTGVhZGluZzogMCxcbiAgICAgICAgICAgICAgICAgICAgaXNEZXBlbmRlZE9uOiAwLFxuICAgICAgICAgICAgICAgICAgICBoYXNSZWR1bmRhbmN5OiAwLFxuICAgICAgICAgICAgICAgICAgICBkZWdyYWRQcmlvOiAwLFxuICAgICAgICAgICAgICAgICAgICBkZXBlbmRzT246IDFcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgb3V0cHV0U2FtcGxlcy5wdXNoKG1wNFNhbXBsZSk7XG4gICAgICAgICAgICBsYXN0UFRTID0gcHRzO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsYXN0U2FtcGxlRHVyYXRpb24gPSAwO1xuICAgICAgICB2YXIgbmJTYW1wbGVzID0gb3V0cHV0U2FtcGxlcy5sZW5ndGg7XG4gICAgICAgIC8vIHNldCBsYXN0IHNhbXBsZSBkdXJhdGlvbiBhcyBiZWluZyBpZGVudGljYWwgdG8gcHJldmlvdXMgc2FtcGxlXG4gICAgICAgIGlmIChuYlNhbXBsZXMgPj0gMikge1xuICAgICAgICAgICAgbGFzdFNhbXBsZUR1cmF0aW9uID0gb3V0cHV0U2FtcGxlc1tuYlNhbXBsZXMgLSAyXS5kdXJhdGlvbjtcbiAgICAgICAgICAgIG1wNFNhbXBsZS5kdXJhdGlvbiA9IGxhc3RTYW1wbGVEdXJhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmJTYW1wbGVzKSB7XG4gICAgICAgICAgICAvLyBuZXh0IGF1ZGlvIHNhbXBsZSBQVFMgc2hvdWxkIGJlIGVxdWFsIHRvIGxhc3Qgc2FtcGxlIFBUUyArIGR1cmF0aW9uXG4gICAgICAgICAgICB0aGlzLm5leHRBdWRpb1B0cyA9IG5leHRBdWRpb1B0cyA9IGxhc3RQVFMgKyBzY2FsZUZhY3RvciAqIGxhc3RTYW1wbGVEdXJhdGlvbjtcbiAgICAgICAgICAgIC8vIGxvZ2dlci5sb2coJ0F1ZGlvL1BUUy9QVFNlbmQ6JyArIGF1ZGlvU2FtcGxlLnB0cy50b0ZpeGVkKDApICsgJy8nICsgdGhpcy5uZXh0QWFjRHRzLnRvRml4ZWQoMCkpO1xuICAgICAgICAgICAgdHJhY2subGVuID0gMDtcbiAgICAgICAgICAgIHRyYWNrLnNhbXBsZXMgPSBvdXRwdXRTYW1wbGVzO1xuICAgICAgICAgICAgaWYgKHJhd01QRUcpIHtcbiAgICAgICAgICAgICAgICBtb29mID0gbmV3IFVpbnQ4QXJyYXkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG1vb2YgPSBtcDRfZ2VuZXJhdG9yXzEuZGVmYXVsdC5tb29mKHRyYWNrLnNlcXVlbmNlTnVtYmVyKyssIGZpcnN0UFRTIC8gc2NhbGVGYWN0b3IsIHRyYWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyYWNrLnNhbXBsZXMgPSBbXTtcbiAgICAgICAgICAgIHZhciBzdGFydCA9IGZpcnN0UFRTIC8gaW5wdXRUaW1lU2NhbGU7XG4gICAgICAgICAgICB2YXIgZW5kID0gbmV4dEF1ZGlvUHRzIC8gaW5wdXRUaW1lU2NhbGU7XG4gICAgICAgICAgICB2YXIgYXVkaW9EYXRhID0ge1xuICAgICAgICAgICAgICAgIGRhdGExOiBtb29mLFxuICAgICAgICAgICAgICAgIGRhdGEyOiBtZGF0LFxuICAgICAgICAgICAgICAgIHN0YXJ0UFRTOiBzdGFydCxcbiAgICAgICAgICAgICAgICBlbmRQVFM6IGVuZCxcbiAgICAgICAgICAgICAgICBzdGFydERUUzogc3RhcnQsXG4gICAgICAgICAgICAgICAgZW5kRFRTOiBlbmQsXG4gICAgICAgICAgICAgICAgdHlwZTogJ2F1ZGlvJyxcbiAgICAgICAgICAgICAgICBoYXNBdWRpbzogdHJ1ZSxcbiAgICAgICAgICAgICAgICBoYXNWaWRlbzogZmFsc2UsXG4gICAgICAgICAgICAgICAgbmI6IG5iU2FtcGxlc1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMub2JzZXJ2ZXIudHJpZ2dlcihldmVudHNfMS5kZWZhdWx0LkZSQUdfUEFSU0lOR19EQVRBLCBhdWRpb0RhdGEpO1xuICAgICAgICAgICAgcmV0dXJuIGF1ZGlvRGF0YTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIE1QNFJlbXV4ZXIucHJvdG90eXBlLnJlbXV4RW1wdHlBdWRpbyA9IGZ1bmN0aW9uICh0cmFjaywgdGltZU9mZnNldCwgY29udGlndW91cywgdmlkZW9EYXRhKSB7XG4gICAgICAgIHZhciBpbnB1dFRpbWVTY2FsZSA9IHRyYWNrLmlucHV0VGltZVNjYWxlLCBtcDR0aW1lU2NhbGUgPSB0cmFjay5zYW1wbGVyYXRlID8gdHJhY2suc2FtcGxlcmF0ZSA6IGlucHV0VGltZVNjYWxlLCBzY2FsZUZhY3RvciA9IGlucHV0VGltZVNjYWxlIC8gbXA0dGltZVNjYWxlLCBuZXh0QXVkaW9QdHMgPSB0aGlzLm5leHRBdWRpb1B0cywgXG4gICAgICAgIC8vIHN5bmMgd2l0aCB2aWRlbydzIHRpbWVzdGFtcFxuICAgICAgICBzdGFydERUUyA9IChuZXh0QXVkaW9QdHMgIT09IHVuZGVmaW5lZCA/IG5leHRBdWRpb1B0cyA6IHZpZGVvRGF0YS5zdGFydERUUyAqIGlucHV0VGltZVNjYWxlKSArIHRoaXMuX2luaXREVFMsIGVuZERUUyA9IHZpZGVvRGF0YS5lbmREVFMgKiBpbnB1dFRpbWVTY2FsZSArIHRoaXMuX2luaXREVFMsIFxuICAgICAgICAvLyBvbmUgc2FtcGxlJ3MgZHVyYXRpb24gdmFsdWVcbiAgICAgICAgc2FtcGxlRHVyYXRpb24gPSAxMDI0LCBmcmFtZUR1cmF0aW9uID0gc2NhbGVGYWN0b3IgKiBzYW1wbGVEdXJhdGlvbiwgXG4gICAgICAgIC8vIHNhbXBsZXMgY291bnQgb2YgdGhpcyBzZWdtZW50J3MgZHVyYXRpb25cbiAgICAgICAgbmJTYW1wbGVzID0gTWF0aC5jZWlsKChlbmREVFMgLSBzdGFydERUUykgLyBmcmFtZUR1cmF0aW9uKSwgXG4gICAgICAgIC8vIHNpbGVudCBmcmFtZVxuICAgICAgICBzaWxlbnRGcmFtZSA9IGFhY19oZWxwZXJfMS5kZWZhdWx0LmdldFNpbGVudEZyYW1lKHRyYWNrLm1hbmlmZXN0Q29kZWMgfHwgdHJhY2suY29kZWMsIHRyYWNrLmNoYW5uZWxDb3VudCk7XG4gICAgICAgIGxvZ2dlcl8xLmxvZ2dlci53YXJuKCdyZW11eCBlbXB0eSBBdWRpbycpO1xuICAgICAgICAvLyBDYW4ndCByZW11eCBpZiB3ZSBjYW4ndCBnZW5lcmF0ZSBhIHNpbGVudCBmcmFtZS4uLlxuICAgICAgICBpZiAoIXNpbGVudEZyYW1lKSB7XG4gICAgICAgICAgICBsb2dnZXJfMS5sb2dnZXIudHJhY2UoJ1VuYWJsZSB0byByZW11eEVtcHR5QXVkaW8gc2luY2Ugd2Ugd2VyZSB1bmFibGUgdG8gZ2V0IGEgc2lsZW50IGZyYW1lIGZvciBnaXZlbiBhdWRpbyBjb2RlYyEnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2FtcGxlcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5iU2FtcGxlczsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgc3RhbXAgPSBzdGFydERUUyArIGkgKiBmcmFtZUR1cmF0aW9uO1xuICAgICAgICAgICAgc2FtcGxlcy5wdXNoKHsgdW5pdDogc2lsZW50RnJhbWUsIHB0czogc3RhbXAsIGR0czogc3RhbXAgfSk7XG4gICAgICAgICAgICB0cmFjay5sZW4gKz0gc2lsZW50RnJhbWUubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHRyYWNrLnNhbXBsZXMgPSBzYW1wbGVzO1xuICAgICAgICB0aGlzLnJlbXV4QXVkaW8odHJhY2ssIHRpbWVPZmZzZXQsIGNvbnRpZ3VvdXMpO1xuICAgIH07XG4gICAgTVA0UmVtdXhlci5wcm90b3R5cGUucmVtdXhJRDMgPSBmdW5jdGlvbiAodHJhY2spIHtcbiAgICAgICAgdmFyIGxlbmd0aCA9IHRyYWNrLnNhbXBsZXMubGVuZ3RoLCBzYW1wbGU7XG4gICAgICAgIHZhciBpbnB1dFRpbWVTY2FsZSA9IHRyYWNrLmlucHV0VGltZVNjYWxlO1xuICAgICAgICB2YXIgaW5pdFBUUyA9IHRoaXMuX2luaXRQVFM7XG4gICAgICAgIHZhciBpbml0RFRTID0gdGhpcy5faW5pdERUUztcbiAgICAgICAgLy8gY29uc3VtZSBzYW1wbGVzXG4gICAgICAgIGlmIChsZW5ndGgpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgICAgICBzYW1wbGUgPSB0cmFjay5zYW1wbGVzW2luZGV4XTtcbiAgICAgICAgICAgICAgICAvLyBzZXR0aW5nIGlkMyBwdHMsIGR0cyB0byByZWxhdGl2ZSB0aW1lXG4gICAgICAgICAgICAgICAgLy8gdXNpbmcgdGhpcy5faW5pdFBUUyBhbmQgdGhpcy5faW5pdERUUyB0byBjYWxjdWxhdGUgcmVsYXRpdmUgdGltZVxuICAgICAgICAgICAgICAgIHNhbXBsZS5wdHMgPSAoKHNhbXBsZS5wdHMgLSBpbml0UFRTKSAvIGlucHV0VGltZVNjYWxlKTtcbiAgICAgICAgICAgICAgICBzYW1wbGUuZHRzID0gKChzYW1wbGUuZHRzIC0gaW5pdERUUykgLyBpbnB1dFRpbWVTY2FsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm9ic2VydmVyLnRyaWdnZXIoZXZlbnRzXzEuZGVmYXVsdC5GUkFHX1BBUlNJTkdfTUVUQURBVEEsIHtcbiAgICAgICAgICAgICAgICBzYW1wbGVzOiB0cmFjay5zYW1wbGVzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0cmFjay5zYW1wbGVzID0gW107XG4gICAgfTtcbiAgICBNUDRSZW11eGVyLnByb3RvdHlwZS5yZW11eFRleHQgPSBmdW5jdGlvbiAodHJhY2spIHtcbiAgICAgICAgdHJhY2suc2FtcGxlcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gKGEucHRzIC0gYi5wdHMpO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGxlbmd0aCA9IHRyYWNrLnNhbXBsZXMubGVuZ3RoLCBzYW1wbGU7XG4gICAgICAgIHZhciBpbnB1dFRpbWVTY2FsZSA9IHRyYWNrLmlucHV0VGltZVNjYWxlO1xuICAgICAgICB2YXIgaW5pdFBUUyA9IHRoaXMuX2luaXRQVFM7XG4gICAgICAgIC8vIGNvbnN1bWUgc2FtcGxlc1xuICAgICAgICBpZiAobGVuZ3RoKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgc2FtcGxlID0gdHJhY2suc2FtcGxlc1tpbmRleF07XG4gICAgICAgICAgICAgICAgLy8gc2V0dGluZyB0ZXh0IHB0cywgZHRzIHRvIHJlbGF0aXZlIHRpbWVcbiAgICAgICAgICAgICAgICAvLyB1c2luZyB0aGlzLl9pbml0UFRTIGFuZCB0aGlzLl9pbml0RFRTIHRvIGNhbGN1bGF0ZSByZWxhdGl2ZSB0aW1lXG4gICAgICAgICAgICAgICAgc2FtcGxlLnB0cyA9ICgoc2FtcGxlLnB0cyAtIGluaXRQVFMpIC8gaW5wdXRUaW1lU2NhbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5vYnNlcnZlci50cmlnZ2VyKGV2ZW50c18xLmRlZmF1bHQuRlJBR19QQVJTSU5HX1VTRVJEQVRBLCB7XG4gICAgICAgICAgICAgICAgc2FtcGxlczogdHJhY2suc2FtcGxlc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdHJhY2suc2FtcGxlcyA9IFtdO1xuICAgIH07XG4gICAgTVA0UmVtdXhlci5wcm90b3R5cGUuX1BUU05vcm1hbGl6ZSA9IGZ1bmN0aW9uICh2YWx1ZSwgcmVmZXJlbmNlKSB7XG4gICAgICAgIHZhciBvZmZzZXQ7XG4gICAgICAgIGlmIChyZWZlcmVuY2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZWZlcmVuY2UgPCB2YWx1ZSkge1xuICAgICAgICAgICAgLy8gLSAyXjMzXG4gICAgICAgICAgICBvZmZzZXQgPSAtODU4OTkzNDU5MjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vICsgMl4zM1xuICAgICAgICAgICAgb2Zmc2V0ID0gODU4OTkzNDU5MjtcbiAgICAgICAgfVxuICAgICAgICAvKiBQVFMgaXMgMzNiaXQgKGZyb20gMCB0byAyXjMzIC0xKVxuICAgICAgICAgIGlmIGRpZmYgYmV0d2VlbiB2YWx1ZSBhbmQgcmVmZXJlbmNlIGlzIGJpZ2dlciB0aGFuIGhhbGYgb2YgdGhlIGFtcGxpdHVkZSAoMl4zMikgdGhlbiBpdCBtZWFucyB0aGF0XG4gICAgICAgICAgUFRTIGxvb3Bpbmcgb2NjdXJlZC4gZmlsbCB0aGUgZ2FwICovXG4gICAgICAgIHdoaWxlIChNYXRoLmFicyh2YWx1ZSAtIHJlZmVyZW5jZSkgPiA0Mjk0OTY3Mjk2KSB7XG4gICAgICAgICAgICB2YWx1ZSArPSBvZmZzZXQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG4gICAgcmV0dXJuIE1QNFJlbXV4ZXI7XG59KCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gTVA0UmVtdXhlcjtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9yZW11eC9wYXNzdGhyb3VnaC1yZW11eGVyLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvcmVtdXgvcGFzc3Rocm91Z2gtcmVtdXhlci5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIHBhc3N0aHJvdWdoIHJlbXV4ZXJcbiovXG52YXIgZXZlbnRzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9ldmVudHMgKi8gXCIuL3NyYy9ldmVudHMuanNcIik7XG52YXIgUGFzc1Rocm91Z2hSZW11eGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFBhc3NUaHJvdWdoUmVtdXhlcihvYnNlcnZlcikge1xuICAgICAgICB0aGlzLm9ic2VydmVyID0gb2JzZXJ2ZXI7XG4gICAgfVxuICAgIFBhc3NUaHJvdWdoUmVtdXhlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICB9O1xuICAgIFBhc3NUaHJvdWdoUmVtdXhlci5wcm90b3R5cGUucmVzZXRUaW1lU3RhbXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgfTtcbiAgICBQYXNzVGhyb3VnaFJlbXV4ZXIucHJvdG90eXBlLnJlc2V0SW5pdFNlZ21lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgfTtcbiAgICBQYXNzVGhyb3VnaFJlbXV4ZXIucHJvdG90eXBlLnJlbXV4ID0gZnVuY3Rpb24gKGF1ZGlvVHJhY2ssIHZpZGVvVHJhY2ssIGlkM1RyYWNrLCB0ZXh0VHJhY2ssIHRpbWVPZmZzZXQsIGNvbnRpZ3VvdXMsIGFjY3VyYXRlVGltZU9mZnNldCwgcmF3RGF0YSkge1xuICAgICAgICB2YXIgb2JzZXJ2ZXIgPSB0aGlzLm9ic2VydmVyO1xuICAgICAgICB2YXIgc3RyZWFtVHlwZSA9ICcnO1xuICAgICAgICBpZiAoYXVkaW9UcmFjaykge1xuICAgICAgICAgICAgc3RyZWFtVHlwZSArPSAnYXVkaW8nO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2aWRlb1RyYWNrKSB7XG4gICAgICAgICAgICBzdHJlYW1UeXBlICs9ICd2aWRlbyc7XG4gICAgICAgIH1cbiAgICAgICAgb2JzZXJ2ZXIudHJpZ2dlcihldmVudHNfMS5kZWZhdWx0LkZSQUdfUEFSU0lOR19EQVRBLCB7XG4gICAgICAgICAgICBkYXRhMTogcmF3RGF0YSxcbiAgICAgICAgICAgIHN0YXJ0UFRTOiB0aW1lT2Zmc2V0LFxuICAgICAgICAgICAgc3RhcnREVFM6IHRpbWVPZmZzZXQsXG4gICAgICAgICAgICB0eXBlOiBzdHJlYW1UeXBlLFxuICAgICAgICAgICAgaGFzQXVkaW86ICEhYXVkaW9UcmFjayxcbiAgICAgICAgICAgIGhhc1ZpZGVvOiAhIXZpZGVvVHJhY2ssXG4gICAgICAgICAgICBuYjogMSxcbiAgICAgICAgICAgIGRyb3BwZWQ6IDBcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIG5vdGlmeSBlbmQgb2YgcGFyc2luZ1xuICAgICAgICBvYnNlcnZlci50cmlnZ2VyKGV2ZW50c18xLmRlZmF1bHQuRlJBR19QQVJTRUQpO1xuICAgIH07XG4gICAgcmV0dXJuIFBhc3NUaHJvdWdoUmVtdXhlcjtcbn0oKSk7XG5leHBvcnRzLmRlZmF1bHQgPSBQYXNzVGhyb3VnaFJlbXV4ZXI7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvdGFzay1sb29wLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy90YXNrLWxvb3AuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBldmVudF9oYW5kbGVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2V2ZW50LWhhbmRsZXIgKi8gXCIuL3NyYy9ldmVudC1oYW5kbGVyLmpzXCIpO1xuLyoqXG4gKiBTdWItY2xhc3Mgc3BlY2lhbGl6YXRpb24gb2YgRXZlbnRIYW5kbGVyIGJhc2UgY2xhc3MuXG4gKlxuICogVGFza0xvb3AgYWxsb3dzIHRvIHNjaGVkdWxlIGEgdGFzayBmdW5jdGlvbiBiZWluZyBjYWxsZWQgKG9wdGlvbm5hbHkgcmVwZWF0ZWRseSkgb24gdGhlIG1haW4gbG9vcCxcbiAqIHNjaGVkdWxlZCBhc3luY2hyb25lb3VzbHksIGF2b2lkaW5nIHJlY3Vyc2l2ZSBjYWxscyBpbiB0aGUgc2FtZSB0aWNrLlxuICpcbiAqIFRoZSB0YXNrIGl0c2VsZiBpcyBpbXBsZW1lbnRlZCBpbiBgZG9UaWNrYC4gSXQgY2FuIGJlIHJlcXVlc3RlZCBhbmQgY2FsbGVkIGZvciBzaW5nbGUgZXhlY3V0aW9uXG4gKiB1c2luZyB0aGUgYHRpY2tgIG1ldGhvZC5cbiAqXG4gKiBJdCB3aWxsIGJlIGFzc3VyZWQgdGhhdCB0aGUgdGFzayBleGVjdXRpb24gbWV0aG9kIChgdGlja2ApIG9ubHkgZ2V0cyBjYWxsZWQgb25jZSBwZXIgbWFpbiBsb29wIFwidGlja1wiLFxuICogbm8gbWF0dGVyIGhvdyBvZnRlbiBpdCBnZXRzIHJlcXVlc3RlZCBmb3IgZXhlY3V0aW9uLiBFeGVjdXRpb24gaW4gZnVydGhlciB0aWNrcyB3aWxsIGJlIHNjaGVkdWxlZCBhY2NvcmRpbmdseS5cbiAqXG4gKiBJZiBmdXJ0aGVyIGV4ZWN1dGlvbiByZXF1ZXN0cyBoYXZlIGFscmVhZHkgYmVlbiBzY2hlZHVsZWQgb24gdGhlIG5leHQgdGljaywgaXQgY2FuIGJlIGNoZWNrZWQgd2l0aCBgaGFzTmV4dFRpY2tgLFxuICogYW5kIGNhbmNlbGxlZCB3aXRoIGBjbGVhck5leHRUaWNrYC5cbiAqXG4gKiBUaGUgdGFzayBjYW4gYmUgc2NoZWR1bGVkIGFzIGFuIGludGVydmFsIHJlcGVhdGVkbHkgd2l0aCBhIHBlcmlvZCBhcyBwYXJhbWV0ZXIgKHNlZSBgc2V0SW50ZXJ2YWxgLCBgY2xlYXJJbnRlcnZhbGApLlxuICpcbiAqIFN1Yi1jbGFzc2VzIG5lZWQgdG8gaW1wbGVtZW50IHRoZSBgZG9UaWNrYCBtZXRob2Qgd2hpY2ggd2lsbCBlZmZlY3RpdmVseSBoYXZlIHRoZSB0YXNrIGV4ZWN1dGlvbiByb3V0aW5lLlxuICpcbiAqIEZ1cnRoZXIgZXhwbGFuYXRpb25zOlxuICpcbiAqIFRoZSBiYXNlY2xhc3MgaGFzIGEgYHRpY2tgIG1ldGhvZCB0aGF0IHdpbGwgc2NoZWR1bGUgdGhlIGRvVGljayBjYWxsLiBJdCBtYXkgYmUgY2FsbGVkIHN5bmNocm9uZW91c2x5XG4gKiBvbmx5IGZvciBhIHN0YWNrLWRlcHRoIG9mIG9uZS4gT24gcmUtZW50cmFudCBjYWxscywgc3ViLXNlcXVlbnQgY2FsbHMgYXJlIHNjaGVkdWxlZCBmb3IgbmV4dCBtYWluIGxvb3AgdGlja3MuXG4gKlxuICogV2hlbiB0aGUgdGFzayBleGVjdXRpb24gKGB0aWNrYCBtZXRob2QpIGlzIGNhbGxlZCBpbiByZS1lbnRyYW50IHdheSB0aGlzIGlzIGRldGVjdGVkIGFuZFxuICogd2UgYXJlIGxpbWl0aW5nIHRoZSB0YXNrIGV4ZWN1dGlvbiBwZXIgY2FsbCBzdGFjayB0byBleGFjdGx5IG9uZSwgYnV0IHNjaGVkdWxpbmcvcG9zdC1wb25pbmcgZnVydGhlclxuICogdGFzayBwcm9jZXNzaW5nIG9uIHRoZSBuZXh0IG1haW4gbG9vcCBpdGVyYXRpb24gKGFsc28ga25vd24gYXMgXCJuZXh0IHRpY2tcIiBpbiB0aGUgTm9kZS9KUyBydW50aW1lIGxpbmdvKS5cbiAqL1xudmFyIFRhc2tMb29wID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhUYXNrTG9vcCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUYXNrTG9vcChobHMpIHtcbiAgICAgICAgdmFyIGV2ZW50cyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgZXZlbnRzW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5hcHBseSh0aGlzLCBbaGxzXS5jb25jYXQoZXZlbnRzKSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuX3RpY2tJbnRlcnZhbCA9IG51bGw7XG4gICAgICAgIF90aGlzLl90aWNrVGltZXIgPSBudWxsO1xuICAgICAgICBfdGhpcy5fdGlja0NhbGxDb3VudCA9IDA7XG4gICAgICAgIF90aGlzLl9ib3VuZFRpY2sgPSBfdGhpcy50aWNrLmJpbmQoX3RoaXMpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICAgIFRhc2tMb29wLnByb3RvdHlwZS5vbkhhbmRsZXJEZXN0cm95aW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBjbGVhciBhbGwgdGltZXJzIGJlZm9yZSB1bnJlZ2lzdGVyaW5nIGZyb20gZXZlbnQgYnVzXG4gICAgICAgIHRoaXMuY2xlYXJOZXh0VGljaygpO1xuICAgICAgICB0aGlzLmNsZWFySW50ZXJ2YWwoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIFRhc2tMb29wLnByb3RvdHlwZS5oYXNJbnRlcnZhbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fdGlja0ludGVydmFsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgVGFza0xvb3AucHJvdG90eXBlLmhhc05leHRUaWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl90aWNrVGltZXI7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWlsbGlzIEludGVydmFsIHRpbWUgKG1zKVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIHdoZW4gaW50ZXJ2YWwgaGFzIGJlZW4gc2NoZWR1bGVkLCBmYWxzZSB3aGVuIGFscmVhZHkgc2NoZWR1bGVkIChubyBlZmZlY3QpXG4gICAgICovXG4gICAgVGFza0xvb3AucHJvdG90eXBlLnNldEludGVydmFsID0gZnVuY3Rpb24gKG1pbGxpcykge1xuICAgICAgICBpZiAoIXRoaXMuX3RpY2tJbnRlcnZhbCkge1xuICAgICAgICAgICAgdGhpcy5fdGlja0ludGVydmFsID0gc2V0SW50ZXJ2YWwodGhpcy5fYm91bmRUaWNrLCBtaWxsaXMpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgd2hlbiBpbnRlcnZhbCB3YXMgY2xlYXJlZCwgZmFsc2Ugd2hlbiBub25lIHdhcyBzZXQgKG5vIGVmZmVjdClcbiAgICAgKi9cbiAgICBUYXNrTG9vcC5wcm90b3R5cGUuY2xlYXJJbnRlcnZhbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3RpY2tJbnRlcnZhbCkge1xuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLl90aWNrSW50ZXJ2YWwpO1xuICAgICAgICAgICAgdGhpcy5fdGlja0ludGVydmFsID0gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIHdoZW4gdGltZW91dCB3YXMgY2xlYXJlZCwgZmFsc2Ugd2hlbiBub25lIHdhcyBzZXQgKG5vIGVmZmVjdClcbiAgICAgKi9cbiAgICBUYXNrTG9vcC5wcm90b3R5cGUuY2xlYXJOZXh0VGljayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3RpY2tUaW1lcikge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3RpY2tUaW1lcik7XG4gICAgICAgICAgICB0aGlzLl90aWNrVGltZXIgPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogV2lsbCBjYWxsIHRoZSBzdWJjbGFzcyBkb1RpY2sgaW1wbGVtZW50YXRpb24gaW4gdGhpcyBtYWluIGxvb3AgdGlja1xuICAgICAqIG9yIGluIHRoZSBuZXh0IG9uZSAodmlhIHNldFRpbWVvdXQoLDApKSBpbiBjYXNlIGl0IGhhcyBhbHJlYWR5IGJlZW4gY2FsbGVkXG4gICAgICogaW4gdGhpcyB0aWNrIChpbiBjYXNlIHRoaXMgaXMgYSByZS1lbnRyYW50IGNhbGwpLlxuICAgICAqL1xuICAgIFRhc2tMb29wLnByb3RvdHlwZS50aWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl90aWNrQ2FsbENvdW50Kys7XG4gICAgICAgIGlmICh0aGlzLl90aWNrQ2FsbENvdW50ID09PSAxKSB7XG4gICAgICAgICAgICB0aGlzLmRvVGljaygpO1xuICAgICAgICAgICAgLy8gcmUtZW50cmFudCBjYWxsIHRvIHRpY2sgZnJvbSBwcmV2aW91cyBkb1RpY2sgY2FsbCBzdGFja1xuICAgICAgICAgICAgLy8gLT4gc2NoZWR1bGUgYSBjYWxsIG9uIHRoZSBuZXh0IG1haW4gbG9vcCBpdGVyYXRpb24gdG8gcHJvY2VzcyB0aGlzIHRhc2sgcHJvY2Vzc2luZyByZXF1ZXN0XG4gICAgICAgICAgICBpZiAodGhpcy5fdGlja0NhbGxDb3VudCA+IDEpIHtcbiAgICAgICAgICAgICAgICAvLyBtYWtlIHN1cmUgb25seSBvbmUgdGltZXIgZXhpc3RzIGF0IGFueSB0aW1lIGF0IG1heFxuICAgICAgICAgICAgICAgIHRoaXMuY2xlYXJOZXh0VGljaygpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3RpY2tUaW1lciA9IHNldFRpbWVvdXQodGhpcy5fYm91bmRUaWNrLCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3RpY2tDYWxsQ291bnQgPSAwO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBGb3Igc3ViY2xhc3MgdG8gaW1wbGVtZW50IHRhc2sgbG9naWNcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKi9cbiAgICBUYXNrTG9vcC5wcm90b3R5cGUuZG9UaWNrID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgIHJldHVybiBUYXNrTG9vcDtcbn0oZXZlbnRfaGFuZGxlcl8xLmRlZmF1bHQpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IFRhc2tMb29wO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3V0aWxzL2F0dHItbGlzdC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvdXRpbHMvYXR0ci1saXN0LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihOdW1iZXIpIHtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBERUNJTUFMX1JFU09MVVRJT05fUkVHRVggPSAvXihcXGQrKXgoXFxkKykkLzsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11c2VsZXNzLWVzY2FwZVxudmFyIEFUVFJfTElTVF9SRUdFWCA9IC9cXHMqKC4rPylcXHMqPSgoPzpcXFwiLio/XFxcIil8Lio/KSg/Oix8JCkvZzsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11c2VsZXNzLWVzY2FwZVxuLy8gYWRhcHRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9rYW5vbmdpbC9ub2RlLW0zdThwYXJzZS9ibG9iL21hc3Rlci9hdHRybGlzdC5qc1xudmFyIEF0dHJMaXN0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEF0dHJMaXN0KGF0dHJzKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYXR0cnMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBhdHRycyA9IEF0dHJMaXN0LnBhcnNlQXR0ckxpc3QoYXR0cnMpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGF0dHIgaW4gYXR0cnMpIHtcbiAgICAgICAgICAgIGlmIChhdHRycy5oYXNPd25Qcm9wZXJ0eShhdHRyKSkge1xuICAgICAgICAgICAgICAgIHRoaXNbYXR0cl0gPSBhdHRyc1thdHRyXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBBdHRyTGlzdC5wcm90b3R5cGUuZGVjaW1hbEludGVnZXIgPSBmdW5jdGlvbiAoYXR0ck5hbWUpIHtcbiAgICAgICAgdmFyIGludFZhbHVlID0gcGFyc2VJbnQodGhpc1thdHRyTmFtZV0sIDEwKTtcbiAgICAgICAgaWYgKGludFZhbHVlID4gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpIHtcbiAgICAgICAgICAgIHJldHVybiBJbmZpbml0eTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW50VmFsdWU7XG4gICAgfTtcbiAgICBBdHRyTGlzdC5wcm90b3R5cGUuaGV4YWRlY2ltYWxJbnRlZ2VyID0gZnVuY3Rpb24gKGF0dHJOYW1lKSB7XG4gICAgICAgIGlmICh0aGlzW2F0dHJOYW1lXSkge1xuICAgICAgICAgICAgdmFyIHN0cmluZ1ZhbHVlID0gKHRoaXNbYXR0ck5hbWVdIHx8ICcweCcpLnNsaWNlKDIpO1xuICAgICAgICAgICAgc3RyaW5nVmFsdWUgPSAoKHN0cmluZ1ZhbHVlLmxlbmd0aCAmIDEpID8gJzAnIDogJycpICsgc3RyaW5nVmFsdWU7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBuZXcgVWludDhBcnJheShzdHJpbmdWYWx1ZS5sZW5ndGggLyAyKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyaW5nVmFsdWUubGVuZ3RoIC8gMjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFsdWVbaV0gPSBwYXJzZUludChzdHJpbmdWYWx1ZS5zbGljZShpICogMiwgaSAqIDIgKyAyKSwgMTYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEF0dHJMaXN0LnByb3RvdHlwZS5oZXhhZGVjaW1hbEludGVnZXJBc051bWJlciA9IGZ1bmN0aW9uIChhdHRyTmFtZSkge1xuICAgICAgICB2YXIgaW50VmFsdWUgPSBwYXJzZUludCh0aGlzW2F0dHJOYW1lXSwgMTYpO1xuICAgICAgICBpZiAoaW50VmFsdWUgPiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUikge1xuICAgICAgICAgICAgcmV0dXJuIEluZmluaXR5O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbnRWYWx1ZTtcbiAgICB9O1xuICAgIEF0dHJMaXN0LnByb3RvdHlwZS5kZWNpbWFsRmxvYXRpbmdQb2ludCA9IGZ1bmN0aW9uIChhdHRyTmFtZSkge1xuICAgICAgICByZXR1cm4gcGFyc2VGbG9hdCh0aGlzW2F0dHJOYW1lXSk7XG4gICAgfTtcbiAgICBBdHRyTGlzdC5wcm90b3R5cGUuZW51bWVyYXRlZFN0cmluZyA9IGZ1bmN0aW9uIChhdHRyTmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpc1thdHRyTmFtZV07XG4gICAgfTtcbiAgICBBdHRyTGlzdC5wcm90b3R5cGUuZGVjaW1hbFJlc29sdXRpb24gPSBmdW5jdGlvbiAoYXR0ck5hbWUpIHtcbiAgICAgICAgdmFyIHJlcyA9IERFQ0lNQUxfUkVTT0xVVElPTl9SRUdFWC5leGVjKHRoaXNbYXR0ck5hbWVdKTtcbiAgICAgICAgaWYgKHJlcyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgd2lkdGg6IHBhcnNlSW50KHJlc1sxXSwgMTApLFxuICAgICAgICAgICAgaGVpZ2h0OiBwYXJzZUludChyZXNbMl0sIDEwKVxuICAgICAgICB9O1xuICAgIH07XG4gICAgQXR0ckxpc3QucGFyc2VBdHRyTGlzdCA9IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICB2YXIgbWF0Y2gsIGF0dHJzID0ge307XG4gICAgICAgIEFUVFJfTElTVF9SRUdFWC5sYXN0SW5kZXggPSAwO1xuICAgICAgICB3aGlsZSAoKG1hdGNoID0gQVRUUl9MSVNUX1JFR0VYLmV4ZWMoaW5wdXQpKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gbWF0Y2hbMl0sIHF1b3RlID0gJ1wiJztcbiAgICAgICAgICAgIGlmICh2YWx1ZS5pbmRleE9mKHF1b3RlKSA9PT0gMCAmJlxuICAgICAgICAgICAgICAgIHZhbHVlLmxhc3RJbmRleE9mKHF1b3RlKSA9PT0gKHZhbHVlLmxlbmd0aCAtIDEpKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5zbGljZSgxLCAtMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhdHRyc1ttYXRjaFsxXV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXR0cnM7XG4gICAgfTtcbiAgICByZXR1cm4gQXR0ckxpc3Q7XG59KCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gQXR0ckxpc3Q7XG5cbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqL30uY2FsbCh0aGlzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3NyYy9wb2x5ZmlsbHMvbnVtYmVyICovIFwiLi9zcmMvcG9seWZpbGxzL251bWJlci5qc1wiKVtcIk51bWJlclwiXSkpXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3V0aWxzL2JpbmFyeS1zZWFyY2guanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy91dGlscy9iaW5hcnktc2VhcmNoLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qISBNb2R1bGVDb25jYXRlbmF0aW9uIGJhaWxvdXQ6IE1vZHVsZSBpcyBub3QgYW4gRUNNQVNjcmlwdCBtb2R1bGUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBCaW5hcnlTZWFyY2ggPSB7XG4gICAgLyoqXG4gICAgICAgKiBTZWFyY2hlcyBmb3IgYW4gaXRlbSBpbiBhbiBhcnJheSB3aGljaCBtYXRjaGVzIGEgY2VydGFpbiBjb25kaXRpb24uXG4gICAgICAgKiBUaGlzIHJlcXVpcmVzIHRoZSBjb25kaXRpb24gdG8gb25seSBtYXRjaCBvbmUgaXRlbSBpbiB0aGUgYXJyYXksXG4gICAgICAgKiBhbmQgZm9yIHRoZSBhcnJheSB0byBiZSBvcmRlcmVkLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7QXJyYXl9IGxpc3QgVGhlIGFycmF5IHRvIHNlYXJjaC5cbiAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbXBhcmlzb25GdW5jdGlvblxuICAgICAgICogICAgICBDYWxsZWQgYW5kIHByb3ZpZGVkIGEgY2FuZGlkYXRlIGl0ZW0gYXMgdGhlIGZpcnN0IGFyZ3VtZW50LlxuICAgICAgICogICAgICBTaG91bGQgcmV0dXJuOlxuICAgICAgICogICAgICAgICAgPiAtMSBpZiB0aGUgaXRlbSBzaG91bGQgYmUgbG9jYXRlZCBhdCBhIGxvd2VyIGluZGV4IHRoYW4gdGhlIHByb3ZpZGVkIGl0ZW0uXG4gICAgICAgKiAgICAgICAgICA+IDEgaWYgdGhlIGl0ZW0gc2hvdWxkIGJlIGxvY2F0ZWQgYXQgYSBoaWdoZXIgaW5kZXggdGhhbiB0aGUgcHJvdmlkZWQgaXRlbS5cbiAgICAgICAqICAgICAgICAgID4gMCBpZiB0aGUgaXRlbSBpcyB0aGUgaXRlbSB5b3UncmUgbG9va2luZyBmb3IuXG4gICAgICAgKlxuICAgICAgICogQHJldHVybiB7Kn0gVGhlIG9iamVjdCBpZiBpdCBpcyBmb3VuZCBvciBudWxsIG90aGVyd2lzZS5cbiAgICAgICAqL1xuICAgIHNlYXJjaDogZnVuY3Rpb24gKGxpc3QsIGNvbXBhcmlzb25GdW5jdGlvbikge1xuICAgICAgICB2YXIgbWluSW5kZXggPSAwO1xuICAgICAgICB2YXIgbWF4SW5kZXggPSBsaXN0Lmxlbmd0aCAtIDE7XG4gICAgICAgIHZhciBjdXJyZW50SW5kZXggPSBudWxsO1xuICAgICAgICB2YXIgY3VycmVudEVsZW1lbnQgPSBudWxsO1xuICAgICAgICB3aGlsZSAobWluSW5kZXggPD0gbWF4SW5kZXgpIHtcbiAgICAgICAgICAgIGN1cnJlbnRJbmRleCA9IChtaW5JbmRleCArIG1heEluZGV4KSAvIDIgfCAwO1xuICAgICAgICAgICAgY3VycmVudEVsZW1lbnQgPSBsaXN0W2N1cnJlbnRJbmRleF07XG4gICAgICAgICAgICB2YXIgY29tcGFyaXNvblJlc3VsdCA9IGNvbXBhcmlzb25GdW5jdGlvbihjdXJyZW50RWxlbWVudCk7XG4gICAgICAgICAgICBpZiAoY29tcGFyaXNvblJlc3VsdCA+IDApIHtcbiAgICAgICAgICAgICAgICBtaW5JbmRleCA9IGN1cnJlbnRJbmRleCArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjb21wYXJpc29uUmVzdWx0IDwgMCkge1xuICAgICAgICAgICAgICAgIG1heEluZGV4ID0gY3VycmVudEluZGV4IC0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBjdXJyZW50RWxlbWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gQmluYXJ5U2VhcmNoO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3V0aWxzL2J1ZmZlci1oZWxwZXIuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy91dGlscy9idWZmZXItaGVscGVyLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qISBNb2R1bGVDb25jYXRlbmF0aW9uIGJhaWxvdXQ6IE1vZHVsZSBpcyBub3QgYW4gRUNNQVNjcmlwdCBtb2R1bGUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogQG1vZHVsZSBCdWZmZXJIZWxwZXJcbiAqXG4gKiBQcm92aWRpbmcgbWV0aG9kcyBkZWFsaW5nIHdpdGggYnVmZmVyIGxlbmd0aCByZXRyaWV2YWwgZm9yIGV4YW1wbGUuXG4gKlxuICogSW4gZ2VuZXJhbCwgYSBoZWxwZXIgYXJvdW5kIEhUTUw1IE1lZGlhRWxlbWVudCBUaW1lUmFuZ2VzIGdhdGhlcmVkIGZyb20gYGJ1ZmZlcmVkYCBwcm9wZXJ0eS5cbiAqXG4gKiBBbHNvIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0hUTUxNZWRpYUVsZW1lbnQvYnVmZmVyZWRcbiovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgQnVmZmVySGVscGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEJ1ZmZlckhlbHBlcigpIHtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRydWUgaWYgYG1lZGlhYCdzIGJ1ZmZlcmVkIGluY2x1ZGUgYHBvc2l0aW9uYFxuICAgICAqIEBwYXJhbSB7SFRNTE1lZGlhRWxlbWVudHxTb3VyY2VCdWZmZXJ9IG1lZGlhXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBvc2l0aW9uXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgQnVmZmVySGVscGVyLmlzQnVmZmVyZWQgPSBmdW5jdGlvbiAobWVkaWEsIHBvc2l0aW9uKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAobWVkaWEpIHtcbiAgICAgICAgICAgICAgICB2YXIgYnVmZmVyZWQgPSBtZWRpYS5idWZmZXJlZDtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ1ZmZlcmVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwb3NpdGlvbiA+PSBidWZmZXJlZC5zdGFydChpKSAmJiBwb3NpdGlvbiA8PSBidWZmZXJlZC5lbmQoaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgLy8gdGhpcyBpcyB0byBjYXRjaFxuICAgICAgICAgICAgLy8gSW52YWxpZFN0YXRlRXJyb3I6IEZhaWxlZCB0byByZWFkIHRoZSAnYnVmZmVyZWQnIHByb3BlcnR5IGZyb20gJ1NvdXJjZUJ1ZmZlcic6XG4gICAgICAgICAgICAvLyBUaGlzIFNvdXJjZUJ1ZmZlciBoYXMgYmVlbiByZW1vdmVkIGZyb20gdGhlIHBhcmVudCBtZWRpYSBzb3VyY2VcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBCdWZmZXJIZWxwZXIuYnVmZmVySW5mbyA9IGZ1bmN0aW9uIChtZWRpYSwgcG9zLCBtYXhIb2xlRHVyYXRpb24pIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChtZWRpYSkge1xuICAgICAgICAgICAgICAgIHZhciB2YnVmZmVyZWQgPSBtZWRpYS5idWZmZXJlZCwgYnVmZmVyZWQgPSBbXSwgaSA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdmJ1ZmZlcmVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlcmVkLnB1c2goeyBzdGFydDogdmJ1ZmZlcmVkLnN0YXJ0KGkpLCBlbmQ6IHZidWZmZXJlZC5lbmQoaSkgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmJ1ZmZlcmVkSW5mbyhidWZmZXJlZCwgcG9zLCBtYXhIb2xlRHVyYXRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgLy8gdGhpcyBpcyB0byBjYXRjaFxuICAgICAgICAgICAgLy8gSW52YWxpZFN0YXRlRXJyb3I6IEZhaWxlZCB0byByZWFkIHRoZSAnYnVmZmVyZWQnIHByb3BlcnR5IGZyb20gJ1NvdXJjZUJ1ZmZlcic6XG4gICAgICAgICAgICAvLyBUaGlzIFNvdXJjZUJ1ZmZlciBoYXMgYmVlbiByZW1vdmVkIGZyb20gdGhlIHBhcmVudCBtZWRpYSBzb3VyY2VcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBsZW46IDAsIHN0YXJ0OiBwb3MsIGVuZDogcG9zLCBuZXh0U3RhcnQ6IHVuZGVmaW5lZCB9O1xuICAgIH07XG4gICAgQnVmZmVySGVscGVyLmJ1ZmZlcmVkSW5mbyA9IGZ1bmN0aW9uIChidWZmZXJlZCwgcG9zLCBtYXhIb2xlRHVyYXRpb24pIHtcbiAgICAgICAgdmFyIGJ1ZmZlcmVkMiA9IFtdLCBcbiAgICAgICAgLy8gYnVmZmVyU3RhcnQgYW5kIGJ1ZmZlckVuZCBhcmUgYnVmZmVyIGJvdW5kYXJpZXMgYXJvdW5kIGN1cnJlbnQgdmlkZW8gcG9zaXRpb25cbiAgICAgICAgYnVmZmVyTGVuLCBidWZmZXJTdGFydCwgYnVmZmVyRW5kLCBidWZmZXJTdGFydE5leHQsIGk7XG4gICAgICAgIC8vIHNvcnQgb24gYnVmZmVyLnN0YXJ0L3NtYWxsZXIgZW5kIChJRSBkb2VzIG5vdCBhbHdheXMgcmV0dXJuIHNvcnRlZCBidWZmZXJlZCByYW5nZSlcbiAgICAgICAgYnVmZmVyZWQuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgdmFyIGRpZmYgPSBhLnN0YXJ0IC0gYi5zdGFydDtcbiAgICAgICAgICAgIGlmIChkaWZmKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRpZmY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYi5lbmQgLSBhLmVuZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIHRoZXJlIG1pZ2h0IGJlIHNvbWUgc21hbGwgaG9sZXMgYmV0d2VlbiBidWZmZXIgdGltZSByYW5nZVxuICAgICAgICAvLyBjb25zaWRlciB0aGF0IGhvbGVzIHNtYWxsZXIgdGhhbiBtYXhIb2xlRHVyYXRpb24gYXJlIGlycmVsZXZhbnQgYW5kIGJ1aWxkIGFub3RoZXJcbiAgICAgICAgLy8gYnVmZmVyIHRpbWUgcmFuZ2UgcmVwcmVzZW50YXRpb25zIHRoYXQgZGlzY2FyZHMgdGhvc2UgaG9sZXNcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGJ1ZmZlcmVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgYnVmMmxlbiA9IGJ1ZmZlcmVkMi5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoYnVmMmxlbikge1xuICAgICAgICAgICAgICAgIHZhciBidWYyZW5kID0gYnVmZmVyZWQyW2J1ZjJsZW4gLSAxXS5lbmQ7XG4gICAgICAgICAgICAgICAgLy8gaWYgc21hbGwgaG9sZSAodmFsdWUgYmV0d2VlbiAwIG9yIG1heEhvbGVEdXJhdGlvbiApIG9yIG92ZXJsYXBwaW5nIChuZWdhdGl2ZSlcbiAgICAgICAgICAgICAgICBpZiAoKGJ1ZmZlcmVkW2ldLnN0YXJ0IC0gYnVmMmVuZCkgPCBtYXhIb2xlRHVyYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbWVyZ2Ugb3ZlcmxhcHBpbmcgdGltZSByYW5nZXNcbiAgICAgICAgICAgICAgICAgICAgLy8gdXBkYXRlIGxhc3RSYW5nZS5lbmQgb25seSBpZiBzbWFsbGVyIHRoYW4gaXRlbS5lbmRcbiAgICAgICAgICAgICAgICAgICAgLy8gZS5nLiAgWyAxLCAxNV0gd2l0aCAgWyAyLDhdID0+IFsgMSwxNV0gKG5vIG5lZWQgdG8gbW9kaWZ5IGxhc3RSYW5nZS5lbmQpXG4gICAgICAgICAgICAgICAgICAgIC8vIHdoZXJlYXMgWyAxLCA4XSB3aXRoICBbIDIsMTVdID0+IFsgMSwxNV0gKCBsYXN0UmFuZ2Ugc2hvdWxkIHN3aXRjaCBmcm9tIFsxLDhdIHRvIFsxLDE1XSlcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJ1ZmZlcmVkW2ldLmVuZCA+IGJ1ZjJlbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlcmVkMltidWYybGVuIC0gMV0uZW5kID0gYnVmZmVyZWRbaV0uZW5kO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBiaWcgaG9sZVxuICAgICAgICAgICAgICAgICAgICBidWZmZXJlZDIucHVzaChidWZmZXJlZFtpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gZmlyc3QgdmFsdWVcbiAgICAgICAgICAgICAgICBidWZmZXJlZDIucHVzaChidWZmZXJlZFtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpID0gMCwgYnVmZmVyTGVuID0gMCwgYnVmZmVyU3RhcnQgPSBidWZmZXJFbmQgPSBwb3M7IGkgPCBidWZmZXJlZDIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBzdGFydCA9IGJ1ZmZlcmVkMltpXS5zdGFydCwgZW5kID0gYnVmZmVyZWQyW2ldLmVuZDtcbiAgICAgICAgICAgIC8vIGxvZ2dlci5sb2coJ2J1ZiBzdGFydC9lbmQ6JyArIGJ1ZmZlcmVkLnN0YXJ0KGkpICsgJy8nICsgYnVmZmVyZWQuZW5kKGkpKTtcbiAgICAgICAgICAgIGlmICgocG9zICsgbWF4SG9sZUR1cmF0aW9uKSA+PSBzdGFydCAmJiBwb3MgPCBlbmQpIHtcbiAgICAgICAgICAgICAgICAvLyBwbGF5IHBvc2l0aW9uIGlzIGluc2lkZSB0aGlzIGJ1ZmZlciBUaW1lUmFuZ2UsIHJldHJpZXZlIGVuZCBvZiBidWZmZXIgcG9zaXRpb24gYW5kIGJ1ZmZlciBsZW5ndGhcbiAgICAgICAgICAgICAgICBidWZmZXJTdGFydCA9IHN0YXJ0O1xuICAgICAgICAgICAgICAgIGJ1ZmZlckVuZCA9IGVuZDtcbiAgICAgICAgICAgICAgICBidWZmZXJMZW4gPSBidWZmZXJFbmQgLSBwb3M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICgocG9zICsgbWF4SG9sZUR1cmF0aW9uKSA8IHN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgYnVmZmVyU3RhcnROZXh0ID0gc3RhcnQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgbGVuOiBidWZmZXJMZW4sIHN0YXJ0OiBidWZmZXJTdGFydCwgZW5kOiBidWZmZXJFbmQsIG5leHRTdGFydDogYnVmZmVyU3RhcnROZXh0IH07XG4gICAgfTtcbiAgICByZXR1cm4gQnVmZmVySGVscGVyO1xufSgpKTtcbmV4cG9ydHMuQnVmZmVySGVscGVyID0gQnVmZmVySGVscGVyO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3V0aWxzL2NlYS02MDgtcGFyc2VyLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3V0aWxzL2NlYS02MDgtcGFyc2VyLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKipcbiAqXG4gKiBUaGlzIGNvZGUgd2FzIHBvcnRlZCBmcm9tIHRoZSBkYXNoLmpzIHByb2plY3QgYXQ6XG4gKiAgIGh0dHBzOi8vZ2l0aHViLmNvbS9EYXNoLUluZHVzdHJ5LUZvcnVtL2Rhc2guanMvYmxvYi9kZXZlbG9wbWVudC9leHRlcm5hbHMvY2VhNjA4LXBhcnNlci5qc1xuICogICBodHRwczovL2dpdGh1Yi5jb20vRGFzaC1JbmR1c3RyeS1Gb3J1bS9kYXNoLmpzL2NvbW1pdC84MjY5YjI2YTc2MWUwODUzYmIyMWQ3ODc4MGVkOTQ1MTQ0ZWNkZDRkI2RpZmYtNzFiYzI5NWEyZDZiNmI3MDkzYTFkMzI5MGQ1M2E0YjJcbiAqXG4gKiBUaGUgb3JpZ2luYWwgY29weXJpZ2h0IGFwcGVhcnMgYmVsb3c6XG4gKlxuICogVGhlIGNvcHlyaWdodCBpbiB0aGlzIHNvZnR3YXJlIGlzIGJlaW5nIG1hZGUgYXZhaWxhYmxlIHVuZGVyIHRoZSBCU0QgTGljZW5zZSxcbiAqIGluY2x1ZGVkIGJlbG93LiBUaGlzIHNvZnR3YXJlIG1heSBiZSBzdWJqZWN0IHRvIG90aGVyIHRoaXJkIHBhcnR5IGFuZCBjb250cmlidXRvclxuICogcmlnaHRzLCBpbmNsdWRpbmcgcGF0ZW50IHJpZ2h0cywgYW5kIG5vIHN1Y2ggcmlnaHRzIGFyZSBncmFudGVkIHVuZGVyIHRoaXMgbGljZW5zZS5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUtMjAxNiwgREFTSCBJbmR1c3RyeSBGb3J1bS5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0IG1vZGlmaWNhdGlvbixcbiAqIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcbiAqICAxLiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsIHRoaXNcbiAqICBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAqICAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcbiAqICB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uIGFuZC9vclxuICogIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG4gKiAgMi4gTmVpdGhlciB0aGUgbmFtZSBvZiBEYXNoIEluZHVzdHJ5IEZvcnVtIG5vciB0aGUgbmFtZXMgb2YgaXRzXG4gKiAgY29udHJpYnV0b3JzIG1heSBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0cyBkZXJpdmVkIGZyb20gdGhpcyBzb2Z0d2FyZVxuICogIHdpdGhvdXQgc3BlY2lmaWMgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxuICpcbiAqICBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTIEFTIElTIEFORCBBTllcbiAqICBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEXG4gKiAgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBESVNDTEFJTUVELlxuICogIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFQgSE9MREVSIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsXG4gKiAgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVFxuICogIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1JcbiAqICBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSxcbiAqICBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpXG4gKiAgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEVcbiAqICBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiAqL1xuLyoqXG4gICAgICogIEV4Y2VwdGlvbnMgZnJvbSByZWd1bGFyIEFTQ0lJLiBDb2RlUG9pbnRzIGFyZSBtYXBwZWQgdG8gVVRGLTE2IGNvZGVzXG4gICAgICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgc3BlY2lhbENlYTYwOENoYXJzQ29kZXMgPSB7XG4gICAgMHgyYTogMHhlMSxcbiAgICAweDVjOiAweGU5LFxuICAgIDB4NWU6IDB4ZWQsXG4gICAgMHg1ZjogMHhmMyxcbiAgICAweDYwOiAweGZhLFxuICAgIDB4N2I6IDB4ZTcsXG4gICAgMHg3YzogMHhmNyxcbiAgICAweDdkOiAweGQxLFxuICAgIDB4N2U6IDB4ZjEsXG4gICAgMHg3ZjogMHgyNTg4LFxuICAgIC8vIFRISVMgQkxPQ0sgSU5DTFVERVMgVEhFIDE2IEVYVEVOREVEIChUV08tQllURSkgTElORSAyMSBDSEFSQUNURVJTXG4gICAgLy8gVEhBVCBDT01FIEZST00gSEkgQllURT0weDExIEFORCBMT1cgQkVUV0VFTiAweDMwIEFORCAweDNGXG4gICAgLy8gVEhJUyBNRUFOUyBUSEFUIFxceDUwIE1VU1QgQkUgQURERUQgVE8gVEhFIFZBTFVFU1xuICAgIDB4ODA6IDB4YWUsXG4gICAgMHg4MTogMHhiMCxcbiAgICAweDgyOiAweGJkLFxuICAgIDB4ODM6IDB4YmYsXG4gICAgMHg4NDogMHgyMTIyLFxuICAgIDB4ODU6IDB4YTIsXG4gICAgMHg4NjogMHhhMyxcbiAgICAweDg3OiAweDI2NmEsXG4gICAgMHg4ODogMHhlMCxcbiAgICAweDg5OiAweDIwLFxuICAgIDB4OGE6IDB4ZTgsXG4gICAgMHg4YjogMHhlMixcbiAgICAweDhjOiAweGVhLFxuICAgIDB4OGQ6IDB4ZWUsXG4gICAgMHg4ZTogMHhmNCxcbiAgICAweDhmOiAweGZiLFxuICAgIC8vIFRISVMgQkxPQ0sgSU5DTFVERVMgVEhFIDMyIEVYVEVOREVEIChUV08tQllURSkgTElORSAyMSBDSEFSQUNURVJTXG4gICAgLy8gVEhBVCBDT01FIEZST00gSEkgQllURT0weDEyIEFORCBMT1cgQkVUV0VFTiAweDIwIEFORCAweDNGXG4gICAgMHg5MDogMHhjMSxcbiAgICAweDkxOiAweGM5LFxuICAgIDB4OTI6IDB4ZDMsXG4gICAgMHg5MzogMHhkYSxcbiAgICAweDk0OiAweGRjLFxuICAgIDB4OTU6IDB4ZmMsXG4gICAgMHg5NjogMHgyMDE4LFxuICAgIDB4OTc6IDB4YTEsXG4gICAgMHg5ODogMHgyYSxcbiAgICAweDk5OiAweDIwMTksXG4gICAgMHg5YTogMHgyNTAxLFxuICAgIDB4OWI6IDB4YTksXG4gICAgMHg5YzogMHgyMTIwLFxuICAgIDB4OWQ6IDB4MjAyMixcbiAgICAweDllOiAweDIwMWMsXG4gICAgMHg5ZjogMHgyMDFkLFxuICAgIDB4YTA6IDB4YzAsXG4gICAgMHhhMTogMHhjMixcbiAgICAweGEyOiAweGM3LFxuICAgIDB4YTM6IDB4YzgsXG4gICAgMHhhNDogMHhjYSxcbiAgICAweGE1OiAweGNiLFxuICAgIDB4YTY6IDB4ZWIsXG4gICAgMHhhNzogMHhjZSxcbiAgICAweGE4OiAweGNmLFxuICAgIDB4YTk6IDB4ZWYsXG4gICAgMHhhYTogMHhkNCxcbiAgICAweGFiOiAweGQ5LFxuICAgIDB4YWM6IDB4ZjksXG4gICAgMHhhZDogMHhkYixcbiAgICAweGFlOiAweGFiLFxuICAgIDB4YWY6IDB4YmIsXG4gICAgLy8gVEhJUyBCTE9DSyBJTkNMVURFUyBUSEUgMzIgRVhURU5ERUQgKFRXTy1CWVRFKSBMSU5FIDIxIENIQVJBQ1RFUlNcbiAgICAvLyBUSEFUIENPTUUgRlJPTSBISSBCWVRFPTB4MTMgQU5EIExPVyBCRVRXRUVOIDB4MjAgQU5EIDB4M0ZcbiAgICAweGIwOiAweGMzLFxuICAgIDB4YjE6IDB4ZTMsXG4gICAgMHhiMjogMHhjZCxcbiAgICAweGIzOiAweGNjLFxuICAgIDB4YjQ6IDB4ZWMsXG4gICAgMHhiNTogMHhkMixcbiAgICAweGI2OiAweGYyLFxuICAgIDB4Yjc6IDB4ZDUsXG4gICAgMHhiODogMHhmNSxcbiAgICAweGI5OiAweDdiLFxuICAgIDB4YmE6IDB4N2QsXG4gICAgMHhiYjogMHg1YyxcbiAgICAweGJjOiAweDVlLFxuICAgIDB4YmQ6IDB4NWYsXG4gICAgMHhiZTogMHg3YyxcbiAgICAweGJmOiAweDIyM2MsXG4gICAgMHhjMDogMHhjNCxcbiAgICAweGMxOiAweGU0LFxuICAgIDB4YzI6IDB4ZDYsXG4gICAgMHhjMzogMHhmNixcbiAgICAweGM0OiAweGRmLFxuICAgIDB4YzU6IDB4YTUsXG4gICAgMHhjNjogMHhhNCxcbiAgICAweGM3OiAweDI1MDMsXG4gICAgMHhjODogMHhjNSxcbiAgICAweGM5OiAweGU1LFxuICAgIDB4Y2E6IDB4ZDgsXG4gICAgMHhjYjogMHhmOCxcbiAgICAweGNjOiAweDI1MGYsXG4gICAgMHhjZDogMHgyNTEzLFxuICAgIDB4Y2U6IDB4MjUxNyxcbiAgICAweGNmOiAweDI1MWIgLy8gQm94IGRyYXdpbmdzIGhlYXZ5IHVwIGFuZCBsZWZ0XG59O1xuLyoqXG4gKiBVdGlsc1xuICovXG52YXIgZ2V0Q2hhckZvckJ5dGUgPSBmdW5jdGlvbiAoYnl0ZSkge1xuICAgIHZhciBjaGFyQ29kZSA9IGJ5dGU7XG4gICAgaWYgKHNwZWNpYWxDZWE2MDhDaGFyc0NvZGVzLmhhc093blByb3BlcnR5KGJ5dGUpKSB7XG4gICAgICAgIGNoYXJDb2RlID0gc3BlY2lhbENlYTYwOENoYXJzQ29kZXNbYnl0ZV07XG4gICAgfVxuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoYXJDb2RlKTtcbn07XG52YXIgTlJfUk9XUyA9IDE1LCBOUl9DT0xTID0gMTAwO1xuLy8gVGFibGVzIHRvIGxvb2sgdXAgcm93IGZyb20gUEFDIGRhdGFcbnZhciByb3dzTG93Q2gxID0geyAweDExOiAxLCAweDEyOiAzLCAweDE1OiA1LCAweDE2OiA3LCAweDE3OiA5LCAweDEwOiAxMSwgMHgxMzogMTIsIDB4MTQ6IDE0IH07XG52YXIgcm93c0hpZ2hDaDEgPSB7IDB4MTE6IDIsIDB4MTI6IDQsIDB4MTU6IDYsIDB4MTY6IDgsIDB4MTc6IDEwLCAweDEzOiAxMywgMHgxNDogMTUgfTtcbnZhciByb3dzTG93Q2gyID0geyAweDE5OiAxLCAweDFBOiAzLCAweDFEOiA1LCAweDFFOiA3LCAweDFGOiA5LCAweDE4OiAxMSwgMHgxQjogMTIsIDB4MUM6IDE0IH07XG52YXIgcm93c0hpZ2hDaDIgPSB7IDB4MTk6IDIsIDB4MUE6IDQsIDB4MUQ6IDYsIDB4MUU6IDgsIDB4MUY6IDEwLCAweDFCOiAxMywgMHgxQzogMTUgfTtcbnZhciBiYWNrZ3JvdW5kQ29sb3JzID0gWyd3aGl0ZScsICdncmVlbicsICdibHVlJywgJ2N5YW4nLCAncmVkJywgJ3llbGxvdycsICdtYWdlbnRhJywgJ2JsYWNrJywgJ3RyYW5zcGFyZW50J107XG4vKipcbiAqIFNpbXBsZSBsb2dnZXIgY2xhc3MgdG8gYmUgYWJsZSB0byB3cml0ZSB3aXRoIHRpbWUtc3RhbXBzIGFuZCBmaWx0ZXIgb24gbGV2ZWwuXG4gKi9cbnZhciBsb2dnZXIgPSB7XG4gICAgdmVyYm9zZUZpbHRlcjogeyAnREFUQSc6IDMsICdERUJVRyc6IDMsICdJTkZPJzogMiwgJ1dBUk5JTkcnOiAyLCAnVEVYVCc6IDEsICdFUlJPUic6IDAgfSxcbiAgICB0aW1lOiBudWxsLFxuICAgIHZlcmJvc2VMZXZlbDogMCxcbiAgICBzZXRUaW1lOiBmdW5jdGlvbiAobmV3VGltZSkge1xuICAgICAgICB0aGlzLnRpbWUgPSBuZXdUaW1lO1xuICAgIH0sXG4gICAgbG9nOiBmdW5jdGlvbiAoc2V2ZXJpdHksIG1zZykge1xuICAgICAgICB2YXIgbWluTGV2ZWwgPSB0aGlzLnZlcmJvc2VGaWx0ZXJbc2V2ZXJpdHldO1xuICAgICAgICBpZiAodGhpcy52ZXJib3NlTGV2ZWwgPj0gbWluTGV2ZWwpIHtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKHRoaXMudGltZSArICcgWycgKyBzZXZlcml0eSArICddICcgKyBtc2cpO1xuICAgICAgICB9XG4gICAgfVxufTtcbnZhciBudW1BcnJheVRvSGV4QXJyYXkgPSBmdW5jdGlvbiAobnVtQXJyYXkpIHtcbiAgICB2YXIgaGV4QXJyYXkgPSBbXTtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IG51bUFycmF5Lmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGhleEFycmF5LnB1c2gobnVtQXJyYXlbal0udG9TdHJpbmcoMTYpKTtcbiAgICB9XG4gICAgcmV0dXJuIGhleEFycmF5O1xufTtcbnZhciBQZW5TdGF0ZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBQZW5TdGF0ZShmb3JlZ3JvdW5kLCB1bmRlcmxpbmUsIGl0YWxpY3MsIGJhY2tncm91bmQsIGZsYXNoKSB7XG4gICAgICAgIHRoaXMuZm9yZWdyb3VuZCA9IGZvcmVncm91bmQgfHwgJ3doaXRlJztcbiAgICAgICAgdGhpcy51bmRlcmxpbmUgPSB1bmRlcmxpbmUgfHwgZmFsc2U7XG4gICAgICAgIHRoaXMuaXRhbGljcyA9IGl0YWxpY3MgfHwgZmFsc2U7XG4gICAgICAgIHRoaXMuYmFja2dyb3VuZCA9IGJhY2tncm91bmQgfHwgJ2JsYWNrJztcbiAgICAgICAgdGhpcy5mbGFzaCA9IGZsYXNoIHx8IGZhbHNlO1xuICAgIH1cbiAgICBQZW5TdGF0ZS5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZm9yZWdyb3VuZCA9ICd3aGl0ZSc7XG4gICAgICAgIHRoaXMudW5kZXJsaW5lID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaXRhbGljcyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmJhY2tncm91bmQgPSAnYmxhY2snO1xuICAgICAgICB0aGlzLmZsYXNoID0gZmFsc2U7XG4gICAgfTtcbiAgICBQZW5TdGF0ZS5wcm90b3R5cGUuc2V0U3R5bGVzID0gZnVuY3Rpb24gKHN0eWxlcykge1xuICAgICAgICB2YXIgYXR0cmlicyA9IFsnZm9yZWdyb3VuZCcsICd1bmRlcmxpbmUnLCAnaXRhbGljcycsICdiYWNrZ3JvdW5kJywgJ2ZsYXNoJ107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXR0cmlicy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHN0eWxlID0gYXR0cmlic1tpXTtcbiAgICAgICAgICAgIGlmIChzdHlsZXMuaGFzT3duUHJvcGVydHkoc3R5bGUpKSB7XG4gICAgICAgICAgICAgICAgdGhpc1tzdHlsZV0gPSBzdHlsZXNbc3R5bGVdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBQZW5TdGF0ZS5wcm90b3R5cGUuaXNEZWZhdWx0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuZm9yZWdyb3VuZCA9PT0gJ3doaXRlJyAmJiAhdGhpcy51bmRlcmxpbmUgJiYgIXRoaXMuaXRhbGljcyAmJlxuICAgICAgICAgICAgdGhpcy5iYWNrZ3JvdW5kID09PSAnYmxhY2snICYmICF0aGlzLmZsYXNoKTtcbiAgICB9O1xuICAgIFBlblN0YXRlLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiAob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuICgodGhpcy5mb3JlZ3JvdW5kID09PSBvdGhlci5mb3JlZ3JvdW5kKSAmJlxuICAgICAgICAgICAgKHRoaXMudW5kZXJsaW5lID09PSBvdGhlci51bmRlcmxpbmUpICYmXG4gICAgICAgICAgICAodGhpcy5pdGFsaWNzID09PSBvdGhlci5pdGFsaWNzKSAmJlxuICAgICAgICAgICAgKHRoaXMuYmFja2dyb3VuZCA9PT0gb3RoZXIuYmFja2dyb3VuZCkgJiZcbiAgICAgICAgICAgICh0aGlzLmZsYXNoID09PSBvdGhlci5mbGFzaCkpO1xuICAgIH07XG4gICAgUGVuU3RhdGUucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAobmV3UGVuU3RhdGUpIHtcbiAgICAgICAgdGhpcy5mb3JlZ3JvdW5kID0gbmV3UGVuU3RhdGUuZm9yZWdyb3VuZDtcbiAgICAgICAgdGhpcy51bmRlcmxpbmUgPSBuZXdQZW5TdGF0ZS51bmRlcmxpbmU7XG4gICAgICAgIHRoaXMuaXRhbGljcyA9IG5ld1BlblN0YXRlLml0YWxpY3M7XG4gICAgICAgIHRoaXMuYmFja2dyb3VuZCA9IG5ld1BlblN0YXRlLmJhY2tncm91bmQ7XG4gICAgICAgIHRoaXMuZmxhc2ggPSBuZXdQZW5TdGF0ZS5mbGFzaDtcbiAgICB9O1xuICAgIFBlblN0YXRlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICgnY29sb3I9JyArIHRoaXMuZm9yZWdyb3VuZCArICcsIHVuZGVybGluZT0nICsgdGhpcy51bmRlcmxpbmUgKyAnLCBpdGFsaWNzPScgKyB0aGlzLml0YWxpY3MgK1xuICAgICAgICAgICAgJywgYmFja2dyb3VuZD0nICsgdGhpcy5iYWNrZ3JvdW5kICsgJywgZmxhc2g9JyArIHRoaXMuZmxhc2gpO1xuICAgIH07XG4gICAgcmV0dXJuIFBlblN0YXRlO1xufSgpKTtcbi8qKlxuICogVW5pY29kZSBjaGFyYWN0ZXIgd2l0aCBzdHlsaW5nIGFuZCBiYWNrZ3JvdW5kLlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBTdHlsZWRVbmljb2RlQ2hhciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTdHlsZWRVbmljb2RlQ2hhcih1Y2hhciwgZm9yZWdyb3VuZCwgdW5kZXJsaW5lLCBpdGFsaWNzLCBiYWNrZ3JvdW5kLCBmbGFzaCkge1xuICAgICAgICB0aGlzLnVjaGFyID0gdWNoYXIgfHwgJyAnOyAvLyB1bmljb2RlIGNoYXJhY3RlclxuICAgICAgICB0aGlzLnBlblN0YXRlID0gbmV3IFBlblN0YXRlKGZvcmVncm91bmQsIHVuZGVybGluZSwgaXRhbGljcywgYmFja2dyb3VuZCwgZmxhc2gpO1xuICAgIH1cbiAgICBTdHlsZWRVbmljb2RlQ2hhci5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudWNoYXIgPSAnICc7XG4gICAgICAgIHRoaXMucGVuU3RhdGUucmVzZXQoKTtcbiAgICB9O1xuICAgIFN0eWxlZFVuaWNvZGVDaGFyLnByb3RvdHlwZS5zZXRDaGFyID0gZnVuY3Rpb24gKHVjaGFyLCBuZXdQZW5TdGF0ZSkge1xuICAgICAgICB0aGlzLnVjaGFyID0gdWNoYXI7XG4gICAgICAgIHRoaXMucGVuU3RhdGUuY29weShuZXdQZW5TdGF0ZSk7XG4gICAgfTtcbiAgICBTdHlsZWRVbmljb2RlQ2hhci5wcm90b3R5cGUuc2V0UGVuU3RhdGUgPSBmdW5jdGlvbiAobmV3UGVuU3RhdGUpIHtcbiAgICAgICAgdGhpcy5wZW5TdGF0ZS5jb3B5KG5ld1BlblN0YXRlKTtcbiAgICB9O1xuICAgIFN0eWxlZFVuaWNvZGVDaGFyLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiAob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudWNoYXIgPT09IG90aGVyLnVjaGFyICYmIHRoaXMucGVuU3RhdGUuZXF1YWxzKG90aGVyLnBlblN0YXRlKTtcbiAgICB9O1xuICAgIFN0eWxlZFVuaWNvZGVDaGFyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKG5ld0NoYXIpIHtcbiAgICAgICAgdGhpcy51Y2hhciA9IG5ld0NoYXIudWNoYXI7XG4gICAgICAgIHRoaXMucGVuU3RhdGUuY29weShuZXdDaGFyLnBlblN0YXRlKTtcbiAgICB9O1xuICAgIFN0eWxlZFVuaWNvZGVDaGFyLnByb3RvdHlwZS5pc0VtcHR5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy51Y2hhciA9PT0gJyAnICYmIHRoaXMucGVuU3RhdGUuaXNEZWZhdWx0KCk7XG4gICAgfTtcbiAgICByZXR1cm4gU3R5bGVkVW5pY29kZUNoYXI7XG59KCkpO1xuLyoqXG4gKiBDRUEtNjA4IHJvdyBjb25zaXN0aW5nIG9mIE5SX0NPTFMgaW5zdGFuY2VzIG9mIFN0eWxlZFVuaWNvZGVDaGFyLlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBSb3cgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUm93KCkge1xuICAgICAgICB0aGlzLmNoYXJzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTlJfQ09MUzsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLmNoYXJzLnB1c2gobmV3IFN0eWxlZFVuaWNvZGVDaGFyKCkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucG9zID0gMDtcbiAgICAgICAgdGhpcy5jdXJyUGVuU3RhdGUgPSBuZXcgUGVuU3RhdGUoKTtcbiAgICB9XG4gICAgUm93LnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiAob3RoZXIpIHtcbiAgICAgICAgdmFyIGVxdWFsID0gdHJ1ZTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBOUl9DT0xTOyBpKyspIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5jaGFyc1tpXS5lcXVhbHMob3RoZXIuY2hhcnNbaV0pKSB7XG4gICAgICAgICAgICAgICAgZXF1YWwgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXF1YWw7XG4gICAgfTtcbiAgICBSb3cucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAob3RoZXIpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBOUl9DT0xTOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuY2hhcnNbaV0uY29weShvdGhlci5jaGFyc1tpXSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFJvdy5wcm90b3R5cGUuaXNFbXB0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGVtcHR5ID0gdHJ1ZTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBOUl9DT0xTOyBpKyspIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5jaGFyc1tpXS5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgICAgICBlbXB0eSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbXB0eTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAgICogIFNldCB0aGUgY3Vyc29yIHRvIGEgdmFsaWQgY29sdW1uLlxuICAgICAgICovXG4gICAgUm93LnByb3RvdHlwZS5zZXRDdXJzb3IgPSBmdW5jdGlvbiAoYWJzUG9zKSB7XG4gICAgICAgIGlmICh0aGlzLnBvcyAhPT0gYWJzUG9zKSB7XG4gICAgICAgICAgICB0aGlzLnBvcyA9IGFic1BvcztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wb3MgPCAwKSB7XG4gICAgICAgICAgICBsb2dnZXIubG9nKCdFUlJPUicsICdOZWdhdGl2ZSBjdXJzb3IgcG9zaXRpb24gJyArIHRoaXMucG9zKTtcbiAgICAgICAgICAgIHRoaXMucG9zID0gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnBvcyA+IE5SX0NPTFMpIHtcbiAgICAgICAgICAgIGxvZ2dlci5sb2coJ0VSUk9SJywgJ1RvbyBsYXJnZSBjdXJzb3IgcG9zaXRpb24gJyArIHRoaXMucG9zKTtcbiAgICAgICAgICAgIHRoaXMucG9zID0gTlJfQ09MUztcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICAgKiBNb3ZlIHRoZSBjdXJzb3IgcmVsYXRpdmUgdG8gY3VycmVudCBwb3NpdGlvbi5cbiAgICAgICAqL1xuICAgIFJvdy5wcm90b3R5cGUubW92ZUN1cnNvciA9IGZ1bmN0aW9uIChyZWxQb3MpIHtcbiAgICAgICAgdmFyIG5ld1BvcyA9IHRoaXMucG9zICsgcmVsUG9zO1xuICAgICAgICBpZiAocmVsUG9zID4gMSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMucG9zICsgMTsgaSA8IG5ld1BvcyArIDE7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMuY2hhcnNbaV0uc2V0UGVuU3RhdGUodGhpcy5jdXJyUGVuU3RhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0Q3Vyc29yKG5ld1Bvcyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgICAqIEJhY2tzcGFjZSwgbW92ZSBvbmUgc3RlcCBiYWNrIGFuZCBjbGVhciBjaGFyYWN0ZXIuXG4gICAgICAgKi9cbiAgICBSb3cucHJvdG90eXBlLmJhY2tTcGFjZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5tb3ZlQ3Vyc29yKC0xKTtcbiAgICAgICAgdGhpcy5jaGFyc1t0aGlzLnBvc10uc2V0Q2hhcignICcsIHRoaXMuY3VyclBlblN0YXRlKTtcbiAgICB9O1xuICAgIFJvdy5wcm90b3R5cGUuaW5zZXJ0Q2hhciA9IGZ1bmN0aW9uIChieXRlKSB7XG4gICAgICAgIGlmIChieXRlID49IDB4OTApIHsgLy8gRXh0ZW5kZWQgY2hhclxuICAgICAgICAgICAgdGhpcy5iYWNrU3BhY2UoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY2hhciA9IGdldENoYXJGb3JCeXRlKGJ5dGUpO1xuICAgICAgICBpZiAodGhpcy5wb3MgPj0gTlJfQ09MUykge1xuICAgICAgICAgICAgbG9nZ2VyLmxvZygnRVJST1InLCAnQ2Fubm90IGluc2VydCAnICsgYnl0ZS50b1N0cmluZygxNikgK1xuICAgICAgICAgICAgICAgICcgKCcgKyBjaGFyICsgJykgYXQgcG9zaXRpb24gJyArIHRoaXMucG9zICsgJy4gU2tpcHBpbmcgaXQhJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jaGFyc1t0aGlzLnBvc10uc2V0Q2hhcihjaGFyLCB0aGlzLmN1cnJQZW5TdGF0ZSk7XG4gICAgICAgIHRoaXMubW92ZUN1cnNvcigxKTtcbiAgICB9O1xuICAgIFJvdy5wcm90b3R5cGUuY2xlYXJGcm9tUG9zID0gZnVuY3Rpb24gKHN0YXJ0UG9zKSB7XG4gICAgICAgIHZhciBpO1xuICAgICAgICBmb3IgKGkgPSBzdGFydFBvczsgaSA8IE5SX0NPTFM7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5jaGFyc1tpXS5yZXNldCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBSb3cucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmNsZWFyRnJvbVBvcygwKTtcbiAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgICAgICB0aGlzLmN1cnJQZW5TdGF0ZS5yZXNldCgpO1xuICAgIH07XG4gICAgUm93LnByb3RvdHlwZS5jbGVhclRvRW5kT2ZSb3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuY2xlYXJGcm9tUG9zKHRoaXMucG9zKTtcbiAgICB9O1xuICAgIFJvdy5wcm90b3R5cGUuZ2V0VGV4dFN0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNoYXJzID0gW107XG4gICAgICAgIHZhciBlbXB0eSA9IHRydWU7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTlJfQ09MUzsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgY2hhciA9IHRoaXMuY2hhcnNbaV0udWNoYXI7XG4gICAgICAgICAgICBpZiAoY2hhciAhPT0gJyAnKSB7XG4gICAgICAgICAgICAgICAgZW1wdHkgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNoYXJzLnB1c2goY2hhcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVtcHR5KSB7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gY2hhcnMuam9pbignJyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFJvdy5wcm90b3R5cGUuc2V0UGVuU3R5bGVzID0gZnVuY3Rpb24gKHN0eWxlcykge1xuICAgICAgICB0aGlzLmN1cnJQZW5TdGF0ZS5zZXRTdHlsZXMoc3R5bGVzKTtcbiAgICAgICAgdmFyIGN1cnJDaGFyID0gdGhpcy5jaGFyc1t0aGlzLnBvc107XG4gICAgICAgIGN1cnJDaGFyLnNldFBlblN0YXRlKHRoaXMuY3VyclBlblN0YXRlKTtcbiAgICB9O1xuICAgIHJldHVybiBSb3c7XG59KCkpO1xuLyoqXG4gKiBLZWVwIGEgQ0VBLTYwOCBzY3JlZW4gb2YgMzJ4MTUgc3R5bGVkIGNoYXJhY3RlcnNcbiAqIEBjb25zdHJ1Y3RvclxuKi9cbnZhciBDYXB0aW9uU2NyZWVuID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENhcHRpb25TY3JlZW4oKSB7XG4gICAgICAgIHRoaXMucm93cyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IE5SX1JPV1M7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5yb3dzLnB1c2gobmV3IFJvdygpKTtcbiAgICAgICAgfSAvLyBOb3RlIHRoYXQgd2UgdXNlIHplcm8tYmFzZWQgbnVtYmVyaW5nICgwLTE0KVxuICAgICAgICB0aGlzLmN1cnJSb3cgPSBOUl9ST1dTIC0gMTtcbiAgICAgICAgdGhpcy5uclJvbGxVcFJvd3MgPSBudWxsO1xuICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgfVxuICAgIENhcHRpb25TY3JlZW4ucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IE5SX1JPV1M7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5yb3dzW2ldLmNsZWFyKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jdXJyUm93ID0gTlJfUk9XUyAtIDE7XG4gICAgfTtcbiAgICBDYXB0aW9uU2NyZWVuLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiAob3RoZXIpIHtcbiAgICAgICAgdmFyIGVxdWFsID0gdHJ1ZTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBOUl9ST1dTOyBpKyspIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5yb3dzW2ldLmVxdWFscyhvdGhlci5yb3dzW2ldKSkge1xuICAgICAgICAgICAgICAgIGVxdWFsID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVxdWFsO1xuICAgIH07XG4gICAgQ2FwdGlvblNjcmVlbi5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIChvdGhlcikge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IE5SX1JPV1M7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5yb3dzW2ldLmNvcHkob3RoZXIucm93c1tpXSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENhcHRpb25TY3JlZW4ucHJvdG90eXBlLmlzRW1wdHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBlbXB0eSA9IHRydWU7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTlJfUk9XUzsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMucm93c1tpXS5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgICAgICBlbXB0eSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbXB0eTtcbiAgICB9O1xuICAgIENhcHRpb25TY3JlZW4ucHJvdG90eXBlLmJhY2tTcGFjZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJvdyA9IHRoaXMucm93c1t0aGlzLmN1cnJSb3ddO1xuICAgICAgICByb3cuYmFja1NwYWNlKCk7XG4gICAgfTtcbiAgICBDYXB0aW9uU2NyZWVuLnByb3RvdHlwZS5jbGVhclRvRW5kT2ZSb3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByb3cgPSB0aGlzLnJvd3NbdGhpcy5jdXJyUm93XTtcbiAgICAgICAgcm93LmNsZWFyVG9FbmRPZlJvdygpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICAgKiBJbnNlcnQgYSBjaGFyYWN0ZXIgKHdpdGhvdXQgc3R5bGluZykgaW4gdGhlIGN1cnJlbnQgcm93LlxuICAgICAgICovXG4gICAgQ2FwdGlvblNjcmVlbi5wcm90b3R5cGUuaW5zZXJ0Q2hhciA9IGZ1bmN0aW9uIChjaGFyKSB7XG4gICAgICAgIHZhciByb3cgPSB0aGlzLnJvd3NbdGhpcy5jdXJyUm93XTtcbiAgICAgICAgcm93Lmluc2VydENoYXIoY2hhcik7XG4gICAgfTtcbiAgICBDYXB0aW9uU2NyZWVuLnByb3RvdHlwZS5zZXRQZW4gPSBmdW5jdGlvbiAoc3R5bGVzKSB7XG4gICAgICAgIHZhciByb3cgPSB0aGlzLnJvd3NbdGhpcy5jdXJyUm93XTtcbiAgICAgICAgcm93LnNldFBlblN0eWxlcyhzdHlsZXMpO1xuICAgIH07XG4gICAgQ2FwdGlvblNjcmVlbi5wcm90b3R5cGUubW92ZUN1cnNvciA9IGZ1bmN0aW9uIChyZWxQb3MpIHtcbiAgICAgICAgdmFyIHJvdyA9IHRoaXMucm93c1t0aGlzLmN1cnJSb3ddO1xuICAgICAgICByb3cubW92ZUN1cnNvcihyZWxQb3MpO1xuICAgIH07XG4gICAgQ2FwdGlvblNjcmVlbi5wcm90b3R5cGUuc2V0Q3Vyc29yID0gZnVuY3Rpb24gKGFic1Bvcykge1xuICAgICAgICBsb2dnZXIubG9nKCdJTkZPJywgJ3NldEN1cnNvcjogJyArIGFic1Bvcyk7XG4gICAgICAgIHZhciByb3cgPSB0aGlzLnJvd3NbdGhpcy5jdXJyUm93XTtcbiAgICAgICAgcm93LnNldEN1cnNvcihhYnNQb3MpO1xuICAgIH07XG4gICAgQ2FwdGlvblNjcmVlbi5wcm90b3R5cGUuc2V0UEFDID0gZnVuY3Rpb24gKHBhY0RhdGEpIHtcbiAgICAgICAgbG9nZ2VyLmxvZygnSU5GTycsICdwYWNEYXRhID0gJyArIEpTT04uc3RyaW5naWZ5KHBhY0RhdGEpKTtcbiAgICAgICAgdmFyIG5ld1JvdyA9IHBhY0RhdGEucm93IC0gMTtcbiAgICAgICAgaWYgKHRoaXMubnJSb2xsVXBSb3dzICYmIG5ld1JvdyA8IHRoaXMubnJSb2xsVXBSb3dzIC0gMSkge1xuICAgICAgICAgICAgbmV3Um93ID0gdGhpcy5uclJvbGxVcFJvd3MgLSAxO1xuICAgICAgICB9XG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aGlzIG9ubHkgYWZmZWN0cyBSb2xsLXVwIENhcHRpb25zIGJ5IGNoZWNraW5nIHRoaXMubnJSb2xsVXBSb3dzXG4gICAgICAgIGlmICh0aGlzLm5yUm9sbFVwUm93cyAmJiB0aGlzLmN1cnJSb3cgIT09IG5ld1Jvdykge1xuICAgICAgICAgICAgLy8gY2xlYXIgYWxsIHJvd3MgZmlyc3RcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTlJfUk9XUzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yb3dzW2ldLmNsZWFyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDb3B5IHRoaXMubnJSb2xsVXBSb3dzIHJvd3MgZnJvbSBsYXN0T3V0cHV0U2NyZWVuIGFuZCBwbGFjZSBpdCBpbiB0aGUgbmV3Um93IGxvY2F0aW9uXG4gICAgICAgICAgICAvLyB0b3BSb3dJbmRleCAtIHRoZSBzdGFydCBvZiByb3dzIHRvIGNvcHkgKGluY2x1c2l2ZSBpbmRleClcbiAgICAgICAgICAgIHZhciB0b3BSb3dJbmRleCA9IHRoaXMuY3VyclJvdyArIDEgLSAodGhpcy5uclJvbGxVcFJvd3MpO1xuICAgICAgICAgICAgLy8gV2Ugb25seSBjb3B5IGlmIHRoZSBsYXN0IHBvc2l0aW9uIHdhcyBhbHJlYWR5IHNob3duLlxuICAgICAgICAgICAgLy8gV2UgdXNlIHRoZSBjdWVTdGFydFRpbWUgdmFsdWUgdG8gY2hlY2sgdGhpcy5cbiAgICAgICAgICAgIHZhciBsYXN0T3V0cHV0U2NyZWVuID0gdGhpcy5sYXN0T3V0cHV0U2NyZWVuO1xuICAgICAgICAgICAgaWYgKGxhc3RPdXRwdXRTY3JlZW4pIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJldkxpbmVUaW1lID0gbGFzdE91dHB1dFNjcmVlbi5yb3dzW3RvcFJvd0luZGV4XS5jdWVTdGFydFRpbWU7XG4gICAgICAgICAgICAgICAgaWYgKHByZXZMaW5lVGltZSAmJiBwcmV2TGluZVRpbWUgPCBsb2dnZXIudGltZSkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubnJSb2xsVXBSb3dzOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucm93c1tuZXdSb3cgLSB0aGlzLm5yUm9sbFVwUm93cyArIGkgKyAxXS5jb3B5KGxhc3RPdXRwdXRTY3JlZW4ucm93c1t0b3BSb3dJbmRleCArIGldKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmN1cnJSb3cgPSBuZXdSb3c7XG4gICAgICAgIHZhciByb3cgPSB0aGlzLnJvd3NbdGhpcy5jdXJyUm93XTtcbiAgICAgICAgaWYgKHBhY0RhdGEuaW5kZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgaW5kZW50ID0gcGFjRGF0YS5pbmRlbnQ7XG4gICAgICAgICAgICB2YXIgcHJldlBvcyA9IE1hdGgubWF4KGluZGVudCAtIDEsIDApO1xuICAgICAgICAgICAgcm93LnNldEN1cnNvcihwYWNEYXRhLmluZGVudCk7XG4gICAgICAgICAgICBwYWNEYXRhLmNvbG9yID0gcm93LmNoYXJzW3ByZXZQb3NdLnBlblN0YXRlLmZvcmVncm91bmQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN0eWxlcyA9IHsgZm9yZWdyb3VuZDogcGFjRGF0YS5jb2xvciwgdW5kZXJsaW5lOiBwYWNEYXRhLnVuZGVybGluZSwgaXRhbGljczogcGFjRGF0YS5pdGFsaWNzLCBiYWNrZ3JvdW5kOiAnYmxhY2snLCBmbGFzaDogZmFsc2UgfTtcbiAgICAgICAgdGhpcy5zZXRQZW4oc3R5bGVzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAgICogU2V0IGJhY2tncm91bmQvZXh0cmEgZm9yZWdyb3VuZCwgYnV0IGZpcnN0IGRvIGJhY2tfc3BhY2UsIGFuZCB0aGVuIGluc2VydCBzcGFjZSAoYmFja3dhcmRzIGNvbXBhdGliaWxpdHkpLlxuICAgICAgICovXG4gICAgQ2FwdGlvblNjcmVlbi5wcm90b3R5cGUuc2V0QmtnRGF0YSA9IGZ1bmN0aW9uIChia2dEYXRhKSB7XG4gICAgICAgIGxvZ2dlci5sb2coJ0lORk8nLCAnYmtnRGF0YSA9ICcgKyBKU09OLnN0cmluZ2lmeShia2dEYXRhKSk7XG4gICAgICAgIHRoaXMuYmFja1NwYWNlKCk7XG4gICAgICAgIHRoaXMuc2V0UGVuKGJrZ0RhdGEpO1xuICAgICAgICB0aGlzLmluc2VydENoYXIoMHgyMCk7IC8vIFNwYWNlXG4gICAgfTtcbiAgICBDYXB0aW9uU2NyZWVuLnByb3RvdHlwZS5zZXRSb2xsVXBSb3dzID0gZnVuY3Rpb24gKG5yUm93cykge1xuICAgICAgICB0aGlzLm5yUm9sbFVwUm93cyA9IG5yUm93cztcbiAgICB9O1xuICAgIENhcHRpb25TY3JlZW4ucHJvdG90eXBlLnJvbGxVcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMubnJSb2xsVXBSb3dzID09PSBudWxsKSB7XG4gICAgICAgICAgICBsb2dnZXIubG9nKCdERUJVRycsICdyb2xsX3VwIGJ1dCBuclJvbGxVcFJvd3Mgbm90IHNldCB5ZXQnKTtcbiAgICAgICAgICAgIHJldHVybjsgLy8gTm90IHByb3Blcmx5IHNldHVwXG4gICAgICAgIH1cbiAgICAgICAgbG9nZ2VyLmxvZygnVEVYVCcsIHRoaXMuZ2V0RGlzcGxheVRleHQoKSk7XG4gICAgICAgIHZhciB0b3BSb3dJbmRleCA9IHRoaXMuY3VyclJvdyArIDEgLSB0aGlzLm5yUm9sbFVwUm93cztcbiAgICAgICAgdmFyIHRvcFJvdyA9IHRoaXMucm93cy5zcGxpY2UodG9wUm93SW5kZXgsIDEpWzBdO1xuICAgICAgICB0b3BSb3cuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5yb3dzLnNwbGljZSh0aGlzLmN1cnJSb3csIDAsIHRvcFJvdyk7XG4gICAgICAgIGxvZ2dlci5sb2coJ0lORk8nLCAnUm9sbGluZyB1cCcpO1xuICAgICAgICAvLyBsb2dnZXIubG9nKCdURVhUJywgdGhpcy5nZXRfZGlzcGxheV90ZXh0KCkpXG4gICAgfTtcbiAgICAvKipcbiAgICAgICogR2V0IGFsbCBub24tZW1wdHkgcm93cyB3aXRoIGFzIHVuaWNvZGUgdGV4dC5cbiAgICAgICovXG4gICAgQ2FwdGlvblNjcmVlbi5wcm90b3R5cGUuZ2V0RGlzcGxheVRleHQgPSBmdW5jdGlvbiAoYXNPbmVSb3cpIHtcbiAgICAgICAgYXNPbmVSb3cgPSBhc09uZVJvdyB8fCBmYWxzZTtcbiAgICAgICAgdmFyIGRpc3BsYXlUZXh0ID0gW107XG4gICAgICAgIHZhciB0ZXh0ID0gJyc7XG4gICAgICAgIHZhciByb3dOciA9IC0xO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IE5SX1JPV1M7IGkrKykge1xuICAgICAgICAgICAgdmFyIHJvd1RleHQgPSB0aGlzLnJvd3NbaV0uZ2V0VGV4dFN0cmluZygpO1xuICAgICAgICAgICAgaWYgKHJvd1RleHQpIHtcbiAgICAgICAgICAgICAgICByb3dOciA9IGkgKyAxO1xuICAgICAgICAgICAgICAgIGlmIChhc09uZVJvdykge1xuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5VGV4dC5wdXNoKCdSb3cgJyArIHJvd05yICsgJzogXFwnJyArIHJvd1RleHQgKyAnXFwnJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5VGV4dC5wdXNoKHJvd1RleHQudHJpbSgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRpc3BsYXlUZXh0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGlmIChhc09uZVJvdykge1xuICAgICAgICAgICAgICAgIHRleHQgPSAnWycgKyBkaXNwbGF5VGV4dC5qb2luKCcgfCAnKSArICddJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRleHQgPSBkaXNwbGF5VGV4dC5qb2luKCdcXG4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGV4dDtcbiAgICB9O1xuICAgIENhcHRpb25TY3JlZW4ucHJvdG90eXBlLmdldFRleHRBbmRGb3JtYXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJvd3M7XG4gICAgfTtcbiAgICByZXR1cm4gQ2FwdGlvblNjcmVlbjtcbn0oKSk7XG4vLyB2YXIgbW9kZXMgPSBbJ01PREVfUk9MTC1VUCcsICdNT0RFX1BPUC1PTicsICdNT0RFX1BBSU5ULU9OJywgJ01PREVfVEVYVCddO1xudmFyIENlYTYwOENoYW5uZWwgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ2VhNjA4Q2hhbm5lbChjaGFubmVsTnVtYmVyLCBvdXRwdXRGaWx0ZXIpIHtcbiAgICAgICAgdGhpcy5jaE5yID0gY2hhbm5lbE51bWJlcjtcbiAgICAgICAgdGhpcy5vdXRwdXRGaWx0ZXIgPSBvdXRwdXRGaWx0ZXI7XG4gICAgICAgIHRoaXMubW9kZSA9IG51bGw7XG4gICAgICAgIHRoaXMudmVyYm9zZSA9IDA7XG4gICAgICAgIHRoaXMuZGlzcGxheWVkTWVtb3J5ID0gbmV3IENhcHRpb25TY3JlZW4oKTtcbiAgICAgICAgdGhpcy5ub25EaXNwbGF5ZWRNZW1vcnkgPSBuZXcgQ2FwdGlvblNjcmVlbigpO1xuICAgICAgICB0aGlzLmxhc3RPdXRwdXRTY3JlZW4gPSBuZXcgQ2FwdGlvblNjcmVlbigpO1xuICAgICAgICB0aGlzLmN1cnJSb2xsVXBSb3cgPSB0aGlzLmRpc3BsYXllZE1lbW9yeS5yb3dzW05SX1JPV1MgLSAxXTtcbiAgICAgICAgdGhpcy53cml0ZVNjcmVlbiA9IHRoaXMuZGlzcGxheWVkTWVtb3J5O1xuICAgICAgICB0aGlzLm1vZGUgPSBudWxsO1xuICAgICAgICB0aGlzLmN1ZVN0YXJ0VGltZSA9IG51bGw7IC8vIEtlZXBzIHRyYWNrIG9mIHdoZXJlIGEgY3VlIHN0YXJ0ZWQuXG4gICAgfVxuICAgIENlYTYwOENoYW5uZWwucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLm1vZGUgPSBudWxsO1xuICAgICAgICB0aGlzLmRpc3BsYXllZE1lbW9yeS5yZXNldCgpO1xuICAgICAgICB0aGlzLm5vbkRpc3BsYXllZE1lbW9yeS5yZXNldCgpO1xuICAgICAgICB0aGlzLmxhc3RPdXRwdXRTY3JlZW4ucmVzZXQoKTtcbiAgICAgICAgdGhpcy5jdXJyUm9sbFVwUm93ID0gdGhpcy5kaXNwbGF5ZWRNZW1vcnkucm93c1tOUl9ST1dTIC0gMV07XG4gICAgICAgIHRoaXMud3JpdGVTY3JlZW4gPSB0aGlzLmRpc3BsYXllZE1lbW9yeTtcbiAgICAgICAgdGhpcy5tb2RlID0gbnVsbDtcbiAgICAgICAgdGhpcy5jdWVTdGFydFRpbWUgPSBudWxsO1xuICAgICAgICB0aGlzLmxhc3RDdWVFbmRUaW1lID0gbnVsbDtcbiAgICB9O1xuICAgIENlYTYwOENoYW5uZWwucHJvdG90eXBlLmdldEhhbmRsZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm91dHB1dEZpbHRlcjtcbiAgICB9O1xuICAgIENlYTYwOENoYW5uZWwucHJvdG90eXBlLnNldEhhbmRsZXIgPSBmdW5jdGlvbiAobmV3SGFuZGxlcikge1xuICAgICAgICB0aGlzLm91dHB1dEZpbHRlciA9IG5ld0hhbmRsZXI7XG4gICAgfTtcbiAgICBDZWE2MDhDaGFubmVsLnByb3RvdHlwZS5zZXRQQUMgPSBmdW5jdGlvbiAocGFjRGF0YSkge1xuICAgICAgICB0aGlzLndyaXRlU2NyZWVuLnNldFBBQyhwYWNEYXRhKTtcbiAgICB9O1xuICAgIENlYTYwOENoYW5uZWwucHJvdG90eXBlLnNldEJrZ0RhdGEgPSBmdW5jdGlvbiAoYmtnRGF0YSkge1xuICAgICAgICB0aGlzLndyaXRlU2NyZWVuLnNldEJrZ0RhdGEoYmtnRGF0YSk7XG4gICAgfTtcbiAgICBDZWE2MDhDaGFubmVsLnByb3RvdHlwZS5zZXRNb2RlID0gZnVuY3Rpb24gKG5ld01vZGUpIHtcbiAgICAgICAgaWYgKG5ld01vZGUgPT09IHRoaXMubW9kZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubW9kZSA9IG5ld01vZGU7XG4gICAgICAgIGxvZ2dlci5sb2coJ0lORk8nLCAnTU9ERT0nICsgbmV3TW9kZSk7XG4gICAgICAgIGlmICh0aGlzLm1vZGUgPT09ICdNT0RFX1BPUC1PTicpIHtcbiAgICAgICAgICAgIHRoaXMud3JpdGVTY3JlZW4gPSB0aGlzLm5vbkRpc3BsYXllZE1lbW9yeTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMud3JpdGVTY3JlZW4gPSB0aGlzLmRpc3BsYXllZE1lbW9yeTtcbiAgICAgICAgICAgIHRoaXMud3JpdGVTY3JlZW4ucmVzZXQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5tb2RlICE9PSAnTU9ERV9ST0xMLVVQJykge1xuICAgICAgICAgICAgdGhpcy5kaXNwbGF5ZWRNZW1vcnkubnJSb2xsVXBSb3dzID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMubm9uRGlzcGxheWVkTWVtb3J5Lm5yUm9sbFVwUm93cyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tb2RlID0gbmV3TW9kZTtcbiAgICB9O1xuICAgIENlYTYwOENoYW5uZWwucHJvdG90eXBlLmluc2VydENoYXJzID0gZnVuY3Rpb24gKGNoYXJzKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hhcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMud3JpdGVTY3JlZW4uaW5zZXJ0Q2hhcihjaGFyc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNjcmVlbiA9IHRoaXMud3JpdGVTY3JlZW4gPT09IHRoaXMuZGlzcGxheWVkTWVtb3J5ID8gJ0RJU1AnIDogJ05PTl9ESVNQJztcbiAgICAgICAgbG9nZ2VyLmxvZygnSU5GTycsIHNjcmVlbiArICc6ICcgKyB0aGlzLndyaXRlU2NyZWVuLmdldERpc3BsYXlUZXh0KHRydWUpKTtcbiAgICAgICAgaWYgKHRoaXMubW9kZSA9PT0gJ01PREVfUEFJTlQtT04nIHx8IHRoaXMubW9kZSA9PT0gJ01PREVfUk9MTC1VUCcpIHtcbiAgICAgICAgICAgIGxvZ2dlci5sb2coJ1RFWFQnLCAnRElTUExBWUVEOiAnICsgdGhpcy5kaXNwbGF5ZWRNZW1vcnkuZ2V0RGlzcGxheVRleHQodHJ1ZSkpO1xuICAgICAgICAgICAgdGhpcy5vdXRwdXREYXRhVXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENlYTYwOENoYW5uZWwucHJvdG90eXBlLmNjUkNMID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBsb2dnZXIubG9nKCdJTkZPJywgJ1JDTCAtIFJlc3VtZSBDYXB0aW9uIExvYWRpbmcnKTtcbiAgICAgICAgdGhpcy5zZXRNb2RlKCdNT0RFX1BPUC1PTicpO1xuICAgIH07XG4gICAgQ2VhNjA4Q2hhbm5lbC5wcm90b3R5cGUuY2NCUyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbG9nZ2VyLmxvZygnSU5GTycsICdCUyAtIEJhY2tTcGFjZScpO1xuICAgICAgICBpZiAodGhpcy5tb2RlID09PSAnTU9ERV9URVhUJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMud3JpdGVTY3JlZW4uYmFja1NwYWNlKCk7XG4gICAgICAgIGlmICh0aGlzLndyaXRlU2NyZWVuID09PSB0aGlzLmRpc3BsYXllZE1lbW9yeSkge1xuICAgICAgICAgICAgdGhpcy5vdXRwdXREYXRhVXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENlYTYwOENoYW5uZWwucHJvdG90eXBlLmNjQU9GID0gZnVuY3Rpb24gKCkge1xuICAgIH07XG4gICAgQ2VhNjA4Q2hhbm5lbC5wcm90b3R5cGUuY2NBT04gPSBmdW5jdGlvbiAoKSB7XG4gICAgfTtcbiAgICBDZWE2MDhDaGFubmVsLnByb3RvdHlwZS5jY0RFUiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbG9nZ2VyLmxvZygnSU5GTycsICdERVItIERlbGV0ZSB0byBFbmQgb2YgUm93Jyk7XG4gICAgICAgIHRoaXMud3JpdGVTY3JlZW4uY2xlYXJUb0VuZE9mUm93KCk7XG4gICAgICAgIHRoaXMub3V0cHV0RGF0YVVwZGF0ZSgpO1xuICAgIH07XG4gICAgQ2VhNjA4Q2hhbm5lbC5wcm90b3R5cGUuY2NSVSA9IGZ1bmN0aW9uIChuclJvd3MpIHtcbiAgICAgICAgbG9nZ2VyLmxvZygnSU5GTycsICdSVSgnICsgbnJSb3dzICsgJykgLSBSb2xsIFVwJyk7XG4gICAgICAgIHRoaXMud3JpdGVTY3JlZW4gPSB0aGlzLmRpc3BsYXllZE1lbW9yeTtcbiAgICAgICAgdGhpcy5zZXRNb2RlKCdNT0RFX1JPTEwtVVAnKTtcbiAgICAgICAgdGhpcy53cml0ZVNjcmVlbi5zZXRSb2xsVXBSb3dzKG5yUm93cyk7XG4gICAgfTtcbiAgICBDZWE2MDhDaGFubmVsLnByb3RvdHlwZS5jY0ZPTiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbG9nZ2VyLmxvZygnSU5GTycsICdGT04gLSBGbGFzaCBPbicpO1xuICAgICAgICB0aGlzLndyaXRlU2NyZWVuLnNldFBlbih7IGZsYXNoOiB0cnVlIH0pO1xuICAgIH07XG4gICAgQ2VhNjA4Q2hhbm5lbC5wcm90b3R5cGUuY2NSREMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGxvZ2dlci5sb2coJ0lORk8nLCAnUkRDIC0gUmVzdW1lIERpcmVjdCBDYXB0aW9uaW5nJyk7XG4gICAgICAgIHRoaXMuc2V0TW9kZSgnTU9ERV9QQUlOVC1PTicpO1xuICAgIH07XG4gICAgQ2VhNjA4Q2hhbm5lbC5wcm90b3R5cGUuY2NUUiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbG9nZ2VyLmxvZygnSU5GTycsICdUUicpO1xuICAgICAgICB0aGlzLnNldE1vZGUoJ01PREVfVEVYVCcpO1xuICAgIH07XG4gICAgQ2VhNjA4Q2hhbm5lbC5wcm90b3R5cGUuY2NSVEQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGxvZ2dlci5sb2coJ0lORk8nLCAnUlREJyk7XG4gICAgICAgIHRoaXMuc2V0TW9kZSgnTU9ERV9URVhUJyk7XG4gICAgfTtcbiAgICBDZWE2MDhDaGFubmVsLnByb3RvdHlwZS5jY0VETSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbG9nZ2VyLmxvZygnSU5GTycsICdFRE0gLSBFcmFzZSBEaXNwbGF5ZWQgTWVtb3J5Jyk7XG4gICAgICAgIHRoaXMuZGlzcGxheWVkTWVtb3J5LnJlc2V0KCk7XG4gICAgICAgIHRoaXMub3V0cHV0RGF0YVVwZGF0ZSh0cnVlKTtcbiAgICB9O1xuICAgIENlYTYwOENoYW5uZWwucHJvdG90eXBlLmNjQ1IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGxvZ2dlci5sb2coJ0NSIC0gQ2FycmlhZ2UgUmV0dXJuJyk7XG4gICAgICAgIHRoaXMud3JpdGVTY3JlZW4ucm9sbFVwKCk7XG4gICAgICAgIHRoaXMub3V0cHV0RGF0YVVwZGF0ZSh0cnVlKTtcbiAgICB9O1xuICAgIENlYTYwOENoYW5uZWwucHJvdG90eXBlLmNjRU5NID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBsb2dnZXIubG9nKCdJTkZPJywgJ0VOTSAtIEVyYXNlIE5vbi1kaXNwbGF5ZWQgTWVtb3J5Jyk7XG4gICAgICAgIHRoaXMubm9uRGlzcGxheWVkTWVtb3J5LnJlc2V0KCk7XG4gICAgfTtcbiAgICBDZWE2MDhDaGFubmVsLnByb3RvdHlwZS5jY0VPQyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbG9nZ2VyLmxvZygnSU5GTycsICdFT0MgLSBFbmQgT2YgQ2FwdGlvbicpO1xuICAgICAgICBpZiAodGhpcy5tb2RlID09PSAnTU9ERV9QT1AtT04nKSB7XG4gICAgICAgICAgICB2YXIgdG1wID0gdGhpcy5kaXNwbGF5ZWRNZW1vcnk7XG4gICAgICAgICAgICB0aGlzLmRpc3BsYXllZE1lbW9yeSA9IHRoaXMubm9uRGlzcGxheWVkTWVtb3J5O1xuICAgICAgICAgICAgdGhpcy5ub25EaXNwbGF5ZWRNZW1vcnkgPSB0bXA7XG4gICAgICAgICAgICB0aGlzLndyaXRlU2NyZWVuID0gdGhpcy5ub25EaXNwbGF5ZWRNZW1vcnk7XG4gICAgICAgICAgICBsb2dnZXIubG9nKCdURVhUJywgJ0RJU1A6ICcgKyB0aGlzLmRpc3BsYXllZE1lbW9yeS5nZXREaXNwbGF5VGV4dCgpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm91dHB1dERhdGFVcGRhdGUodHJ1ZSk7XG4gICAgfTtcbiAgICBDZWE2MDhDaGFubmVsLnByb3RvdHlwZS5jY1RPID0gZnVuY3Rpb24gKG5yQ29scykge1xuICAgICAgICBsb2dnZXIubG9nKCdJTkZPJywgJ1RPKCcgKyBuckNvbHMgKyAnKSAtIFRhYiBPZmZzZXQnKTtcbiAgICAgICAgdGhpcy53cml0ZVNjcmVlbi5tb3ZlQ3Vyc29yKG5yQ29scyk7XG4gICAgfTtcbiAgICBDZWE2MDhDaGFubmVsLnByb3RvdHlwZS5jY01JRFJPVyA9IGZ1bmN0aW9uIChzZWNvbmRCeXRlKSB7XG4gICAgICAgIHZhciBzdHlsZXMgPSB7IGZsYXNoOiBmYWxzZSB9O1xuICAgICAgICBzdHlsZXMudW5kZXJsaW5lID0gc2Vjb25kQnl0ZSAlIDIgPT09IDE7XG4gICAgICAgIHN0eWxlcy5pdGFsaWNzID0gc2Vjb25kQnl0ZSA+PSAweDJlO1xuICAgICAgICBpZiAoIXN0eWxlcy5pdGFsaWNzKSB7XG4gICAgICAgICAgICB2YXIgY29sb3JJbmRleCA9IE1hdGguZmxvb3Ioc2Vjb25kQnl0ZSAvIDIpIC0gMHgxMDtcbiAgICAgICAgICAgIHZhciBjb2xvcnMgPSBbJ3doaXRlJywgJ2dyZWVuJywgJ2JsdWUnLCAnY3lhbicsICdyZWQnLCAneWVsbG93JywgJ21hZ2VudGEnXTtcbiAgICAgICAgICAgIHN0eWxlcy5mb3JlZ3JvdW5kID0gY29sb3JzW2NvbG9ySW5kZXhdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3R5bGVzLmZvcmVncm91bmQgPSAnd2hpdGUnO1xuICAgICAgICB9XG4gICAgICAgIGxvZ2dlci5sb2coJ0lORk8nLCAnTUlEUk9XOiAnICsgSlNPTi5zdHJpbmdpZnkoc3R5bGVzKSk7XG4gICAgICAgIHRoaXMud3JpdGVTY3JlZW4uc2V0UGVuKHN0eWxlcyk7XG4gICAgfTtcbiAgICBDZWE2MDhDaGFubmVsLnByb3RvdHlwZS5vdXRwdXREYXRhVXBkYXRlID0gZnVuY3Rpb24gKGRpc3BhdGNoKSB7XG4gICAgICAgIGlmIChkaXNwYXRjaCA9PT0gdm9pZCAwKSB7IGRpc3BhdGNoID0gZmFsc2U7IH1cbiAgICAgICAgdmFyIHQgPSBsb2dnZXIudGltZTtcbiAgICAgICAgaWYgKHQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vdXRwdXRGaWx0ZXIpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmN1ZVN0YXJ0VGltZSA9PT0gbnVsbCAmJiAhdGhpcy5kaXNwbGF5ZWRNZW1vcnkuaXNFbXB0eSgpKSB7IC8vIFN0YXJ0IG9mIGEgbmV3IGN1ZVxuICAgICAgICAgICAgICAgIHRoaXMuY3VlU3RhcnRUaW1lID0gdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5kaXNwbGF5ZWRNZW1vcnkuZXF1YWxzKHRoaXMubGFzdE91dHB1dFNjcmVlbikpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMub3V0cHV0RmlsdGVyLm5ld0N1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vdXRwdXRGaWx0ZXIubmV3Q3VlKHRoaXMuY3VlU3RhcnRUaW1lLCB0LCB0aGlzLmxhc3RPdXRwdXRTY3JlZW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRpc3BhdGNoID09PSB0cnVlICYmIHRoaXMub3V0cHV0RmlsdGVyLmRpc3BhdGNoQ3VlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vdXRwdXRGaWx0ZXIuZGlzcGF0Y2hDdWUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmN1ZVN0YXJ0VGltZSA9IHRoaXMuZGlzcGxheWVkTWVtb3J5LmlzRW1wdHkoKSA/IG51bGwgOiB0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubGFzdE91dHB1dFNjcmVlbi5jb3B5KHRoaXMuZGlzcGxheWVkTWVtb3J5KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ2VhNjA4Q2hhbm5lbC5wcm90b3R5cGUuY3VlU3BsaXRBdFRpbWUgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICBpZiAodGhpcy5vdXRwdXRGaWx0ZXIpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5kaXNwbGF5ZWRNZW1vcnkuaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3V0cHV0RmlsdGVyLm5ld0N1ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm91dHB1dEZpbHRlci5uZXdDdWUodGhpcy5jdWVTdGFydFRpbWUsIHQsIHRoaXMuZGlzcGxheWVkTWVtb3J5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5jdWVTdGFydFRpbWUgPSB0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gQ2VhNjA4Q2hhbm5lbDtcbn0oKSk7XG52YXIgQ2VhNjA4UGFyc2VyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENlYTYwOFBhcnNlcihmaWVsZCwgb3V0MSwgb3V0Mikge1xuICAgICAgICB0aGlzLmZpZWxkID0gZmllbGQgfHwgMTtcbiAgICAgICAgdGhpcy5vdXRwdXRzID0gW291dDEsIG91dDJdO1xuICAgICAgICB0aGlzLmNoYW5uZWxzID0gW25ldyBDZWE2MDhDaGFubmVsKDEsIG91dDEpLCBuZXcgQ2VhNjA4Q2hhbm5lbCgyLCBvdXQyKV07XG4gICAgICAgIHRoaXMuY3VyckNoTnIgPSAtMTsgLy8gV2lsbCBiZSAxIG9yIDJcbiAgICAgICAgdGhpcy5sYXN0Q21kQSA9IG51bGw7IC8vIEZpcnN0IGJ5dGUgb2YgbGFzdCBjb21tYW5kXG4gICAgICAgIHRoaXMubGFzdENtZEIgPSBudWxsOyAvLyBTZWNvbmQgYnl0ZSBvZiBsYXN0IGNvbW1hbmRcbiAgICAgICAgdGhpcy5idWZmZXJlZERhdGEgPSBbXTtcbiAgICAgICAgdGhpcy5zdGFydFRpbWUgPSBudWxsO1xuICAgICAgICB0aGlzLmxhc3RUaW1lID0gbnVsbDtcbiAgICAgICAgdGhpcy5kYXRhQ291bnRlcnMgPSB7ICdwYWRkaW5nJzogMCwgJ2NoYXInOiAwLCAnY21kJzogMCwgJ290aGVyJzogMCB9O1xuICAgIH1cbiAgICBDZWE2MDhQYXJzZXIucHJvdG90eXBlLmdldEhhbmRsZXIgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hhbm5lbHNbaW5kZXhdLmdldEhhbmRsZXIoKTtcbiAgICB9O1xuICAgIENlYTYwOFBhcnNlci5wcm90b3R5cGUuc2V0SGFuZGxlciA9IGZ1bmN0aW9uIChpbmRleCwgbmV3SGFuZGxlcikge1xuICAgICAgICB0aGlzLmNoYW5uZWxzW2luZGV4XS5zZXRIYW5kbGVyKG5ld0hhbmRsZXIpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICAgKiBBZGQgZGF0YSBmb3IgdGltZSB0IGluIGZvcm1zIG9mIGxpc3Qgb2YgYnl0ZXMgKHVuc2lnbmVkIGludHMpLiBUaGUgYnl0ZXMgYXJlIHRyZWF0ZWQgYXMgcGFpcnMuXG4gICAgICAgKi9cbiAgICBDZWE2MDhQYXJzZXIucHJvdG90eXBlLmFkZERhdGEgPSBmdW5jdGlvbiAodCwgYnl0ZUxpc3QpIHtcbiAgICAgICAgdmFyIGNtZEZvdW5kLCBhLCBiLCBjaGFyc0ZvdW5kID0gZmFsc2U7XG4gICAgICAgIHRoaXMubGFzdFRpbWUgPSB0O1xuICAgICAgICBsb2dnZXIuc2V0VGltZSh0KTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlTGlzdC5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgICAgYSA9IGJ5dGVMaXN0W2ldICYgMHg3ZjtcbiAgICAgICAgICAgIGIgPSBieXRlTGlzdFtpICsgMV0gJiAweDdmO1xuICAgICAgICAgICAgaWYgKGEgPT09IDAgJiYgYiA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGF0YUNvdW50ZXJzLnBhZGRpbmcgKz0gMjtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxvZ2dlci5sb2coJ0RBVEEnLCAnWycgKyBudW1BcnJheVRvSGV4QXJyYXkoW2J5dGVMaXN0W2ldLCBieXRlTGlzdFtpICsgMV1dKSArICddIC0+ICgnICsgbnVtQXJyYXlUb0hleEFycmF5KFthLCBiXSkgKyAnKScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY21kRm91bmQgPSB0aGlzLnBhcnNlQ21kKGEsIGIpO1xuICAgICAgICAgICAgaWYgKCFjbWRGb3VuZCkge1xuICAgICAgICAgICAgICAgIGNtZEZvdW5kID0gdGhpcy5wYXJzZU1pZHJvdyhhLCBiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghY21kRm91bmQpIHtcbiAgICAgICAgICAgICAgICBjbWRGb3VuZCA9IHRoaXMucGFyc2VQQUMoYSwgYik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWNtZEZvdW5kKSB7XG4gICAgICAgICAgICAgICAgY21kRm91bmQgPSB0aGlzLnBhcnNlQmFja2dyb3VuZEF0dHJpYnV0ZXMoYSwgYik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWNtZEZvdW5kKSB7XG4gICAgICAgICAgICAgICAgY2hhcnNGb3VuZCA9IHRoaXMucGFyc2VDaGFycyhhLCBiKTtcbiAgICAgICAgICAgICAgICBpZiAoY2hhcnNGb3VuZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jdXJyQ2hOciAmJiB0aGlzLmN1cnJDaE5yID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjaGFubmVsID0gdGhpcy5jaGFubmVsc1t0aGlzLmN1cnJDaE5yIC0gMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFubmVsLmluc2VydENoYXJzKGNoYXJzRm91bmQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmxvZygnV0FSTklORycsICdObyBjaGFubmVsIGZvdW5kIHlldC4gVEVYVC1NT0RFPycpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNtZEZvdW5kKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhQ291bnRlcnMuY21kICs9IDI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGFyc0ZvdW5kKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhQ291bnRlcnMuY2hhciArPSAyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhQ291bnRlcnMub3RoZXIgKz0gMjtcbiAgICAgICAgICAgICAgICBsb2dnZXIubG9nKCdXQVJOSU5HJywgJ0NvdWxkblxcJ3QgcGFyc2UgY2xlYW5lZCBkYXRhICcgKyBudW1BcnJheVRvSGV4QXJyYXkoW2EsIGJdKSArXG4gICAgICAgICAgICAgICAgICAgICcgb3JpZzogJyArIG51bUFycmF5VG9IZXhBcnJheShbYnl0ZUxpc3RbaV0sIGJ5dGVMaXN0W2kgKyAxXV0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICAgKiBQYXJzZSBDb21tYW5kLlxuICAgICAgICogQHJldHVybnMge0Jvb2xlYW59IFRlbGxzIGlmIGEgY29tbWFuZCB3YXMgZm91bmRcbiAgICAgICAqL1xuICAgIENlYTYwOFBhcnNlci5wcm90b3R5cGUucGFyc2VDbWQgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICB2YXIgY2hOciA9IG51bGw7XG4gICAgICAgIHZhciBjb25kMSA9IChhID09PSAweDE0IHx8IGEgPT09IDB4MUMpICYmIChiID49IDB4MjAgJiYgYiA8PSAweDJGKTtcbiAgICAgICAgdmFyIGNvbmQyID0gKGEgPT09IDB4MTcgfHwgYSA9PT0gMHgxRikgJiYgKGIgPj0gMHgyMSAmJiBiIDw9IDB4MjMpO1xuICAgICAgICBpZiAoIShjb25kMSB8fCBjb25kMikpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYSA9PT0gdGhpcy5sYXN0Q21kQSAmJiBiID09PSB0aGlzLmxhc3RDbWRCKSB7XG4gICAgICAgICAgICB0aGlzLmxhc3RDbWRBID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMubGFzdENtZEIgPSBudWxsOyAvLyBSZXBlYXRlZCBjb21tYW5kcyBhcmUgZHJvcHBlZCAob25jZSlcbiAgICAgICAgICAgIGxvZ2dlci5sb2coJ0RFQlVHJywgJ1JlcGVhdGVkIGNvbW1hbmQgKCcgKyBudW1BcnJheVRvSGV4QXJyYXkoW2EsIGJdKSArICcpIGlzIGRyb3BwZWQnKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhID09PSAweDE0IHx8IGEgPT09IDB4MTcpIHtcbiAgICAgICAgICAgIGNoTnIgPSAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY2hOciA9IDI7XG4gICAgICAgIH0gLy8gKGEgPT09IDB4MUMgfHwgYT09PSAweDFmKVxuICAgICAgICB2YXIgY2hhbm5lbCA9IHRoaXMuY2hhbm5lbHNbY2hOciAtIDFdO1xuICAgICAgICBpZiAoYSA9PT0gMHgxNCB8fCBhID09PSAweDFDKSB7XG4gICAgICAgICAgICBpZiAoYiA9PT0gMHgyMCkge1xuICAgICAgICAgICAgICAgIGNoYW5uZWwuY2NSQ0woKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGIgPT09IDB4MjEpIHtcbiAgICAgICAgICAgICAgICBjaGFubmVsLmNjQlMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGIgPT09IDB4MjIpIHtcbiAgICAgICAgICAgICAgICBjaGFubmVsLmNjQU9GKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChiID09PSAweDIzKSB7XG4gICAgICAgICAgICAgICAgY2hhbm5lbC5jY0FPTigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYiA9PT0gMHgyNCkge1xuICAgICAgICAgICAgICAgIGNoYW5uZWwuY2NERVIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGIgPT09IDB4MjUpIHtcbiAgICAgICAgICAgICAgICBjaGFubmVsLmNjUlUoMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChiID09PSAweDI2KSB7XG4gICAgICAgICAgICAgICAgY2hhbm5lbC5jY1JVKDMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYiA9PT0gMHgyNykge1xuICAgICAgICAgICAgICAgIGNoYW5uZWwuY2NSVSg0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGIgPT09IDB4MjgpIHtcbiAgICAgICAgICAgICAgICBjaGFubmVsLmNjRk9OKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChiID09PSAweDI5KSB7XG4gICAgICAgICAgICAgICAgY2hhbm5lbC5jY1JEQygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYiA9PT0gMHgyQSkge1xuICAgICAgICAgICAgICAgIGNoYW5uZWwuY2NUUigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYiA9PT0gMHgyQikge1xuICAgICAgICAgICAgICAgIGNoYW5uZWwuY2NSVEQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGIgPT09IDB4MkMpIHtcbiAgICAgICAgICAgICAgICBjaGFubmVsLmNjRURNKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChiID09PSAweDJEKSB7XG4gICAgICAgICAgICAgICAgY2hhbm5lbC5jY0NSKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChiID09PSAweDJFKSB7XG4gICAgICAgICAgICAgICAgY2hhbm5lbC5jY0VOTSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYiA9PT0gMHgyRikge1xuICAgICAgICAgICAgICAgIGNoYW5uZWwuY2NFT0MoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHsgLy8gYSA9PSAweDE3IHx8IGEgPT0gMHgxRlxuICAgICAgICAgICAgY2hhbm5lbC5jY1RPKGIgLSAweDIwKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxhc3RDbWRBID0gYTtcbiAgICAgICAgdGhpcy5sYXN0Q21kQiA9IGI7XG4gICAgICAgIHRoaXMuY3VyckNoTnIgPSBjaE5yO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAgICogUGFyc2UgbWlkcm93IHN0eWxpbmcgY29tbWFuZFxuICAgICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICAgKi9cbiAgICBDZWE2MDhQYXJzZXIucHJvdG90eXBlLnBhcnNlTWlkcm93ID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgdmFyIGNoTnIgPSBudWxsO1xuICAgICAgICBpZiAoKChhID09PSAweDExKSB8fCAoYSA9PT0gMHgxOSkpICYmIGIgPj0gMHgyMCAmJiBiIDw9IDB4MmYpIHtcbiAgICAgICAgICAgIGlmIChhID09PSAweDExKSB7XG4gICAgICAgICAgICAgICAgY2hOciA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjaE5yID0gMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjaE5yICE9PSB0aGlzLmN1cnJDaE5yKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmxvZygnRVJST1InLCAnTWlzbWF0Y2ggY2hhbm5lbCBpbiBtaWRyb3cgcGFyc2luZycpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBjaGFubmVsID0gdGhpcy5jaGFubmVsc1tjaE5yIC0gMV07XG4gICAgICAgICAgICBjaGFubmVsLmNjTUlEUk9XKGIpO1xuICAgICAgICAgICAgbG9nZ2VyLmxvZygnREVCVUcnLCAnTUlEUk9XICgnICsgbnVtQXJyYXlUb0hleEFycmF5KFthLCBiXSkgKyAnKScpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICAgKiBQYXJzZSBQcmVhYmxlIEFjY2VzcyBDb2RlcyAoVGFibGUgNTMpLlxuICAgICAgICogQHJldHVybnMge0Jvb2xlYW59IFRlbGxzIGlmIFBBQyBmb3VuZFxuICAgICAgICovXG4gICAgQ2VhNjA4UGFyc2VyLnByb3RvdHlwZS5wYXJzZVBBQyA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHZhciBjaE5yID0gbnVsbDtcbiAgICAgICAgdmFyIHJvdyA9IG51bGw7XG4gICAgICAgIHZhciBjYXNlMSA9ICgoYSA+PSAweDExICYmIGEgPD0gMHgxNykgfHwgKGEgPj0gMHgxOSAmJiBhIDw9IDB4MUYpKSAmJiAoYiA+PSAweDQwICYmIGIgPD0gMHg3Rik7XG4gICAgICAgIHZhciBjYXNlMiA9IChhID09PSAweDEwIHx8IGEgPT09IDB4MTgpICYmIChiID49IDB4NDAgJiYgYiA8PSAweDVGKTtcbiAgICAgICAgaWYgKCEoY2FzZTEgfHwgY2FzZTIpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGEgPT09IHRoaXMubGFzdENtZEEgJiYgYiA9PT0gdGhpcy5sYXN0Q21kQikge1xuICAgICAgICAgICAgdGhpcy5sYXN0Q21kQSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmxhc3RDbWRCID0gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiB0cnVlOyAvLyBSZXBlYXRlZCBjb21tYW5kcyBhcmUgZHJvcHBlZCAob25jZSlcbiAgICAgICAgfVxuICAgICAgICBjaE5yID0gKGEgPD0gMHgxNykgPyAxIDogMjtcbiAgICAgICAgaWYgKGIgPj0gMHg0MCAmJiBiIDw9IDB4NUYpIHtcbiAgICAgICAgICAgIHJvdyA9IChjaE5yID09PSAxKSA/IHJvd3NMb3dDaDFbYV0gOiByb3dzTG93Q2gyW2FdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgeyAvLyAweDYwIDw9IGIgPD0gMHg3RlxuICAgICAgICAgICAgcm93ID0gKGNoTnIgPT09IDEpID8gcm93c0hpZ2hDaDFbYV0gOiByb3dzSGlnaENoMlthXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcGFjRGF0YSA9IHRoaXMuaW50ZXJwcmV0UEFDKHJvdywgYik7XG4gICAgICAgIHZhciBjaGFubmVsID0gdGhpcy5jaGFubmVsc1tjaE5yIC0gMV07XG4gICAgICAgIGNoYW5uZWwuc2V0UEFDKHBhY0RhdGEpO1xuICAgICAgICB0aGlzLmxhc3RDbWRBID0gYTtcbiAgICAgICAgdGhpcy5sYXN0Q21kQiA9IGI7XG4gICAgICAgIHRoaXMuY3VyckNoTnIgPSBjaE5yO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAgICogSW50ZXJwcmV0IHRoZSBzZWNvbmQgYnl0ZSBvZiB0aGUgcGFjLCBhbmQgcmV0dXJuIHRoZSBpbmZvcm1hdGlvbi5cbiAgICAgICAqIEByZXR1cm5zIHtPYmplY3R9IHBhY0RhdGEgd2l0aCBzdHlsZSBwYXJhbWV0ZXJzLlxuICAgICAgICovXG4gICAgQ2VhNjA4UGFyc2VyLnByb3RvdHlwZS5pbnRlcnByZXRQQUMgPSBmdW5jdGlvbiAocm93LCBieXRlKSB7XG4gICAgICAgIHZhciBwYWNJbmRleCA9IGJ5dGU7XG4gICAgICAgIHZhciBwYWNEYXRhID0geyBjb2xvcjogbnVsbCwgaXRhbGljczogZmFsc2UsIGluZGVudDogbnVsbCwgdW5kZXJsaW5lOiBmYWxzZSwgcm93OiByb3cgfTtcbiAgICAgICAgaWYgKGJ5dGUgPiAweDVGKSB7XG4gICAgICAgICAgICBwYWNJbmRleCA9IGJ5dGUgLSAweDYwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGFjSW5kZXggPSBieXRlIC0gMHg0MDtcbiAgICAgICAgfVxuICAgICAgICBwYWNEYXRhLnVuZGVybGluZSA9IChwYWNJbmRleCAmIDEpID09PSAxO1xuICAgICAgICBpZiAocGFjSW5kZXggPD0gMHhkKSB7XG4gICAgICAgICAgICBwYWNEYXRhLmNvbG9yID0gWyd3aGl0ZScsICdncmVlbicsICdibHVlJywgJ2N5YW4nLCAncmVkJywgJ3llbGxvdycsICdtYWdlbnRhJywgJ3doaXRlJ11bTWF0aC5mbG9vcihwYWNJbmRleCAvIDIpXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwYWNJbmRleCA8PSAweGYpIHtcbiAgICAgICAgICAgIHBhY0RhdGEuaXRhbGljcyA9IHRydWU7XG4gICAgICAgICAgICBwYWNEYXRhLmNvbG9yID0gJ3doaXRlJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhY0RhdGEuaW5kZW50ID0gKE1hdGguZmxvb3IoKHBhY0luZGV4IC0gMHgxMCkgLyAyKSkgKiA0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYWNEYXRhOyAvLyBOb3RlIHRoYXQgcm93IGhhcyB6ZXJvIG9mZnNldC4gVGhlIHNwZWMgdXNlcyAxLlxuICAgIH07XG4gICAgLyoqXG4gICAgICAgKiBQYXJzZSBjaGFyYWN0ZXJzLlxuICAgICAgICogQHJldHVybnMgQW4gYXJyYXkgd2l0aCAxIHRvIDIgY29kZXMgY29ycmVzcG9uZGluZyB0byBjaGFycywgaWYgZm91bmQuIG51bGwgb3RoZXJ3aXNlLlxuICAgICAgICovXG4gICAgQ2VhNjA4UGFyc2VyLnByb3RvdHlwZS5wYXJzZUNoYXJzID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgdmFyIGNoYW5uZWxOciA9IG51bGwsIGNoYXJDb2RlcyA9IG51bGwsIGNoYXJDb2RlMSA9IG51bGw7XG4gICAgICAgIGlmIChhID49IDB4MTkpIHtcbiAgICAgICAgICAgIGNoYW5uZWxOciA9IDI7XG4gICAgICAgICAgICBjaGFyQ29kZTEgPSBhIC0gODtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNoYW5uZWxOciA9IDE7XG4gICAgICAgICAgICBjaGFyQ29kZTEgPSBhO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFyQ29kZTEgPj0gMHgxMSAmJiBjaGFyQ29kZTEgPD0gMHgxMykge1xuICAgICAgICAgICAgLy8gU3BlY2lhbCBjaGFyYWN0ZXJcbiAgICAgICAgICAgIHZhciBvbmVDb2RlID0gYjtcbiAgICAgICAgICAgIGlmIChjaGFyQ29kZTEgPT09IDB4MTEpIHtcbiAgICAgICAgICAgICAgICBvbmVDb2RlID0gYiArIDB4NTA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGFyQ29kZTEgPT09IDB4MTIpIHtcbiAgICAgICAgICAgICAgICBvbmVDb2RlID0gYiArIDB4NzA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBvbmVDb2RlID0gYiArIDB4OTA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsb2dnZXIubG9nKCdJTkZPJywgJ1NwZWNpYWwgY2hhciBcXCcnICsgZ2V0Q2hhckZvckJ5dGUob25lQ29kZSkgKyAnXFwnIGluIGNoYW5uZWwgJyArIGNoYW5uZWxOcik7XG4gICAgICAgICAgICBjaGFyQ29kZXMgPSBbb25lQ29kZV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYSA+PSAweDIwICYmIGEgPD0gMHg3Zikge1xuICAgICAgICAgICAgY2hhckNvZGVzID0gKGIgPT09IDApID8gW2FdIDogW2EsIGJdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFyQ29kZXMpIHtcbiAgICAgICAgICAgIHZhciBoZXhDb2RlcyA9IG51bUFycmF5VG9IZXhBcnJheShjaGFyQ29kZXMpO1xuICAgICAgICAgICAgbG9nZ2VyLmxvZygnREVCVUcnLCAnQ2hhciBjb2RlcyA9ICAnICsgaGV4Q29kZXMuam9pbignLCcpKTtcbiAgICAgICAgICAgIHRoaXMubGFzdENtZEEgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5sYXN0Q21kQiA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNoYXJDb2RlcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAgKiBQYXJzZSBleHRlbmRlZCBiYWNrZ3JvdW5kIGF0dHJpYnV0ZXMgYXMgd2VsbCBhcyBuZXcgZm9yZWdyb3VuZCBjb2xvciBibGFjay5cbiAgICAgICogQHJldHVybnN7Qm9vbGVhbn0gVGVsbHMgaWYgYmFja2dyb3VuZCBhdHRyaWJ1dGVzIGFyZSBmb3VuZFxuICAgICAgKi9cbiAgICBDZWE2MDhQYXJzZXIucHJvdG90eXBlLnBhcnNlQmFja2dyb3VuZEF0dHJpYnV0ZXMgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICB2YXIgYmtnRGF0YSwgaW5kZXgsIGNoTnIsIGNoYW5uZWw7XG4gICAgICAgIHZhciBjYXNlMSA9IChhID09PSAweDEwIHx8IGEgPT09IDB4MTgpICYmIChiID49IDB4MjAgJiYgYiA8PSAweDJmKTtcbiAgICAgICAgdmFyIGNhc2UyID0gKGEgPT09IDB4MTcgfHwgYSA9PT0gMHgxZikgJiYgKGIgPj0gMHgyZCAmJiBiIDw9IDB4MmYpO1xuICAgICAgICBpZiAoIShjYXNlMSB8fCBjYXNlMikpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBia2dEYXRhID0ge307XG4gICAgICAgIGlmIChhID09PSAweDEwIHx8IGEgPT09IDB4MTgpIHtcbiAgICAgICAgICAgIGluZGV4ID0gTWF0aC5mbG9vcigoYiAtIDB4MjApIC8gMik7XG4gICAgICAgICAgICBia2dEYXRhLmJhY2tncm91bmQgPSBiYWNrZ3JvdW5kQ29sb3JzW2luZGV4XTtcbiAgICAgICAgICAgIGlmIChiICUgMiA9PT0gMSkge1xuICAgICAgICAgICAgICAgIGJrZ0RhdGEuYmFja2dyb3VuZCA9IGJrZ0RhdGEuYmFja2dyb3VuZCArICdfc2VtaSc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYiA9PT0gMHgyZCkge1xuICAgICAgICAgICAgYmtnRGF0YS5iYWNrZ3JvdW5kID0gJ3RyYW5zcGFyZW50JztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJrZ0RhdGEuZm9yZWdyb3VuZCA9ICdibGFjayc7XG4gICAgICAgICAgICBpZiAoYiA9PT0gMHgyZikge1xuICAgICAgICAgICAgICAgIGJrZ0RhdGEudW5kZXJsaW5lID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjaE5yID0gKGEgPCAweDE4KSA/IDEgOiAyO1xuICAgICAgICBjaGFubmVsID0gdGhpcy5jaGFubmVsc1tjaE5yIC0gMV07XG4gICAgICAgIGNoYW5uZWwuc2V0QmtnRGF0YShia2dEYXRhKTtcbiAgICAgICAgdGhpcy5sYXN0Q21kQSA9IG51bGw7XG4gICAgICAgIHRoaXMubGFzdENtZEIgPSBudWxsO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAgICogUmVzZXQgc3RhdGUgb2YgcGFyc2VyIGFuZCBpdHMgY2hhbm5lbHMuXG4gICAgICAgKi9cbiAgICBDZWE2MDhQYXJzZXIucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY2hhbm5lbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNoYW5uZWxzW2ldKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGFubmVsc1tpXS5yZXNldCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMubGFzdENtZEEgPSBudWxsO1xuICAgICAgICB0aGlzLmxhc3RDbWRCID0gbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAgICogVHJpZ2dlciB0aGUgZ2VuZXJhdGlvbiBvZiBhIGN1ZSwgYW5kIHRoZSBzdGFydCBvZiBhIG5ldyBvbmUgaWYgZGlzcGxheVNjcmVlbnMgYXJlIG5vdCBlbXB0eS5cbiAgICAgICAqL1xuICAgIENlYTYwOFBhcnNlci5wcm90b3R5cGUuY3VlU3BsaXRBdFRpbWUgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY2hhbm5lbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNoYW5uZWxzW2ldKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGFubmVsc1tpXS5jdWVTcGxpdEF0VGltZSh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIENlYTYwOFBhcnNlcjtcbn0oKSk7XG5leHBvcnRzLmRlZmF1bHQgPSBDZWE2MDhQYXJzZXI7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvdXRpbHMvY29kZWNzLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy91dGlscy9jb2RlY3MuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vLyBmcm9tIGh0dHA6Ly9tcDRyYS5vcmcvY29kZWNzLmh0bWxcbnZhciBzYW1wbGVFbnRyeUNvZGVzSVNPID0ge1xuICAgIGF1ZGlvOiB7XG4gICAgICAgICdhM2RzJzogdHJ1ZSxcbiAgICAgICAgJ2FjLTMnOiB0cnVlLFxuICAgICAgICAnYWMtNCc6IHRydWUsXG4gICAgICAgICdhbGFjJzogdHJ1ZSxcbiAgICAgICAgJ2FsYXcnOiB0cnVlLFxuICAgICAgICAnZHJhMSc6IHRydWUsXG4gICAgICAgICdkdHMrJzogdHJ1ZSxcbiAgICAgICAgJ2R0cy0nOiB0cnVlLFxuICAgICAgICAnZHRzYyc6IHRydWUsXG4gICAgICAgICdkdHNlJzogdHJ1ZSxcbiAgICAgICAgJ2R0c2gnOiB0cnVlLFxuICAgICAgICAnZWMtMyc6IHRydWUsXG4gICAgICAgICdlbmNhJzogdHJ1ZSxcbiAgICAgICAgJ2c3MTknOiB0cnVlLFxuICAgICAgICAnZzcyNic6IHRydWUsXG4gICAgICAgICdtNGFlJzogdHJ1ZSxcbiAgICAgICAgJ21oYTEnOiB0cnVlLFxuICAgICAgICAnbWhhMic6IHRydWUsXG4gICAgICAgICdtaG0xJzogdHJ1ZSxcbiAgICAgICAgJ21obTInOiB0cnVlLFxuICAgICAgICAnbWxwYSc6IHRydWUsXG4gICAgICAgICdtcDRhJzogdHJ1ZSxcbiAgICAgICAgJ3JhdyAnOiB0cnVlLFxuICAgICAgICAnT3B1cyc6IHRydWUsXG4gICAgICAgICdzYW1yJzogdHJ1ZSxcbiAgICAgICAgJ3Nhd2InOiB0cnVlLFxuICAgICAgICAnc2F3cCc6IHRydWUsXG4gICAgICAgICdzZXZjJzogdHJ1ZSxcbiAgICAgICAgJ3NxY3AnOiB0cnVlLFxuICAgICAgICAnc3Ntdic6IHRydWUsXG4gICAgICAgICd0d29zJzogdHJ1ZSxcbiAgICAgICAgJ3VsYXcnOiB0cnVlXG4gICAgfSxcbiAgICB2aWRlbzoge1xuICAgICAgICAnYXZjMSc6IHRydWUsXG4gICAgICAgICdhdmMyJzogdHJ1ZSxcbiAgICAgICAgJ2F2YzMnOiB0cnVlLFxuICAgICAgICAnYXZjNCc6IHRydWUsXG4gICAgICAgICdhdmNwJzogdHJ1ZSxcbiAgICAgICAgJ2RyYWMnOiB0cnVlLFxuICAgICAgICAnZHZhdic6IHRydWUsXG4gICAgICAgICdkdmhlJzogdHJ1ZSxcbiAgICAgICAgJ2VuY3YnOiB0cnVlLFxuICAgICAgICAnaGV2MSc6IHRydWUsXG4gICAgICAgICdodmMxJzogdHJ1ZSxcbiAgICAgICAgJ21qcDInOiB0cnVlLFxuICAgICAgICAnbXA0dic6IHRydWUsXG4gICAgICAgICdtdmMxJzogdHJ1ZSxcbiAgICAgICAgJ212YzInOiB0cnVlLFxuICAgICAgICAnbXZjMyc6IHRydWUsXG4gICAgICAgICdtdmM0JzogdHJ1ZSxcbiAgICAgICAgJ3Jlc3YnOiB0cnVlLFxuICAgICAgICAncnY2MCc6IHRydWUsXG4gICAgICAgICdzMjYzJzogdHJ1ZSxcbiAgICAgICAgJ3N2YzEnOiB0cnVlLFxuICAgICAgICAnc3ZjMic6IHRydWUsXG4gICAgICAgICd2Yy0xJzogdHJ1ZSxcbiAgICAgICAgJ3ZwMDgnOiB0cnVlLFxuICAgICAgICAndnAwOSc6IHRydWVcbiAgICB9XG59O1xuZnVuY3Rpb24gaXNDb2RlY1R5cGUoY29kZWMsIHR5cGUpIHtcbiAgICB2YXIgdHlwZUNvZGVzID0gc2FtcGxlRW50cnlDb2Rlc0lTT1t0eXBlXTtcbiAgICByZXR1cm4gISF0eXBlQ29kZXMgJiYgdHlwZUNvZGVzW2NvZGVjLnNsaWNlKDAsIDQpXSA9PT0gdHJ1ZTtcbn1cbmV4cG9ydHMuaXNDb2RlY1R5cGUgPSBpc0NvZGVjVHlwZTtcbmZ1bmN0aW9uIGlzQ29kZWNTdXBwb3J0ZWRJbk1wNChjb2RlYywgdHlwZSkge1xuICAgIHJldHVybiB3aW5kb3cuTWVkaWFTb3VyY2UuaXNUeXBlU3VwcG9ydGVkKCh0eXBlIHx8ICd2aWRlbycpICsgXCIvbXA0O2NvZGVjcz1cXFwiXCIgKyBjb2RlYyArIFwiXFxcIlwiKTtcbn1cbmV4cG9ydHMuaXNDb2RlY1N1cHBvcnRlZEluTXA0ID0gaXNDb2RlY1N1cHBvcnRlZEluTXA0O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3V0aWxzL2N1ZXMuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy91dGlscy9jdWVzLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qISBNb2R1bGVDb25jYXRlbmF0aW9uIGJhaWxvdXQ6IE1vZHVsZSBpcyBub3QgYW4gRUNNQVNjcmlwdCBtb2R1bGUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB2dHRwYXJzZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdnR0cGFyc2VyICovIFwiLi9zcmMvdXRpbHMvdnR0cGFyc2VyLmpzXCIpO1xuZnVuY3Rpb24gbmV3Q3VlKHRyYWNrLCBzdGFydFRpbWUsIGVuZFRpbWUsIGNhcHRpb25TY3JlZW4pIHtcbiAgICB2YXIgcm93O1xuICAgIHZhciBjdWU7XG4gICAgdmFyIGluZGVudGluZztcbiAgICB2YXIgaW5kZW50O1xuICAgIHZhciB0ZXh0O1xuICAgIHZhciBWVFRDdWUgPSB3aW5kb3cuVlRUQ3VlIHx8IHdpbmRvdy5UZXh0VHJhY2tDdWU7XG4gICAgZm9yICh2YXIgciA9IDA7IHIgPCBjYXB0aW9uU2NyZWVuLnJvd3MubGVuZ3RoOyByKyspIHtcbiAgICAgICAgcm93ID0gY2FwdGlvblNjcmVlbi5yb3dzW3JdO1xuICAgICAgICBpbmRlbnRpbmcgPSB0cnVlO1xuICAgICAgICBpbmRlbnQgPSAwO1xuICAgICAgICB0ZXh0ID0gJyc7XG4gICAgICAgIGlmICghcm93LmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgZm9yICh2YXIgYyA9IDA7IGMgPCByb3cuY2hhcnMubGVuZ3RoOyBjKyspIHtcbiAgICAgICAgICAgICAgICBpZiAocm93LmNoYXJzW2NdLnVjaGFyLm1hdGNoKC9cXHMvKSAmJiBpbmRlbnRpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZW50Kys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0ICs9IHJvdy5jaGFyc1tjXS51Y2hhcjtcbiAgICAgICAgICAgICAgICAgICAgaW5kZW50aW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVG8gYmUgdXNlZCBmb3IgY2xlYW5pbmctdXAgb3JwaGFuZWQgcm9sbC11cCBjYXB0aW9uc1xuICAgICAgICAgICAgcm93LmN1ZVN0YXJ0VGltZSA9IHN0YXJ0VGltZTtcbiAgICAgICAgICAgIC8vIEdpdmUgYSBzbGlnaHQgYnVtcCB0byB0aGUgZW5kVGltZSBpZiBpdCdzIGVxdWFsIHRvIHN0YXJ0VGltZSB0byBhdm9pZCBhIFN5bnRheEVycm9yIGluIElFXG4gICAgICAgICAgICBpZiAoc3RhcnRUaW1lID09PSBlbmRUaW1lKSB7XG4gICAgICAgICAgICAgICAgZW5kVGltZSArPSAwLjAwMDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdWUgPSBuZXcgVlRUQ3VlKHN0YXJ0VGltZSwgZW5kVGltZSwgdnR0cGFyc2VyXzEuZml4TGluZUJyZWFrcyh0ZXh0LnRyaW0oKSkpO1xuICAgICAgICAgICAgaWYgKGluZGVudCA+PSAxNikge1xuICAgICAgICAgICAgICAgIGluZGVudC0tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaW5kZW50Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBWVFRDdWUubGluZSBnZXQncyBmbGFrZXkgd2hlbiB1c2luZyBjb250cm9scywgc28gbGV0J3Mgbm93IGluY2x1ZGUgbGluZSAxMyYxNFxuICAgICAgICAgICAgLy8gYWxzbywgZHJvcCBsaW5lIDEgc2luY2UgaXQncyB0byBjbG9zZSB0byB0aGUgdG9wXG4gICAgICAgICAgICBpZiAobmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvRmlyZWZveFxcLy8pKSB7XG4gICAgICAgICAgICAgICAgY3VlLmxpbmUgPSByICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGN1ZS5saW5lID0gKHIgPiA3ID8gciAtIDIgOiByICsgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdWUuYWxpZ24gPSAnbGVmdCc7XG4gICAgICAgICAgICAvLyBDbGFtcCB0aGUgcG9zaXRpb24gYmV0d2VlbiAwIGFuZCAxMDAgLSBpZiBvdXQgb2YgdGhlc2UgYm91bmRzLCBGaXJlZm94IHRocm93cyBhbiBleGNlcHRpb24gYW5kIGNhcHRpb25zIGJyZWFrXG4gICAgICAgICAgICBjdWUucG9zaXRpb24gPSBNYXRoLm1heCgwLCBNYXRoLm1pbigxMDAsIDEwMCAqIChpbmRlbnQgLyAzMikgKyAobmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvRmlyZWZveFxcLy8pID8gNTAgOiAwKSkpO1xuICAgICAgICAgICAgdHJhY2suYWRkQ3VlKGN1ZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLm5ld0N1ZSA9IG5ld0N1ZTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy91dGlscy9kaXNjb250aW51aXRpZXMuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3V0aWxzL2Rpc2NvbnRpbnVpdGllcy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qISBNb2R1bGVDb25jYXRlbmF0aW9uIGJhaWxvdXQ6IE1vZHVsZSBpcyBub3QgYW4gRUNNQVNjcmlwdCBtb2R1bGUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi8oZnVuY3Rpb24oTnVtYmVyKSB7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgYmluYXJ5X3NlYXJjaF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9iaW5hcnktc2VhcmNoICovIFwiLi9zcmMvdXRpbHMvYmluYXJ5LXNlYXJjaC5qc1wiKTtcbnZhciBsb2dnZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL2xvZ2dlciAqLyBcIi4vc3JjL3V0aWxzL2xvZ2dlci5qc1wiKTtcbmZ1bmN0aW9uIGZpbmRGaXJzdEZyYWdXaXRoQ0MoZnJhZ21lbnRzLCBjYykge1xuICAgIHZhciBmaXJzdEZyYWcgPSBudWxsO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZnJhZ21lbnRzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciBjdXJyZW50RnJhZyA9IGZyYWdtZW50c1tpXTtcbiAgICAgICAgaWYgKGN1cnJlbnRGcmFnICYmIGN1cnJlbnRGcmFnLmNjID09PSBjYykge1xuICAgICAgICAgICAgZmlyc3RGcmFnID0gY3VycmVudEZyYWc7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmlyc3RGcmFnO1xufVxuZXhwb3J0cy5maW5kRmlyc3RGcmFnV2l0aENDID0gZmluZEZpcnN0RnJhZ1dpdGhDQztcbmZ1bmN0aW9uIGZpbmRGcmFnV2l0aENDKGZyYWdtZW50cywgQ0MpIHtcbiAgICByZXR1cm4gYmluYXJ5X3NlYXJjaF8xLmRlZmF1bHQuc2VhcmNoKGZyYWdtZW50cywgZnVuY3Rpb24gKGNhbmRpZGF0ZSkge1xuICAgICAgICBpZiAoY2FuZGlkYXRlLmNjIDwgQ0MpIHtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNhbmRpZGF0ZS5jYyA+IENDKSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZXhwb3J0cy5maW5kRnJhZ1dpdGhDQyA9IGZpbmRGcmFnV2l0aENDO1xuZnVuY3Rpb24gc2hvdWxkQWxpZ25PbkRpc2NvbnRpbnVpdGllcyhsYXN0RnJhZywgbGFzdExldmVsLCBkZXRhaWxzKSB7XG4gICAgdmFyIHNob3VsZEFsaWduID0gZmFsc2U7XG4gICAgaWYgKGxhc3RMZXZlbCAmJiBsYXN0TGV2ZWwuZGV0YWlscyAmJiBkZXRhaWxzKSB7XG4gICAgICAgIGlmIChkZXRhaWxzLmVuZENDID4gZGV0YWlscy5zdGFydENDIHx8IChsYXN0RnJhZyAmJiBsYXN0RnJhZy5jYyA8IGRldGFpbHMuc3RhcnRDQykpIHtcbiAgICAgICAgICAgIHNob3VsZEFsaWduID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2hvdWxkQWxpZ247XG59XG5leHBvcnRzLnNob3VsZEFsaWduT25EaXNjb250aW51aXRpZXMgPSBzaG91bGRBbGlnbk9uRGlzY29udGludWl0aWVzO1xuLy8gRmluZCB0aGUgZmlyc3QgZnJhZyBpbiB0aGUgcHJldmlvdXMgbGV2ZWwgd2hpY2ggbWF0Y2hlcyB0aGUgQ0Mgb2YgdGhlIGZpcnN0IGZyYWcgb2YgdGhlIG5ldyBsZXZlbFxuZnVuY3Rpb24gZmluZERpc2NvbnRpbnVvdXNSZWZlcmVuY2VGcmFnKHByZXZEZXRhaWxzLCBjdXJEZXRhaWxzKSB7XG4gICAgdmFyIHByZXZGcmFncyA9IHByZXZEZXRhaWxzLmZyYWdtZW50cztcbiAgICB2YXIgY3VyRnJhZ3MgPSBjdXJEZXRhaWxzLmZyYWdtZW50cztcbiAgICBpZiAoIWN1ckZyYWdzLmxlbmd0aCB8fCAhcHJldkZyYWdzLmxlbmd0aCkge1xuICAgICAgICBsb2dnZXJfMS5sb2dnZXIubG9nKCdObyBmcmFnbWVudHMgdG8gYWxpZ24nKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgcHJldlN0YXJ0RnJhZyA9IGZpbmRGaXJzdEZyYWdXaXRoQ0MocHJldkZyYWdzLCBjdXJGcmFnc1swXS5jYyk7XG4gICAgaWYgKCFwcmV2U3RhcnRGcmFnIHx8IChwcmV2U3RhcnRGcmFnICYmICFwcmV2U3RhcnRGcmFnLnN0YXJ0UFRTKSkge1xuICAgICAgICBsb2dnZXJfMS5sb2dnZXIubG9nKCdObyBmcmFnIGluIHByZXZpb3VzIGxldmVsIHRvIGFsaWduIG9uJyk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmV0dXJuIHByZXZTdGFydEZyYWc7XG59XG5leHBvcnRzLmZpbmREaXNjb250aW51b3VzUmVmZXJlbmNlRnJhZyA9IGZpbmREaXNjb250aW51b3VzUmVmZXJlbmNlRnJhZztcbmZ1bmN0aW9uIGFkanVzdFB0cyhzbGlkaW5nLCBkZXRhaWxzKSB7XG4gICAgZGV0YWlscy5mcmFnbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoZnJhZykge1xuICAgICAgICBpZiAoZnJhZykge1xuICAgICAgICAgICAgdmFyIHN0YXJ0ID0gZnJhZy5zdGFydCArIHNsaWRpbmc7XG4gICAgICAgICAgICBmcmFnLnN0YXJ0ID0gZnJhZy5zdGFydFBUUyA9IHN0YXJ0O1xuICAgICAgICAgICAgZnJhZy5lbmRQVFMgPSBzdGFydCArIGZyYWcuZHVyYXRpb247XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBkZXRhaWxzLlBUU0tub3duID0gdHJ1ZTtcbn1cbmV4cG9ydHMuYWRqdXN0UHRzID0gYWRqdXN0UHRzO1xuLyoqXG4gKiBVc2luZyB0aGUgcGFyYW1ldGVycyBvZiB0aGUgbGFzdCBsZXZlbCwgdGhpcyBmdW5jdGlvbiBjb21wdXRlcyBQVFMnIG9mIHRoZSBuZXcgZnJhZ21lbnRzIHNvIHRoYXQgdGhleSBmb3JtIGFcbiAqIGNvbnRpZ3VvdXMgc3RyZWFtIHdpdGggdGhlIGxhc3QgZnJhZ21lbnRzLlxuICogVGhlIFBUUyBvZiBhIGZyYWdtZW50IGxldHMgSGxzLmpzIGtub3cgd2hlcmUgaXQgZml0cyBpbnRvIGEgc3RyZWFtIC0gYnkga25vd2luZyBldmVyeSBQVFMsIHdlIGtub3cgd2hpY2ggZnJhZ21lbnQgdG9cbiAqIGRvd25sb2FkIGF0IGFueSBnaXZlbiB0aW1lLiBQVFMgaXMgbm9ybWFsbHkgY29tcHV0ZWQgd2hlbiB0aGUgZnJhZ21lbnQgaXMgZGVtdXhlZCwgc28gdGFraW5nIHRoaXMgc3RlcCBzYXZlcyB1cyB0aW1lXG4gKiBhbmQgYW4gZXh0cmEgZG93bmxvYWQuXG4gKiBAcGFyYW0gbGFzdEZyYWdcbiAqIEBwYXJhbSBsYXN0TGV2ZWxcbiAqIEBwYXJhbSBkZXRhaWxzXG4gKi9cbmZ1bmN0aW9uIGFsaWduU3RyZWFtKGxhc3RGcmFnLCBsYXN0TGV2ZWwsIGRldGFpbHMpIHtcbiAgICBhbGlnbkRpc2NvbnRpbnVpdGllcyhsYXN0RnJhZywgZGV0YWlscywgbGFzdExldmVsKTtcbiAgICBpZiAoIWRldGFpbHMuUFRTS25vd24gJiYgbGFzdExldmVsKSB7XG4gICAgICAgIC8vIElmIHRoZSBQVFMgd2Fzbid0IGZpZ3VyZWQgb3V0IHZpYSBkaXNjb250aW51aXR5IHNlcXVlbmNlIHRoYXQgbWVhbnMgdGhlcmUgd2FzIG5vIENDIGluY3JlYXNlIHdpdGhpbiB0aGUgbGV2ZWwuXG4gICAgICAgIC8vIEFsaWduaW5nIHZpYSBQcm9ncmFtIERhdGUgVGltZSBzaG91bGQgdGhlcmVmb3JlIGJlIHJlbGlhYmxlLCBzaW5jZSBQRFQgc2hvdWxkIGJlIHRoZSBzYW1lIHdpdGhpbiB0aGUgc2FtZVxuICAgICAgICAvLyBkaXNjb250aW51aXR5IHNlcXVlbmNlLlxuICAgICAgICBhbGlnblBEVChkZXRhaWxzLCBsYXN0TGV2ZWwuZGV0YWlscyk7XG4gICAgfVxufVxuZXhwb3J0cy5hbGlnblN0cmVhbSA9IGFsaWduU3RyZWFtO1xuLyoqXG4gKiBDb21wdXRlcyB0aGUgUFRTIGlmIGEgbmV3IGxldmVsJ3MgZnJhZ21lbnRzIHVzaW5nIHRoZSBQVFMgb2YgYSBmcmFnbWVudCBpbiB0aGUgbGFzdCBsZXZlbCB3aGljaCBzaGFyZXMgdGhlIHNhbWVcbiAqIGRpc2NvbnRpbnVpdHkgc2VxdWVuY2UuXG4gKiBAcGFyYW0gbGFzdExldmVsIC0gVGhlIGRldGFpbHMgb2YgdGhlIGxhc3QgbG9hZGVkIGxldmVsXG4gKiBAcGFyYW0gZGV0YWlscyAtIFRoZSBkZXRhaWxzIG9mIHRoZSBuZXcgbGV2ZWxcbiAqL1xuZnVuY3Rpb24gYWxpZ25EaXNjb250aW51aXRpZXMobGFzdEZyYWcsIGRldGFpbHMsIGxhc3RMZXZlbCkge1xuICAgIGlmIChzaG91bGRBbGlnbk9uRGlzY29udGludWl0aWVzKGxhc3RGcmFnLCBsYXN0TGV2ZWwsIGRldGFpbHMpKSB7XG4gICAgICAgIHZhciByZWZlcmVuY2VGcmFnID0gZmluZERpc2NvbnRpbnVvdXNSZWZlcmVuY2VGcmFnKGxhc3RMZXZlbC5kZXRhaWxzLCBkZXRhaWxzKTtcbiAgICAgICAgaWYgKHJlZmVyZW5jZUZyYWcpIHtcbiAgICAgICAgICAgIGxvZ2dlcl8xLmxvZ2dlci5sb2coJ0FkanVzdGluZyBQVFMgdXNpbmcgbGFzdCBsZXZlbCBkdWUgdG8gQ0MgaW5jcmVhc2Ugd2l0aGluIGN1cnJlbnQgbGV2ZWwnKTtcbiAgICAgICAgICAgIGFkanVzdFB0cyhyZWZlcmVuY2VGcmFnLnN0YXJ0LCBkZXRhaWxzKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuYWxpZ25EaXNjb250aW51aXRpZXMgPSBhbGlnbkRpc2NvbnRpbnVpdGllcztcbi8qKlxuICogQ29tcHV0ZXMgdGhlIFBUUyBvZiBhIG5ldyBsZXZlbCdzIGZyYWdtZW50cyB1c2luZyB0aGUgZGlmZmVyZW5jZSBpbiBQcm9ncmFtIERhdGUgVGltZSBmcm9tIHRoZSBsYXN0IGxldmVsLlxuICogQHBhcmFtIGRldGFpbHMgLSBUaGUgZGV0YWlscyBvZiB0aGUgbmV3IGxldmVsXG4gKiBAcGFyYW0gbGFzdERldGFpbHMgLSBUaGUgZGV0YWlscyBvZiB0aGUgbGFzdCBsb2FkZWQgbGV2ZWxcbiAqL1xuZnVuY3Rpb24gYWxpZ25QRFQoZGV0YWlscywgbGFzdERldGFpbHMpIHtcbiAgICBpZiAobGFzdERldGFpbHMgJiYgbGFzdERldGFpbHMuZnJhZ21lbnRzLmxlbmd0aCkge1xuICAgICAgICBpZiAoIWRldGFpbHMuaGFzUHJvZ3JhbURhdGVUaW1lIHx8ICFsYXN0RGV0YWlscy5oYXNQcm9ncmFtRGF0ZVRpbWUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBpZiBsYXN0IGxldmVsIHNsaWRpbmcgaXMgMTAwMCBhbmQgaXRzIGZpcnN0IGZyYWcgUFJPR1JBTS1EQVRFLVRJTUUgaXMgMjAxNy0wOC0yMCAxOjEwOjAwIEFNXG4gICAgICAgIC8vIGFuZCBpZiBuZXcgZGV0YWlscyBmaXJzdCBmcmFnIFBST0dSQU0gREFURS1USU1FIGlzIDIwMTctMDgtMjAgMToxMDowOCBBTVxuICAgICAgICAvLyB0aGVuIHdlIGNhbiBkZWR1Y2UgdGhhdCBwbGF5bGlzdCBCIHNsaWRpbmcgaXMgMTAwMCs4ID0gMTAwOHNcbiAgICAgICAgdmFyIGxhc3RQRFQgPSBsYXN0RGV0YWlscy5mcmFnbWVudHNbMF0ucHJvZ3JhbURhdGVUaW1lO1xuICAgICAgICB2YXIgbmV3UERUID0gZGV0YWlscy5mcmFnbWVudHNbMF0ucHJvZ3JhbURhdGVUaW1lO1xuICAgICAgICAvLyBkYXRlIGRpZmYgaXMgaW4gbXMuIGZyYWcuc3RhcnQgaXMgaW4gc2Vjb25kc1xuICAgICAgICB2YXIgc2xpZGluZyA9IChuZXdQRFQgLSBsYXN0UERUKSAvIDEwMDAgKyBsYXN0RGV0YWlscy5mcmFnbWVudHNbMF0uc3RhcnQ7XG4gICAgICAgIGlmIChOdW1iZXIuaXNGaW5pdGUoc2xpZGluZykpIHtcbiAgICAgICAgICAgIGxvZ2dlcl8xLmxvZ2dlci5sb2coXCJhZGp1c3RpbmcgUFRTIHVzaW5nIHByb2dyYW1EYXRlVGltZSBkZWx0YSwgc2xpZGluZzpcIiArIHNsaWRpbmcudG9GaXhlZCgzKSk7XG4gICAgICAgICAgICBhZGp1c3RQdHMoc2xpZGluZywgZGV0YWlscyk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLmFsaWduUERUID0gYWxpZ25QRFQ7XG5cbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqL30uY2FsbCh0aGlzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3NyYy9wb2x5ZmlsbHMvbnVtYmVyICovIFwiLi9zcmMvcG9seWZpbGxzL251bWJlci5qc1wiKVtcIk51bWJlclwiXSkpXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3V0aWxzL2V3bWEtYmFuZHdpZHRoLWVzdGltYXRvci5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvdXRpbHMvZXdtYS1iYW5kd2lkdGgtZXN0aW1hdG9yLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLypcbiAqIEVXTUEgQmFuZHdpZHRoIEVzdGltYXRvclxuICogIC0gaGVhdmlseSBpbnNwaXJlZCBmcm9tIHNoYWthLXBsYXllclxuICogVHJhY2tzIGJhbmR3aWR0aCBzYW1wbGVzIGFuZCBlc3RpbWF0ZXMgYXZhaWxhYmxlIGJhbmR3aWR0aC5cbiAqIEJhc2VkIG9uIHRoZSBtaW5pbXVtIG9mIHR3byBleHBvbmVudGlhbGx5LXdlaWdodGVkIG1vdmluZyBhdmVyYWdlcyB3aXRoXG4gKiBkaWZmZXJlbnQgaGFsZi1saXZlcy5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGV3bWFfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL2V3bWEgKi8gXCIuL3NyYy91dGlscy9ld21hLmpzXCIpO1xudmFyIEV3bWFCYW5kV2lkdGhFc3RpbWF0b3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRXdtYUJhbmRXaWR0aEVzdGltYXRvcihobHMsIHNsb3csIGZhc3QsIGRlZmF1bHRFc3RpbWF0ZSkge1xuICAgICAgICB0aGlzLmhscyA9IGhscztcbiAgICAgICAgdGhpcy5kZWZhdWx0RXN0aW1hdGVfID0gZGVmYXVsdEVzdGltYXRlO1xuICAgICAgICB0aGlzLm1pbldlaWdodF8gPSAwLjAwMTtcbiAgICAgICAgdGhpcy5taW5EZWxheU1zXyA9IDUwO1xuICAgICAgICB0aGlzLnNsb3dfID0gbmV3IGV3bWFfMS5kZWZhdWx0KHNsb3cpO1xuICAgICAgICB0aGlzLmZhc3RfID0gbmV3IGV3bWFfMS5kZWZhdWx0KGZhc3QpO1xuICAgIH1cbiAgICBFd21hQmFuZFdpZHRoRXN0aW1hdG9yLnByb3RvdHlwZS5zYW1wbGUgPSBmdW5jdGlvbiAoZHVyYXRpb25NcywgbnVtQnl0ZXMpIHtcbiAgICAgICAgZHVyYXRpb25NcyA9IE1hdGgubWF4KGR1cmF0aW9uTXMsIHRoaXMubWluRGVsYXlNc18pO1xuICAgICAgICB2YXIgYmFuZHdpZHRoID0gODAwMCAqIG51bUJ5dGVzIC8gZHVyYXRpb25NcywgXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdpbnN0YW50IGJ3OicrIE1hdGgucm91bmQoYmFuZHdpZHRoKSk7XG4gICAgICAgIC8vIHdlIHdlaWdodCBzYW1wbGUgdXNpbmcgbG9hZGluZyBkdXJhdGlvbi4uLi5cbiAgICAgICAgd2VpZ2h0ID0gZHVyYXRpb25NcyAvIDEwMDA7XG4gICAgICAgIHRoaXMuZmFzdF8uc2FtcGxlKHdlaWdodCwgYmFuZHdpZHRoKTtcbiAgICAgICAgdGhpcy5zbG93Xy5zYW1wbGUod2VpZ2h0LCBiYW5kd2lkdGgpO1xuICAgIH07XG4gICAgRXdtYUJhbmRXaWR0aEVzdGltYXRvci5wcm90b3R5cGUuY2FuRXN0aW1hdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBmYXN0ID0gdGhpcy5mYXN0XztcbiAgICAgICAgcmV0dXJuIChmYXN0ICYmIGZhc3QuZ2V0VG90YWxXZWlnaHQoKSA+PSB0aGlzLm1pbldlaWdodF8pO1xuICAgIH07XG4gICAgRXdtYUJhbmRXaWR0aEVzdGltYXRvci5wcm90b3R5cGUuZ2V0RXN0aW1hdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmNhbkVzdGltYXRlKCkpIHtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdzbG93IGVzdGltYXRlOicrIE1hdGgucm91bmQodGhpcy5zbG93Xy5nZXRFc3RpbWF0ZSgpKSk7XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnZmFzdCBlc3RpbWF0ZTonKyBNYXRoLnJvdW5kKHRoaXMuZmFzdF8uZ2V0RXN0aW1hdGUoKSkpO1xuICAgICAgICAgICAgLy8gVGFrZSB0aGUgbWluaW11bSBvZiB0aGVzZSB0d28gZXN0aW1hdGVzLiAgVGhpcyBzaG91bGQgaGF2ZSB0aGUgZWZmZWN0IG9mXG4gICAgICAgICAgICAvLyBhZGFwdGluZyBkb3duIHF1aWNrbHksIGJ1dCB1cCBtb3JlIHNsb3dseS5cbiAgICAgICAgICAgIHJldHVybiBNYXRoLm1pbih0aGlzLmZhc3RfLmdldEVzdGltYXRlKCksIHRoaXMuc2xvd18uZ2V0RXN0aW1hdGUoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kZWZhdWx0RXN0aW1hdGVfO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBFd21hQmFuZFdpZHRoRXN0aW1hdG9yLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgIH07XG4gICAgcmV0dXJuIEV3bWFCYW5kV2lkdGhFc3RpbWF0b3I7XG59KCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gRXdtYUJhbmRXaWR0aEVzdGltYXRvcjtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy91dGlscy9ld21hLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvdXRpbHMvZXdtYS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKlxuICogY29tcHV0ZSBhbiBFeHBvbmVudGlhbCBXZWlnaHRlZCBtb3ZpbmcgYXZlcmFnZVxuICogLSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Nb3ZpbmdfYXZlcmFnZSNFeHBvbmVudGlhbF9tb3ZpbmdfYXZlcmFnZVxuICogIC0gaGVhdmlseSBpbnNwaXJlZCBmcm9tIHNoYWthLXBsYXllclxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgRVdNQSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvLyAgQWJvdXQgaGFsZiBvZiB0aGUgZXN0aW1hdGVkIHZhbHVlIHdpbGwgYmUgZnJvbSB0aGUgbGFzdCB8aGFsZkxpZmV8IHNhbXBsZXMgYnkgd2VpZ2h0LlxuICAgIGZ1bmN0aW9uIEVXTUEoaGFsZkxpZmUpIHtcbiAgICAgICAgLy8gTGFyZ2VyIHZhbHVlcyBvZiBhbHBoYSBleHBpcmUgaGlzdG9yaWNhbCBkYXRhIG1vcmUgc2xvd2x5LlxuICAgICAgICB0aGlzLmFscGhhXyA9IGhhbGZMaWZlID8gTWF0aC5leHAoTWF0aC5sb2coMC41KSAvIGhhbGZMaWZlKSA6IDA7XG4gICAgICAgIHRoaXMuZXN0aW1hdGVfID0gMDtcbiAgICAgICAgdGhpcy50b3RhbFdlaWdodF8gPSAwO1xuICAgIH1cbiAgICBFV01BLnByb3RvdHlwZS5zYW1wbGUgPSBmdW5jdGlvbiAod2VpZ2h0LCB2YWx1ZSkge1xuICAgICAgICB2YXIgYWRqQWxwaGEgPSBNYXRoLnBvdyh0aGlzLmFscGhhXywgd2VpZ2h0KTtcbiAgICAgICAgdGhpcy5lc3RpbWF0ZV8gPSB2YWx1ZSAqICgxIC0gYWRqQWxwaGEpICsgYWRqQWxwaGEgKiB0aGlzLmVzdGltYXRlXztcbiAgICAgICAgdGhpcy50b3RhbFdlaWdodF8gKz0gd2VpZ2h0O1xuICAgIH07XG4gICAgRVdNQS5wcm90b3R5cGUuZ2V0VG90YWxXZWlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvdGFsV2VpZ2h0XztcbiAgICB9O1xuICAgIEVXTUEucHJvdG90eXBlLmdldEVzdGltYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5hbHBoYV8pIHtcbiAgICAgICAgICAgIHZhciB6ZXJvRmFjdG9yID0gMSAtIE1hdGgucG93KHRoaXMuYWxwaGFfLCB0aGlzLnRvdGFsV2VpZ2h0Xyk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lc3RpbWF0ZV8gLyB6ZXJvRmFjdG9yO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXN0aW1hdGVfO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gRVdNQTtcbn0oKSk7XG5leHBvcnRzLmRlZmF1bHQgPSBFV01BO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3V0aWxzL2dldC1zZWxmLXNjb3BlLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3V0aWxzL2dldC1zZWxmLXNjb3BlLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5mdW5jdGlvbiBnZXRTZWxmU2NvcGUoKSB7XG4gICAgLy8gc2VlIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xMTIzNzI1OS81ODk0OTNcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgLyogZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmICovXG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHdpbmRvdztcbiAgICB9XG59XG5leHBvcnRzLmdldFNlbGZTY29wZSA9IGdldFNlbGZTY29wZTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy91dGlscy9sb2dnZXIuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3V0aWxzL2xvZ2dlci5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qISBNb2R1bGVDb25jYXRlbmF0aW9uIGJhaWxvdXQ6IE1vZHVsZSBpcyBub3QgYW4gRUNNQVNjcmlwdCBtb2R1bGUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBnZXRfc2VsZl9zY29wZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9nZXQtc2VsZi1zY29wZSAqLyBcIi4vc3JjL3V0aWxzL2dldC1zZWxmLXNjb3BlLmpzXCIpO1xuZnVuY3Rpb24gbm9vcCgpIHsgfVxudmFyIGZha2VMb2dnZXIgPSB7XG4gICAgdHJhY2U6IG5vb3AsXG4gICAgZGVidWc6IG5vb3AsXG4gICAgbG9nOiBub29wLFxuICAgIHdhcm46IG5vb3AsXG4gICAgaW5mbzogbm9vcCxcbiAgICBlcnJvcjogbm9vcFxufTtcbnZhciBleHBvcnRlZExvZ2dlciA9IGZha2VMb2dnZXI7XG4vLyBsZXQgbGFzdENhbGxUaW1lO1xuLy8gZnVuY3Rpb24gZm9ybWF0TXNnV2l0aFRpbWVJbmZvKHR5cGUsIG1zZykge1xuLy8gICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuLy8gICBjb25zdCBkaWZmID0gbGFzdENhbGxUaW1lID8gJysnICsgKG5vdyAtIGxhc3RDYWxsVGltZSkgOiAnMCc7XG4vLyAgIGxhc3RDYWxsVGltZSA9IG5vdztcbi8vICAgbXNnID0gKG5ldyBEYXRlKG5vdykpLnRvSVNPU3RyaW5nKCkgKyAnIHwgWycgKyAgdHlwZSArICddID4gJyArIG1zZyArICcgKCAnICsgZGlmZiArICcgbXMgKSc7XG4vLyAgIHJldHVybiBtc2c7XG4vLyB9XG5mdW5jdGlvbiBmb3JtYXRNc2codHlwZSwgbXNnKSB7XG4gICAgbXNnID0gJ1snICsgdHlwZSArICddID4gJyArIG1zZztcbiAgICByZXR1cm4gbXNnO1xufVxudmFyIGdsb2JhbCA9IGdldF9zZWxmX3Njb3BlXzEuZ2V0U2VsZlNjb3BlKCk7XG5mdW5jdGlvbiBjb25zb2xlUHJpbnRGbih0eXBlKSB7XG4gICAgdmFyIGZ1bmMgPSBnbG9iYWwuY29uc29sZVt0eXBlXTtcbiAgICBpZiAoZnVuYykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFyZ3NbMF0pIHtcbiAgICAgICAgICAgICAgICBhcmdzWzBdID0gZm9ybWF0TXNnKHR5cGUsIGFyZ3NbMF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuYy5hcHBseShnbG9iYWwuY29uc29sZSwgYXJncyk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBub29wO1xufVxuZnVuY3Rpb24gZXhwb3J0TG9nZ2VyRnVuY3Rpb25zKGRlYnVnQ29uZmlnKSB7XG4gICAgdmFyIGZ1bmN0aW9ucyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIGZ1bmN0aW9uc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgZnVuY3Rpb25zLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgZXhwb3J0ZWRMb2dnZXJbdHlwZV0gPSBkZWJ1Z0NvbmZpZ1t0eXBlXSA/IGRlYnVnQ29uZmlnW3R5cGVdLmJpbmQoZGVidWdDb25maWcpIDogY29uc29sZVByaW50Rm4odHlwZSk7XG4gICAgfSk7XG59XG5leHBvcnRzLmVuYWJsZUxvZ3MgPSBmdW5jdGlvbiAoZGVidWdDb25maWcpIHtcbiAgICBpZiAoZGVidWdDb25maWcgPT09IHRydWUgfHwgdHlwZW9mIGRlYnVnQ29uZmlnID09PSAnb2JqZWN0Jykge1xuICAgICAgICBleHBvcnRMb2dnZXJGdW5jdGlvbnMoZGVidWdDb25maWcsIFxuICAgICAgICAvLyBSZW1vdmUgb3V0IGZyb20gbGlzdCBoZXJlIHRvIGhhcmQtZGlzYWJsZSBhIGxvZy1sZXZlbFxuICAgICAgICAvLyAndHJhY2UnLFxuICAgICAgICAnZGVidWcnLCAnbG9nJywgJ2luZm8nLCAnd2FybicsICdlcnJvcicpO1xuICAgICAgICAvLyBTb21lIGJyb3dzZXJzIGRvbid0IGFsbG93IHRvIHVzZSBiaW5kIG9uIGNvbnNvbGUgb2JqZWN0IGFueXdheVxuICAgICAgICAvLyBmYWxsYmFjayB0byBkZWZhdWx0IGlmIG5lZWRlZFxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZXhwb3J0ZWRMb2dnZXIubG9nKCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGV4cG9ydGVkTG9nZ2VyID0gZmFrZUxvZ2dlcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZXhwb3J0ZWRMb2dnZXIgPSBmYWtlTG9nZ2VyO1xuICAgIH1cbn07XG5leHBvcnRzLmxvZ2dlciA9IGV4cG9ydGVkTG9nZ2VyO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3V0aWxzL21lZGlha2V5cy1oZWxwZXIuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy91dGlscy9tZWRpYWtleXMtaGVscGVyLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qISBNb2R1bGVDb25jYXRlbmF0aW9uIGJhaWxvdXQ6IE1vZHVsZSBpcyBub3QgYW4gRUNNQVNjcmlwdCBtb2R1bGUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciByZXF1ZXN0TWVkaWFLZXlTeXN0ZW1BY2Nlc3MgPSAoZnVuY3Rpb24gKCkge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cubmF2aWdhdG9yICYmIHdpbmRvdy5uYXZpZ2F0b3IucmVxdWVzdE1lZGlhS2V5U3lzdGVtQWNjZXNzKSB7XG4gICAgICAgIHJldHVybiB3aW5kb3cubmF2aWdhdG9yLnJlcXVlc3RNZWRpYUtleVN5c3RlbUFjY2Vzcy5iaW5kKHdpbmRvdy5uYXZpZ2F0b3IpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufSkoKTtcbmV4cG9ydHMucmVxdWVzdE1lZGlhS2V5U3lzdGVtQWNjZXNzID0gcmVxdWVzdE1lZGlhS2V5U3lzdGVtQWNjZXNzO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3V0aWxzL21lZGlhc291cmNlLWhlbHBlci5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvdXRpbHMvbWVkaWFzb3VyY2UtaGVscGVyLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyoqXG4gKiBNZWRpYVNvdXJjZSBoZWxwZXJcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZnVuY3Rpb24gZ2V0TWVkaWFTb3VyY2UoKSB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiB3aW5kb3cuTWVkaWFTb3VyY2UgfHwgd2luZG93LldlYktpdE1lZGlhU291cmNlO1xuICAgIH1cbn1cbmV4cG9ydHMuZ2V0TWVkaWFTb3VyY2UgPSBnZXRNZWRpYVNvdXJjZTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy91dGlscy9vdXRwdXQtZmlsdGVyLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvdXRpbHMvb3V0cHV0LWZpbHRlci5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgT3V0cHV0RmlsdGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE91dHB1dEZpbHRlcih0aW1lbGluZUNvbnRyb2xsZXIsIHRyYWNrTmFtZSkge1xuICAgICAgICB0aGlzLnRpbWVsaW5lQ29udHJvbGxlciA9IHRpbWVsaW5lQ29udHJvbGxlcjtcbiAgICAgICAgdGhpcy50cmFja05hbWUgPSB0cmFja05hbWU7XG4gICAgICAgIHRoaXMuc3RhcnRUaW1lID0gbnVsbDtcbiAgICAgICAgdGhpcy5lbmRUaW1lID0gbnVsbDtcbiAgICAgICAgdGhpcy5zY3JlZW4gPSBudWxsO1xuICAgIH1cbiAgICBPdXRwdXRGaWx0ZXIucHJvdG90eXBlLmRpc3BhdGNoQ3VlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5zdGFydFRpbWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRpbWVsaW5lQ29udHJvbGxlci5hZGRDdWVzKHRoaXMudHJhY2tOYW1lLCB0aGlzLnN0YXJ0VGltZSwgdGhpcy5lbmRUaW1lLCB0aGlzLnNjcmVlbik7XG4gICAgICAgIHRoaXMuc3RhcnRUaW1lID0gbnVsbDtcbiAgICB9O1xuICAgIE91dHB1dEZpbHRlci5wcm90b3R5cGUubmV3Q3VlID0gZnVuY3Rpb24gKHN0YXJ0VGltZSwgZW5kVGltZSwgc2NyZWVuKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXJ0VGltZSA9PT0gbnVsbCB8fCB0aGlzLnN0YXJ0VGltZSA+IHN0YXJ0VGltZSkge1xuICAgICAgICAgICAgdGhpcy5zdGFydFRpbWUgPSBzdGFydFRpbWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbmRUaW1lID0gZW5kVGltZTtcbiAgICAgICAgdGhpcy5zY3JlZW4gPSBzY3JlZW47XG4gICAgICAgIHRoaXMudGltZWxpbmVDb250cm9sbGVyLmNyZWF0ZUNhcHRpb25zVHJhY2sodGhpcy50cmFja05hbWUpO1xuICAgIH07XG4gICAgcmV0dXJuIE91dHB1dEZpbHRlcjtcbn0oKSk7XG5leHBvcnRzLmRlZmF1bHQgPSBPdXRwdXRGaWx0ZXI7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvdXRpbHMvdGV4dHRyYWNrLXV0aWxzLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy91dGlscy90ZXh0dHJhY2stdXRpbHMuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5mdW5jdGlvbiBzZW5kQWRkVHJhY2tFdmVudCh0cmFjaywgdmlkZW9FbCkge1xuICAgIHZhciBldmVudCA9IG51bGw7XG4gICAgdHJ5IHtcbiAgICAgICAgZXZlbnQgPSBuZXcgd2luZG93LkV2ZW50KCdhZGR0cmFjaycpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIC8vIGZvciBJRTExXG4gICAgICAgIGV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0V2ZW50Jyk7XG4gICAgICAgIGV2ZW50LmluaXRFdmVudCgnYWRkdHJhY2snLCBmYWxzZSwgZmFsc2UpO1xuICAgIH1cbiAgICBldmVudC50cmFjayA9IHRyYWNrO1xuICAgIHZpZGVvRWwuZGlzcGF0Y2hFdmVudChldmVudCk7XG59XG5leHBvcnRzLnNlbmRBZGRUcmFja0V2ZW50ID0gc2VuZEFkZFRyYWNrRXZlbnQ7XG5mdW5jdGlvbiBjbGVhckN1cnJlbnRDdWVzKHRyYWNrKSB7XG4gICAgaWYgKHRyYWNrICYmIHRyYWNrLmN1ZXMpIHtcbiAgICAgICAgd2hpbGUgKHRyYWNrLmN1ZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdHJhY2sucmVtb3ZlQ3VlKHRyYWNrLmN1ZXNbMF0pO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5jbGVhckN1cnJlbnRDdWVzID0gY2xlYXJDdXJyZW50Q3VlcztcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy91dGlscy90aW1lLXJhbmdlcy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy91dGlscy90aW1lLXJhbmdlcy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyoqXG4gKiAgVGltZVJhbmdlcyB0byBzdHJpbmcgaGVscGVyXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBUaW1lUmFuZ2VzID0ge1xuICAgIHRvU3RyaW5nOiBmdW5jdGlvbiAocikge1xuICAgICAgICB2YXIgbG9nID0gJycsIGxlbiA9IHIubGVuZ3RoO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBsb2cgKz0gJ1snICsgci5zdGFydChpKS50b0ZpeGVkKDMpICsgJywnICsgci5lbmQoaSkudG9GaXhlZCgzKSArICddJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbG9nO1xuICAgIH1cbn07XG5leHBvcnRzLmRlZmF1bHQgPSBUaW1lUmFuZ2VzO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3V0aWxzL3Z0dGN1ZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvdXRpbHMvdnR0Y3VlLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyoqXG4gKiBDb3B5cmlnaHQgMjAxMyB2dHQuanMgQ29udHJpYnV0b3JzXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LlZUVEN1ZSkge1xuICAgICAgICByZXR1cm4gd2luZG93LlZUVEN1ZTtcbiAgICB9XG4gICAgdmFyIGF1dG9LZXl3b3JkID0gJ2F1dG8nO1xuICAgIHZhciBkaXJlY3Rpb25TZXR0aW5nID0ge1xuICAgICAgICAnJzogdHJ1ZSxcbiAgICAgICAgbHI6IHRydWUsXG4gICAgICAgIHJsOiB0cnVlXG4gICAgfTtcbiAgICB2YXIgYWxpZ25TZXR0aW5nID0ge1xuICAgICAgICBzdGFydDogdHJ1ZSxcbiAgICAgICAgbWlkZGxlOiB0cnVlLFxuICAgICAgICBlbmQ6IHRydWUsXG4gICAgICAgIGxlZnQ6IHRydWUsXG4gICAgICAgIHJpZ2h0OiB0cnVlXG4gICAgfTtcbiAgICBmdW5jdGlvbiBmaW5kRGlyZWN0aW9uU2V0dGluZyh2YWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkaXIgPSBkaXJlY3Rpb25TZXR0aW5nW3ZhbHVlLnRvTG93ZXJDYXNlKCldO1xuICAgICAgICByZXR1cm4gZGlyID8gdmFsdWUudG9Mb3dlckNhc2UoKSA6IGZhbHNlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmaW5kQWxpZ25TZXR0aW5nKHZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGFsaWduID0gYWxpZ25TZXR0aW5nW3ZhbHVlLnRvTG93ZXJDYXNlKCldO1xuICAgICAgICByZXR1cm4gYWxpZ24gPyB2YWx1ZS50b0xvd2VyQ2FzZSgpIDogZmFsc2U7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGV4dGVuZChvYmopIHtcbiAgICAgICAgdmFyIGkgPSAxO1xuICAgICAgICBmb3IgKDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGNvYmogPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIGNvYmopIHtcbiAgICAgICAgICAgICAgICBvYmpbcF0gPSBjb2JqW3BdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFZUVEN1ZShzdGFydFRpbWUsIGVuZFRpbWUsIHRleHQpIHtcbiAgICAgICAgdmFyIGN1ZSA9IHRoaXM7XG4gICAgICAgIHZhciBpc0lFOCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG5hdmlnYXRvciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gKC9NU0lFXFxzOFxcLjAvKS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuICAgICAgICB9KSgpO1xuICAgICAgICB2YXIgYmFzZU9iaiA9IHt9O1xuICAgICAgICBpZiAoaXNJRTgpIHtcbiAgICAgICAgICAgIGN1ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2N1c3RvbScpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYmFzZU9iai5lbnVtZXJhYmxlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogU2hpbSBpbXBsZW1lbnRhdGlvbiBzcGVjaWZpYyBwcm9wZXJ0aWVzLiBUaGVzZSBwcm9wZXJ0aWVzIGFyZSBub3QgaW5cbiAgICAgICAgICogdGhlIHNwZWMuXG4gICAgICAgICAqL1xuICAgICAgICAvLyBMZXRzIHVzIGtub3cgd2hlbiB0aGUgVlRUQ3VlJ3MgZGF0YSBoYXMgY2hhbmdlZCBpbiBzdWNoIGEgd2F5IHRoYXQgd2UgbmVlZFxuICAgICAgICAvLyB0byByZWNvbXB1dGUgaXRzIGRpc3BsYXkgc3RhdGUuIFRoaXMgbGV0cyB1cyBjb21wdXRlIGl0cyBkaXNwbGF5IHN0YXRlXG4gICAgICAgIC8vIGxhemlseS5cbiAgICAgICAgY3VlLmhhc0JlZW5SZXNldCA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogVlRUQ3VlIGFuZCBUZXh0VHJhY2tDdWUgcHJvcGVydGllc1xuICAgICAgICAgKiBodHRwOi8vZGV2LnczLm9yZy9odG1sNS93ZWJ2dHQvI3Z0dGN1ZS1pbnRlcmZhY2VcbiAgICAgICAgICovXG4gICAgICAgIHZhciBfaWQgPSAnJztcbiAgICAgICAgdmFyIF9wYXVzZU9uRXhpdCA9IGZhbHNlO1xuICAgICAgICB2YXIgX3N0YXJ0VGltZSA9IHN0YXJ0VGltZTtcbiAgICAgICAgdmFyIF9lbmRUaW1lID0gZW5kVGltZTtcbiAgICAgICAgdmFyIF90ZXh0ID0gdGV4dDtcbiAgICAgICAgdmFyIF9yZWdpb24gPSBudWxsO1xuICAgICAgICB2YXIgX3ZlcnRpY2FsID0gJyc7XG4gICAgICAgIHZhciBfc25hcFRvTGluZXMgPSB0cnVlO1xuICAgICAgICB2YXIgX2xpbmUgPSAnYXV0byc7XG4gICAgICAgIHZhciBfbGluZUFsaWduID0gJ3N0YXJ0JztcbiAgICAgICAgdmFyIF9wb3NpdGlvbiA9IDUwO1xuICAgICAgICB2YXIgX3Bvc2l0aW9uQWxpZ24gPSAnbWlkZGxlJztcbiAgICAgICAgdmFyIF9zaXplID0gNTA7XG4gICAgICAgIHZhciBfYWxpZ24gPSAnbWlkZGxlJztcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSwgJ2lkJywgZXh0ZW5kKHt9LCBiYXNlT2JqLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2lkO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgX2lkID0gJycgKyB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VlLCAncGF1c2VPbkV4aXQnLCBleHRlbmQoe30sIGJhc2VPYmosIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfcGF1c2VPbkV4aXQ7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICBfcGF1c2VPbkV4aXQgPSAhIXZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsICdzdGFydFRpbWUnLCBleHRlbmQoe30sIGJhc2VPYmosIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfc3RhcnRUaW1lO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignU3RhcnQgdGltZSBtdXN0IGJlIHNldCB0byBhIG51bWJlci4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX3N0YXJ0VGltZSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIHRoaXMuaGFzQmVlblJlc2V0ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VlLCAnZW5kVGltZScsIGV4dGVuZCh7fSwgYmFzZU9iaiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9lbmRUaW1lO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRW5kIHRpbWUgbXVzdCBiZSBzZXQgdG8gYSBudW1iZXIuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF9lbmRUaW1lID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgdGhpcy5oYXNCZWVuUmVzZXQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsICd0ZXh0JywgZXh0ZW5kKHt9LCBiYXNlT2JqLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RleHQ7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICBfdGV4dCA9ICcnICsgdmFsdWU7XG4gICAgICAgICAgICAgICAgdGhpcy5oYXNCZWVuUmVzZXQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsICdyZWdpb24nLCBleHRlbmQoe30sIGJhc2VPYmosIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfcmVnaW9uO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgX3JlZ2lvbiA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIHRoaXMuaGFzQmVlblJlc2V0ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VlLCAndmVydGljYWwnLCBleHRlbmQoe30sIGJhc2VPYmosIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdmVydGljYWw7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2V0dGluZyA9IGZpbmREaXJlY3Rpb25TZXR0aW5nKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAvLyBIYXZlIHRvIGNoZWNrIGZvciBmYWxzZSBiZWNhdXNlIHRoZSBzZXR0aW5nIGFuIGJlIGFuIGVtcHR5IHN0cmluZy5cbiAgICAgICAgICAgICAgICBpZiAoc2V0dGluZyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdBbiBpbnZhbGlkIG9yIGlsbGVnYWwgc3RyaW5nIHdhcyBzcGVjaWZpZWQuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF92ZXJ0aWNhbCA9IHNldHRpbmc7XG4gICAgICAgICAgICAgICAgdGhpcy5oYXNCZWVuUmVzZXQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsICdzbmFwVG9MaW5lcycsIGV4dGVuZCh7fSwgYmFzZU9iaiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9zbmFwVG9MaW5lcztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIF9zbmFwVG9MaW5lcyA9ICEhdmFsdWU7XG4gICAgICAgICAgICAgICAgdGhpcy5oYXNCZWVuUmVzZXQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsICdsaW5lJywgZXh0ZW5kKHt9LCBiYXNlT2JqLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2xpbmU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJyAmJiB2YWx1ZSAhPT0gYXV0b0tleXdvcmQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdBbiBpbnZhbGlkIG51bWJlciBvciBpbGxlZ2FsIHN0cmluZyB3YXMgc3BlY2lmaWVkLicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfbGluZSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIHRoaXMuaGFzQmVlblJlc2V0ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VlLCAnbGluZUFsaWduJywgZXh0ZW5kKHt9LCBiYXNlT2JqLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2xpbmVBbGlnbjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHZhciBzZXR0aW5nID0gZmluZEFsaWduU2V0dGluZyh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKCFzZXR0aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignQW4gaW52YWxpZCBvciBpbGxlZ2FsIHN0cmluZyB3YXMgc3BlY2lmaWVkLicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfbGluZUFsaWduID0gc2V0dGluZztcbiAgICAgICAgICAgICAgICB0aGlzLmhhc0JlZW5SZXNldCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSwgJ3Bvc2l0aW9uJywgZXh0ZW5kKHt9LCBiYXNlT2JqLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3Bvc2l0aW9uO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlIDwgMCB8fCB2YWx1ZSA+IDEwMCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Bvc2l0aW9uIG11c3QgYmUgYmV0d2VlbiAwIGFuZCAxMDAuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF9wb3NpdGlvbiA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIHRoaXMuaGFzQmVlblJlc2V0ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VlLCAncG9zaXRpb25BbGlnbicsIGV4dGVuZCh7fSwgYmFzZU9iaiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9wb3NpdGlvbkFsaWduO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNldHRpbmcgPSBmaW5kQWxpZ25TZXR0aW5nKHZhbHVlKTtcbiAgICAgICAgICAgICAgICBpZiAoIXNldHRpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdBbiBpbnZhbGlkIG9yIGlsbGVnYWwgc3RyaW5nIHdhcyBzcGVjaWZpZWQuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF9wb3NpdGlvbkFsaWduID0gc2V0dGluZztcbiAgICAgICAgICAgICAgICB0aGlzLmhhc0JlZW5SZXNldCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSwgJ3NpemUnLCBleHRlbmQoe30sIGJhc2VPYmosIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfc2l6ZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA8IDAgfHwgdmFsdWUgPiAxMDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTaXplIG11c3QgYmUgYmV0d2VlbiAwIGFuZCAxMDAuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF9zaXplID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgdGhpcy5oYXNCZWVuUmVzZXQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsICdhbGlnbicsIGV4dGVuZCh7fSwgYmFzZU9iaiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9hbGlnbjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHZhciBzZXR0aW5nID0gZmluZEFsaWduU2V0dGluZyh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKCFzZXR0aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignQW4gaW52YWxpZCBvciBpbGxlZ2FsIHN0cmluZyB3YXMgc3BlY2lmaWVkLicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfYWxpZ24gPSBzZXR0aW5nO1xuICAgICAgICAgICAgICAgIHRoaXMuaGFzQmVlblJlc2V0ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuICAgICAgICAvKipcbiAgICAgICAgICogT3RoZXIgPHRyYWNrPiBzcGVjIGRlZmluZWQgcHJvcGVydGllc1xuICAgICAgICAgKi9cbiAgICAgICAgLy8gaHR0cDovL3d3dy53aGF0d2cub3JnL3NwZWNzL3dlYi1hcHBzL2N1cnJlbnQtd29yay9tdWx0aXBhZ2UvdGhlLXZpZGVvLWVsZW1lbnQuaHRtbCN0ZXh0LXRyYWNrLWN1ZS1kaXNwbGF5LXN0YXRlXG4gICAgICAgIGN1ZS5kaXNwbGF5U3RhdGUgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChpc0lFOCkge1xuICAgICAgICAgICAgcmV0dXJuIGN1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBWVFRDdWUgbWV0aG9kc1xuICAgICAqL1xuICAgIFZUVEN1ZS5wcm90b3R5cGUuZ2V0Q3VlQXNIVE1MID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBBc3N1bWUgV2ViVlRULmNvbnZlcnRDdWVUb0RPTVRyZWUgaXMgb24gdGhlIGdsb2JhbC5cbiAgICAgICAgdmFyIFdlYlZUVCA9IHdpbmRvdy5XZWJWVFQ7XG4gICAgICAgIHJldHVybiBXZWJWVFQuY29udmVydEN1ZVRvRE9NVHJlZSh3aW5kb3csIHRoaXMudGV4dCk7XG4gICAgfTtcbiAgICByZXR1cm4gVlRUQ3VlO1xufSkoKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy91dGlscy92dHRwYXJzZXIuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3V0aWxzL3Z0dHBhcnNlci5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qISBNb2R1bGVDb25jYXRlbmF0aW9uIGJhaWxvdXQ6IE1vZHVsZSBpcyBub3QgYW4gRUNNQVNjcmlwdCBtb2R1bGUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qXG4gKiBTb3VyY2U6IGh0dHBzOi8vZ2l0aHViLmNvbS9tb3ppbGxhL3Z0dC5qcy9ibG9iL21hc3Rlci9kaXN0L3Z0dC5qcyNMMTcxNlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdnR0Y3VlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3Z0dGN1ZSAqLyBcIi4vc3JjL3V0aWxzL3Z0dGN1ZS5qc1wiKTtcbnZhciBTdHJpbmdEZWNvZGVyID0gZnVuY3Rpb24gU3RyaW5nRGVjb2RlcigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBkZWNvZGU6IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIGRhdGEgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFcnJvciAtIGV4cGVjdGVkIHN0cmluZyBkYXRhLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChlbmNvZGVVUklDb21wb25lbnQoZGF0YSkpO1xuICAgICAgICB9XG4gICAgfTtcbn07XG5mdW5jdGlvbiBWVFRQYXJzZXIoKSB7XG4gICAgdGhpcy53aW5kb3cgPSB3aW5kb3c7XG4gICAgdGhpcy5zdGF0ZSA9ICdJTklUSUFMJztcbiAgICB0aGlzLmJ1ZmZlciA9ICcnO1xuICAgIHRoaXMuZGVjb2RlciA9IG5ldyBTdHJpbmdEZWNvZGVyKCk7XG4gICAgdGhpcy5yZWdpb25MaXN0ID0gW107XG59XG4vLyBUcnkgdG8gcGFyc2UgaW5wdXQgYXMgYSB0aW1lIHN0YW1wLlxuZnVuY3Rpb24gcGFyc2VUaW1lU3RhbXAoaW5wdXQpIHtcbiAgICBmdW5jdGlvbiBjb21wdXRlU2Vjb25kcyhoLCBtLCBzLCBmKSB7XG4gICAgICAgIHJldHVybiAoaCB8IDApICogMzYwMCArIChtIHwgMCkgKiA2MCArIChzIHwgMCkgKyAoZiB8IDApIC8gMTAwMDtcbiAgICB9XG4gICAgdmFyIG0gPSBpbnB1dC5tYXRjaCgvXihcXGQrKTooXFxkezJ9KSg6XFxkezJ9KT9cXC4oXFxkezN9KS8pO1xuICAgIGlmICghbSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKG1bM10pIHtcbiAgICAgICAgLy8gVGltZXN0YW1wIHRha2VzIHRoZSBmb3JtIG9mIFtob3Vyc106W21pbnV0ZXNdOltzZWNvbmRzXS5bbWlsbGlzZWNvbmRzXVxuICAgICAgICByZXR1cm4gY29tcHV0ZVNlY29uZHMobVsxXSwgbVsyXSwgbVszXS5yZXBsYWNlKCc6JywgJycpLCBtWzRdKTtcbiAgICB9XG4gICAgZWxzZSBpZiAobVsxXSA+IDU5KSB7XG4gICAgICAgIC8vIFRpbWVzdGFtcCB0YWtlcyB0aGUgZm9ybSBvZiBbaG91cnNdOlttaW51dGVzXS5bbWlsbGlzZWNvbmRzXVxuICAgICAgICAvLyBGaXJzdCBwb3NpdGlvbiBpcyBob3VycyBhcyBpdCdzIG92ZXIgNTkuXG4gICAgICAgIHJldHVybiBjb21wdXRlU2Vjb25kcyhtWzFdLCBtWzJdLCAwLCBtWzRdKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIFRpbWVzdGFtcCB0YWtlcyB0aGUgZm9ybSBvZiBbbWludXRlc106W3NlY29uZHNdLlttaWxsaXNlY29uZHNdXG4gICAgICAgIHJldHVybiBjb21wdXRlU2Vjb25kcygwLCBtWzFdLCBtWzJdLCBtWzRdKTtcbiAgICB9XG59XG4vLyBBIHNldHRpbmdzIG9iamVjdCBob2xkcyBrZXkvdmFsdWUgcGFpcnMgYW5kIHdpbGwgaWdub3JlIGFueXRoaW5nIGJ1dCB0aGUgZmlyc3Rcbi8vIGFzc2lnbm1lbnQgdG8gYSBzcGVjaWZpYyBrZXkuXG5mdW5jdGlvbiBTZXR0aW5ncygpIHtcbiAgICB0aGlzLnZhbHVlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG59XG5TZXR0aW5ncy5wcm90b3R5cGUgPSB7XG4gICAgLy8gT25seSBhY2NlcHQgdGhlIGZpcnN0IGFzc2lnbm1lbnQgdG8gYW55IGtleS5cbiAgICBzZXQ6IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgICAgIGlmICghdGhpcy5nZXQoaykgJiYgdiAhPT0gJycpIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWVzW2tdID0gdjtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgLy8gUmV0dXJuIHRoZSB2YWx1ZSBmb3IgYSBrZXksIG9yIGEgZGVmYXVsdCB2YWx1ZS5cbiAgICAvLyBJZiAnZGVmYXVsdEtleScgaXMgcGFzc2VkIHRoZW4gJ2RmbHQnIGlzIGFzc3VtZWQgdG8gYmUgYW4gb2JqZWN0IHdpdGhcbiAgICAvLyBhIG51bWJlciBvZiBwb3NzaWJsZSBkZWZhdWx0IHZhbHVlcyBhcyBwcm9wZXJ0aWVzIHdoZXJlICdkZWZhdWx0S2V5JyBpc1xuICAgIC8vIHRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRoYXQgd2lsbCBiZSBjaG9zZW47IG90aGVyd2lzZSBpdCdzIGFzc3VtZWQgdG8gYmVcbiAgICAvLyBhIHNpbmdsZSB2YWx1ZS5cbiAgICBnZXQ6IGZ1bmN0aW9uIChrLCBkZmx0LCBkZWZhdWx0S2V5KSB7XG4gICAgICAgIGlmIChkZWZhdWx0S2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5oYXMoaykgPyB0aGlzLnZhbHVlc1trXSA6IGRmbHRbZGVmYXVsdEtleV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuaGFzKGspID8gdGhpcy52YWx1ZXNba10gOiBkZmx0O1xuICAgIH0sXG4gICAgLy8gQ2hlY2sgd2hldGhlciB3ZSBoYXZlIGEgdmFsdWUgZm9yIGEga2V5LlxuICAgIGhhczogZnVuY3Rpb24gKGspIHtcbiAgICAgICAgcmV0dXJuIGsgaW4gdGhpcy52YWx1ZXM7XG4gICAgfSxcbiAgICAvLyBBY2NlcHQgYSBzZXR0aW5nIGlmIGl0cyBvbmUgb2YgdGhlIGdpdmVuIGFsdGVybmF0aXZlcy5cbiAgICBhbHQ6IGZ1bmN0aW9uIChrLCB2LCBhKSB7XG4gICAgICAgIGZvciAodmFyIG4gPSAwOyBuIDwgYS5sZW5ndGg7ICsrbikge1xuICAgICAgICAgICAgaWYgKHYgPT09IGFbbl0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldChrLCB2KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG4gICAgLy8gQWNjZXB0IGEgc2V0dGluZyBpZiBpdHMgYSB2YWxpZCAoc2lnbmVkKSBpbnRlZ2VyLlxuICAgIGludGVnZXI6IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgICAgIGlmICgvXi0/XFxkKyQvLnRlc3QodikpIHsgLy8gaW50ZWdlclxuICAgICAgICAgICAgdGhpcy5zZXQoaywgcGFyc2VJbnQodiwgMTApKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgLy8gQWNjZXB0IGEgc2V0dGluZyBpZiBpdHMgYSB2YWxpZCBwZXJjZW50YWdlLlxuICAgIHBlcmNlbnQ6IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgICAgIHZhciBtO1xuICAgICAgICBpZiAoKG0gPSB2Lm1hdGNoKC9eKFtcXGRdezEsM30pKFxcLltcXGRdKik/JSQvKSkpIHtcbiAgICAgICAgICAgIHYgPSBwYXJzZUZsb2F0KHYpO1xuICAgICAgICAgICAgaWYgKHYgPj0gMCAmJiB2IDw9IDEwMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0KGssIHYpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59O1xuLy8gSGVscGVyIGZ1bmN0aW9uIHRvIHBhcnNlIGlucHV0IGludG8gZ3JvdXBzIHNlcGFyYXRlZCBieSAnZ3JvdXBEZWxpbScsIGFuZFxuLy8gaW50ZXJwcmV0ZSBlYWNoIGdyb3VwIGFzIGEga2V5L3ZhbHVlIHBhaXIgc2VwYXJhdGVkIGJ5ICdrZXlWYWx1ZURlbGltJy5cbmZ1bmN0aW9uIHBhcnNlT3B0aW9ucyhpbnB1dCwgY2FsbGJhY2ssIGtleVZhbHVlRGVsaW0sIGdyb3VwRGVsaW0pIHtcbiAgICB2YXIgZ3JvdXBzID0gZ3JvdXBEZWxpbSA/IGlucHV0LnNwbGl0KGdyb3VwRGVsaW0pIDogW2lucHV0XTtcbiAgICBmb3IgKHZhciBpIGluIGdyb3Vwcykge1xuICAgICAgICBpZiAodHlwZW9mIGdyb3Vwc1tpXSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBrdiA9IGdyb3Vwc1tpXS5zcGxpdChrZXlWYWx1ZURlbGltKTtcbiAgICAgICAgaWYgKGt2Lmxlbmd0aCAhPT0gMikge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGsgPSBrdlswXTtcbiAgICAgICAgdmFyIHYgPSBrdlsxXTtcbiAgICAgICAgY2FsbGJhY2soaywgdik7XG4gICAgfVxufVxudmFyIGRlZmF1bHRzID0gbmV3IHZ0dGN1ZV8xLmRlZmF1bHQoMCwgMCwgMCk7XG4vLyAnbWlkZGxlJyB3YXMgY2hhbmdlZCB0byAnY2VudGVyJyBpbiB0aGUgc3BlYzogaHR0cHM6Ly9naXRodWIuY29tL3czYy93ZWJ2dHQvcHVsbC8yNDRcbi8vICBTYWZhcmkgZG9lc24ndCB5ZXQgc3VwcG9ydCB0aGlzIGNoYW5nZSwgYnV0IEZGIGFuZCBDaHJvbWUgZG8uXG52YXIgY2VudGVyID0gZGVmYXVsdHMuYWxpZ24gPT09ICdtaWRkbGUnID8gJ21pZGRsZScgOiAnY2VudGVyJztcbmZ1bmN0aW9uIHBhcnNlQ3VlKGlucHV0LCBjdWUsIHJlZ2lvbkxpc3QpIHtcbiAgICAvLyBSZW1lbWJlciB0aGUgb3JpZ2luYWwgaW5wdXQgaWYgd2UgbmVlZCB0byB0aHJvdyBhbiBlcnJvci5cbiAgICB2YXIgb0lucHV0ID0gaW5wdXQ7XG4gICAgLy8gNC4xIFdlYlZUVCB0aW1lc3RhbXBcbiAgICBmdW5jdGlvbiBjb25zdW1lVGltZVN0YW1wKCkge1xuICAgICAgICB2YXIgdHMgPSBwYXJzZVRpbWVTdGFtcChpbnB1dCk7XG4gICAgICAgIGlmICh0cyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNYWxmb3JtZWQgdGltZXN0YW1wOiAnICsgb0lucHV0KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZW1vdmUgdGltZSBzdGFtcCBmcm9tIGlucHV0LlxuICAgICAgICBpbnB1dCA9IGlucHV0LnJlcGxhY2UoL15bXlxcc2EtekEtWi1dKy8sICcnKTtcbiAgICAgICAgcmV0dXJuIHRzO1xuICAgIH1cbiAgICAvLyA0LjQuMiBXZWJWVFQgY3VlIHNldHRpbmdzXG4gICAgZnVuY3Rpb24gY29uc3VtZUN1ZVNldHRpbmdzKGlucHV0LCBjdWUpIHtcbiAgICAgICAgdmFyIHNldHRpbmdzID0gbmV3IFNldHRpbmdzKCk7XG4gICAgICAgIHBhcnNlT3B0aW9ucyhpbnB1dCwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoaykge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3JlZ2lvbic6XG4gICAgICAgICAgICAgICAgICAgIC8vIEZpbmQgdGhlIGxhc3QgcmVnaW9uIHdlIHBhcnNlZCB3aXRoIHRoZSBzYW1lIHJlZ2lvbiBpZC5cbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IHJlZ2lvbkxpc3QubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZWdpb25MaXN0W2ldLmlkID09PSB2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3Muc2V0KGssIHJlZ2lvbkxpc3RbaV0ucmVnaW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICd2ZXJ0aWNhbCc6XG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLmFsdChrLCB2LCBbJ3JsJywgJ2xyJ10pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdsaW5lJzpcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHMgPSB2LnNwbGl0KCcsJyksIHZhbHMwID0gdmFsc1swXTtcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MuaW50ZWdlcihrLCB2YWxzMCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZXR0aW5ncy5wZXJjZW50KGssIHZhbHMwKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3Muc2V0KCdzbmFwVG9MaW5lcycsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5hbHQoaywgdmFsczAsIFsnYXV0byddKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHMubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5hbHQoJ2xpbmVBbGlnbicsIHZhbHNbMV0sIFsnc3RhcnQnLCBjZW50ZXIsICdlbmQnXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAncG9zaXRpb24nOlxuICAgICAgICAgICAgICAgICAgICB2YWxzID0gdi5zcGxpdCgnLCcpO1xuICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5wZXJjZW50KGssIHZhbHNbMF0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFscy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLmFsdCgncG9zaXRpb25BbGlnbicsIHZhbHNbMV0sIFsnc3RhcnQnLCBjZW50ZXIsICdlbmQnLCAnbGluZS1sZWZ0JywgJ2xpbmUtcmlnaHQnLCAnYXV0byddKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdzaXplJzpcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MucGVyY2VudChrLCB2KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnYWxpZ24nOlxuICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5hbHQoaywgdiwgWydzdGFydCcsIGNlbnRlciwgJ2VuZCcsICdsZWZ0JywgJ3JpZ2h0J10pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgLzovLCAvXFxzLyk7XG4gICAgICAgIC8vIEFwcGx5IGRlZmF1bHQgdmFsdWVzIGZvciBhbnkgbWlzc2luZyBmaWVsZHMuXG4gICAgICAgIGN1ZS5yZWdpb24gPSBzZXR0aW5ncy5nZXQoJ3JlZ2lvbicsIG51bGwpO1xuICAgICAgICBjdWUudmVydGljYWwgPSBzZXR0aW5ncy5nZXQoJ3ZlcnRpY2FsJywgJycpO1xuICAgICAgICB2YXIgbGluZSA9IHNldHRpbmdzLmdldCgnbGluZScsICdhdXRvJyk7XG4gICAgICAgIGlmIChsaW5lID09PSAnYXV0bycgJiYgZGVmYXVsdHMubGluZSA9PT0gLTEpIHtcbiAgICAgICAgICAgIC8vIHNldCBudW1lcmljIGxpbmUgbnVtYmVyIGZvciBTYWZhcmlcbiAgICAgICAgICAgIGxpbmUgPSAtMTtcbiAgICAgICAgfVxuICAgICAgICBjdWUubGluZSA9IGxpbmU7XG4gICAgICAgIGN1ZS5saW5lQWxpZ24gPSBzZXR0aW5ncy5nZXQoJ2xpbmVBbGlnbicsICdzdGFydCcpO1xuICAgICAgICBjdWUuc25hcFRvTGluZXMgPSBzZXR0aW5ncy5nZXQoJ3NuYXBUb0xpbmVzJywgdHJ1ZSk7XG4gICAgICAgIGN1ZS5zaXplID0gc2V0dGluZ3MuZ2V0KCdzaXplJywgMTAwKTtcbiAgICAgICAgY3VlLmFsaWduID0gc2V0dGluZ3MuZ2V0KCdhbGlnbicsIGNlbnRlcik7XG4gICAgICAgIHZhciBwb3NpdGlvbiA9IHNldHRpbmdzLmdldCgncG9zaXRpb24nLCAnYXV0bycpO1xuICAgICAgICBpZiAocG9zaXRpb24gPT09ICdhdXRvJyAmJiBkZWZhdWx0cy5wb3NpdGlvbiA9PT0gNTApIHtcbiAgICAgICAgICAgIC8vIHNldCBudW1lcmljIHBvc2l0aW9uIGZvciBTYWZhcmlcbiAgICAgICAgICAgIHBvc2l0aW9uID0gY3VlLmFsaWduID09PSAnc3RhcnQnIHx8IGN1ZS5hbGlnbiA9PT0gJ2xlZnQnID8gMCA6IGN1ZS5hbGlnbiA9PT0gJ2VuZCcgfHwgY3VlLmFsaWduID09PSAncmlnaHQnID8gMTAwIDogNTA7XG4gICAgICAgIH1cbiAgICAgICAgY3VlLnBvc2l0aW9uID0gcG9zaXRpb247XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNraXBXaGl0ZXNwYWNlKCkge1xuICAgICAgICBpbnB1dCA9IGlucHV0LnJlcGxhY2UoL15cXHMrLywgJycpO1xuICAgIH1cbiAgICAvLyA0LjEgV2ViVlRUIGN1ZSB0aW1pbmdzLlxuICAgIHNraXBXaGl0ZXNwYWNlKCk7XG4gICAgY3VlLnN0YXJ0VGltZSA9IGNvbnN1bWVUaW1lU3RhbXAoKTsgLy8gKDEpIGNvbGxlY3QgY3VlIHN0YXJ0IHRpbWVcbiAgICBza2lwV2hpdGVzcGFjZSgpO1xuICAgIGlmIChpbnB1dC5zdWJzdHIoMCwgMykgIT09ICctLT4nKSB7IC8vICgzKSBuZXh0IGNoYXJhY3RlcnMgbXVzdCBtYXRjaCAnLS0+J1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01hbGZvcm1lZCB0aW1lIHN0YW1wICh0aW1lIHN0YW1wcyBtdXN0IGJlIHNlcGFyYXRlZCBieSBcXCctLT5cXCcpOiAnICtcbiAgICAgICAgICAgIG9JbnB1dCk7XG4gICAgfVxuICAgIGlucHV0ID0gaW5wdXQuc3Vic3RyKDMpO1xuICAgIHNraXBXaGl0ZXNwYWNlKCk7XG4gICAgY3VlLmVuZFRpbWUgPSBjb25zdW1lVGltZVN0YW1wKCk7IC8vICg1KSBjb2xsZWN0IGN1ZSBlbmQgdGltZVxuICAgIC8vIDQuMSBXZWJWVFQgY3VlIHNldHRpbmdzIGxpc3QuXG4gICAgc2tpcFdoaXRlc3BhY2UoKTtcbiAgICBjb25zdW1lQ3VlU2V0dGluZ3MoaW5wdXQsIGN1ZSk7XG59XG5mdW5jdGlvbiBmaXhMaW5lQnJlYWtzKGlucHV0KSB7XG4gICAgcmV0dXJuIGlucHV0LnJlcGxhY2UoLzxicig/OiBcXC8pPz4vZ2ksICdcXG4nKTtcbn1cbmV4cG9ydHMuZml4TGluZUJyZWFrcyA9IGZpeExpbmVCcmVha3M7XG5WVFRQYXJzZXIucHJvdG90eXBlID0ge1xuICAgIHBhcnNlOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIC8vIElmIHRoZXJlIGlzIG5vIGRhdGEgdGhlbiB3ZSB3b24ndCBkZWNvZGUgaXQsIGJ1dCB3aWxsIGp1c3QgdHJ5IHRvIHBhcnNlXG4gICAgICAgIC8vIHdoYXRldmVyIGlzIGluIGJ1ZmZlciBhbHJlYWR5LiBUaGlzIG1heSBvY2N1ciBpbiBjaXJjdW1zdGFuY2VzLCBmb3JcbiAgICAgICAgLy8gZXhhbXBsZSB3aGVuIGZsdXNoKCkgaXMgY2FsbGVkLlxuICAgICAgICBpZiAoZGF0YSkge1xuICAgICAgICAgICAgLy8gVHJ5IHRvIGRlY29kZSB0aGUgZGF0YSB0aGF0IHdlIHJlY2VpdmVkLlxuICAgICAgICAgICAgc2VsZi5idWZmZXIgKz0gc2VsZi5kZWNvZGVyLmRlY29kZShkYXRhLCB7IHN0cmVhbTogdHJ1ZSB9KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjb2xsZWN0TmV4dExpbmUoKSB7XG4gICAgICAgICAgICB2YXIgYnVmZmVyID0gc2VsZi5idWZmZXI7XG4gICAgICAgICAgICB2YXIgcG9zID0gMDtcbiAgICAgICAgICAgIGJ1ZmZlciA9IGZpeExpbmVCcmVha3MoYnVmZmVyKTtcbiAgICAgICAgICAgIHdoaWxlIChwb3MgPCBidWZmZXIubGVuZ3RoICYmIGJ1ZmZlcltwb3NdICE9PSAnXFxyJyAmJiBidWZmZXJbcG9zXSAhPT0gJ1xcbicpIHtcbiAgICAgICAgICAgICAgICArK3BvcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBsaW5lID0gYnVmZmVyLnN1YnN0cigwLCBwb3MpO1xuICAgICAgICAgICAgLy8gQWR2YW5jZSB0aGUgYnVmZmVyIGVhcmx5IGluIGNhc2Ugd2UgZmFpbCBiZWxvdy5cbiAgICAgICAgICAgIGlmIChidWZmZXJbcG9zXSA9PT0gJ1xccicpIHtcbiAgICAgICAgICAgICAgICArK3BvcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChidWZmZXJbcG9zXSA9PT0gJ1xcbicpIHtcbiAgICAgICAgICAgICAgICArK3BvcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbGYuYnVmZmVyID0gYnVmZmVyLnN1YnN0cihwb3MpO1xuICAgICAgICAgICAgcmV0dXJuIGxpbmU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gMy4yIFdlYlZUVCBtZXRhZGF0YSBoZWFkZXIgc3ludGF4XG4gICAgICAgIGZ1bmN0aW9uIHBhcnNlSGVhZGVyKGlucHV0KSB7XG4gICAgICAgICAgICBwYXJzZU9wdGlvbnMoaW5wdXQsIGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ1JlZ2lvbic6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAzLjMgV2ViVlRUIHJlZ2lvbiBtZXRhZGF0YSBoZWFkZXIgc3ludGF4XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygncGFyc2UgcmVnaW9uJywgdik7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBwYXJzZVJlZ2lvbih2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIC86Lyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gNS4xIFdlYlZUVCBmaWxlIHBhcnNpbmcuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgbGluZSA9IHZvaWQgMDtcbiAgICAgICAgICAgIGlmIChzZWxmLnN0YXRlID09PSAnSU5JVElBTCcpIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBjYW4ndCBzdGFydCBwYXJzaW5nIHVudGlsIHdlIGhhdmUgdGhlIGZpcnN0IGxpbmUuXG4gICAgICAgICAgICAgICAgaWYgKCEvXFxyXFxufFxcbi8udGVzdChzZWxmLmJ1ZmZlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxpbmUgPSBjb2xsZWN0TmV4dExpbmUoKTtcbiAgICAgICAgICAgICAgICAvLyBzdHJpcCBvZiBVVEYtOCBCT00gaWYgYW55XG4gICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQnl0ZV9vcmRlcl9tYXJrI1VURi04XG4gICAgICAgICAgICAgICAgdmFyIG0gPSBsaW5lLm1hdGNoKC9eKMOvwrvCvyk/V0VCVlRUKFsgXFx0XS4qKT8kLyk7XG4gICAgICAgICAgICAgICAgaWYgKCFtIHx8ICFtWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTWFsZm9ybWVkIFdlYlZUVCBzaWduYXR1cmUuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNlbGYuc3RhdGUgPSAnSEVBREVSJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBhbHJlYWR5Q29sbGVjdGVkTGluZSA9IGZhbHNlO1xuICAgICAgICAgICAgd2hpbGUgKHNlbGYuYnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgY2FuJ3QgcGFyc2UgYSBsaW5lIHVudGlsIHdlIGhhdmUgdGhlIGZ1bGwgbGluZS5cbiAgICAgICAgICAgICAgICBpZiAoIS9cXHJcXG58XFxuLy50ZXN0KHNlbGYuYnVmZmVyKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFhbHJlYWR5Q29sbGVjdGVkTGluZSkge1xuICAgICAgICAgICAgICAgICAgICBsaW5lID0gY29sbGVjdE5leHRMaW5lKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhbHJlYWR5Q29sbGVjdGVkTGluZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHNlbGYuc3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnSEVBREVSJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIDEzLTE4IC0gQWxsb3cgYSBoZWFkZXIgKG1ldGFkYXRhKSB1bmRlciB0aGUgV0VCVlRUIGxpbmUuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoLzovLnRlc3QobGluZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJzZUhlYWRlcihsaW5lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFsaW5lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQW4gZW1wdHkgbGluZSB0ZXJtaW5hdGVzIHRoZSBoZWFkZXIgYW5kIHN0YXJ0cyB0aGUgYm9keSAoY3VlcykuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5zdGF0ZSA9ICdJRCc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnTk9URSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZ25vcmUgTk9URSBibG9ja3MuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWxpbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnN0YXRlID0gJ0lEJztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdJRCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBmb3IgdGhlIHN0YXJ0IG9mIE5PVEUgYmxvY2tzLlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKC9eTk9URSgkfFsgXFx0XSkvLnRlc3QobGluZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnN0YXRlID0gJ05PVEUnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gMTktMjkgLSBBbGxvdyBhbnkgbnVtYmVyIG9mIGxpbmUgdGVybWluYXRvcnMsIHRoZW4gaW5pdGlhbGl6ZSBuZXcgY3VlIHZhbHVlcy5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbGluZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jdWUgPSBuZXcgdnR0Y3VlXzEuZGVmYXVsdCgwLCAwLCAnJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnN0YXRlID0gJ0NVRSc7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAzMC0zOSAtIENoZWNrIGlmIHNlbGYgbGluZSBjb250YWlucyBhbiBvcHRpb25hbCBpZGVudGlmaWVyIG9yIHRpbWluZyBkYXRhLlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxpbmUuaW5kZXhPZignLS0+JykgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jdWUuaWQgPSBsaW5lO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBQcm9jZXNzIGxpbmUgYXMgc3RhcnQgb2YgYSBjdWUuXG4gICAgICAgICAgICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnQ1VFJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIDQwIC0gQ29sbGVjdCBjdWUgdGltaW5ncyBhbmQgc2V0dGluZ3MuXG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlQ3VlKGxpbmUsIHNlbGYuY3VlLCBzZWxmLnJlZ2lvbkxpc3QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJbiBjYXNlIG9mIGFuIGVycm9yIGlnbm9yZSByZXN0IG9mIHRoZSBjdWUuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jdWUgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuc3RhdGUgPSAnQkFEQ1VFJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuc3RhdGUgPSAnQ1VFVEVYVCc7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnQ1VFVEVYVCc6XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaGFzU3Vic3RyaW5nID0gbGluZS5pbmRleE9mKCctLT4nKSAhPT0gLTE7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAzNCAtIElmIHdlIGhhdmUgYW4gZW1wdHkgbGluZSB0aGVuIHJlcG9ydCB0aGUgY3VlLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gMzUgLSBJZiB3ZSBoYXZlIHRoZSBzcGVjaWFsIHN1YnN0cmluZyAnLS0+JyB0aGVuIHJlcG9ydCB0aGUgY3VlLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYnV0IGRvIG5vdCBjb2xsZWN0IHRoZSBsaW5lIGFzIHdlIG5lZWQgdG8gcHJvY2VzcyB0aGUgY3VycmVudFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gb25lIGFzIGEgbmV3IGN1ZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbGluZSB8fCBoYXNTdWJzdHJpbmcgJiYgKGFscmVhZHlDb2xsZWN0ZWRMaW5lID0gdHJ1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBhcmUgZG9uZSBwYXJzaW5nIHNlbGYgY3VlLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLm9uY3VlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYub25jdWUoc2VsZi5jdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmN1ZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5zdGF0ZSA9ICdJRCc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5jdWUudGV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY3VlLnRleHQgKz0gJ1xcbic7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmN1ZS50ZXh0ICs9IGxpbmU7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnQkFEQ1VFJzogLy8gQkFEQ1VFXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyA1NC02MiAtIENvbGxlY3QgYW5kIGRpc2NhcmQgdGhlIHJlbWFpbmluZyBjdWUuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWxpbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnN0YXRlID0gJ0lEJztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLy8gSWYgd2UgYXJlIGN1cnJlbnRseSBwYXJzaW5nIGEgY3VlLCByZXBvcnQgd2hhdCB3ZSBoYXZlLlxuICAgICAgICAgICAgaWYgKHNlbGYuc3RhdGUgPT09ICdDVUVURVhUJyAmJiBzZWxmLmN1ZSAmJiBzZWxmLm9uY3VlKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5vbmN1ZShzZWxmLmN1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWxmLmN1ZSA9IG51bGw7XG4gICAgICAgICAgICAvLyBFbnRlciBCQURXRUJWVFQgc3RhdGUgaWYgaGVhZGVyIHdhcyBub3QgcGFyc2VkIGNvcnJlY3RseSBvdGhlcndpc2VcbiAgICAgICAgICAgIC8vIGFub3RoZXIgZXhjZXB0aW9uIG9jY3VycmVkIHNvIGVudGVyIEJBRENVRSBzdGF0ZS5cbiAgICAgICAgICAgIHNlbGYuc3RhdGUgPSBzZWxmLnN0YXRlID09PSAnSU5JVElBTCcgPyAnQkFEV0VCVlRUJyA6ICdCQURDVUUnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgZmx1c2g6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gRmluaXNoIGRlY29kaW5nIHRoZSBzdHJlYW0uXG4gICAgICAgICAgICBzZWxmLmJ1ZmZlciArPSBzZWxmLmRlY29kZXIuZGVjb2RlKCk7XG4gICAgICAgICAgICAvLyBTeW50aGVzaXplIHRoZSBlbmQgb2YgdGhlIGN1cnJlbnQgY3VlIG9yIHJlZ2lvbi5cbiAgICAgICAgICAgIGlmIChzZWxmLmN1ZSB8fCBzZWxmLnN0YXRlID09PSAnSEVBREVSJykge1xuICAgICAgICAgICAgICAgIHNlbGYuYnVmZmVyICs9ICdcXG5cXG4nO1xuICAgICAgICAgICAgICAgIHNlbGYucGFyc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIHdlJ3ZlIGZsdXNoZWQsIHBhcnNlZCwgYW5kIHdlJ3JlIHN0aWxsIG9uIHRoZSBJTklUSUFMIHN0YXRlIHRoZW5cbiAgICAgICAgICAgIC8vIHRoYXQgbWVhbnMgd2UgZG9uJ3QgaGF2ZSBlbm91Z2ggb2YgdGhlIHN0cmVhbSB0byBwYXJzZSB0aGUgZmlyc3RcbiAgICAgICAgICAgIC8vIGxpbmUuXG4gICAgICAgICAgICBpZiAoc2VsZi5zdGF0ZSA9PT0gJ0lOSVRJQUwnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNYWxmb3JtZWQgV2ViVlRUIHNpZ25hdHVyZS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VsZi5vbmZsdXNoKSB7XG4gICAgICAgICAgICBzZWxmLm9uZmx1c2goKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gVlRUUGFyc2VyO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3V0aWxzL3dlYnZ0dC1wYXJzZXIuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy91dGlscy93ZWJ2dHQtcGFyc2VyLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qISBNb2R1bGVDb25jYXRlbmF0aW9uIGJhaWxvdXQ6IE1vZHVsZSBpcyBub3QgYW4gRUNNQVNjcmlwdCBtb2R1bGUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi8oZnVuY3Rpb24oTnVtYmVyKSB7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdnR0cGFyc2VyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3Z0dHBhcnNlciAqLyBcIi4vc3JjL3V0aWxzL3Z0dHBhcnNlci5qc1wiKTtcbnZhciBpZDNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2RlbXV4L2lkMyAqLyBcIi4vc3JjL2RlbXV4L2lkMy5qc1wiKTtcbi8vIFN0cmluZy5wcm90b3R5cGUuc3RhcnRzV2l0aCBpcyBub3Qgc3VwcG9ydGVkIGluIElFMTFcbnZhciBzdGFydHNXaXRoID0gZnVuY3Rpb24gKGlucHV0U3RyaW5nLCBzZWFyY2hTdHJpbmcsIHBvc2l0aW9uKSB7XG4gICAgcmV0dXJuIGlucHV0U3RyaW5nLnN1YnN0cihwb3NpdGlvbiB8fCAwLCBzZWFyY2hTdHJpbmcubGVuZ3RoKSA9PT0gc2VhcmNoU3RyaW5nO1xufTtcbnZhciBjdWVTdHJpbmcybWlsbGlzID0gZnVuY3Rpb24gKHRpbWVTdHJpbmcpIHtcbiAgICB2YXIgdHMgPSBwYXJzZUludCh0aW1lU3RyaW5nLnN1YnN0cigtMykpO1xuICAgIHZhciBzZWNzID0gcGFyc2VJbnQodGltZVN0cmluZy5zdWJzdHIoLTYsIDIpKTtcbiAgICB2YXIgbWlucyA9IHBhcnNlSW50KHRpbWVTdHJpbmcuc3Vic3RyKC05LCAyKSk7XG4gICAgdmFyIGhvdXJzID0gdGltZVN0cmluZy5sZW5ndGggPiA5ID8gcGFyc2VJbnQodGltZVN0cmluZy5zdWJzdHIoMCwgdGltZVN0cmluZy5pbmRleE9mKCc6JykpKSA6IDA7XG4gICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUodHMpIHx8ICFOdW1iZXIuaXNGaW5pdGUoc2VjcykgfHwgIU51bWJlci5pc0Zpbml0ZShtaW5zKSB8fCAhTnVtYmVyLmlzRmluaXRlKGhvdXJzKSkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIHRzICs9IDEwMDAgKiBzZWNzO1xuICAgIHRzICs9IDYwICogMTAwMCAqIG1pbnM7XG4gICAgdHMgKz0gNjAgKiA2MCAqIDEwMDAgKiBob3VycztcbiAgICByZXR1cm4gdHM7XG59O1xuLy8gRnJvbSBodHRwczovL2dpdGh1Yi5jb20vZGFya3NreWFwcC9zdHJpbmctaGFzaFxudmFyIGhhc2ggPSBmdW5jdGlvbiAodGV4dCkge1xuICAgIHZhciBoYXNoID0gNTM4MTtcbiAgICB2YXIgaSA9IHRleHQubGVuZ3RoO1xuICAgIHdoaWxlIChpKSB7XG4gICAgICAgIGhhc2ggPSAoaGFzaCAqIDMzKSBeIHRleHQuY2hhckNvZGVBdCgtLWkpO1xuICAgIH1cbiAgICByZXR1cm4gKGhhc2ggPj4+IDApLnRvU3RyaW5nKCk7XG59O1xudmFyIGNhbGN1bGF0ZU9mZnNldCA9IGZ1bmN0aW9uICh2dHRDQ3MsIGNjLCBwcmVzZW50YXRpb25UaW1lKSB7XG4gICAgdmFyIGN1cnJDQyA9IHZ0dENDc1tjY107XG4gICAgdmFyIHByZXZDQyA9IHZ0dENDc1tjdXJyQ0MucHJldkNDXTtcbiAgICAvLyBUaGlzIGlzIHRoZSBmaXJzdCBkaXNjb250aW51aXR5IG9yIGN1ZXMgaGF2ZSBiZWVuIHByb2Nlc3NlZCBzaW5jZSB0aGUgbGFzdCBkaXNjb250aW51aXR5XG4gICAgLy8gT2Zmc2V0ID0gY3VycmVudCBkaXNjb250aW51aXR5IHRpbWVcbiAgICBpZiAoIXByZXZDQyB8fCAoIXByZXZDQy5uZXcgJiYgY3VyckNDLm5ldykpIHtcbiAgICAgICAgdnR0Q0NzLmNjT2Zmc2V0ID0gdnR0Q0NzLnByZXNlbnRhdGlvbk9mZnNldCA9IGN1cnJDQy5zdGFydDtcbiAgICAgICAgY3VyckNDLm5ldyA9IGZhbHNlO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIFRoZXJlIGhhdmUgYmVlbiBkaXNjb250aW51aXRpZXMgc2luY2UgY3VlcyB3ZXJlIGxhc3QgcGFyc2VkLlxuICAgIC8vIE9mZnNldCA9IHRpbWUgZWxhcHNlZFxuICAgIHdoaWxlIChwcmV2Q0MgJiYgcHJldkNDLm5ldykge1xuICAgICAgICB2dHRDQ3MuY2NPZmZzZXQgKz0gY3VyckNDLnN0YXJ0IC0gcHJldkNDLnN0YXJ0O1xuICAgICAgICBjdXJyQ0MubmV3ID0gZmFsc2U7XG4gICAgICAgIGN1cnJDQyA9IHByZXZDQztcbiAgICAgICAgcHJldkNDID0gdnR0Q0NzW2N1cnJDQy5wcmV2Q0NdO1xuICAgIH1cbiAgICB2dHRDQ3MucHJlc2VudGF0aW9uT2Zmc2V0ID0gcHJlc2VudGF0aW9uVGltZTtcbn07XG52YXIgV2ViVlRUUGFyc2VyID0ge1xuICAgIHBhcnNlOiBmdW5jdGlvbiAodnR0Qnl0ZUFycmF5LCBzeW5jUFRTLCB2dHRDQ3MsIGNjLCBjYWxsQmFjaywgZXJyb3JDYWxsQmFjaykge1xuICAgICAgICAvLyBDb252ZXJ0IGJ5dGVBcnJheSBpbnRvIHN0cmluZywgcmVwbGFjaW5nIGFueSBzb21ld2hhdCBleG90aWMgbGluZWZlZWRzIHdpdGggXCJcXG5cIiwgdGhlbiBzcGxpdCBvbiB0aGF0IGNoYXJhY3Rlci5cbiAgICAgICAgdmFyIHJlID0gL1xcclxcbnxcXG5cXHJ8XFxufFxcci9nO1xuICAgICAgICAvLyBVaW50OEFycmF5LnByb3RvdHlwZS5yZWR1Y2UgaXMgbm90IGltcGxlbWVudGVkIGluIElFMTFcbiAgICAgICAgdmFyIHZ0dExpbmVzID0gaWQzXzEudXRmOEFycmF5VG9TdHIobmV3IFVpbnQ4QXJyYXkodnR0Qnl0ZUFycmF5KSkudHJpbSgpLnJlcGxhY2UocmUsICdcXG4nKS5zcGxpdCgnXFxuJyk7XG4gICAgICAgIHZhciBjdWVUaW1lID0gJzAwOjAwLjAwMCc7XG4gICAgICAgIHZhciBtcGVnVHMgPSAwO1xuICAgICAgICB2YXIgbG9jYWxUaW1lID0gMDtcbiAgICAgICAgdmFyIHByZXNlbnRhdGlvblRpbWUgPSAwO1xuICAgICAgICB2YXIgY3VlcyA9IFtdO1xuICAgICAgICB2YXIgcGFyc2luZ0Vycm9yO1xuICAgICAgICB2YXIgaW5IZWFkZXIgPSB0cnVlO1xuICAgICAgICAvLyBsZXQgVlRUQ3VlID0gVlRUQ3VlIHx8IHdpbmRvdy5UZXh0VHJhY2tDdWU7XG4gICAgICAgIC8vIENyZWF0ZSBwYXJzZXIgb2JqZWN0IHVzaW5nIFZUVEN1ZSB3aXRoIFRleHRUcmFja0N1ZSBmYWxsYmFjayBvbiBjZXJ0YWluIGJyb3dzZXJzLlxuICAgICAgICB2YXIgcGFyc2VyID0gbmV3IHZ0dHBhcnNlcl8xLmRlZmF1bHQoKTtcbiAgICAgICAgcGFyc2VyLm9uY3VlID0gZnVuY3Rpb24gKGN1ZSkge1xuICAgICAgICAgICAgLy8gQWRqdXN0IGN1ZSB0aW1pbmc7IGNsYW1wIGN1ZXMgdG8gc3RhcnQgbm8gZWFybGllciB0aGFuIC0gYW5kIGRyb3AgY3VlcyB0aGF0IGRvbid0IGVuZCBhZnRlciAtIDAgb24gdGltZWxpbmUuXG4gICAgICAgICAgICB2YXIgY3VyckNDID0gdnR0Q0NzW2NjXTtcbiAgICAgICAgICAgIHZhciBjdWVPZmZzZXQgPSB2dHRDQ3MuY2NPZmZzZXQ7XG4gICAgICAgICAgICAvLyBVcGRhdGUgb2Zmc2V0cyBmb3IgbmV3IGRpc2NvbnRpbnVpdGllc1xuICAgICAgICAgICAgaWYgKGN1cnJDQyAmJiBjdXJyQ0MubmV3KSB7XG4gICAgICAgICAgICAgICAgaWYgKGxvY2FsVGltZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdoZW4gbG9jYWwgdGltZSBpcyBwcm92aWRlZCwgb2Zmc2V0ID0gZGlzY29udGludWl0eSBzdGFydCB0aW1lIC0gbG9jYWwgdGltZVxuICAgICAgICAgICAgICAgICAgICBjdWVPZmZzZXQgPSB2dHRDQ3MuY2NPZmZzZXQgPSBjdXJyQ0Muc3RhcnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjYWxjdWxhdGVPZmZzZXQodnR0Q0NzLCBjYywgcHJlc2VudGF0aW9uVGltZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHByZXNlbnRhdGlvblRpbWUpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSBoYXZlIE1QRUdUUywgb2Zmc2V0ID0gcHJlc2VudGF0aW9uIHRpbWUgKyBkaXNjb250aW51aXR5IG9mZnNldFxuICAgICAgICAgICAgICAgIGN1ZU9mZnNldCA9IHByZXNlbnRhdGlvblRpbWUgLSB2dHRDQ3MucHJlc2VudGF0aW9uT2Zmc2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VlLnN0YXJ0VGltZSArPSBjdWVPZmZzZXQgLSBsb2NhbFRpbWU7XG4gICAgICAgICAgICBjdWUuZW5kVGltZSArPSBjdWVPZmZzZXQgLSBsb2NhbFRpbWU7XG4gICAgICAgICAgICAvLyBDcmVhdGUgYSB1bmlxdWUgaGFzaCBpZCBmb3IgYSBjdWUgYmFzZWQgb24gc3RhcnQvZW5kIHRpbWVzIGFuZCB0ZXh0LlxuICAgICAgICAgICAgLy8gVGhpcyBoZWxwcyB0aW1lbGluZS1jb250cm9sbGVyIHRvIGF2b2lkIHNob3dpbmcgcmVwZWF0ZWQgY2FwdGlvbnMuXG4gICAgICAgICAgICBjdWUuaWQgPSBoYXNoKGN1ZS5zdGFydFRpbWUudG9TdHJpbmcoKSkgKyBoYXNoKGN1ZS5lbmRUaW1lLnRvU3RyaW5nKCkpICsgaGFzaChjdWUudGV4dCk7XG4gICAgICAgICAgICAvLyBGaXggZW5jb2Rpbmcgb2Ygc3BlY2lhbCBjaGFyYWN0ZXJzLiBUT0RPOiBUZXN0IHdpdGggYWxsIHNvcnRzIG9mIHdlaXJkIGNoYXJhY3RlcnMuXG4gICAgICAgICAgICBjdWUudGV4dCA9IGRlY29kZVVSSUNvbXBvbmVudChlbmNvZGVVUklDb21wb25lbnQoY3VlLnRleHQpKTtcbiAgICAgICAgICAgIGlmIChjdWUuZW5kVGltZSA+IDApIHtcbiAgICAgICAgICAgICAgICBjdWVzLnB1c2goY3VlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcGFyc2VyLm9ucGFyc2luZ2Vycm9yID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHBhcnNpbmdFcnJvciA9IGU7XG4gICAgICAgIH07XG4gICAgICAgIHBhcnNlci5vbmZsdXNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHBhcnNpbmdFcnJvciAmJiBlcnJvckNhbGxCYWNrKSB7XG4gICAgICAgICAgICAgICAgZXJyb3JDYWxsQmFjayhwYXJzaW5nRXJyb3IpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhbGxCYWNrKGN1ZXMpO1xuICAgICAgICB9O1xuICAgICAgICAvLyBHbyB0aHJvdWdoIGNvbnRlbnRzIGxpbmUgYnkgbGluZS5cbiAgICAgICAgdnR0TGluZXMuZm9yRWFjaChmdW5jdGlvbiAobGluZSkge1xuICAgICAgICAgICAgaWYgKGluSGVhZGVyKSB7XG4gICAgICAgICAgICAgICAgLy8gTG9vayBmb3IgWC1USU1FU1RBTVAtTUFQIGluIGhlYWRlci5cbiAgICAgICAgICAgICAgICBpZiAoc3RhcnRzV2l0aChsaW5lLCAnWC1USU1FU1RBTVAtTUFQPScpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE9uY2UgZm91bmQsIG5vIG1vcmUgYXJlIGFsbG93ZWQgYW55d2F5LCBzbyBzdG9wIHNlYXJjaGluZy5cbiAgICAgICAgICAgICAgICAgICAgaW5IZWFkZXIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgLy8gRXh0cmFjdCBMT0NBTCBhbmQgTVBFR1RTLlxuICAgICAgICAgICAgICAgICAgICBsaW5lLnN1YnN0cigxNikuc3BsaXQoJywnKS5mb3JFYWNoKGZ1bmN0aW9uICh0aW1lc3RhbXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdGFydHNXaXRoKHRpbWVzdGFtcCwgJ0xPQ0FMOicpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VlVGltZSA9IHRpbWVzdGFtcC5zdWJzdHIoNik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChzdGFydHNXaXRoKHRpbWVzdGFtcCwgJ01QRUdUUzonKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1wZWdUcyA9IHBhcnNlSW50KHRpbWVzdGFtcC5zdWJzdHIoNykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENhbGN1bGF0ZSBzdWJ0aXRsZSBvZmZzZXQgaW4gbWlsbGlzZWNvbmRzLlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN5bmNQVFMgKyAoKHZ0dENDc1tjY10uc3RhcnQgKiA5MDAwMCkgfHwgMCkgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3luY1BUUyArPSA4NTg5OTM0NTkyO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWRqdXN0IE1QRUdUUyBieSBzeW5jIFBUUy5cbiAgICAgICAgICAgICAgICAgICAgICAgIG1wZWdUcyAtPSBzeW5jUFRTO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29udmVydCBjdWUgdGltZSB0byBzZWNvbmRzXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhbFRpbWUgPSBjdWVTdHJpbmcybWlsbGlzKGN1ZVRpbWUpIC8gMTAwMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvbnZlcnQgTVBFR1RTIHRvIHNlY29uZHMgZnJvbSA5MGtIei5cbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXNlbnRhdGlvblRpbWUgPSBtcGVnVHMgLyA5MDAwMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsb2NhbFRpbWUgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2luZ0Vycm9yID0gbmV3IEVycm9yKFwiTWFsZm9ybWVkIFgtVElNRVNUQU1QLU1BUDogXCIgKyBsaW5lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2luZ0Vycm9yID0gbmV3IEVycm9yKFwiTWFsZm9ybWVkIFgtVElNRVNUQU1QLU1BUDogXCIgKyBsaW5lKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBSZXR1cm4gd2l0aG91dCBwYXJzaW5nIFgtVElNRVNUQU1QLU1BUCBsaW5lLlxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGxpbmUgPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgIGluSGVhZGVyID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUGFyc2UgbGluZSBieSBkZWZhdWx0LlxuICAgICAgICAgICAgcGFyc2VyLnBhcnNlKGxpbmUgKyAnXFxuJyk7XG4gICAgICAgIH0pO1xuICAgICAgICBwYXJzZXIuZmx1c2goKTtcbiAgICB9XG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gV2ViVlRUUGFyc2VyO1xuXG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwodGhpcywgX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9zcmMvcG9seWZpbGxzL251bWJlciAqLyBcIi4vc3JjL3BvbHlmaWxscy9udW1iZXIuanNcIilbXCJOdW1iZXJcIl0pKVxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy91dGlscy94aHItbG9hZGVyLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvdXRpbHMveGhyLWxvYWRlci5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKipcbiAqIFhIUiBiYXNlZCBsb2dnZXJcbiovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgbG9nZ2VyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy9sb2dnZXIgKi8gXCIuL3NyYy91dGlscy9sb2dnZXIuanNcIik7XG52YXIgcGVyZm9ybWFuY2UgPSB3aW5kb3cucGVyZm9ybWFuY2UsIFhNTEh0dHBSZXF1ZXN0ID0gd2luZG93LlhNTEh0dHBSZXF1ZXN0O1xudmFyIFhockxvYWRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBYaHJMb2FkZXIoY29uZmlnKSB7XG4gICAgICAgIGlmIChjb25maWcgJiYgY29uZmlnLnhoclNldHVwKSB7XG4gICAgICAgICAgICB0aGlzLnhoclNldHVwID0gY29uZmlnLnhoclNldHVwO1xuICAgICAgICB9XG4gICAgfVxuICAgIFhockxvYWRlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5hYm9ydCgpO1xuICAgICAgICB0aGlzLmxvYWRlciA9IG51bGw7XG4gICAgfTtcbiAgICBYaHJMb2FkZXIucHJvdG90eXBlLmFib3J0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbG9hZGVyID0gdGhpcy5sb2FkZXI7XG4gICAgICAgIGlmIChsb2FkZXIgJiYgbG9hZGVyLnJlYWR5U3RhdGUgIT09IDQpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdHMuYWJvcnRlZCA9IHRydWU7XG4gICAgICAgICAgICBsb2FkZXIuYWJvcnQoKTtcbiAgICAgICAgfVxuICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRoaXMucmVxdWVzdFRpbWVvdXQpO1xuICAgICAgICB0aGlzLnJlcXVlc3RUaW1lb3V0ID0gbnVsbDtcbiAgICAgICAgd2luZG93LmNsZWFyVGltZW91dCh0aGlzLnJldHJ5VGltZW91dCk7XG4gICAgICAgIHRoaXMucmV0cnlUaW1lb3V0ID0gbnVsbDtcbiAgICB9O1xuICAgIFhockxvYWRlci5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uIChjb250ZXh0LCBjb25maWcsIGNhbGxiYWNrcykge1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICAgICAgdGhpcy5jYWxsYmFja3MgPSBjYWxsYmFja3M7XG4gICAgICAgIHRoaXMuc3RhdHMgPSB7IHRyZXF1ZXN0OiBwZXJmb3JtYW5jZS5ub3coKSwgcmV0cnk6IDAgfTtcbiAgICAgICAgdGhpcy5yZXRyeURlbGF5ID0gY29uZmlnLnJldHJ5RGVsYXk7XG4gICAgICAgIHRoaXMubG9hZEludGVybmFsKCk7XG4gICAgfTtcbiAgICBYaHJMb2FkZXIucHJvdG90eXBlLmxvYWRJbnRlcm5hbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHhociwgY29udGV4dCA9IHRoaXMuY29udGV4dDtcbiAgICAgICAgeGhyID0gdGhpcy5sb2FkZXIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgICAgdmFyIHN0YXRzID0gdGhpcy5zdGF0cztcbiAgICAgICAgc3RhdHMudGZpcnN0ID0gMDtcbiAgICAgICAgc3RhdHMubG9hZGVkID0gMDtcbiAgICAgICAgdmFyIHhoclNldHVwID0gdGhpcy54aHJTZXR1cDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICh4aHJTZXR1cCkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHhoclNldHVwKHhociwgY29udGV4dC51cmwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBmaXggeGhyU2V0dXA6ICh4aHIsIHVybCkgPT4ge3hoci5zZXRSZXF1ZXN0SGVhZGVyKFwiQ29udGVudC1MYW5ndWFnZVwiLCBcInRlc3RcIik7fVxuICAgICAgICAgICAgICAgICAgICAvLyBub3Qgd29ya2luZywgYXMgeGhyLnNldFJlcXVlc3RIZWFkZXIgZXhwZWN0cyB4aHIucmVhZHlTdGF0ZSA9PT0gT1BFTlxuICAgICAgICAgICAgICAgICAgICB4aHIub3BlbignR0VUJywgY29udGV4dC51cmwsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB4aHJTZXR1cCh4aHIsIGNvbnRleHQudXJsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXhoci5yZWFkeVN0YXRlKSB7XG4gICAgICAgICAgICAgICAgeGhyLm9wZW4oJ0dFVCcsIGNvbnRleHQudXJsLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLy8gSUUxMSB0aHJvd3MgYW4gZXhjZXB0aW9uIG9uIHhoci5vcGVuIGlmIGF0dGVtcHRpbmcgdG8gYWNjZXNzIGFuIEhUVFAgcmVzb3VyY2Ugb3ZlciBIVFRQU1xuICAgICAgICAgICAgdGhpcy5jYWxsYmFja3Mub25FcnJvcih7IGNvZGU6IHhoci5zdGF0dXMsIHRleHQ6IGUubWVzc2FnZSB9LCBjb250ZXh0LCB4aHIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb250ZXh0LnJhbmdlRW5kKSB7XG4gICAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcignUmFuZ2UnLCAnYnl0ZXM9JyArIGNvbnRleHQucmFuZ2VTdGFydCArICctJyArIChjb250ZXh0LnJhbmdlRW5kIC0gMSkpO1xuICAgICAgICB9XG4gICAgICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSB0aGlzLnJlYWR5c3RhdGVjaGFuZ2UuYmluZCh0aGlzKTtcbiAgICAgICAgeGhyLm9ucHJvZ3Jlc3MgPSB0aGlzLmxvYWRwcm9ncmVzcy5iaW5kKHRoaXMpO1xuICAgICAgICB4aHIucmVzcG9uc2VUeXBlID0gY29udGV4dC5yZXNwb25zZVR5cGU7XG4gICAgICAgIC8vIHNldHVwIHRpbWVvdXQgYmVmb3JlIHdlIHBlcmZvcm0gcmVxdWVzdFxuICAgICAgICB0aGlzLnJlcXVlc3RUaW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQodGhpcy5sb2FkdGltZW91dC5iaW5kKHRoaXMpLCB0aGlzLmNvbmZpZy50aW1lb3V0KTtcbiAgICAgICAgeGhyLnNlbmQoKTtcbiAgICB9O1xuICAgIFhockxvYWRlci5wcm90b3R5cGUucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB2YXIgeGhyID0gZXZlbnQuY3VycmVudFRhcmdldCwgcmVhZHlTdGF0ZSA9IHhoci5yZWFkeVN0YXRlLCBzdGF0cyA9IHRoaXMuc3RhdHMsIGNvbnRleHQgPSB0aGlzLmNvbnRleHQsIGNvbmZpZyA9IHRoaXMuY29uZmlnO1xuICAgICAgICAvLyBkb24ndCBwcm9jZWVkIGlmIHhociBoYXMgYmVlbiBhYm9ydGVkXG4gICAgICAgIGlmIChzdGF0cy5hYm9ydGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gPj0gSEVBREVSU19SRUNFSVZFRFxuICAgICAgICBpZiAocmVhZHlTdGF0ZSA+PSAyKSB7XG4gICAgICAgICAgICAvLyBjbGVhciB4aHIgdGltZW91dCBhbmQgcmVhcm0gaXQgaWYgcmVhZHlTdGF0ZSBsZXNzIHRoYW4gNFxuICAgICAgICAgICAgd2luZG93LmNsZWFyVGltZW91dCh0aGlzLnJlcXVlc3RUaW1lb3V0KTtcbiAgICAgICAgICAgIGlmIChzdGF0cy50Zmlyc3QgPT09IDApIHtcbiAgICAgICAgICAgICAgICBzdGF0cy50Zmlyc3QgPSBNYXRoLm1heChwZXJmb3JtYW5jZS5ub3coKSwgc3RhdHMudHJlcXVlc3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlYWR5U3RhdGUgPT09IDQpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3RhdHVzXzEgPSB4aHIuc3RhdHVzO1xuICAgICAgICAgICAgICAgIC8vIGh0dHAgc3RhdHVzIGJldHdlZW4gMjAwIHRvIDI5OSBhcmUgYWxsIHN1Y2Nlc3NmdWxcbiAgICAgICAgICAgICAgICBpZiAoc3RhdHVzXzEgPj0gMjAwICYmIHN0YXR1c18xIDwgMzAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRzLnRsb2FkID0gTWF0aC5tYXgoc3RhdHMudGZpcnN0LCBwZXJmb3JtYW5jZS5ub3coKSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkYXRhID0gdm9pZCAwLCBsZW4gPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb250ZXh0LnJlc3BvbnNlVHlwZSA9PT0gJ2FycmF5YnVmZmVyJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IHhoci5yZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlbiA9IGRhdGEuYnl0ZUxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSB4aHIucmVzcG9uc2VUZXh0O1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVuID0gZGF0YS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc3RhdHMubG9hZGVkID0gc3RhdHMudG90YWwgPSBsZW47XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXNwb25zZSA9IHsgdXJsOiB4aHIucmVzcG9uc2VVUkwsIGRhdGE6IGRhdGEgfTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jYWxsYmFja3Mub25TdWNjZXNzKHJlc3BvbnNlLCBzdGF0cywgY29udGV4dCwgeGhyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIG1heCBuYiBvZiByZXRyaWVzIHJlYWNoZWQgb3IgaWYgaHR0cCBzdGF0dXMgYmV0d2VlbiA0MDAgYW5kIDQ5OSAoc3VjaCBlcnJvciBjYW5ub3QgYmUgcmVjb3ZlcmVkLCByZXRyeWluZyBpcyB1c2VsZXNzKSwgcmV0dXJuIGVycm9yXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGF0cy5yZXRyeSA+PSBjb25maWcubWF4UmV0cnkgfHwgKHN0YXR1c18xID49IDQwMCAmJiBzdGF0dXNfMSA8IDQ5OSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmxvZ2dlci5lcnJvcihzdGF0dXNfMSArIFwiIHdoaWxlIGxvYWRpbmcgXCIgKyBjb250ZXh0LnVybCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbGxiYWNrcy5vbkVycm9yKHsgY29kZTogc3RhdHVzXzEsIHRleHQ6IHhoci5zdGF0dXNUZXh0IH0sIGNvbnRleHQsIHhocik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByZXRyeVxuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLndhcm4oc3RhdHVzXzEgKyBcIiB3aGlsZSBsb2FkaW5nIFwiICsgY29udGV4dC51cmwgKyBcIiwgcmV0cnlpbmcgaW4gXCIgKyB0aGlzLnJldHJ5RGVsYXkgKyBcIi4uLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFib3J0cyBhbmQgcmVzZXRzIGludGVybmFsIHN0YXRlXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNjaGVkdWxlIHJldHJ5XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJldHJ5VGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0KHRoaXMubG9hZEludGVybmFsLmJpbmQodGhpcyksIHRoaXMucmV0cnlEZWxheSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzZXQgZXhwb25lbnRpYWwgYmFja29mZlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXRyeURlbGF5ID0gTWF0aC5taW4oMiAqIHRoaXMucmV0cnlEZWxheSwgY29uZmlnLm1heFJldHJ5RGVsYXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHMucmV0cnkrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHJlYWR5U3RhdGUgPj0gMiBBTkQgcmVhZHlTdGF0ZSAhPT00IChyZWFkeVN0YXRlID0gSEVBREVSU19SRUNFSVZFRCB8fCBMT0FESU5HKSByZWFybSB0aW1lb3V0IGFzIHhociBub3QgZmluaXNoZWQgeWV0XG4gICAgICAgICAgICAgICAgdGhpcy5yZXF1ZXN0VGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0KHRoaXMubG9hZHRpbWVvdXQuYmluZCh0aGlzKSwgY29uZmlnLnRpbWVvdXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBYaHJMb2FkZXIucHJvdG90eXBlLmxvYWR0aW1lb3V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBsb2dnZXJfMS5sb2dnZXIud2FybihcInRpbWVvdXQgd2hpbGUgbG9hZGluZyBcIiArIHRoaXMuY29udGV4dC51cmwpO1xuICAgICAgICB0aGlzLmNhbGxiYWNrcy5vblRpbWVvdXQodGhpcy5zdGF0cywgdGhpcy5jb250ZXh0LCBudWxsKTtcbiAgICB9O1xuICAgIFhockxvYWRlci5wcm90b3R5cGUubG9hZHByb2dyZXNzID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHZhciB4aHIgPSBldmVudC5jdXJyZW50VGFyZ2V0LCBzdGF0cyA9IHRoaXMuc3RhdHM7XG4gICAgICAgIHN0YXRzLmxvYWRlZCA9IGV2ZW50LmxvYWRlZDtcbiAgICAgICAgaWYgKGV2ZW50Lmxlbmd0aENvbXB1dGFibGUpIHtcbiAgICAgICAgICAgIHN0YXRzLnRvdGFsID0gZXZlbnQudG90YWw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG9uUHJvZ3Jlc3MgPSB0aGlzLmNhbGxiYWNrcy5vblByb2dyZXNzO1xuICAgICAgICBpZiAob25Qcm9ncmVzcykge1xuICAgICAgICAgICAgLy8gdGhpcmQgYXJnIGlzIHRvIHByb3ZpZGUgb24gcHJvZ3Jlc3MgZGF0YVxuICAgICAgICAgICAgb25Qcm9ncmVzcyhzdGF0cywgdGhpcy5jb250ZXh0LCBudWxsLCB4aHIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gWGhyTG9hZGVyO1xufSgpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IFhockxvYWRlcjtcblxuXG4vKioqLyB9KVxuXG4vKioqKioqLyB9KVtcImRlZmF1bHRcIl07XG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhscy5qcy5tYXAiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0EiLCJzb3VyY2VSb290IjoiIn0=